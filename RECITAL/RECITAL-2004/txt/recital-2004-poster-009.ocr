RECITAL, Fes, 19-22 avril 2004

Traitement informatique de Pinﬂexion dans le Lunaf,
dictionnaire électronique du luxembourgeois

F rancisca LUNA GARCIA

Laboratoire d ’Informatique et d ’Intelligence Artificielle — INSA Strasbourg
24, boulevard de la Victoire
67000 Strasbourg

luna@messa ge. lu

Universite’ Marc Bloch
22, rue Rene’ Descartes
67084 Strasbourg Cedex

Résumé — Abstract

Afin de générer les formes ﬂéchies des noms luxembourgeois dans le dictionnaire
luxembourgeois, nous utilisons un code ﬂexionnel. Ce code s’étant révélé trop contraignant
pour traiter l’inﬂexion (altemance vocalique/Umlaut), nous présentons ici un moyen efficace
pour coder ce phénomene. La pertinence de ce type de code est double. D’une part, il
correspond mieux aux besoins du linguiste qui aimerait établir des classes ﬂexionnelles
naturelles sans trop de contraintes informatiques. D’autre part, il permet de réduire
significativement le nombre de classes ﬂexionnelles. Le dictionnaire électronique
luxembourgeois dispose ainsi de deux codes qui peuvent se combiner er1tre eux pour n1ieux
traiter les particularités morphologiques des mots luxembourgeois.

In order to generate the inﬂected forms of the Luxemburgish nouns in the Luxemburgish
dictionary, we use a ﬂexional. This code having proved to be too constraining to treat the
inﬂection (vocalic alternation/Umlaut), we present here an effective means to encode this
phenomenon. The relevance of this code is two—fold. On the one hand, it corresponds better to
the needs of the linguist who would like to establish natural ﬂexional classes without too
many data—processing constraints. In addition, it reduces the number of ﬂexional classes
significantly. The Luxemburgish dictionary has thus two codes which can be combined for a
better processing of the morphological characteristics of the Luxemburgish words.

Mots-clefs — Keywords
inﬂexion vocalique, codage, génération automatique, luxembourgeois
vowel inﬂection, encoding, automatic generation, Luxemburgish

1 Problématique et contexte

Avec notre these sur l’E‘tude morphologique de la langue luxembourgeoise en vue de la
creation d’un dictionnaire e’lectronique des mots luxembourgeois, le luxembourgeois fait ses
premiers pas dans le monde du dictionnaire électronique. Dans une premiere phase, il est
question de créer un dictionnaire électronique grace a la génération automatique de mots.
Dans cette communication, nous allons nous intéresser a l’inﬂexion, phénomene qui nous a
pose probleme lors de la génération. En effet, les langues germaniques ne marquent pas

F rancisca LUNA GARCIA

seulement le pluriel a la ﬁn du mot, mais aussi a l’intérieur du mot. Le codage que nous avons
adopté pour générer les mots luxembourgeois, c’est—a—dire pour obtenir a partir du lemme la
forme plurielle des noms, s’est vite révélé inefficace pour traiter l’inﬂexion (altemance
vocalique ou Umlaut). Nous obtenions un nombre de classes ﬂexionnelles trop élevé. Nous
voulons presenter ici le codage créé afin de pallier ce probleme.

A notre connaissance, ce phénomene ne bénéficie pas d’un traitement particulier dans les
dictionnaires électroniques des autres langues germaniques. Dans le dictionnaire électronique
luxembourgeois, le Lunaf, nous utilisons deux types de codes, l’un ﬂexionnel qui est utilise
pour générer les mots luxembourgeois, l’autre appelé <<inﬂexionnel », utilise uniquement
pour coder l’altemance vocalique ou Umlaut lors de la génération de la forme plurielle des
noms luxembourgeois. Ce code << inﬂexionnel » n’est intéressant que lorsqu’il s’agit
d’ apporter des modifications a l’intérieur d’un mot. Nous avons programme le code pour qu’il
ne fonctionne que pour les voyelles, puisque l’inﬂexion est assez réguliere et qu’en
luxembourgeois, il n’y a pas d’autres changements morphologiques a faire a l’intérieur du
mot.

Ci—dessous, nous allons presenter le code ﬂexionnel ainsi que le code << inﬂexionnel »,
tous les deux imposés par les caractéristiques de la langue luxembourgeoise. Nous voulons
montrer qu’ensemble, ils nous permettent de générer de facon optimale les mots de cette
langue. Mais tout d’abord, introduisons DicoManager, le systeme qui accueille le Lunaf,
puisque le code dont nous allons parler est celui utilisé dans les dictionnaires électroniques de
ce systeme.

DicoManager1 est un systeme informatique qui n’a pas été créé pour une application
particuliere. Il offre la possibilité de créer pour chaque langue naturelle un dictionnaire
électronique constitué de deux bases de données, auxquelles les applications feront appel
er1tre autres pour la reconnaissance de mots dans un texte. En general, on considere que la
fonction premiere d’une telle base de données est d’associer une chaine de caracteres
représentant la forme des mots graphiques et sémantiques et des formes ﬂéchies avec
différentes informations rendant possible, par exemple l’étiquetage ultérieur des mots dans la
phrase. Chaque dictionnaire électronique de DicoManager est donc constitué de deux bases de
données lexicales, DicoCan et DicoForm. La premiere contient une liste de lemmes sous leur
forme canonique, la deuxieme, les formes ﬂéchies des lemmes. Le Lunaf compte 325 classes
ﬂexionnelles dont 77 nominales. Ces 77 classes ﬂexionnelles représentent chacune un code
ﬂexionnel qui permet de générer la forme ﬂéchie, c’est—a—dire la forme plurielle du nom2.
Voyons d’ abord, en quoi consiste ce code ﬂexionnel.

2 Le code ﬂexionnel du Lunaf

Ce que nous codons ici, c’est la catégorie grammaticale du nombre. Les marques du
pluriel des noms luxembourgeois peuvent etre regroupées en cinq types ﬂexionnels (Bruch,
1973 ; Poitou, 1987 ; Schanen, 1980 ; Newton, 1996). Deux de ces types marquent le pluriel
par l’affixation et par l’inﬂexion. Un seul uniquement par l’inﬂexion.

1 Systeme créé au sein du Laboratoire d’Informatique et d’Inte11igence Artificielle (LIIA) de Strasbourg,
programme en Java et utilisant MySQL pour la creation des bases de données.

Les lemmes sont issus de notre corpus rassemblé a partir de textes sur Internet. Il comporte 500.000 mots et
nous a permis d’obtenir 16000 mots sous leur forme lemmatisée.

Traitement de l ’inﬂexion dans le Luna)‘, dictionnaire électronique du luxembourgeois.

Les lemmes (infinitif pour les verbes, nominatif singulier pour les noms et les adjectifs) de
DicoCan vont subir la generation automatique. Nous aurons ainsi dans DicoForm (la base des
formes ﬂechies) pour les mots variables, la conjugaison des verbes, la declinaison des
adjectifs et la forme plurielle des noms. Les mots invariables (adverbe, preposition,
conjonction, etc.) sont stockes tels quels (sans subir de generation) dans les deux bases. Le
code << inﬂexionnel », que nous allons voir plus loin ne concernant que les noms, nous ne
parlerons pas dans cette communication des autres categories lexicales.

Le code ﬂexionnel qui permet la generation des formes ﬂechies se compose de deux
parties, une partie qui contient les instructions pour generer les formes ﬂechies a partir du
lemme — qui fait l’objet de cette communication — et une partie qui comporte les inforrnations
morpho—syntaxiques, notamment le genre, le nombre et le cas pour les noms. Voyons deux
exemples de generation non1inale : en/... (type B) pour Auto — Auto—en (voiture), 2éi/... (type
D) pour Schlag — Schléi (coup).

Dans le premier exemple nous ajoutons la marque du pluriel <en> au nom, alors que dans le
deuxieme exemple nous deplacons le curseur de deux lettres vers la gauche, ce qui efface les
lettres <ag>, puis nous inserons <ei>.

Le codage utilise dans les dictionnaires electroniques de DicoManager ressemble a celui
utilise dans le dictionnaire du LADL, le DELAF (dictionnaire des formes ﬂechies). Nous
l’avons adapte a la langue luxembourgeoise et l’avons modifie pour pouvoir coder et generer
les mots luxembourgeois dans le Lunaf. Pour construire le Lunaf, les lemmes peuvent subir
jusqu’a quatre operations : un nombre entier speciﬁe le nombre de lettres a enlever a partir de
la fin du mot vers la gauche ; les caracteres en minuscule ajoutent des lettres ; la commande C
copie une lettre (il faut mettre autant de C qu’il a de lettres a aj outer) ; la commande R deplace
le curseur et efface la lettre a droite (un R par lettre a effacer). Celles—ci sont realisees par des
transducteurs a etats finis (Sproat, 1992) qu’il a fallu modiﬁer pour traiter l’inﬂexion.

Afin de bien comprendre les raisons pour lesquelles nous avons cherche un code qui
permette de coder plus efﬁcacement l’inﬂexion, nous vous presentons brievement les
modifications apportees au codage que nous venons de decrire. En fait, les mots du Lunaf
sont generes a partir de deux codes differents. Nous venons d’en voir un au paragraphe
precedent. Il presente une legere variante en fonction des mots qu’il s’agit de generer. Pour
generer certains temps verbaux par exemple, il est necessaire d’utiliser deux autres

commandes que nous decrivons ci—dessous.

Le participe II du verbe léieren (etudier), c’est—a—dire geléiert (appris), s’obtient a
partir du code ﬂexionnel suivant : B geE2t/....
La commande B (Beginning) renvoie le curseur en debut de mot. Cette commande peut se
reveler importante lorsqu’il s’agit d’aj outer des preﬁxes en debut de mot, comme par exemple
pour ajouter le prefixe <ge> du participe II. Cette commande est en etroite liaison avec la
commande E (End), qui renvoie le curseur a la fin du mot. A nouveau, elle est tres utile pour
la formation du participe II, puisque grace a elle, apres avoir ajoute le prefixe <ge> avec la
commande B, elle place le curseur a la fin du verbe et permet ainsi l’ajout de la terminaison
du participe II. Voyons en detail le code de l’exemple donne plus haut :
participe II du verbe léieren (etudier): B geE2t/PART.

B deplacer le curseur en debut de mot
ge aj outer <ge>
E deplacer le curseur en fin de mot

2 enlever deux lettres

F rancisca LUNA GARCIA

t aj outer <t>
Ce qui nous donne la forme ﬂéchie geléiert (étudié). En somme, l’opération E (End) permet
l’enchainement d’ operations de suppression, de copie et de remplacement de lettres.

Nous venons de voir comment fonctionne le code ﬂexionnel général. Il permet de générer
la conjugaison des verbes, la déclinaison des adjectifs et de la plupart des noms
luxembourgeois. En revanche, il a fallu implémenter un code spécifique pour traiter le
phénomene de l’inﬂexion.

3 Le code « inﬂexionnel » du Lunaf

Nous avons voulu trouver un moyen efficace de coder l’inﬂexion des voyelles du radical.
Le codage que nous avons décrit précédemment était trop compliqué et engendrait une
multiplication des classes ﬂexionnelles lorsqu’il s’agissait de coder l’inﬂexion. Il a donc fallu
créer ce nouveau code. Il s’agit surtout de montrer la particularité de ce code par rapport a
celui que nous venons de voir, ainsi que son utilité.
En fait, le codage du Lunaf propose trois facons de déplacer le curseur dans le mot : dans le
code ﬂexionnel le déplacement du curseur se fait lettre par lettre et/ou en debut ou en ﬁn de
mot, et dans le code << inﬂexionnel » le curseur se place sur une lettre precise a l’intérieur du
mot.
Nous avons donc ajouté la possibilité de chercher une chaine de caracteres et de la
remplacer par une autre chaine de caracteres. Par exemple pour passer de Hafen (port) a
Hafen (ports) on va coder l’information de la facon suivante dans le Lunaf : (a)‘ci)/... 3.

La voyelle du radical qui subit l’inﬂexion se met er1tre parentheses, suivie de la voyelle
inﬂéchie. L’éconon1ie de classes ﬂexionnelles se fait surtout lorsque les voyelles de plusieurs
noms subissent la meme inﬂexion. Par exemple, les noms comme Stad (ville), Schued
(dégats) et Daach (toit) deviennent au pluriel Stied, Schied, Diech. En utilisant le code
ﬂexionnel décrit en 2) pour générer ce type de pluriel, nous aurions les trois classes
ﬂexionnelles suivantes et donc trois codes différents: 2RieE/... pour Stad, 3RiE/... pour
Schued, 4RrieE/... pour Daach. Avec le code <<inﬂexionnel » ces trois noms et leurs
composés ne sont regroupés que dans un seul code: (a;aa;ue)ie)/..... pour Stud a Stied,
Daach %Diech, Schued aSchied.

Un tel code fonctionne de gauche a droite, c’est—a—dire, que la premiere voyelle recherchée est
celle qui se trouve le plus a gauche dans le code. Le programme cherchera d’abord la
premiere voyelle, le <a>. S’il ne la trouve pas, il recherchera la voyelle suivante du code, le
<aa>. Et si la encore il ne trouve pas, il passera au couple suivant, le <ue>. D’apres notre
corpus, nous avons obtenu un maximum de trois voyelles (ou double voyelles) dans chaque
code.

La recherche de la voyelle dans le nom se fait de droite a gauche et cela pour
permettre la mise au pluriel des noms composes ou pour gérer les cas ou un meme nom
comporterait deux voyelles identiques. Ce choix de recherche dans le mot se justifie pour
deux raisons. La premiere est due au fait que si nous ne procédions pas par la fin du mot, le
générateur de formes ne saurait pas quelle voyelle doit subir l’inﬂexion. Voyons les exemples
suivants : soit les noms Akaafsstad (ville commerciale) et Kamavalstad (ville de carnaval) et

3 Les parentheses ont pour se111 but de delimiter les operations sur le lemme.

Traitement de l ’inﬂexion dans le Luna)‘, dictionnaire électronique du luxembourgeois.

le code ﬂexionnel precedent : (a;aa;u)ie)/.... Est—ce le <aa> de Akaafs— ou le <a> de —stad ou
lequel des quatre <a> de Kamavalstad qui doit subir l’inﬂexion ? Il se produirait une
ambigu'1'te et le programme genererait une forme ﬂechie incorrecte.

La deuxieme raison est etroitement liee a la nature meme des noms composes. Le membre
principal des noms composes se trouve toujours a la ﬁn du compose. Dans les exemples que
nous venons de donner, il s’agit de Stad (ville). Ce qui fait une bonne raison de commencer
par la fin du mot. Ce code << inﬂexionnel » permet ainsi de generer de facon optimale les mots
simples et les mots composes. Le transducteur fonctionne lui aussi de droite a gauche. Dans
l’exemple precedent, le transducteur fait que l’on passe du lemme au singulier Stad (ville) a la
forme lexicale au pluriel Stied (villes). Cette facon de proceder est decrite chez Cornell
(1988). Le transducteur comporte egalement des informations morpho—syntaxiques. Il est
compose d’un arc marque par exemple a:ie pour manipuler la transduction de Stad a Stied. En
plus, cet arc est marque [+pl], signifiant qu’il introduit la propriete morpho—syntaXique
[+pluriel] en meme temps qu’il effectue la transduction du /a/ de surface vers le /ie/ lexical.

Quelques exemples de codes << inﬂexionnels » vont nous permettre de mieux Visualiser
les classes nominales concernees. Par rapport au code ﬂexionnel, le code << inﬂexionnel »
permet de relever des regularites dans l’inﬂexion, c’est—a—dire les voyelles ou diphtongues qui
subissent la meme altemance, puisque chaque code regroupe tous les noms qui marquent le
pluriel de la meme facon :

(a;o)ee) —> Bam — Beem (arbre), Nol — Neel (clou, ongle),
(ou;o)ei) —> Fouss — Féiss (pied), Stat — Stéit (menage).

Dans ces exemples nous voyons qu’en luxembourgeois, il est possible que plusieurs noms
subissent la meme inﬂexion lors de la mise au pluriel (Luna Garcia, 2002 ; Schanen, 2004).
L’ordre des voyelles a remplacer n’est pas aleatoire. Il est determine en raison de la frequence
de remplacement, c’est—a—dire qu’une voyelle ou une diphtongue qui subit plus souvent
l’inﬂexion prendra la premiere place dans le code. Ceci reduit le risque d’erreur lorsque le
nom contient plus d’une voyelle.

Il est possible de combiner le code ﬂexionnel et le code << inﬂexionnel », notamment
lorsque le nom subit l’inﬂexion et l’ajout de la marque du pluriel en fin de mot. Pour generer
la forme plurielle des noms suivants: Lach — Léicher (trou), Faass — Féisser (tonneau), nous
combinons les deux codes de la facon suivante: (a;aa)‘ci)er/....

Les avantages du code << inﬂexionnel » sont donc :
o une generation sin1ilaire des mots simples et des mots composes,
0 le deplacement du curseur sur une lettre ou un couple de lettres precises a
l’interieur d’un mot,

o la possibilite d’ etablir un ordre de frequence,

o la possibilite de reperer les regularites ﬂexionnelles

o la possibilite de le combiner au code ﬂexionnel.

Ce code peut neanmoins presenter un desavantage, qui va dependre des caracteristiques
morphologiques de la langue traitee. Selon le nombre de voyelles contenues dans le mot, cette
facon de proceder peut se reveler handicapante. En effet, lorsque le nom (surtout les noms
composes) contient plusieurs voyelles et que le code se compose de deux ou trois voyelles a
inﬂechir, il peut y avoir un probleme. En luxembourgeois, nous n’avons pas encore rencontre
ce type de probleme, mais nous ne l’excluons pas. Nous avons fabrique l’exemple suivant
pour illustrer ce cas. Soit un nom comme *Kamevalstad (ville de carnaval) et le code

F rancisca LUNA GARCIA

suivant : *(e;a)ie)/.... La voyelle qui subit le plus souvent l’inﬂexion, le <e> dans ce cas, se
retrouve en premiere position et sera donc remplacee en premier. Cette situation va donc
produire une forme incorrecte etant donne que c’est le <a> de Stad (ville) qui doit etre
inﬂechi. Mais heureusement, cet inconvenient ne devrait pas etre tres frequent pour les noms
simples en luxembourgeois, puisque du moins d’apres notre corpus, les noms au singulier ne
contiennent qu’une voyelle ou une diphtongue. En revanche, ce probleme pourrait se poser
pour les noms composes, meme si c’est peu probable en luxembourgeois.

4 Résultats

Dans le Lunaf, nous utilisons donc deux codes qui traitent chacun une caracteristique
particuliere de la morphologie des noms luxembourgeois. Dans cette communication, nous
avons voulu presenter le code qui permet de traiter l’inﬂexion des noms luxembourgeois et
qui de ce fait est appele << inﬂexionnel ». Le codage utilise dans notre dictionnaire
electronique propose donc trois facons de deplacer le curseur dans le mot : lettre par lettre, en
debut ou en fin de mot et sur une lettre precise a l’interieur du mot.

Grace au code << inﬂexionnel » nous avons effectivement reduit le nombre de classes. De
92 classes ﬂexionnelles nominales nous sommes passes a 77. Bien que les exemples de codes
donnes plus haut ne se composent que de voyelles et de diphtongues, nous n’excluons pas le
remplacement de consonnes a l’interieur du mot lorsque les caracteristiques de la langue
traitee s’y pretent.

Ce code n’a pas ete cree pour traiter exclusivement l’inﬂexion des noms de la langue
luxembourgeoise. Il est tout a fait possible de l’utiliser dans d’autres langues qui presentent
des alternances vocaliques du meme genre comme par exemple les langues germaniques.

Références

CORNELL T. (1988), << IceParse : A model of inﬂectional parsing and word recognition for
Icelandic ablauting verbs ». In: Morphology as a Computational Problem, Department of
Linguistics, University of California, Los Angeles.

LUNA GARCIA F. (2002), << Particularites morphologiques du mot luxembourgeois et leur
implementation pour la generation automatique des mots ». In: Bulletin Universitaire de
Linguistique Ge’ne’rale et Appliquée (BULAG), n°27, pp.151—166.

NEWTON G. (1996), Luxembourg and Letzebuergesch, Oxford, Clarendon Press.

POITOU J. (1987), << La ﬂexion des substantifs en allemand]I ». In: Nouveaux Cahiers
d ’Allemand, n°3, pp.299—314.

SCHANEN F. (1980), Recherches sur la syntaxe du luxembourgeois de Schengen, these
soutenue a Paris IV.

SILBERZTEIN M. (1996), INTEX 3.4 reference manual, LADL, Universite Paris 7.

SPROAT R. (1992), Morphology and Computation, Cambridge, The MIT Press.

