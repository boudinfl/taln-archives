<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Utilisation des ontologies pour la mod&#233;lisation logique d&#8217;une commande en langue naturel</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>R&#201;CITAL 2007, Toulouse, 5&#8211;8 juin 2007
</p>
<p>Utilisation des ontologies pour la mod&#233;lisation logique
d&#8217;une commande en langue naturel
</p>
<p>Laurent MAZUEL
LIP6, 104 avenue du Pr&#233;sident Kennedy, 75016 Paris
</p>
<p>laurent.mazuel@lip6.fr
</p>
<p>R&#233;sum&#233;. Dans cet article, nous nous int&#233;ressons &#224; l&#8217;interpr&#233;tation de commandes en
langue naturelle pour un agent artificiel. Notre architecture repose sur une mod&#233;lisation lo-
gique de la commande pour l&#8217;interpr&#233;tation s&#233;mantique, qui permet de capturer la &#171; structure
fonctionnelle &#187; de la phrase, c&#8217;est-&#224;-dire les r&#244;les des termes les uns par rapport aux autres.
Cet article d&#233;crit une m&#233;thode d&#8217;analyse structurelle de surface qui s&#8217;appuie sur l&#8217;ontologie de
l&#8217;agent pour construire cette mod&#233;lisation logique. Nous d&#233;finissons tout d&#8217;abord un algorithme
d&#8217;ancrage des termes de la commande dans l&#8217;ontologie de l&#8217;agent puis nous montrons com-
ment s&#8217;en servir pour l&#8217;analyse de surface. Enfin, nous expliquons bri&#232;vement comment notre
mod&#233;lisation peut &#234;tre utilis&#233;e au moment de l&#8217;interpr&#233;tation s&#233;mantique des commandes.
</p>
<p>Abstract. In this paper, we focus on natural language interaction for artificial agents. Our
architecture relies on a command logical model to enhance the semantic interpretation. It allows
us to catch the &#171; functional structure &#187; of the user sentence, i.e. each terms compared to each
others. This paper describes a partial structural approach which relies on the agent ontology to
build a logical form of the sentence. We first define an algorithm to anchor a word from the
command in the ontology and we use it to make our partial analysis. Lastly, we explain briefly
how to use our model for the semantic interpretation of the user command.
</p>
<p>Mots-cl&#233;s : commande en langue naturelle, analyse structurelle de surface, mod&#233;lisation
logique, ontologies.
</p>
<p>Keywords: natural language command, partial structural analysis, logical form, onto-
logies.
</p>
<p>1 Introduction
</p>
<p>Dans les applications de commandes en langue naturelle, l&#8217;utilisation d&#8217;un analyseur syntaxique
bas&#233; sur des r&#232;gles grammaticale fortes de la langue pose des probl&#232;mes d&#8217;efficacit&#233; (Milward,
2000; Sabouret &amp; Mazuel, 2005). En effet, les utilisateurs emploient plus r&#233;guli&#232;rement des
mots cl&#233;s plut&#244;t que des phrases bien structur&#233;es (e.g. &#171; drop object low &#187; ou &#171; take blue &#187;). De
plus, dans le cadre d&#8217;applications r&#233;elles, la complexit&#233;, la difficult&#233; d&#8217;&#233;criture de r&#232;gles non-
sp&#233;cifiques et de maintenances rendent ces types d&#8217;approches complexes &#224; mettre en &#339;uvre et
lourdes &#224; utiliser (Sabah, 2006). D&#8217;un autre cot&#233;, l&#8217;utilisation d&#8217;un mod&#232;le &#171; sac de mots &#187; est
insuffisante, g&#233;n&#233;rant des probl&#232;mes de mod&#233;lisation impossible &#224; interpr&#233;ter par la suite (par
exemple, &#171; go from London to Boston &#187; et &#171; go from Boston to London &#187; sont repr&#233;sent&#233;es
par le m&#234;me sac de mots). C&#8217;est pourquoi la majorit&#233; des travaux actuels (Hobbs et al., 1997;
</p>
<p>427</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laurent MAZUEL
</p>
<p>Eliasson, 2007) cherchent &#224; effectuer une analyse partielle (ou de surface), afin de r&#233;duire le co&#251;t
de d&#233;veloppement, augmenter la port&#233;e utilitaire et &#233;viter les &#233;cueils des deux mod&#233;lisations
extr&#234;mes pr&#233;c&#233;demment d&#233;crites.
</p>
<p>Les m&#233;thodes actuelles d&#8217;analyse de surface s&#8217;orientent ainsi vers une mod&#233;lisation bas&#233;e sur la
logique du premier ou second ordre (Shapiro, 2000; Milward, 2000). Cette mod&#233;lisation permet
&#224; la fois de s&#8217;affranchir d&#8217;une analyse syntaxique lourde et de conserver suffisamment d&#8217;in-
formation pour &#234;tre applicable facilement au moment de l&#8217;analyse s&#233;mantique. N&#233;anmoins, le
d&#233;faut de ces syst&#232;mes r&#233;side dans la d&#233;finition de ces pr&#233;dicats, qui doit souvent se faire dans
un langage contraint d&#233;pendant d&#8217;un ensemble d&#8217;axiomes logiques sp&#233;cifiques (Shapiro, 2000;
Sadek et al., 1997). Au contraire, l&#8217;utilisation d&#8217;ontologies dans les syst&#232;mes de dialogue a
pour objectif de rendre les syst&#232;mes plus ind&#233;pendants de l&#8217;application. Elles sont utilis&#233;es par
exemple pour l&#8217;interpr&#233;tation s&#233;mantique d&#8217;une commande pour le syst&#232;me (Milward &amp; Beve-
ridge, 2003; Flycht-Eriksson, 2003) et avant cette interpr&#233;tation pour d&#233;sambigu&#239;ser les termes
d&#8217;une commande (Porzel et al., 2003; Resnik, 1995). Nous pensons qu&#8217;il est aussi possible
d&#8217;exploiter le contenu de l&#8217;ontologie pour construire la repr&#233;sentation structurelle logique de la
commande, ce qui permet de s&#8217;affranchir de la d&#233;finition de r&#232;gles dans un langage sp&#233;cifique.
</p>
<p>Dans cet article, nous proposons de d&#233;finir une m&#233;thode d&#8217;analyse structurelle de surface pour
construire une mod&#233;lisation logique de la commande bas&#233;e sur l&#8217;&#233;tude des concepts et des re-
lations d&#233;finis dans l&#8217;ontologie de l&#8217;agent. Notre analyse s&#8217;appuie sur un ancrage des termes
de la commande dans l&#8217;ontologie (nous nous pla&#231;ons dans le cadre de l&#8217;hypoth&#232;se de connec-
tivit&#233; s&#233;mantique de Sadek (Sadek et al., 1997), qui suppose que tous les concepts de toutes
commandes apparaissent dans l&#8217;ontologie). En fonction des r&#244;les des termes dans l&#8217;ontologie
(relation ou classe), nous construisons une repr&#233;sentation de la commande sous forme de pr&#233;di-
cats (correspondant aux relations) et d&#8217;arguments (instances de classes).
</p>
<p>La section suivante pr&#233;sente bri&#232;vement notre syst&#232;me d&#8217;interpr&#233;tation de commandes en langue
naturel. Nous d&#233;crivons l&#8217;architecture principale et l&#8217;articulation entre les diff&#233;rents compo-
sants. La section 3 d&#233;crit plus pr&#233;cis&#233;ment l&#8217;ancrage des termes utilisateurs &#224; l&#8217;ontologie, l&#8217;al-
gorithme de construction logique de la commande et l&#8217;interpr&#233;tation s&#233;mantique.
</p>
<p>2 Architecture du syst&#232;me de commande en langue naturel
</p>
<p>Notre architecture est bas&#233;e sur le mod&#232;le classique des &#171; modules r&#233;seaux communicants &#187;
(Allen et al., 2000; Seneff, 2002). Cette structure permet le backtrack entre les diff&#233;rents com-
posants ainsi que les r&#233;ponses anticip&#233;es en fonction de l&#8217;&#233;tat du dialogue (figure 1). Nous
donnons dans cette section les grandes lignes des modules de l&#8217;architecture, en gardant les d&#233;-
tails de l&#8217;analyse logique et l&#8217;interpr&#233;tation s&#233;mantique (comme illustration de l&#8217;utilisation de
notre analyse) pour la section 3.1
</p>
<p>1L&#8217;architecture est d&#233;finie plus en d&#233;tails dans (Mazuel &amp; Sabouret, 2006). Elle est utilis&#233;e pour la d&#233;finition
d&#8217;agents conversationnels sur le web : http://www-poleia.lip6.fr/~sabouret/demos.
</p>
<p>428</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ontologies &amp; mod&#233;lisation logique d&#8217;une commande en langue naturel
</p>
<p>FIG. 1 &#8211; Architecture g&#233;n&#233;rale
</p>
<p>2.1 Analyse morphologique et lexical
</p>
<p>Notre module morphologique et lexical est bas&#233; sur la biblioth&#232;que d&#8217;outils OpenNLP2. Nous
utilisons les modules Maximum-Entropy Tokenizer et Chunker, l&#8217;&#233;tiqueteur et le lemmatiseur
bas&#233; sur WordNet. L&#8217;&#233;tiqueteur, le tokenizer et le chunker sont entra&#238;n&#233;s sur des donn&#233;es an-
glaises du Wall Street Journal et du corpus Brown. Le dernier mod&#232;le propos&#233; est annonc&#233; &#224;
96% d&#8217;&#233;tiquetage correct sur des donn&#233;es hors base d&#8217;apprentissage. Une &#233;tude comparative
avec le TreeTagger3 sur quelques exemples tir&#233;s de notre application n&#8217;a pas montr&#233; de pertes
tr&#232;s significatives. Le lemmatiseur bas&#233; sur WordNet permet la d&#233;couverte des mots compos&#233;s
de la commande, dans la mesure o&#249; le terme existe en tant qu&#8217;un des mots d&#8217;un synset (e.g.
&#171; dark red &#187;, &#171; extra large &#187;). Nous n&#8217;avons pas utilis&#233; le module de r&#233;solution d&#8217;anaphore de
OpenNLP, car elles n&#8217;apparaissent que tr&#232;s rarement dans une commande (&#224; la diff&#233;rence de
textes longs ou de dialogues).4
</p>
<p>2.2 Principe de la g&#233;n&#233;ration de commandes formelles
</p>
<p>Notre syst&#232;me de compr&#233;hension des commandes en langue naturelle repose sur une approche
ascendante (i.e. bottom-up) comme il est possible d&#8217;en voir dans (Paraiso &amp; Barth&#232;s, 2004).
Cette approche utilise une liste pr&#233;&#233;tablie de comp&#233;tences (formelles) et essaye de relier la
commande en LN &#224; (au moins) une comp&#233;tence. Cependant, elles pr&#233;sentent des probl&#232;mes
d&#8217;efficacit&#233; en pratique (e.g. &#233;criture des comp&#233;tences, difficult&#233; d&#8217;&#233;volution, etc.) qui font que
nous utilisons actuellement une version ascendante g&#233;n&#233;rative bas&#233;e sur une analyse du code
de notre agent (Mazuel &amp; Sabouret, 2006). Notre mod&#232;le agent, appel&#233; VDL, permet en effet un
acc&#232;s &#224; l&#8217;ex&#233;cution &#224; l&#8217;ensemble du code et de son &#233;tat courant (Sabouret &amp; Sansonnet, 2001).
L&#8217;algorithme de g&#233;n&#233;ration des commandes formelles est inspir&#233; des travaux sur la validation
de logiciel par l&#8217;analyse des pr&#233;conditions d&#8217;activation d&#8217;une action.
</p>
<p>Le principe g&#233;n&#233;ral de l&#8217;approche ascendante g&#233;n&#233;rative est d&#8217;apparier les termes de la com-
mande utilisateur avec les commandes formelles (i.e. not&#233;es &#233;v&#232;nements en VDL) g&#233;n&#233;r&#233;es, qui
correspondent aux commandes que l&#8217;agent est capable de traiter. Cet appariement est le r&#233;sultat
</p>
<p>2http://opennlp.sourceforge.net/
3http://www.ims.uni-stuttgart.de/projekte/corplex/TreeTagger
4En fait, elles apparaissent uniquement lors des dialogues avec l&#8217;utilisateur (exemple : &#171; prend le carre vert &#187;,
</p>
<p>&#171; ok &#187;, &#171; pose le en haut &#187;). C&#8217;est alors le gestionnaire de dialogue qui est responsable de leur r&#233;solution (cf.
section 2.3).
</p>
<p>429</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laurent MAZUEL
</p>
<p>de l&#8217;interpr&#233;tation s&#233;mantique, dont nous parlerons bri&#232;vement en section 3.4. A l&#8217;issue de cette
interpr&#233;tation s&#233;mantique, chaque &#233;v&#232;nement est associ&#233; &#224; un score d&#8217;appariement &#233;valuant la
proximit&#233; de l&#8217;&#233;v&#233;nement avec la commande de l&#8217;utilisateur. L&#8217;objectif de cet article n&#8217;est pas
de pr&#233;senter l&#8217;algorithme de calcul de ce score (le lecteur int&#233;ress&#233; le trouvera dans (Mazuel &amp;
Sabouret, 2006)), mais de pr&#233;senter l&#8217;analyse structurelle de surface qui le rend possible.
</p>
<p>2.3 Le gestionnaire de dialogue
</p>
<p>A l&#8217;issue de l&#8217;interpr&#233;tation s&#233;mantique le gestionnaire de dialogue utilise le score d&#8217;apparie-
ment pour d&#233;terminer la strat&#233;gie de dialogue. Nous utilisons pour cela un syst&#232;me de seuil
inspir&#233; de celui propos&#233; par Patty Maes (Maes, 1994) qui permet de faire la diff&#233;rence entre
les commandes parfaitement comprises, les commandes incertaines et les commandes non-
comprises. Nous avons en plus pris en compte le cas des commandes possibles ou impossibles
dans l&#8217;&#233;tat courant de l&#8217;agent (Mazuel &amp; Sabouret, 2006).
</p>
<p>Pour r&#233;pondre &#224; l&#8217;utilisateur, le gestionnaire de dialogue utilise un g&#233;n&#233;rateur d&#8217;anglais qui
transforme une r&#233;ponse formalis&#233;e en VDL en une phrase anglaise. L&#8217;algorithme actuel est tr&#232;s
simple et ne produit pas des r&#233;ponses grammaticalement correctes, mais donne suffisamment
d&#8217;informations (i.e. de mots clefs) pour aider l&#8217;utilisateur &#224; reformuler sa commande. Notre
objectif &#224; long terme est d&#8217;utiliser un g&#233;n&#233;rateur performant bas&#233; sur XML et les ontologies.
</p>
<p>Par exemple, dans le cas d&#8217;une ambigu&#239;t&#233;, le gestionnaire de dialogue propose &#224; l&#8217;utilisateur
l&#8217;ensemble des commandes possibles dans le contexte courant et utilise le g&#233;n&#233;rateur d&#8217;anglais
pour transformer les commandes formalis&#233;es :
</p>
<p>- I want to go to Boston today.
- Your command is imprecise. I can either :
</p>
<p>- Go Boston with flight is AF1345 and departure time is 8h47
- Go Boston with flight is AA6543 and departure time is 10h34
</p>
<p>3 Analyse fonctionnelle logique
</p>
<p>Nous d&#233;crivons dans cette section comment nous construisons un mod&#232;le de la commande de
l&#8217;utilisateur sous la forme d&#8217;un ensemble de pr&#233;dicats. Nous d&#233;crirons d&#8217;abord le mod&#232;le d&#8217;on-
tologie utilis&#233;, l&#8217;algorithme d&#8217;ancrage d&#8217;un mot dans l&#8217;ontologie, puis enfin la construction
compl&#232;te de la mod&#233;lisation logique de la commande.
</p>
<p>Dans la suite de l&#8217;article, nous noterons St l&#8217;ensemble des cha&#238;nes de caract&#232;res et pour tout
ensemble E, nous noterons P(E) l&#8217;ensemble des sous-ensembles de l&#8217;ensemble E.
</p>
<p>3.1 Mod&#232;le de l&#8217;ontologie
</p>
<p>Dans notre mod&#232;le, l&#8217;ontologie d&#8217;un agent5 est un couple O = &#12296;C,R&#12297; dans lequel :
&#8211; C est l&#8217;ensemble des concepts (ou classes). Un concept repr&#233;sente un ensemble d&#8217;objets r&#233;uni
par les m&#234;mes propri&#233;t&#233;s. Tout concept c &#8712; C est caract&#233;ris&#233; par un label lc (nous nous
5Nous utilisons Jena et OWL pour l&#8217;impl&#233;mentation.
</p>
<p>430</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ontologies &amp; mod&#233;lisation logique d&#8217;une commande en langue naturel
</p>
<p>limiterons &#224; un unique label pour simplifier, mais il peut y en avoir plusieurs dans le cas de
synonymie, &#224; la mani&#232;re des synsets de WordNet).
</p>
<p>&#8211; R est un ensemble de relations binaires. Chaque relation r &#8712; Rest caract&#233;ris&#233;e par un label
de relation lr et un ensemble de couples Er &#8834; C2.
</p>
<p>Par soucis de simplification, nous identifierons lr et lc respectivement au concept c et &#224; la relation
r, et nous noterons ainsi abusivement C etR les ensembles de labels de concepts et de relations.
Nous noterons L = C &#8746; R. Enfin, nous noterons &#12296;c1, r, c2&#12297; &#8712; O lorsque les concepts c1 et c2
sont reli&#233;s par la relation r.
</p>
<p>Soulignons que l&#8217;ontologie de domaine d&#8217;un agent contiendra non seulement les relations usuelles
d&#8217;hyperonymie (isa) et de meronymie (partof ), mais aussi des relations plus sp&#233;cifique du do-
maine comme isLargerThan ou leftOf .
</p>
<p>3.2 Ancrage d&#8217;un mot dans l&#8217;ontologie
</p>
<p>Soit W l&#8217;ensemble ordonn&#233; w1, ..., wn des mots utilis&#233;s dans la commande. L&#8217;ancrage dans
l&#8217;ontologie consiste &#224; trouver le label lc ou lr &#171; le plus proche &#187; pour chaque mot wi. Notre
algorithme se d&#233;compose en trois &#233;tapes :
</p>
<p>1. La simplification morphologique.
2. La recherche des &#171; approximations s&#233;mantiques &#187;.
3. L&#8217;ancrage proprement dit.
</p>
<p>La simplification morphologique consiste &#224; unifier l&#8217;&#233;criture des mots ou des groupes de mots
(accents, minuscule/majuscule, remplacement des espaces par &#171; _ &#187;, etc). Par exemple, le terme
bigger de la commande peut correspondre aux labels bigger-than, is-bigger encore biggerThan
selon la notation adopt&#233;e dans l&#8217;ontologie. Nous ne d&#233;taillerons pas le calcul de cette fonction
que nous noterons appm :St &#8722;&#8594; P(L). Elle prend en entr&#233;e un terme de la commande et ren-
voie la liste de candidats morphologiquement proche parmi les labels pr&#233;sent dans l&#8217;ontologie.
</p>
<p>La recherche des &#171; approximations s&#233;mantiques &#187;.consiste &#224; trouver l&#8217;ensemble des termes de
l&#8217;ontologie les plus proches s&#233;mantiquement d&#8217;un mot de la commande, en utilisant des mesures
de similarit&#233; s&#233;mantique comme d&#233;crites dans (Budanitsky &amp; Hirst, 2006). Nous ne faisons
pas ici d&#8217;interpr&#233;tation s&#233;mantique de la commande dans le contexte de l&#8217;application (nous
ne sommes pour l&#8217;instant que dans l&#8217;analyse structurelle), mais nous cherchons les concepts
repr&#233;sentant le mieux les mots utilis&#233;s par l&#8217;utilisateur. Cette d&#233;marche est &#233;quivalente aux
travaux visant &#224; d&#233;sambigu&#239;ser l&#8217;ensemble des concepts reconnus pour un mot d&#8217;une commande
pour ne choisir que le plus repr&#233;sentatif du contexte de la phrase6 (Porzel et al., 2003; Resnik,
1995). Par un exemple, dans la commande &#171; buy a place for the Pink Floyd show at the cheapest
price &#187;, le terme &#171; cheapest &#187; est proche du label de relation lowerThan et le le terme &#171; show &#187;
du label de concept concert7.
</p>
<p>6Il n&#8217;est pas forc&#233;ment &#233;vident que les phrases employ&#233;es au sein de notre application correspondent exacte-
ment aux sens enregistr&#233;s dans WordNet, surtout lorsqu&#8217;il s&#8217;agit d&#8217;un domaine technique (Resnik, 1995). N&#233;an-
moins, nous ne nous servons pas de WordNet pour l&#8217;interpr&#233;tation s&#233;mantique mais pour aider &#224; retrouver les
mots de l&#8217;utilisateur dans l&#8217;ontologie. Ainsi, si le domaine est technique, l&#8217;ontologie le sera aussi et la plupart des
termes utilisateurs seront retrouv&#233;s directement (ou par simplification morphologique). Nous n&#8217;avons d&#8217;ailleurs
pas constat&#233; en pratique de faux-sens &#224; ce niveau.
</p>
<p>7Ces exemples sous-entendent que &#171; cheapest &#187; et &#171; show &#187; ne sont pas d&#233;finie dans l&#8217;ontologie et n&#8217;ont pas
d&#8217;&#233;quivalent morphologique.
</p>
<p>431</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laurent MAZUEL
</p>
<p>Pour cette recherche, nous avons choisi d&#8217;utiliser la formule de Jiang &amp; Conrath (Jiang &amp;
Conrath, 1997) appliqu&#233;e aux calculs de probabilit&#233;s d&#233;finies par N. Seco (Seco et al., 2004).
Cette formule calcule sur WordNet un score de similarit&#233; s&#233;mantique compris entre [0, 1]. Nous
ne d&#233;taillerons pas cette formule ici car ce n&#8217;est pas l&#8217;objectif de cet article. Elle a &#233;t&#233; plu-
sieurs fois &#233;valu&#233; et pr&#233;sente les meilleurs r&#233;sultats actuels en la mati&#232;re (Budanitsky &amp; Hirst,
2006). Nous noterons simJC(w1, w2) le score de similarit&#233; s&#233;mantique entre les mots w1 &#8712; St
et w2 &#8712; St.
Nous noterons apps : St &#8722;&#8594; P(L) la fonction calculant l&#8217;ensemble des labels les plus proches
du terme de l&#8217;utilisateur. Nous la d&#233;finissons de la fa&#231;on suivante :
</p>
<p>apps(w) =
</p>
<p>{ &#8709; si maxwsim &lt; to
{l &#8712; L tq simJC(l, w) = maxwsim} sinon
</p>
<p>avec to &#8712; [0, 1] le seuil d&#8217;acceptabilit&#233; et la similarit&#233; maximum maxwsim = maxl&#8712;L simJC(l, w).
Le seuil d&#8217;acceptabilit&#233; to permet de d&#233;cider si l&#8217;appariement est acceptable ou non8. La si-
milarit&#233; maxwsim est le score maximal obtenu pour le mot w lors du calcul de similarit&#233; sur
l&#8217;ontologie. Autrement dit, apps(w) donne l&#8217;ensemble des concepts de l&#8217;ontologie de similarit&#233;
maximale avec w.
</p>
<p>Ainsi, nous pouvons d&#233;finir l&#8217;ancrage A &#8834; St&#215; L des mots w1, ..., wn dans l&#8217;ontologie O :
A =
</p>
<p>&#8899;
w&#8712;W
</p>
<p>&#63729;&#63732;&#63732;&#63732;&#63730;&#63732;&#63732;&#63732;&#63731;
&#8899;
</p>
<p>l&#8712;appm(w)
&#12296;w, l&#12297; Si appm(w) )= &#8709;&#8899;
</p>
<p>l&#8712;apps(w)
&#12296;w, l&#12297; Sinon
</p>
<p>Soulignons qu&#8217;un m&#234;me terme peut &#234;tre ancr&#233; &#224; plusieurs labels de l&#8217;ontologie, donc &#224; plusieurs
concepts et/ou relations.
</p>
<p>Soulignons aussi que l&#8217;interpr&#233;tation s&#233;mantique (cf. section 3.4) utilise les scores calcul&#233;s &#224;
cet &#233;tape par simJC pour d&#233;terminer l&#8217;impr&#233;cision globale de la commande. Cette impr&#233;cision
est ensuite utilis&#233;e par le gestionnaire de dialogue pour d&#233;terminer la meilleure strat&#233;gie de
dialogue.
</p>
<p>3.3 Construction des pr&#233;dicats
</p>
<p>Notre objectif est de d&#233;finir une mod&#233;lisation logique qui capture la structure fonctionnelle de
la phrase, c&#8217;est-&#224;-dire de construire un ensemble de pr&#233;dicats repr&#233;sentant les relations entre les
concepts (au sens de l&#8217;ontologie O) tels qu&#8217;ils sont exprim&#233;es dans la commande. Par exemple,
dans &#171; the big object next to the book &#187;, l&#8217;utilisateur exprime une relation &#171; next-to &#187; entre &#171; big
object &#187; et &#171; book &#187;.
</p>
<p>Pour cela, chaque terme est consid&#233;r&#233; du point de vue de son ancrage dans l&#8217;ontologie : si c&#8217;est
une relation, nous la mod&#233;liserons sous la forme d&#8217;un pr&#233;dicat et nous devons rechercher ses
arguments dans la commande parmi les autres termes/concepts. En adoptant une repr&#233;sentation
</p>
<p>8Actuellement et empiriquement, la valeur du seuil d&#8217;acceptabilit&#233; to est de 0.7.
</p>
<p>432</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ontologies &amp; mod&#233;lisation logique d&#8217;une commande en langue naturel
</p>
<p>FIG. 2 &#8211; Mod&#233;lisation de &#171; drop on the lowest line, left of the largest red cube &#187;
</p>
<p>arborescente des pr&#233;dicats, les n&#339;uds des arbres sont les termes de la commande. Les termes
qui sont des labels de concepts sont repr&#233;sent&#233;s par des feuilles. Les termes qui sont des labels
de relations sont repr&#233;sent&#233;s par des n&#339;uds dont les fils sont les arguments de la relation dans
la commande de l&#8217;utilisateur. Par exemple, dans la phrase &#171; drop on the lowest line, left of the
largest cube &#187;, &#171; drop &#187;, &#171; line &#187;, &#171; red &#187; et &#171; cube &#187; sont des feuilles, &#171; lowest &#187; aura comme
fils &#171; line &#187;. Nous obtenons alors le r&#233;sultat pr&#233;sent&#233; dans sur figure 2.
</p>
<p>Toute la difficult&#233; de cette construction r&#233;side dans la capacit&#233; &#224; d&#233;terminer quel terme est un
argument de quelle relation. Id&#233;alement, nous devrions nous appuyer sur l&#8217;analyse s&#233;mantique
de la phrase et sur les d&#233;finitions des relations dans l&#8217;ontologie pour identifier les instances
correspondant &#224; des arguments de l&#8217;agent, en utilisant du backtrack pour rechercher toutes les
permutations possibles.
</p>
<p>Mais dans un premier temps, par soucis d&#8217;efficacit&#233;, nous utiliserons l&#8217;heuristique suivante, tir&#233;e
de nos observations sur les relations dans la langue anglaise :
</p>
<p>Les arguments d&#8217;une relation sont soit l&#8217;ensemble des termes restant dans le syn-
tagme nominal de la relation, soit dans l&#8217;ensemble des termes du syntagme imm&#233;-
diatement suivant.
</p>
<p>La force de cette heuristique est qu&#8217;elle prend aussi en compte le traitement des comparatifs et
des superlatifs :
</p>
<p>1. Si un superlatif appara&#238;t, il l&#8217;est alors &#224; titre d&#8217;adjectif descriptif de l&#8217;objet. Les termes de
la commande reli&#233;s appartiennent donc au m&#234;me syntagme (e.g. &#171; the biggest square &#187;,
&#171; the darkest big object &#187;, etc.).
</p>
<p>2. Si un comparatif appara&#238;t, l&#8217;objet de la comparaison est s&#233;par&#233; par l&#8217;utilisation d&#8217;une
conjonction (&#171; than &#187;, etc.) et donc dans le syntagme suivant (e.g. &#171; higher than the
cube &#187;, &#171; left to the current position &#187;, etc.).
</p>
<p>Formellement, soit S l&#8217;ensemble ordonn&#233; {c1, c2, ..., cn} compos&#233; de n chunks tel que &#8704;i &#8712;
[1, n], ci = {si,1, si,2, ..., si,ki} o&#249; les si,j sont les termes de la commande utilisateur, regroup&#233;s
en chunks9. La fonction &#964; : S #&#8722;&#8594; Sa construit l&#8217;ensemble d&#8217;arbres Sa &#224; partir de la mod&#233;lisa-
tion de la commande chunk&#233;e S. Les &#233;l&#233;ments de Sa seront repr&#233;sent&#233;s en utilisant une notation
pr&#233;dicat/valeurs (chaque pr&#233;dicat repr&#233;sentant un n&#339;ud, et ses valeurs les fils du n&#339;ud).
</p>
<p>La fonction &#964; est d&#233;finie r&#233;cursivement par : &#964;(S) =
</p>
<p>9La commande de l&#8217;utilisateur est l&#8217;ensemble ordonn&#233; Suser = {s1,1, s1,2...., s1,k1 , s2,1, ..., s2,k2 , ..., sn,1, ..., sn,kn}.
433</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laurent MAZUEL
</p>
<p>&#63729;&#63732;&#63730;&#63732;&#63731;
{s1,1 (&#964;({{s1,2, ...s1,k1}}))} &#8746; &#964;({c2, ..., cn}) si (k1 &gt; 1) &#8743; (&#8707;c &#8712; R. &#12296;si,j, c&#12297; &#8712; A)
{s1,1 (&#964;({c2}))} &#8746; &#964;({c3, ..., cn}) si (k1 = 1) &#8743; (&#8707;c &#8712; R. &#12296;si,j, c&#12297; &#8712; A)
{s1,1} &#8746; &#964;({{s1,2, ...s1,k1}, c2, ..., cn}) sinon
</p>
<p>avec &#964;(&#8709;) = &#964;({&#8709;}) = &#8709;. Autrement dit, l&#8217;arbre Sa est obtenu en transformant chaque relation
de la commande en n&#339;ud dont les fils sont les termes restant du chunk (lorsque k1 &gt; 1) ou les
&#233;l&#233;ments du chunk imm&#233;diatement suivant lorsque la relation est le dernier &#233;l&#233;ment du chunk
(k1 = 1). Les concepts sont syst&#233;matiquement transform&#233;s en feuilles. Pour mieux comprendre
cette op&#233;ration, consid&#233;rons l&#8217;exemple suivant : &#171; drop on the lowest line, left of the largest red
cube &#187; est chunk&#233;e en :
</p>
<p>[VP Drop :VB ] [PP on :IN ] [NP the :DT lowest :JJS line :NN ] [ ? ? , :, ] [NP
left :NN ] [PP of :IN ] [NP the :DT largest :JJS red :JJ cube :NN ]
</p>
<p>Apr&#232;s filtrage des termes non- significatifs, nous obtenons l&#8217;ensemble d&#8217;ensembles :
</p>
<p>S = {{drop}, {lowest, line}, {leftof}, {largest, red, cube}}
</p>
<p>Nous obtenons alors &#964;(S) = {drop, lowest(line), leftof(largest(red, cube))}, repr&#233;sent&#233; sous
forme d&#8217;arbre sur la figure 2.
</p>
<p>3.4 Interpr&#233;tation s&#233;mantique
</p>
<p>L&#8217;analyse fonctionnelle d&#233;crite pr&#233;c&#233;demment (cf. figure 3) permet :
</p>
<p>1. La construction d&#8217;un ensemble d&#8217;arbres repr&#233;sentant la commande ;
2. L&#8217;ancrage de cet arbre, par l&#8217;ancrage de chacun de ses termes, sur l&#8217;ontologie.
</p>
<p>Ces deux propri&#233;t&#233;s sont &#224; la base de notre mod&#232;le d&#8217;analyse s&#233;mantique. En effet, de mani&#232;re
similaire, nous ancrons semi-automatiquement le code de l&#8217;agent VDL sur l&#8217;ontologie au mo-
ment de l&#8217;&#233;criture de l&#8217;agent. Ainsi, les &#233;v&#232;nements formels construits par notre algorithme
ascendant g&#233;n&#233;ratif, utilisant des termes issus du code VDL, sont d&#233;j&#224; ancr&#233;es dans l&#8217;ontolo-
gie (chaque commande g&#233;n&#233;r&#233;e ayant un ancrage diff&#232;rent). Nous nous retrouvons alors dans
une situation proche d&#8217;un probl&#232;me d&#8217;appariement d&#8217;ontologies selon une ontologie de r&#233;f&#233;-
rence (e.g. (Aleksovski et al., 2006)). L&#8217;objectif est alors d&#8217;&#233;valuer comparativement ses deux
ancrages, afin de pouvoir d&#233;cider quelles sont les commandes g&#233;n&#233;r&#233;es les plus proches de la
commande en langue naturelle de l&#8217;utilisateur.
</p>
<p>C&#8217;est l&#8217;ancrage des termes de la commande dans l&#8217;ontologie qui permet de se ramener &#224; un
probl&#232;me (non trivial) d&#8217;alignement d&#8217;ontologies. En effet, il nous est alors possible de cal-
culer l&#8217;alignement demandant le moins &#171; d&#8217;effort &#187; d&#8217;approximation entre les deux ensembles
de termes ancr&#233;s et donc d&#8217;en d&#233;duire quel couple (&#233;v&#232;nement/structure de commande) est le
meilleur candidat comme r&#233;sultat &#224; cette interpr&#233;tation s&#233;mantique.
</p>
<p>La mod&#233;lisation logique structur&#233;e de la commande utilisateur est ensuite utilis&#233;e au moment de
l&#8217;interpr&#233;tation s&#233;mantique pour calculer la fermeture transitive de la relation dans le contexte
courant de l&#8217;agent. Par exemple, si l&#8217;utilisateur parle d&#8217;un objet &#171; &#224; c&#244;t&#233; du livre &#187;, notre in-
terpr&#233;tation s&#233;mantique donne l&#8217;ensemble des positions correspondant &#224; &#171; &#224; c&#244;t&#233; du livre &#187; en
fonction de la position du livre dans l&#8217;&#233;tat courant.
</p>
<p>434</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ontologies &amp; mod&#233;lisation logique d&#8217;une commande en langue naturel
</p>
<p>FIG. 3 &#8211; &#201;tat apr&#232;s la mod&#233;lisation logique avec un &#233;v&#232;nement formel et un seul arbre de la
commande.
</p>
<p>4 Conclusion
</p>
<p>Dans cet article, nous proposons un algorithme de mod&#233;lisation d&#8217;une commande sous la forme
d&#8217;un ensemble de propositions logiques qui s&#8217;appuie sur l&#8217;utilisation de l&#8217;ontologie de l&#8217;agent.
Les symboles de pr&#233;dicats utilis&#233;s sont directement extrait &#224; partir des termes de la commande
en fonction de leur proximit&#233; avec les concepts de l&#8217;ontologie. Les r&#244;les de pr&#233;dicats ou argu-
ments pour chaque terme sont choisis &#224; partir de leur d&#233;finition dans l&#8217;ontologie. Ce m&#233;canisme
ne n&#233;cessite donc pas l&#8217;utilisation d&#8217;un formalisme particulier pour d&#233;finir les r&#232;gles d&#8217;analyse
syntaxique. La mod&#233;lisation obtenue est simple &#224; interpr&#233;ter et &#224; utiliser, en particulier pour l&#8217;in-
terpr&#233;tation s&#233;mantique de la commande. La plupart des syst&#232;mes de dialogues actuelles &#233;tant
bas&#233;s sur l&#8217;utilisation d&#8217;ontologies pour l&#8217;interpr&#233;tation s&#233;mantique, l&#8217;approche est applicable &#224;
large &#233;chelle sur des syst&#232;mes d&#8217;impl&#233;mentation diverses.
</p>
<p>La m&#233;thode d&#8217;ancrage des termes de la commande dans l&#8217;ontologie (c&#8217;est-&#224;-dire la recherche
du concept de l&#8217;ontologie le plus proche s&#233;mantiquement d&#8217;un terme donn&#233;) que nous avons
pr&#233;sent&#233; repose sur un algorithme de similarit&#233; s&#233;mantique bas&#233; sur WordNet. L&#8217;&#233;valuation
pr&#233;liminaire de notre syst&#232;me actuellement en court pr&#233;sente des r&#233;sultats encourageants. Ce-
pendant, nous voudrions la valider sur d&#8217;autres agents et ontologies que celles que nous avons
utilis&#233;es jusqu&#8217;&#224; pr&#233;sent, afin de montrer la g&#233;n&#233;ricit&#233; de notre approche.
</p>
<p>R&#233;f&#233;rences
ALEKSOVSKI Z., TEN KATE W. &amp; VAN HARMELEN F. (2006). Exploiting the structure of
background knowledge used in ontology matching. In Proc. Workshop on Ontology Matching
in ISWC2006 : CEUR Workshop Proceedings.
ALLEN J., BYRON D., DZIKOVSKA M., FERGUSON G., GALESCU L. &amp; STENT A. (2000).
An architecture for a generic dialogue shell. NLENG : Natural Language Engineering, 6.
BUDANITSKY A. &amp; HIRST G. (2006). Evaluating wordnet-based measures of semantic dis-
tance. Computational Linguistics, 32(1), 13&#8211;47.
ELIASSON K. (2007). Case-Based Techniques Used for Dialogue Understanding and Planning
in a Human-Robot Dialogue System. In Proc. of IJCAI07, p. 1600&#8211;1605.
FLYCHT-ERIKSSON A. (2003). Design of Ontologies for Dialogue Interaction and Informa-
tion Extraction. In Proc. Workshop on Knowledge and reasoning in practical dialogue systems
(IJCAI&#8217;03).
</p>
<p>435</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laurent MAZUEL
</p>
<p>HOBBS J., APPELT D., BEAR J., ISRAEL D., KAMEYAMA M., STICKEL M. &amp; TYSON
M. (1997). FASTUS : A Cascaded Finite-State Transducer for Extracting Information from
Natural-Language Text. Finite-State Language Processing, p. 383&#8211;406.
JIANG J. &amp; CONRATH D. (1997). Semantic similarity based on corpus statistics and lexical
taxonomy. In Proc. on International Conference on Research in Computational Linguistics, p.
19&#8211;33, Taiwan.
MAES P. (1994). Agents that reduce workload and information overload. Communications of
the ACM, 37(7), 30&#8211;40.
MAZUEL L. &amp; SABOURET N. (2006). Generic command interpretation algorithms for conver-
sational agents. In Proc. Intelligent Agent Technology (IAT&#8217;06), p. 146&#8211;153 : IEEE Computer
Society.
MILWARD D. (2000). Distributing representation for robust interpretation of dialogue utte-
rances. In ACL, p. 133&#8211;141.
MILWARD D. &amp; BEVERIDGE M. (2003). Ontology-based dialogue systems. In Proc. 3rd
Workshop on Knowledge and reasoning in practical dialogue systems (IJCAI03), p. 9&#8211;18.
PARAISO E. &amp; BARTH&#200;S J. (2004). Architecture d&#8217;une interface conversationnelle pour les
agents assistants personnels. In P. PAROUBECK &amp; J.-P. SANSONNET, Eds., Actes de la Jour-
n&#233;e d&#8217;Etude ATALA Agental &#171; Agents et Langue &#187;, p. 83&#8211;90, Paris, France : ATALA ATALA.
PORZEL R., GUREVYCH I. &amp; MULLER C. (2003). Ontology-based contextual coherence
scoring. In Proc. of the Fourth SIGdial Workshop on Discourse and Dialogue, Sapporo, Japan.
RESNIK P. (1995). Using information content to evaluate semantic similarity in a taxonomy.
In IJCAI, p. 448&#8211;453.
SABAH G. (2006). Compr&#233;hension des langues et interaction. Cognition et Traitement de
l&#8217;Information. Hermes-Lavoisier.
SABOURET N. &amp; MAZUEL L. (2005). Commande en langage naturel d&#8217;agents VDL. In Proc.
1st Workshop sur les Agents Conversationnels Anim&#233;s (WACA), p. 53&#8211;62.
SABOURET N. &amp; SANSONNET J. (2001). Automated Answers to Questions about a Running
Process. In Proc. CommonSense 2001, p. 217&#8211;227.
SADEK D., BRETIER P. &amp; PANAGET E. (1997). Artimis : Natural dialogue meets rational
agency. In IJCAI (2), p. 1030&#8211;1035.
SECO N., VEALE T. &amp; HAYES J. (2004). An Intrinsic Information Content Metric for Seman-
tic Similarity in WordNet. In Proc. ECAI&#8217;2004, the 16th European Conference on Artificial
Intelligence, p. 1089&#8211;1090.
SENEFF S. (2002). Response planning and generation in the MERCURY flight reservation
system. In Computer Speech and Language, volume 16, p. 283&#8211;312.
SHAPIRO S. (2000). Sneps : a logic for natural language understanding and commonsense rea-
soning. Natural language processing and knowledge representation : language for knowledge
and knowledge for language, p. 175&#8211;195.
</p>
<p>436</p>

</div></div>
</body></html>