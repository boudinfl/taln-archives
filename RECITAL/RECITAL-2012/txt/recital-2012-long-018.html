<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Peuplement d&#8217;une ontologie mod&#233;lisant le comportement d&#8217;un environnement intelligent guid&#233; par l&#8217;extraction d&#8217;instances de relations</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>Actes de la conf&#233;rence conjointe JEP-TALN-RECITAL 2012, volume 3: RECITAL, pages 281&#8211;294,
Grenoble, 4 au 8 juin 2012. c&#169;2012 ATALA &amp; AFCP
</p>
<p>Peuplement d&#8217;une ontologie mod&#233;lisant le comportement
d&#8217;un environnement intelligent
</p>
<p>guid&#233; par l&#8217;extraction d&#8217;instances de relations
</p>
<p>Driss Sadoun1, 2
(1) LIMSI/CNRS, B.P. 133 91403 Orsay Cedex, France
</p>
<p>(2) Universit&#233; Paris-Sud, 91400 Orsay, France
driss.sadoun@limsi.fr
</p>
<p>R&#201;SUM&#201;
Nous pr&#233;sentons une approche de peuplement d&#8217;ontologie dont le but est de mod&#233;liser le
comportement de composants logiciels afin de faciliter le passage de descriptions d&#8217;exigences
en langue naturelle &#224; des sp&#233;cifications formelles. L&#8217;ontologie que nous cherchons &#224; peupler
a &#233;t&#233; con&#231;ue &#224; partir des connaissances du domaine de la domotique et est initialis&#233;e &#224; partir
d&#8217;une description de la configuration physique d&#8217;un environnement intelligent. Notre m&#233;thode est
guid&#233;e par l&#8217;extraction d&#8217;instances de relations permettant par l&#224;-m&#234;me d&#8217;extraire les instances de
concepts li&#233;s par ces relations. Nous construisons des r&#232;gles d&#8217;extraction &#224; partir d&#8217;&#233;l&#233;ments issus
de l&#8217;analyse syntaxique de descriptions de besoins utilisateurs et de ressources terminologiques
associ&#233;es aux concepts et relations de l&#8217;ontologie. Notre approche de peuplement se distingue
par sa finalit&#233; qui n&#8217;est pas d&#8217;extraire toutes les instances d&#233;crivant un domaine mais d&#8217;extraire
des instances pouvant participer sans conflit &#224; un des multiples fonctionnements d&#233;crit par des
utilisateurs.
</p>
<p>ABSTRACT
Population of an Ontology Modeling the Behavior of an Intelligent Environment Guided
by Instance Relation Extractions
</p>
<p>We present an approach for ontology population, which aims at modeling the behavior of software
components, for enabling a transition from natural language requirements to formal specifications.
The ontology was designed based on the knowledge of the domotic domain and is initialized
from a description of a physical configuration of an intelligent environment. Our method focuses
on extracting relation instances which allows the extraction of concept instances linked by these
relations. We built extraction rules using elements coming from syntactic analysis of user need
descriptions, semantic and terminological resources linked to the knowledge contained in the
ontology. Our approach for ontology population, distinguishes itself by its purpose, which is not
to extract all instances describing a domain but to extract instances that can participate without
any conflict to one of the mutiple operation decribed by users.
</p>
<p>MOTS-CL&#201;S : extraction de relations, peuplement d&#8217;ontologie, repr&#233;sentation des connaissances.
</p>
<p>KEYWORDS: relation extraction, ontology population, knowledge representation.
</p>
<p>281</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>1 Introduction
</p>
<p>Les ontologies permettent une mod&#233;lisation formelle d&#8217;un domaine, en d&#233;crivant ses concepts et
les relations qu&#8217;ils entretiennent ainsi que les individus (ou instances) qui leurs sont associ&#233;s.
La conception d&#8217;une ontologie se fait en deux &#233;tapes, d&#8217;abord sa conceptualisation (Bendaoud
et al., 2007) (Wang et Turner, 2009) qui a pour but de faire &#233;merger les concepts et relations
repr&#233;sentant le domaine vis&#233;, ainsi que les axiomes qui permettront d&#8217;ordonner concepts et
relations dans l&#8217;ontologie et de classer leurs instances, ensuite son peuplement ou instanciation
qui consiste &#224; associer des instances &#224; des concepts et relations existants. C&#8217;est cette deuxi&#232;me
t&#226;che qui sera trait&#233;e dans cet article.
</p>
<p>La m&#233;thode de peuplement choisie est en g&#233;n&#233;ral conditionn&#233;e par l&#8217;usage auquel est destin&#233;e
l&#8217;ontologie. Dans le cas d&#8217;une ontologie mod&#233;lisant un domaine de fa&#231;on descriptive (De Boer
et al., 2007) (Maynard et al., 2008), le but est de d&#233;tecter, d&#8217;extraire et de lister syst&#233;matiquement
toutes les instances contenues dans les textes pouvant refl&#233;ter un concept ou une relation
du domaine &#224; d&#233;crire. L&#8217;ontologie que nous avons con&#231;ue a pour vocation de mod&#233;liser le
comportement dynamique d&#8217;un syst&#232;me de composants logiciels, en l&#8217;occurrence le comportement
d&#8217;un environnement intelligent, que nous avons mod&#233;lis&#233; &#224; partir de l&#8217;&#233;tude des domaines de
r&#233;seaux de capteurs, des environnements intelligents et de la domotique (Sadoun et al., 2011).
Le processus de peuplement aura pour but d&#8217;extraire seulement les instances refl&#233;tant un
comportement possible de ce syst&#232;me sp&#233;cifique &#224; des exigences d&#8217;utilisateurs.
</p>
<p>L&#8217;ambition du projet (Envie Verte 1) dans lequel s&#8217;inscrit ce travail, est de permettre le pilotage
d&#8217;un environnement intelligent en partant de descriptions en langue naturelle du comportement
du syst&#232;me vers des sp&#233;cifications formelles. Les sp&#233;cifications sont donn&#233;es par des utilisateurs
pour exprimer leurs besoins. L&#8217;int&#233;r&#234;t est de permettre une v&#233;rification formelle de la configura-
tion r&#233;sultat avant de la d&#233;ployer. A cette fin, nous avons propos&#233; de passer par l&#8217;interm&#233;diaire
d&#8217;une ontologie du comportement de composants logiciels, pour faciliter le passage de l&#8217;informel
vers le formel (Sadoun et al., 2012). En effet, du fait de leur formalisme bas&#233; sur les logiques de
description, les ontologies constituent un outil puissant pour l&#8217;aide &#224; la v&#233;rification d&#8217;exigences et
de sp&#233;cifications formul&#233;es en langue naturelle. Nous exploitons ontologie et r&#232;gles pour repr&#233;-
senter et v&#233;rifier la consistance et la compl&#233;tude des sp&#233;cifications d&#233;crivant les comportements
de composants logiciels. L&#8217;int&#233;r&#234;t est de rendre ces comportements facilement param&#233;trables et
adaptables.
</p>
<p>L&#8217;ontologie ayant &#233;t&#233; d&#233;finie, cet article en d&#233;crit une m&#233;thode de peuplement. La m&#233;thode
propos&#233;e est centr&#233;e sur la d&#233;tection d&#8217;instances de relations appartenant &#224; la conceptualisation,
point de d&#233;part pour l&#8217;identification d&#8217;instances de concepts.
</p>
<p>La section suivante d&#233;crit l&#8217;&#233;tat de l&#8217;art, la section 3 d&#233;crit bri&#232;vement l&#8217;ontologie, la section
4 d&#233;crit les descriptions d&#8217;environnement et des exigences. En section 5, nous introduisons la
notion d&#8217;interpr&#233;tation des exigences. La section 6 d&#233;crit la m&#233;thode de peuplement d&#8217;ontologie,
puis en section 7 nous discutons la gestion de l&#8217;implicite avant la conclusion et la d&#233;finition des
perspectives.
</p>
<p>1. http ://envieverte.limsi.fr/, projet financ&#233; par DIGITEO 2010
</p>
<p>282</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>2 &#201;tat de l&#8217;art
</p>
<p>Le peuplement automatique d&#8217;ontologie &#224; partir de textes est une probl&#233;matique qui a donn&#233;
lieu &#224; diff&#233;rentes approches (Alani et al., 2003) , (Alani et al., 2004) , (Amardeilh et al., 2005),
(Maynard et al., 2008).
</p>
<p>Afin d&#8217;extraire des connaissances relatives aux artistes sur le web, (Alani et al., 2004) applique
une analyse syntaxique et s&#233;mantique pour la reconnaissance d&#8217;entit&#233;s nomm&#233;es et l&#8217;extraction
de relations entre instances. La base de connaissance ainsi peupl&#233;e servira &#224; la g&#233;n&#233;ration
automatique de biographies.
</p>
<p>(Amardeilh et al., 2005) propose l&#8217;enrichissement d&#8217;une base de connaissance (Topics Maps)
contrainte par une ontologie du domaine. Pour cela il d&#233;finit des r&#232;gles d&#8217;acquisition en langage
XPath pour mettre en correspondance des extractions linguistiques avec l&#8217;ontologie du domaine.
Ces r&#232;gles d&#8217;acquisition s&#8217;appuient sur le parcours d&#8217;arbres conceptuels contenant les informations
pertinentes pour le domaine. (Maynard et al., 2008) utilise une m&#233;thode linguistique et statistique
pour la reconnaissance de termes et utilise des informations contextuelles de trois types :
syntaxique, terminologique et s&#233;mantique. (Witte et al., 2010) utilise des annotations issues
d&#8217;analyses syntaxiques pour associer des entit&#233; nomm&#233;es &#224; des instances de concepts et relations.
</p>
<p>L&#8217;identification de relations conceptuelles dans les textes est un probl&#232;me majeur dans le processus
de peuplement d&#8217;une ontologie, cette t&#226;che a suscit&#233; plusieurs travaux.
</p>
<p>(Makki et al., 2008) d&#233;crit l&#8217;utilisation d&#8217;outils de traitement des langues pour le peuplement
d&#8217;une ontologie de gestion des risques. En partant du principe que les relations s&#233;mantiques
entre concepts sont le plus souvent repr&#233;sent&#233;es par des verbes, il extrait des relations issues
d&#8217;une analyse des verbes et de leur entourage afin d&#8217;extraire des triplets, en utilisant des listes
de verbes synonymes des relations conceptuelles construites &#224; l&#8217;aide de WordNet. Dans notre
m&#233;thode nous construisons des classes s&#233;mantiques contenant des termes, et pas uniquement
des verbes, dont l&#8217;association avec des relations s&#233;mantiques ou concepts est propre au domaine
d&#8217;application.
</p>
<p>(Hasegawa et al., 2004) propose une approche fond&#233;e sur le regroupement de paires d&#8217;enti-
t&#233;s nomm&#233;es apparaissant dans des contextes similaires, o&#249; chaque paire d&#8217;une m&#234;me classe
est consid&#233;r&#233;e comme une instance de la m&#234;me relation. (Bentibebel et al., 2009) g&#233;n&#233;ralise
cette approche en construisant des classes d&#8217;association de termes repr&#233;sentant des relations
conceptuelles potentielles. Une fois ces relations conceptuelles valid&#233;es, ils y associent des r&#232;gles
d&#8217;extraction pour extraire d&#8217;autres occurrences.
</p>
<p>(Lin et Pantel, 2001) avance que des relations binaires peuvent &#234;tre repr&#233;sent&#233;es par des chemins
dans les arbres de d&#233;pendances syntaxiques, ces chemins auront des significations similaires
s&#8217;ils ont tendance &#224; se connecter aux m&#234;mes ensembles de mots. (Nakamura-Delloye et Stern,
2011) exploite ces chemins syntaxiques, pour identifier des relations entre couple d&#8217;entit&#233;
nomm&#233;es pr&#233;alablement extraits (Nakamura-Delloye, 2011) et leurs r&#232;gles. Nous g&#233;n&#233;ralisons
cette approche pour la d&#233;finition de r&#232;gles d&#8217;extraction d&#8217;instances de relations et de concepts,
en exploitant des chemins reliant diff&#233;rent types d&#8217;unit&#233; textuelles.
</p>
<p>283</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>3 Ontologie de l&#8217;environnement intelligent
</p>
<p>L&#8217;environnement intelligent consiste en un ensemble d&#8217;objets communicants (capteurs, action-
neurs et processus de contr&#244;le) qui peut &#234;tre vu comme un r&#233;seau de capteurs. Ces objets
influencent le comportement des &#233;quipements de l&#8217;environnement, sous des conditions bien
d&#233;finies. On peut distinguer une partie mat&#233;rielle : les diff&#233;rents &#233;quipements, leur nombre, leur
type, leur localisation etc. et une partie logicielle : la configuration du comportement.
</p>
<p>Ces deux aspects permettent de d&#233;crire le comportement g&#233;n&#233;ral d&#8217;un environnement intelligent :
&#8211; Un capteur d&#233;tecte l&#8217;apparition d&#8217;un ph&#233;nom&#232;ne ou mesure un ph&#233;nom&#232;ne quantifiable dans
</p>
<p>un espace restreint.
&#8211; Un ph&#233;nom&#232;ne, pour &#234;tre d&#233;tect&#233; ou mesur&#233; par un capteur, doit &#234;tre localis&#233; dans la zone de
</p>
<p>capture du capteur et &#234;tre du type per&#231;u par le capteur (temp&#233;rature, mouvement, ...)
&#8211; Un actionneur est fix&#233; ou connect&#233; &#224; un appareil de l&#8217;environnement.
&#8211; Quand un ph&#233;nom&#232;ne (ou un ensemble de ph&#233;nom&#232;nes) est mesur&#233; ou d&#233;tect&#233;, un contr&#244;le des
</p>
<p>informations collect&#233;es est effectu&#233; et peut conduire &#224; l&#8217;activation d&#8217;un ou plusieurs actionneurs
pour d&#233;clencher une ou plusieurs actions (allumer, &#233;teindre, diminuer, augmenter) sur les
appareils auxquels ils sont connect&#233;s.
</p>
<p>&#8211; Un actionneur peut &#234;tre activ&#233; par un capteur (ou un ensemble de capteurs), s&#8217;il est localis&#233;
dans sa zone (leur zone) de contr&#244;le et g&#232;re le(s) m&#234;me type(s) de ph&#233;nom&#232;ne.
</p>
<p>La figure 1 repr&#233;sente la conceptualisation du comportement de l&#8217;environnement intelligent 2.
</p>
<p>Sensor
</p>
<p>Measuring_sensor Measurable
</p>
<p>Detecting_sensor Event
</p>
<p>Sensor_network_component
</p>
<p>Actuator
</p>
<p>Physical_process
</p>
<p>Location
</p>
<p>Phenomenon
</p>
<p>Actuate_on
</p>
<p>Measure
</p>
<p>Detect
</p>
<p>Located_in
</p>
<p>Zone_of_sensingZone_of_control
</p>
<p>Is_a
</p>
<p>Actuate_on:
</p>
<p>Located_in:
</p>
<p>Zone_of_control:
Zone_of_sensing:
</p>
<p>Measure:
</p>
<p>Detect:
</p>
<p>: disjoint partitions
</p>
<p>Functional
</p>
<p>Functional
</p>
<p>Functional
Functional
Functional
</p>
<p>Transitive
</p>
<p>Property characteristics
</p>
<p>Type
</p>
<p>Located_inLocated_in
</p>
<p>Located_in
</p>
<p>Is_a
</p>
<p>Is_a
Is_a
</p>
<p>Is_a Is_a
</p>
<p>Perceived_type
</p>
<p>Has_type
</p>
<p>Managed_type
</p>
<p>Has_type: Functional
</p>
<p>FIGURE 1 &#8211; Ontologie d&#8217;environnement intelligent
</p>
<p>3.1 R&#244;le de l&#8217;ontologie
</p>
<p>L&#8217;ontologie que nous avons con&#231;ue a pour vocation de faciliter le passage de descriptions des
besoins &#224; des sp&#233;cifications formelles, en vue d&#8217;une v&#233;rification de la consistance et de la
</p>
<p>2. L&#8217;absence d&#8217;un concept utilisateur dans l&#8217;ontologie, est d&#251; au fait que les utilisateurs de l&#8217;environnement ne sont
repr&#233;sent&#233; que par les ph&#233;nom&#232;nes qu&#8217;il peuvent engendrer tel qu&#8217;une pi&#232;ce vide ou pleine.
</p>
<p>284</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>coh&#233;rence de la configuration d&#233;crite en langage naturel par l&#8217;utilisateur de l&#8217;environnement
intelligent. Elle n&#8217;a donc pas vocation &#224; d&#233;crire exhaustivement le domaine des environnements
intelligents et doit rester &#224; un niveau de description assez &#233;lev&#233; pour &#234;tre la plus g&#233;n&#233;rale possible,
afin de pouvoir repr&#233;senter tous les cas de fonctionnement envisageables par un utilisateur. Pour
plus de d&#233;tails sur la conception de l&#8217;ontologie voir (Sadoun et al., 2012)
</p>
<p>La conceptualisation n&#8217;&#233;tant pas soumise au changement selon les besoins utilisateurs, la structure
de l&#8217;ontologie (concepts et relations) a &#233;t&#233; con&#231;ue et fig&#233;e &#224; partir de l&#8217;&#233;tude du domaine des
environnements intelligents et des r&#233;seaux de capteurs. Au contraire, l&#8217;instanciation de l&#8217;ontolo-
gie variera en fonction des descriptions de la configuration physique de l&#8217;environnement et des
besoins utilisateur, et refl&#232;tera pour chaque instanciation un comportement particulier de l&#8217;envi-
ronnement intelligent. La v&#233;rification du mod&#232;le r&#233;sultant permettra de d&#233;tecter d&#8217;&#233;ventuelles
incoh&#233;rences ou oublis dans les descriptions.
</p>
<p>Nous avons d&#233;cid&#233; d&#8217;utiliser comme langage de mod&#233;lisation, le langage OWL augment&#233; de SWRL
et SQWRL pour sa grande expressivit&#233; de repr&#233;sentation des connaissances et ses m&#233;canismes
de raisonnement permettant d&#8217;effectuer un bon nombre des v&#233;rifications n&#233;cessaires avant le
d&#233;ploiement du syst&#232;me mod&#233;lis&#233;.
</p>
<p>3.2 Connaissances mod&#233;lis&#233;es
</p>
<p>L&#8217;ontologie contient deux niveaux : terminologique (TBox) et assertionnel (Abox). Le premier
niveau permet d&#8217;exprimer &#224; l&#8217;aide d&#8217;axiomes des relations entre concepts, ce qui permet par
exemple de d&#233;finir le Domaine et le Range d&#8217;une relation ou de marquer la diff&#233;rence entre un
capteur qui mesure et un capteur qui d&#233;tecte.
</p>
<p>La relation Measure a comme Domaine : Measuring_Sensor et comme Range : Measurable
Un capteur qui mesure est un capteur qui mesure un mesurable.
Measuring_Sensor &#8801; Sensor &#8743; &#8707;Measure.Measurable
La relation Detect a comme Domaine : Detect ing_Sensor et comme Range : Event
Un capteur qui d&#233;tecte est un capteur qui d&#233;tecte un &#233;v&#232;nement.
Detect ing_Sensor &#8801; Sensor &#8743; &#8707;Detect.Event
Le peuplement portera sur le second niveau de notre ontologie et consistera &#224; cr&#233;er les assertions
identifi&#233;es &#224; partir de l&#8217;analyse des descriptions. Diff&#233;rents cas de comportement seront mod&#233;lis&#233;s
par diff&#233;rentes instanciations, issues des descriptions d&#8217;environnement et des besoins utilisateurs.
Chaque instanciation est une sp&#233;cialisation de l&#8217;ontologie, qui repr&#233;sente un comportement
sp&#233;cifique d&#8217;un environnement donn&#233; correspondant aux exigences des utilisateurs.
</p>
<p>3.3 R&#232;gles de comportement
</p>
<p>Des r&#232;gles SWRL permettent de repr&#233;senter les r&#232;gles de comportement dynamique de l&#8217;envi-
ronnement, liant ph&#233;nom&#232;nes et capteurs et capteur et actionneur. Certaines de ces r&#232;gles sont
ind&#233;pendantes des descriptions, car elles repr&#233;sentent un comportement g&#233;n&#233;ral du syst&#232;me.
D&#8217;autres r&#232;gles sont cr&#233;&#233;es automatiquement lorsqu&#8217;elles refl&#232;tent un comportement sp&#233;cifique
aux exigences d&#8217;utilisateurs.
</p>
<p>285</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Les r&#232;gles SWRL (1),(2),(3) repr&#233;sentent des r&#232;gles de comportement g&#233;n&#233;ral de l&#8217;environnement,
la r&#232;gle (4) repr&#233;sente une r&#232;gle sp&#233;cifique &#224; des sp&#233;cifications d&#8217;exigence. Les deux r&#232;gles ci-
dessous permettent de d&#233;duire (ou de cr&#233;er) les instances de la relation Shared_type( ?s, ?e)
</p>
<p>Le ph&#233;nom&#232;ne p et le capteur s partagent le m&#234;me type
Has_t ype(?p, ?t), Perceived_t ype(?s, ?t)&#8594; Shared_t ype(?p, ?s) (1)
L&#8217;actionneur a et le capteur s partagent le m&#234;me type
Managed_t ype(?a, ?t), Perceived_t ype(?s, ?t)&#8594; Shared_t ype(?p, ?s) (2)
Ainsi, certaines instances sont issues du processus de peuplement quand d&#8217;autres sont d&#233;duites
lors d&#8217;un raisonnement sur les instances pr&#233;sentes dans l&#8217;ontologie.
</p>
<p>La r&#232;gle SWRL ci-dessous, stipule que la pr&#233;sence d&#8217;un &#233;v&#233;nement e et d&#8217;un capteur s qui partagent
le m&#234;me type, quand e est localis&#233; dans la zone de d&#233;tection de s, entraine la d&#233;tection de e par s
( Detect(?s, ?e) )
</p>
<p>Event(?e), Sensor(?s), Shared_t ype(s?, ?e), Located_in(?e, l),
Zone_o f _sensing(?s, l)&#8594; Detect(?s, ?e) (3)
Dans la r&#232;gle sp&#233;cifique ci-dessous, nous distinguons deux parties, une premi&#232;re fixe et ind&#233;-
pendante des textes, et une seconde partie (soulign&#233;e dans la r&#232;gle) g&#233;n&#233;r&#233;e en fonction des
exigences d&#233;crites dans les textes.
</p>
<p>Lorsqu&#8217;un capteur mesure une valeur sup&#233;rieure &#224; 20 , l&#8217;actionneur du m&#234;me type augmente
l&#8217;appareil qu&#8217;il contr&#244;le.
</p>
<p>Actuator(?a), Physical_process(?p), Actuate_on(?a, ?p), Located_in(?a, ?l), Measure(?s, ?m),
Shared_t ype(?s, ?a), Zone_o f _cont rol(?s, ?l), Has_value(?m, ?v), lessThanOrEqual(?v, &#8221;20&#8221;)
&#8594; Increase(?a, ?p) (4)
</p>
<p>4 Descriptions textuelles
</p>
<p>Pour piloter son environnement, un utilisateur d&#233;crit, selon la configuration physique de son
environnement, les fonctionnalit&#233;s devant &#234;tre configur&#233;es pour satisfaire ses besoins.
</p>
<p>1. Description de l&#8217;environnement intelligent : d&#233;crit les composants de l&#8217;environnement (cap-
teurs, actionneurs, processus physique, ...), leur nombre, leur type, leur localisation et
leur mani&#232;re d&#8217;interagir. Cette partie d&#233;finit l&#8217;&#233;tat statique de l&#8217;environnement et doit &#234;tre
trait&#233;e avant les besoins utilisateur.
Exemple : L&#8217;appartement vert poss&#232;de un couloir, deux chambres, une salle de bain, et un
grand living qui contient une salle &#224; manger et une cuisine. Chaque pi&#232;ce est &#233;quip&#233;e de
capteurs de mouvement. Chaque ampoule est &#233;quip&#233;e d&#8217;un actionneur.
</p>
<p>2. Besoins utilisateur : d&#233;crit comment et sous quelles conditions les objets de l&#8217;environnement
doivent interagir. Cela permet de produire diff&#233;rentes instanciations de l&#8217;ontologie selon
diff&#233;rents sc&#233;narios.
Exemple : Quand une personne est dans le living room, y allumer la lumi&#232;re.
</p>
<p>Le but de notre projet &#233;tant la v&#233;rification automatique d&#8217;exigences, la description de l&#8217;environne-
ment qui ne fait qu&#8217;&#233;num&#233;rer des composants physiques et leurs modes d&#8217;utilisation. ne nous
</p>
<p>286</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>int&#233;ressera pas dans la phase d&#8217;extraction automatique d&#8217;informations pour le peuplement de
l&#8217;ontologie. Cette description sert n&#233;anmoins &#224; initialiser l&#8217;ontologie (premi&#232;re instanciation)
avec les connaissances li&#233;es aux caract&#233;ristiques physiques de l&#8217;environnement qui seront non
soumises aux changements. L&#8217;instanciation automatique s&#8217;appuiera donc plus particuli&#232;rement
sur les informations contenues dans les descriptions des besoins utilisateur.
</p>
<p>Dans le cadre de notre projet nous partons de descriptions en anglais. Pour la collecte de descrip-
tions de besoins utilisateurs (en anglais et fran&#231;ais), nous avons mis en place une plateforme 3
</p>
<p>permettant &#224; des participants de d&#233;crire un environnement intelligent, en l&#8217;occurrence une
maison intelligente, dont la configuration physique est repr&#233;sent&#233;e par un plan et une description
de diff&#233;rents objets de l&#8217;environnement et de leur mode d&#8217;interaction. Cette description reste
n&#233;anmoins assez g&#233;n&#233;rale de sorte &#224; permettre aux participants d&#8217;exprimer diff&#233;rentes id&#233;es de
configuration correspondant &#224; des besoins vari&#233;s.
</p>
<p>5 Interpr&#233;tation des exigences utilisateur
</p>
<p>Les descriptions utilisateur d&#233;crivent le comportement de l&#8217;environnement en fonction de la
pr&#233;sence de diff&#233;rents ph&#233;nom&#232;nes. Comme les ph&#233;nom&#232;nes possibles ne peuvent g&#233;n&#233;ralement
pas tous appara&#238;tre en m&#234;me temps, ces descriptions contiennent en fait diff&#233;rents cas de
fonctionnement qu&#8217;on appelle interpr&#233;tation.
</p>
<p>Une interpr&#233;tation repr&#233;sente l&#8217;&#233;tat de l&#8217;environnement intelligent &#224; un instant t, cet &#233;tat sera
d&#233;termin&#233; par toutes les instances qui seront pr&#233;sentes dans l&#8217;ontologie &#224; l&#8217;instant t. Une inter-
pr&#233;tation ne contiendra pas toutes les instances reconnues dans les textes mais seulement un
sous-ensemble coh&#233;rent d&#8217;instances mod&#233;lisant une partie des exigences utilisateur.
</p>
<p>Ces instances ont une existence conditionnelle, comme cela est illustr&#233; par les deux phrases
suivantes &quot;When someone is in the kitchen, turn on the light.&quot; et &quot;When nobody is in the kitchen,
turn off the light.&quot;. Les instances de relations et de concepts pouvant &#234;tre extraites de ces phrases
devront donc logiquement appartenir &#224; deux interpr&#233;tations diff&#233;rentes, car il ne peut y avoir au
m&#234;me instant quelqu&#8217;un et personne dans la cuisine. Dans le cas contraire les m&#234;mes instances
d&#233;clencheraient deux r&#232;gles contradictoires engendrant l&#8217;assertion des deux relations Turn_on et
Turn_off entre les m&#234;mes instances, ce qui cr&#233;era une incoh&#233;rence lors du raisonnement.
</p>
<p>L&#8217;instanciation doit donc prendre garde &#224; ne pas ajouter toutes les instances extraites en m&#234;me
temps ou du moins celles pouvant &#234;tre en conflit. Pour le moment, l&#8217;instanciation et le raison-
nement portent sur les instances d&#8217;une phrase &#224; la fois pour &#233;viter les incoh&#233;rences dues &#224; des
instances oppos&#233;es pouvant d&#233;clencher des r&#232;gles contradictoires. Il y a donc autant d&#8217;instancia-
tions que de phrases pr&#233;sentes dans les descriptions. L&#8217;identification d&#8217;instances en conflit s&#8217;inscrit
dans nos travaux futurs.
</p>
<p>Afin de pouvoir naviguer entre descriptions et ontologie, chaque instance extraite se voit allouer
un indice compos&#233; de deux num&#233;ros, celui de la phrase dont elle est issue ainsi que la position
de son n&#339;ud dans l&#8217;arbre syntaxique.
Exemple : Si l&#8217;instance i est issue de l&#8217;analyse de la phrase num&#233;ro 11 et que le num&#233;ro du
n&#339;ud repr&#233;sentant i dans l&#8217;arbre syntaxique est 4, on cr&#233;e les deux instances de relations
Phrase_number(i, 11) et Node_number(i, 4).
</p>
<p>3. http ://perso.limsi.fr/Individu/sadoun/Application/en/SmartHome.php
</p>
<p>287</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Cette r&#233;f&#233;rence &#224; l&#8217;arbre syntaxique va permettre d&#8217;aller dans les descriptions pointer dans les
phrases les termes correspondant aux instances qui sont ambigu&#235;s ou qui cr&#233;ent des incoh&#233;rences,
pour permettre aux utilisateurs de corriger et d&#8217;am&#233;liorer leurs exigences.
</p>
<p>6 Peuplement de l&#8217;ontologie
</p>
<p>La figure 2 illustre le processus de peuplement &#224; partir de sp&#233;cifications en langue naturelle.
L&#8217;ontologie est d&#8217;abord initialis&#233;e avec les instances qui d&#233;crivent sa configuration physique.
L&#8217;utilisation des r&#233;sultats d&#8217;une analyse syntaxique des descriptions utilisateurs faite par le
Stanford Parser (de Marneffe et al., 2006), de ressources terminologiques et des connaissances
d&#233;j&#224; pr&#233;sentes dans l&#8217;ontologie, permettent d&#8217;appliquer des r&#232;gles pour l&#8217;extraction d&#8217;instances.
Les instances extraites vont peupler l&#8217;ontologie et peuvent &#224; leur tour servir &#224; l&#8217;identification de
nouvelles instances.
</p>
<p>Descriptions
</p>
<p>Ontologie
Application
</p>
<p>environnement
utilisateur
</p>
<p>Description
</p>
<p>r&#233;utilisation des instances
</p>
<p>Ressouces
</p>
<p>Initialisation
</p>
<p>l&#8217;ontologie
de
</p>
<p>syntaxique
Analyse
</p>
<p>terminologiques de
</p>
<p>r&#232;gles
de
</p>
<p>d&#8217;extraction
</p>
<p>FIGURE 2 &#8211; Processus de peuplement de l&#8217;ontologie
</p>
<p>6.1 Initialisation de l&#8217;ontologie
</p>
<p>La phase d&#8217;initialisation a pour but de peupler l&#8217;ontologie avec toutes les instances qui re-
pr&#233;sentent la configuration physique de l&#8217;environnement intelligent (instances de capteurs,
d&#8217;actionneurs, appareils, localisations et relations entre instances). Ces instances sont peu sujettes
aux changements, et donc l&#8217;initialisation ne se fait qu&#8217;une fois via une interface de saisie.
</p>
<p>Ci-dessous un exemple d&#8217;instanciation du concept Detect ing_sensor :
</p>
<p>Detecting_sensor(s1) : s1 est une instance de Detect ing_sensor. (I1)
Perceived_type(s1, movement) : s1 d&#233;tecte des ph&#233;nom&#232;nes de type movement. (I2)
Zone_of_sensing(s1,kitchen) : s1 a comme zone de d&#233;tection kitchen (I3)
Zone_of_control(s1,kitchen) : s1 a comme zone de contr&#244;le kitchen (I4)
</p>
<p>Lors de l&#8217;initialisation de l&#8217;ontologie, une instance est cr&#233;&#233;e pour chaque capteur avec comme
</p>
<p>288</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>propri&#233;t&#233;s son type, sa zone de d&#233;tection et sa zone de contr&#244;le.
</p>
<p>6.2 Extraction des instances
</p>
<p>Nous avons choisi de prendre comme point de d&#233;part la d&#233;tection d&#8217;instances de relations plut&#244;t
que de concepts pour aborder le processus de peuplement, choix qui se justifie, par la liste plus
limit&#233;e des formulations pouvant repr&#233;senter des instances de relations dans les corpus. De plus,
seule l&#8217;extraction des instances de concepts participant &#224; une relation s&#233;mantique mod&#233;lis&#233;e dans
l&#8217;ontologie nous int&#233;resse.
</p>
<p>Pour extraire une instance de relation, il faut reconnaitre d&#8217;abord des concepts pouvant la refl&#233;ter,
puis v&#233;rifier que les concepts auxquels elle est li&#233;e dans le texte correspondent aux concepts du
Domaine ou du Range de la relation.
</p>
<p>Nous distinguons deux types de classes s&#233;mantiques, certaines calqu&#233;es sur les concepts et
relations mod&#233;lis&#233;s dans l&#8217;ontologie, telle que la classe &quot;Turn on&quot; contenant tous les termes
pouvant refl&#233;ter l&#8217;action d&#8217;allumer ou de mettre en marche (light on, switch on, open, ...), &#224;
l&#8217;oppos&#233; de la classe &quot;Turn off&quot; (light off, switch off, close, ...) qui refl&#232;te l&#8217;action d&#8217;&#233;teindre ou de
mettre &#224; l&#8217;arr&#234;t, ou la classe &quot;Location&quot; contenant tous termes correspondant &#224; une instance de
localisation issue de la description de l&#8217;environnement (hall, kitchen, parent&#8217;s bedroom, living
room, ...). et d&#8217;autres classes s&#233;mantiques portant sur des connaissances moins sp&#233;cifiques, telle
que la classe S&#233;mantique Conditional Introducer (when, if, each time, ...) qui contient les termes
introduisant une condition.
</p>
<p>L&#8217;utilisation de ressources telles que WordNet, VerbNet ou FrameNet s&#8217;av&#232;re utile pour la construc-
tion de ressources terminologiques. N&#233;anmoins, &#233;tant bas&#233;es sur des connaissances g&#233;n&#233;rales, les
classes s&#233;mantiques qu&#8217;elles d&#233;finissent se r&#233;v&#232;lent &#234;tre moins pertinentes en domaine sp&#233;cialis&#233;
et ne correspondent pas aux concepts que nous avons d&#233;finis.
</p>
<p>L&#8217;ontologie permet de d&#233;finir un vocabulaire conceptuel sans toutefois contenir le volet termi-
nologique. L&#8217;essentiel des connaissances terminologiques que nous utilisons pour l&#8217;extraction
d&#8217;instances de relations et de concepts sont issues de ressources terminologiques ext&#233;rieures &#224;
l&#8217;ontologie mais li&#233;es aux connaissances qu&#8217;elle mod&#233;lise.
</p>
<p>6.3 Extraction des instances
</p>
<p>Nous avons choisi de prendre comme point de d&#233;part la d&#233;tection d&#8217;instances de relations plut&#244;t
que de concepts pour aborder le processus de peuplement, choix qui se justifie par la liste plus
limit&#233;e des formulations pouvant repr&#233;senter des instances de relations dans les corpus. De plus,
seule l&#8217;extraction des instances de concepts participant &#224; une relation s&#233;mantique mod&#233;lis&#233;e dans
l&#8217;ontologie nous int&#233;resse.
</p>
<p>Pour extraire une instance de relation, il faut reconnaitre d&#8217;abord des termes et structures
syntaxiques pouvant la refl&#233;ter, puis v&#233;rifier que les concepts auxquels elle est li&#233;e dans le texte
correspondent aux concepts du Domaine ou du Range de la relation.
</p>
<p>Nous avons donc construit des lexiques permettant de lier termes et concepts. Nous distinguons
deux types de classes s&#233;mantiques. Certaines sont calqu&#233;es sur les concepts et relations mod&#233;lis&#233;s
</p>
<p>289</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>dans l&#8217;ontologie, telle que la classe &quot;Turn on&quot; contenant tous les termes pouvant refl&#233;ter l&#8217;action
d&#8217;allumer ou de mettre en marche (light on, switch on, open, ...), &#224; l&#8217;oppos&#233; de la classe &quot;Turn
off&quot; (light off, switch off, close, ...) qui refl&#232;te l&#8217;action d&#8217;&#233;teindre ou de mettre &#224; l&#8217;arr&#234;t, ou la
classe &quot;Location&quot; contenant tous termes correspondant &#224; une instance de localisation issue de la
description de l&#8217;environnement (hall, kitchen, parent&#8217;s bedroom, living room, ...). D&#8217;autres classes
s&#233;mantiques portent sur des connaissances moins sp&#233;cifiques, telle que la classe S&#233;mantique
Conditional Introducer (when, if, each time, ...) qui contient les termes introduisant une condition.
</p>
<p>L&#8217;utilisation de ressources telles que WordNet, VerbNet ou FrameNet s&#8217;av&#232;re utile pour la construc-
tion de ressources terminologiques. N&#233;anmoins, &#233;tant bas&#233;es sur des connaissances g&#233;n&#233;rales, les
classes s&#233;mantiques qu&#8217;elles d&#233;finissent se r&#233;v&#232;lent &#234;tre moins pertinentes en domaine sp&#233;cialis&#233;
et ne correspondent pas directement aux concepts que nous avons d&#233;finis.
</p>
<p>L&#8217;ontologie permet de d&#233;finir le vocabulaire conceptuel sans toutefois contenir le volet termi-
nologique. L&#8217;essentiel des connaissances terminologiques que nous utilisons pour l&#8217;extraction
d&#8217;instances de relations et de concepts sont issues de ressources terminologiques ext&#233;rieures &#224;
l&#8217;ontologie mais li&#233;es aux connaissances qu&#8217;elle mod&#233;lise.
</p>
<p>6.4 Construction de r&#232;gles d&#8217;extraction
</p>
<p>6.4.1 Chemin syntaxique
</p>
<p>La construction de r&#232;gles d&#8217;extraction s&#8217;appuie sur une analyse des d&#233;pendances syntaxiques.
Dans un arbre de d&#233;pendances (cf figure 3), les d&#233;pendances syntaxiques lient deux n&#339;uds, le
premier que nous appellerons n&#339;ud directeur et le second n&#339;ud d&#233;pendant. Un chemin syntaxique
entre deux n&#339;uds est repr&#233;sent&#233; par les d&#233;pendances qui les lient.
</p>
<p>Par exemple, soit la d&#233;pendance syntaxique sub j(is, someone)
</p>
<p>&#8211; nsubj : nom de la relation (d&#233;pendence sujet nominal)
&#8211; is : mot contenu dans le n&#339;ud directeur.
&#8211; someone : mot contenu dans le n&#339;ud d&#233;pendant.
</p>
<p>Exemple : When someone is in the kitchen, turn on the light. La figure 3 repr&#233;sente l&#8217;arbre des
d&#233;pendances syntaxiques de cette phrase 4.
</p>
<p>FIGURE 3 &#8211; Arbre des d&#233;pendances syntaxiques
</p>
<p>4. Image produite &#224; l&#8217;aide de DependenSee.jar http ://chaoticity.com/dependensee-a-dependency-parse-visualisation-
tool/
</p>
<p>290</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>6.4.2 R&#232;gles d&#8217;extraction
</p>
<p>Les r&#232;gles d&#8217;extraction que nous construisons doivent &#234;tre assez g&#233;n&#233;rales pour s&#8217;appliquer sur
diff&#233;rentes formulations de phrases et assez sp&#233;cifiques pour n&#8217;extraire que les instances de
relations et de concepts les plus pertinentes.
</p>
<p>L&#8217;utilisation de chemins syntaxiques pour reconnaitre la pr&#233;sence d&#8217;instances candidates &#224;
l&#8217;extraction permet de traiter diff&#233;rent types de phrases car les d&#233;pendances syntaxiques formant
ces chemins peuvent apparaitre dans diff&#233;rentes formulations. La v&#233;rification de la pertinence
des instances candidates se fait &#224; l&#8217;aide d&#8217;&#233;l&#233;ments issus de l&#8217;analyse syntaxique des descriptions,
des ressources terminologiques, ainsi que des connaissances mod&#233;lis&#233;es dans l&#8217;ontologie.
</p>
<p>Dans les exemples qui suivent, les termes commen&#231;ant par des minuscules et contenant des
majuscules repr&#233;sentent des fonctions cod&#233;es en java permettant d&#8217;acc&#233;der aux ressources
terminologiques ou aux connaissances contenues dans l&#8217;ontologie.
</p>
<p>R&#232;gle pour l&#8217;extraction d&#8217;une instance de la relation Located_in() :
</p>
<p>Cette r&#232;gle identifie tous les chemins syntaxiques existant entre les deux d&#233;pendances prep 5 et
pobj 6, en v&#233;rifiant qu&#8217;il existe un n&#339;ud commun p entre elles, que ce n&#339;ud est une pr&#233;position
de lieu (isP repLocation(p)), que le n&#339;ud directeur l de la d&#233;pendance pobj corresponde &#224;
une instance du concept Location (isLocation(l)) existante dans l&#8217;ontologie, puis que le n&#339;ud
d&#233;pendant i de la d&#233;pendance prep a comme cat&#233;gorie syntaxique un nom ou un verbe.
</p>
<p>pob j(l, p)&#8743; prep(p, i)&#8743; isP repLocation(p)&#8743; isLocation(l)&#8743; (isNoun(i)&#8744; isVer b(i))
&#8594; Located_in(i, l)
L&#8217;application de cette r&#232;gle &#224; la phrase pr&#233;c&#233;dente a pour r&#233;sultat :
</p>
<p>pob j(kitchen, in)&#8743; prep(in, is)&#8743; isP repLocation(in)&#8743; isLocation(kitchen)
&#8743; (isNoun(is)&#8744; isVer b(is))&#8594; Located_in(is, kitchen)
Dans le cas o&#249; le directeur de la relation Located_in i est issu du verbe auxiliaire to be et qu&#8217;il
existe une relation nsubj 7 entre cet auxiliaire et un nom, l&#8217;auxiliaire est remplac&#233; par ce nom :
</p>
<p>Located_in(i, l)&#8743; isToBe(i)&#8743; nsub j(i, n)&#8594; Located_in(n, l)
Ce qui a pour r&#233;sultat :
</p>
<p>Located_in(is, kitchen)&#8743; isToBe(is)&#8743; nsub j(is, someone)&#8594; Located_in(someone, kitchen)
L&#8217;instance de relation Located_in(someone, kitchen) extraite ne permet pas de typer ou de
d&#233;duire lors d&#8217;un raisonnement sur les instances, le type de someone car le domaine de la relation
Located_in est &#233;gal &#224; tous les concepts (Thing). Aussi, nous d&#233;crivons des r&#232;gles d&#8217;extraction
d&#8217;instances de concepts permettant de d&#233;sambigu&#239;ser des instances qui ne pourraient l&#8217;&#234;tre au
sein de l&#8217;ontologie.
</p>
<p>R&#232;gle pour l&#8217;extraction d&#8217;une instance du concept Event :
</p>
<p>Cette r&#232;gle identifie tous les chemins syntaxiques existant entre les deux d&#233;pendances advmod 8
</p>
<p>5. pobj : objet de la pr&#233;position
6. prep : modificateur pr&#233;positionnel
7. nsubj : sujet nominal
8. advmod : modificateur adverbial
</p>
<p>291</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>et nsubj, en v&#233;rifiant qu&#8217;il existe un n&#339;ud commun v entre elles, que ce n&#339;ud est issu du verbe
auxiliaire to be, que le n&#339;ud d&#233;pendant c de la d&#233;pendance advmod appartient &#224; la classe
S&#233;mantique Conditional Introducer et que le n&#339;ud d&#233;pendant n de la d&#233;pendance nsubj participe
d&#233;j&#224; &#224; une instance de la relation Located_in dans l&#8217;ontologie, car un &#233;v&#232;nement n&#8217;a aucun int&#233;r&#234;t
si l&#8217;on ne connait pas sa localisation.
</p>
<p>advmod(v, c)&#8743; nsub j(v, n)&#8743; isToBe(v)&#8743; IsCondInt roducer(c)&#8743; Located_in(n, l)
&#8594; Event(n)
Ce qui a pour r&#233;sultat :
</p>
<p>advmod(is, When) &#8743; nsub j(is, someone) &#8743; isToBe(is) &#8743; IsCondInt roducer(When) &#8743;
Located_in(someone, kitchen)&#8594; Event(someone)
R&#232;gle pour l&#8217;extraction d&#8217;une instance de la relation Has_type :
</p>
<p>La r&#232;gle ci-dessous identifie la pr&#233;sence des deux instances Event et Located_in issues de l&#8217;ontolo-
gie, contenant l&#8217;instance commune n d&#233;notant le type t (information pr&#233;sente dans nos ressources
terminologiques et s&#233;mantiques)
</p>
<p>Event(n)&#8743; Located_in(n, l)&#8743; denoteT ype(n, t)&#8594; Has_t ype(n, t)
Le terme someone en tant qu&#8217;&#233;v&#232;nement d&#233;note le type movement, on donc a pour r&#233;sultat :
</p>
<p>Event(someone)&#8743; Located_in(someone, kitchen)&#8743; denoteT ype(someone, movement)
&#8594; Has_t ype(someone, movement)
A l&#8217;aide de ces r&#232;gles, nous obtenons des instances de relations et de concepts qui sont ajout&#233;es &#224;
l&#8217;ontologie et qui peuvent &#234;tre r&#233;utilis&#233;es dans d&#8217;autres r&#232;gles.
</p>
<p>L&#8217;ordre d&#8217;application des r&#232;gles d&#8217;extraction n&#8217;a pas de cons&#233;quences sur le r&#233;sultat du peuplement.
N&#233;anmoins comme l&#8217;application de certaines r&#232;gles n&#233;cessite des r&#233;sultats (instances) issues
de l&#8217;application d&#8217;autres r&#232;gles, il est pr&#233;f&#233;rable d&#8217;ordonner leur application pour optimiser le
processus.
</p>
<p>Les r&#232;gles varient en fonction des instances &#224; extraire, mais aussi pour une m&#234;me instance en
fonction de toutes les formulations. Dans un premier temps, nous compl&#232;terons celles-ci pour
d&#233;finir les plus courantes, afin de valider notre m&#233;thodologie d&#8217;instanciation de l&#8217;ontologie.
Nous &#233;tudierons ensuite comment disposer d&#8217;un plus large corpus si le nombre de descriptions
collect&#233;es ne nous permet pas d&#8217;avoir recours &#224; des m&#233;thodes d&#8217;acquisition automatique.
</p>
<p>7 Discussion
</p>
<p>Dans les descriptions utilisateur, les r&#233;f&#233;rences aux capteurs ne sont pratiquement jamais pr&#233;-
sentes, ces r&#233;f&#233;rences sont souvent implicites, r&#233;duisant le capteur &#224; son fonctionnement, ce que
l&#8217;on voit bien dans la phrase : When someone is in the kitchen, turn on the light.
</p>
<p>Or, une instance de relation que nous souhaitons extraire est la relation Detect, qui repr&#233;sente la
d&#233;tection d&#8217;un &#233;v&#233;nement par un capteur.
</p>
<p>C&#8217;est l&#224; que r&#233;side tout l&#8217;int&#233;r&#234;t de notre mod&#232;le, qui ne s&#8217;appuie pas seulement sur les infor-
mations pr&#233;sentes dans les descriptions, mais tient aussi compte de connaissances issues du
</p>
<p>292</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>domaine, qui, le cas &#233;ch&#233;ant, permettent de lever les ambigu&#239;t&#233;s. L&#8217;ontologie mod&#233;lise ainsi le fait
qu&#8217;un capteur est identifiable par sa zone de d&#233;tection et le type d&#8217;&#233;v&#233;nement qu&#8217;il peut d&#233;tecter.
Aussi la reconnaissance d&#8217;instances de ces concepts permettra de d&#233;duire le capteur concern&#233;.
</p>
<p>Nous allons d&#233;tailler ce processus pour l&#8217;exemple :
Les connaissances issues des initialisations I1, I2, I3 (Section 6.1) font que le d&#233;clenchement
de la r&#232;gle SWRL (3) (Section 3) n&#8217;est plus soumis qu&#8217;&#224; l&#8217;extraction des instances suivantes :
Located_in(someone,kitchen), Event(someone), Has_type(someone,movement), car le capteur
devant intervenir dans la r&#232;gle, sera d&#233;duit automatiquement.
</p>
<p>Instanciation de la r&#232;gle SWRL (3)
Event(someone), Sensor(s1), Shared_t ype(s1, someone), Located_in(someone, kitchen),
Zone_o f _sensing(s1, kitchen)&#8594; Detect(s1, someone)
</p>
<p>8 Conclusion et travaux futurs
</p>
<p>Nous avons d&#233;crit une m&#233;thode pour le peuplement automatique d&#8217;une ontologie mod&#233;lisant
le comportement d&#8217;un environnement intelligent, laquelle &#224; pour but de faciliter le passage de
descriptions de besoins utilisateurs en langue naturelle vers des sp&#233;cifications formelles de ces
besoins.
</p>
<p>Cette probl&#233;matique est distincte des approches habituelles pour le peuplement d&#8217;ontologie &#224;
partir de textes qui ont pour but de peupler une ontologie avec toutes les instances extraites
des textes permettant de d&#233;crire un domaine. L&#8217;approche adopt&#233;e dans cet article vise &#224; extraire
uniquement les instances participant &#224; la mod&#233;lisation d&#8217;un des multiples comportements d&#8217;un
syst&#232;me de composants logiciels.
</p>
<p>Notre m&#233;thode est guid&#233;e par l&#8217;extraction d&#8217;instances de relations permettant par l&#224;-m&#234;me
d&#8217;extraire les instances de concepts li&#233;es par ces relations. L&#8217;extraction d&#8217;instances se fait &#224; l&#8217;aide
de r&#232;gles construites manuellement &#224; partir de r&#233;sultats d&#8217;analyse syntaxique, de ressources
terminologiques et des connaissances mod&#233;lis&#233;es dans l&#8217;ontologie. Ainsi seules les instances
les plus pertinentes, car participant &#224; au moins une relation conceptuelle, sont extraites. Le
recours aux connaissances mod&#233;lis&#233;es par l&#8217;ontologie offre un cadre formel pour la r&#233;solution
des ambigu&#239;t&#233;s.
</p>
<p>La mod&#233;lisation r&#233;sultante permet la navigation entre descriptions des exigences en langue
naturelle et sp&#233;cifications formelles, pour la v&#233;rification de ces exigences et leur am&#233;lioration.
</p>
<p>Nos travaux futurs porteront sur l&#8217;approfondissement de l&#8217;acquisition de r&#232;gles, la cr&#233;ation
automatique de r&#232;gles SWRL sp&#233;cifiques au comportement d&#233;crit dans les descriptions utilisateurs
et l&#8217;identification d&#8217;instances pouvant &#234;tre en conflit et dont la pr&#233;sence simultan&#233;e dans une
m&#234;me instanciation serait incoh&#233;rente.
</p>
<p>R&#233;f&#233;rences
</p>
<p>ALANI, H., KIM, S., MILLARD, D. E., WEAL, M. J., HALL, W., LEWIS, P. H. et SHADBOLT, N. (2004).
Using protege for automatic ontology instantiation. In 7th International Prot&#233;g&#233; Conference.
</p>
<p>293</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>ALANI, H., KIM, S., MILLARD, D. E., WEAL, M. J., HALL, W., LEWIS, P. H. et SHADBOLT, N. R. (2003).
Automatic ontology-based knowledge extraction from web documents. IEEE Intelligent Systems.
</p>
<p>AMARDEILH, F., LAUBLET, P. et MINEL, J.-L. (2005). Document annotation and ontology population
from linguistic extractions. In Proceedings of the 3rd international conference on Knowledge
capture.
</p>
<p>BENDAOUD, R., ROUANE HACENE, M., TOUSSAINT, Y., DELECROIX, B. et NAPOLI, A. (2007). Construc-
tion d&#8217;une ontologie &#224; partir d&#8217;un corpus de textes avec l&#8217;ACF. In IC 2007.
</p>
<p>BENTIBEBEL, R., NAZARENKO, A. et SZULMAN, S. (2009). Mise en lumi&#232;re de relations s&#233;mantiques
pour la construction d&#8217;ontologies &#224; partir de textes. In TIA 2009.
</p>
<p>DE BOER, V., VAN SOMEREN, M. et WIELINGA, B. J. (2007). Relation instantiation for ontology
population using the web. In Proceedings of the 29th annual German conference on Artificial
intelligence.
</p>
<p>de MARNEFFE, M.-C., MACCARTNEY, B. et MANNING, C. D. (2006). Generating typed dependency
parses from phrase structure trees. In LREC.
</p>
<p>HASEGAWA, T., SEKINE, S. et GRISHMAN, R. (2004). Discovering relations among named entities
from large corpora. In Proceedings of the 42nd Annual Meeting on Association for Computational
Linguistics.
</p>
<p>LIN, D. et PANTEL, P. (2001). Discovery of inference rules for question answering. Natural
Language Engineering.
</p>
<p>MAKKI, J., ALQUIER, A.-M. et PRINCE, Vp, V. (2008). Ontology Population via NLP Techniques in
Risk Management. In ICSWE : Fifth International Conference on Semantic Web Engineering.
</p>
<p>MAYNARD, D., LI, Y. et PETERS, W. (2008). Nlp techniques for term extraction and ontology
population. In Proceeding of the 2008 conference on Ontology Learning and Population : Bridging
the Gap between Text and Knowledge.
</p>
<p>NAKAMURA-DELLOYE, Y. (2011). Named entity extraction for ontology enrichment. In IPSJ Special
Interest Group - Information Fundamentals and Access Technologies (IFAT).
</p>
<p>NAKAMURA-DELLOYE, Y. et STERN, R. (2011). Extraction de relations et de patrons de relations
entre entit&#233;s nomm&#233;es en vue de l&#8217;enrichissement d&#8217;une ontologie. In TOTh 2011 : Terminologie
&amp; Ontologie : Th&#233;ories et Applications.
</p>
<p>SADOUN, D., DUBOIS, C., GHAMRI-DOUDANE, Y. et GRAU, B. (2011). An ontology for the concep-
tualization of an intelligent environment and its operation. Mexican International Conference on
Artificial Intelligence.
</p>
<p>SADOUN, D., DUBOIS, C., GHAMRI-DOUDANE, Y. et GRAU, B. (2012). Formalisation en OWL pour
v&#233;rifier les sp&#233;cifications d&#8217;un environnement intelligent. In Actes de la conf&#233;rence RFIA 2012.
</p>
<p>WANG, F. et TURNER, K. J. (2009). An ontology-based actuator discovery and invocation
framework in home care systems. In Proceedings of the 7th International Conference on Smart
Homes and Health Telematics : Ambient Assistive Health and Wellness Management in the Heart of
the City.
</p>
<p>WITTE, R., KHAMIS, N. et RILLING, J. (2010). Flexible ontology population from text : The
owlexporter. In Proceedings of the Seventh International Conference on Language Resources and
Evaluation (LREC&#8217;10).
</p>
<p>294</p>

</div></div>
</body></html>