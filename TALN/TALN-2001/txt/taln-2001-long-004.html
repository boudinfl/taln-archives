<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Atelier ATOLL pour les grammaires d&#8217;arbres adjoints</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2001, Tours, 2-5 juillet 2001
</p>
<p>Atelier ATOLL pour les grammaires d&#8217;arbres adjoints
Fran&#231;ois Barth&#233;lemy1, Pierre Boullier2, Philippe Deschamp2,
</p>
<p>Linda Kaouane2 et &#201;ric Villemonte de la Clergerie2
(1) CEDRIC - CNAM,
</p>
<p>92 Rue St Martin - FR-75141 Paris Cedex 03
barthe@cnam.fr
(2) ATOLL - INRIA,
</p>
<p>Domaine de Voluceau - BP 105 - 78153 Le Chesnay Cedex
Eric.De_La_Clergerie@inria.fr
</p>
<p>1 R&#233;sum&#233; &#8211; Abstract
Cet article pr&#233;sente l&#8217;environnement de travail que nous d&#233;veloppons au sein de l&#8217;&#233;quipe ATOLL
pour les grammaires d&#8217;arbres adjoints. Cet environnement comprend plusieurs outils et res-
sources fond&#233;s sur l&#8217;emploi du langage de balisage XML. Ce langage facilite la mise en forme
et l&#8217;&#233;change de ressources linguistiques.
</p>
<p>This paper presents the ATOLL workbench for Tree Adjoining Grammars. This workbench pro-
vides several tools and resources based on the use of the markup language XML which eases
the construction and the exchange of linguistic resources.
</p>
<p>Mots-clefs : TAG, XML, Ressources linguistiques
</p>
<p>2 Introduction
L&#8217;&#233;quipe ATOLL se consacre &#224; l&#8217;&#233;tude et la r&#233;alisation d&#8217;outils pour le linguiste. Notre acti-
vit&#233; principale actuelle porte sur des analyseurs syntaxiques efficaces pour divers formalismes
grammaticaux utilis&#233;s dans le traitement de la langue naturelle. Les grammaires d&#8217;arbres ad-
joints (Tree Adjoining Grammars &#8211; TAG) repr&#233;sentent un de ces formalismes, important sur
le plan linguistique mais aussi sur le plan informatique, car permettant la r&#233;alisation d&#8217;analy-
seurs tabulaires efficaces s&#8217;ex&#233;cutant en temps polynomial et n&#233;cessitant un espace en m&#233;moire
&#233;galement polynomial.
Cependant, notre travail sur les TAG nous a fait prendre conscience du manque de standardisa-
tion des grammaires et de la difficult&#233; d&#8217;utiliser certains des outils existants, en particulier lors
du traitement de grandes grammaires. Le syst&#232;me XTAG1 [The XTAG Research Group, 1995]
fournit un standard implicite, qui manque cependant de lisibilit&#233; et de sp&#233;cifications explicites.
Nous avons de plus rencontr&#233; diff&#233;rentes variantes de XTAG. Enfin, certaines des grammaires
&#233;tudi&#233;es pr&#233;sentent des probl&#232;mes de coh&#233;rence, d&#251;s peut-&#234;tre &#224; un manque d&#8217;outils pour la
gestion et le d&#233;veloppement des TAG.
Nous avons donc &#233;t&#233; amen&#233;s &#224; examiner le langage de d&#233;finition des TAG et &#224; r&#233;fl&#233;chir &#224; des
outils permettant d&#8217;exploiter une repr&#233;sentation standardis&#233;e. Suivant d&#8217;autres, dont le groupe
</p>
<p>1http://www.cis.upenn.edu/~xtag/</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>F. Barth&#233;lemy, P. Boullier, P. Deschamp, L. Kaouane et &#201;. V. de la Clergerie
</p>
<p>LT XML2 et plus particuli&#232;rement [Bonhomme and Lopez, 2000], nous avons conclu que le lan-
gage de balisage XML3 est un choix judicieux pour repr&#233;senter les TAG. En premier lieu, l&#8217;uti-
lisation de DTD permet d&#8217;exprimer clairement la structure logique des grammaires. Ensuite,
le format XML est purement textuel, ce qui permet un &#233;change facile de ressources linguis-
tiques entre environnements h&#233;t&#233;rog&#232;nes ainsi qu&#8217;une lecture imm&#233;diate par un humain. Enfin,
l&#8217;ensemble des outils pour le traitement de documents XML cro&#238;t tr&#232;s rapidement. Partant de
l&#8217;emploi de XML pour les grammaires, nous nous sommes aussi rendu compte de son int&#233;r&#234;t
pour stocker des r&#233;sultats linguistiques comme, par exemple, les for&#234;ts de d&#233;rivation produites
par nos analyseurs.
Nous appuyant sur une repr&#233;sentation en XML, nous avons d&#233;velopp&#233; ou adapt&#233; plusieurs ou-
tils. Notre philosophie dans ce d&#233;veloppement est de privil&#233;gier une approche modulaire plut&#244;t
que monolithique.
Apr&#232;s un bref rappel sur les TAG (section 3), nous d&#233;crivons dans la section 4 les codifications
en XML des grammaires et des for&#234;ts de d&#233;rivation. Les outils de gestion et de conversion
s&#8217;appuyant sur ces codifications sont pr&#233;sent&#233;s dans la section 5. La section 6 passe en revue
nos analyseurs TAG et introduit un serveur d&#8217;analyseurs permettant un acc&#232;s uniforme aux
analyseurs. Nous montrons dans la section 7 comment ce serveur est utilis&#233; par une interface
permettant de visualiser d&#233;rivations et grammaires.
</p>
<p>3 Grammaires d&#8217;arbres adjoints
Le formalisme des TAG [Joshi, 1987] est particuli&#232;rement adapt&#233; &#224; la description de nombreux
ph&#233;nom&#232;nes linguistiques. Une TAG comprend un ensemble d&#8217;arbres &#233;l&#233;mentaires partitionn&#233;
en arbres initiaux et arbres auxiliaires. Les n&#339;uds internes sont &#233;tiquet&#233;s par des non-terminaux
et les feuilles par des terminaux ou des non-terminaux. Chaque arbre auxiliaire
</p>
<p>&#0;
</p>
<p>comporte une
feuille distingu&#233;e, appel&#233;e pied, poss&#233;dant la m&#234;me &#233;tiquette que sa racine.
</p>
<p>Noeud v
d&#8217;adjonction
</p>
<p>Racine
</p>
<p>Pied
</p>
<p>Dorsale
</p>
<p>Arbre auxiliaire 
</p>
<p>Adjonction
A
</p>
<p>A
</p>
<p>A
</p>
<p>A
</p>
<p>A
</p>
<p>&#946;
</p>
<p>FIG. 1: Adjonction
</p>
<p>Deux op&#233;rations servent &#224; construire de nouveaux arbres &#224; partir des arbres &#233;l&#233;mentaires. L&#8217;op&#233;-
ration de substitution remplace une feuille &#1; par un arbre initial dont la racine poss&#232;de la m&#234;me
&#233;tiquette que &#1; . L&#8217;op&#233;ration d&#8217;adjonction est illustr&#233;e par la figure 1 : un arbre auxiliaire &#0; dont
la racine est &#233;tiquet&#233;e par un non-terminal &#2; peut s&#8217;adjoindre sur un n&#339;ud &#1; &#233;galement &#233;tiquet&#233;
par &#2; ; le sous-arbre de racine &#1; est ensuite greff&#233; au pied de
</p>
<p>&#0;
</p>
<p>.
</p>
<p>Les TAG avec structures de traits (Feature TAG &#8211; F-TAG) &#233;tendent les TAG en autorisant l&#8217;at-
tachement sur chaque n&#339;ud d&#8217;une paire d&#8217;arguments &#171; haut &#187; et &#171; bas &#187;, repr&#233;sent&#233;s par des
structures de traits.
</p>
<p>2http://www.ltg.ed.ac.uk/
3http://www.w3c.org/XML/</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Atelier ATOLL pour les grammaires d&#8217;arbres adjoints
</p>
<p>Les TAG lexicalis&#233;es (avec ou sans traits) imposent que chaque arbre &#233;l&#233;mentaire poss&#232;de au
moins une feuille lexicale, c&#8217;est-&#224;-dire &#233;tiquet&#233;e par un terminal. Cependant, une grammaire to-
talement et explicitement lexicalis&#233;e serait gigantesque, avec de nombreux arbres pour chaque
mot du langage. Le format XTAG permet de factoriser la description des grammaires et de
donner suffisamment d&#8217;information pour lexicaliser &#224; la demande des parties de la grammaire.
Les entr&#233;es morphologiques (ou formes fl&#233;chies) regroup&#233;es dans un lexique morphologique
font r&#233;f&#233;rence &#224; des entr&#233;es syntaxiques (ou lemmes) regroup&#233;es dans un lexique syntaxique.
Les lemmes font eux-m&#234;me r&#233;f&#233;rence &#224; des familles de sch&#233;mas d&#8217;arbres. Un sch&#233;ma d&#8217;arbres
est simplement un arbre &#233;l&#233;mentaire avec une feuille distingu&#233;e appel&#233;e ancre, qui est rem-
plac&#233;e lors de la lexicalisation par une forme fl&#233;chie. Chaque r&#233;f&#233;rence (&#224; un lemme ou &#224; des
arbres) est &#233;ventuellement compl&#233;t&#233;e par des contraintes additionnelles portant sur les argu-
ments de l&#8217;ancre ou des autres n&#339;uds des sch&#233;mas d&#8217;arbres ou portant sur la lexicalisation
d&#8217;autres feuilles (co-ancres) 4.
La figure 2 illustre ces diff&#233;rents composants sur un exemple issu d&#8217;une petite grammaire du
fran&#231;ais. Elle montre l&#8217;entr&#233;e morphologique pour donne, l&#8217;entr&#233;e syntaxique \DONNER\ et
le sch&#233;ma d&#8217;arbres tn1pn2 utilis&#233; pour construire l&#8217;arbre lexicalis&#233; tn1pn2(donne) correspon-
dant au patron syntaxique (1). Le lemme stipule que le sujet NP &#0; et le compl&#233;ment d&#8217;objet in-
direct NP &#1; doivent &#234;tre humains et que NP &#1; doit &#234;tre introduit par la pr&#233;position &#224; (co-ancrage).
Dans le sch&#233;ma d&#8217;arbres tn1pn2, les n&#339;uds de substitution sont indiqu&#233;s par
</p>
<p>&#2;
</p>
<p>et le n&#339;ud
ancre par &#3;&#5;&#4; .
</p>
<p>(1) quelqu&#8217;un donne quelque chose &#224; quelqu&#8217;un
</p>
<p>donne: \DONNER\, V
{mode=ind,num=sing}
</p>
<p>\DONNER\,V: tn1pn2[p_2=&#224;]
{NP_0.t:restr=+hum,
NP_2.t:restr=+hum}
</p>
<p>S
tn1pn2
</p>
<p>NP &#0;
&#2;
</p>
<p>VP
</p>
<p>V
</p>
<p>&lt;&gt;V
</p>
<p>NP &#6;
&#2;
</p>
<p>PP
</p>
<p>P &#1;
&#2;
</p>
<p>NP &#1;
&#2;
</p>
<p>FIG. 2: Sch&#233;ma d&#8217;arbre
</p>
<p>4 Codification en langage XML
4.1 Repr&#233;sentation des grammaires
Nous avons con&#231;u une DTD5 qui sp&#233;cifie clairement la structure logique des divers composants
d&#8217;une TAG. L&#8217;extrait suivant de la DTD stipule par exemple qu&#8217;une entr&#233;e morphologique est
introduite par une balise morph, est caract&#233;ris&#233;e par un champ lex servant de cl&#233;, et inclut
une ou plusieurs r&#233;f&#233;rences &#224; un lemme (lemmaref). On peut &#233;galement lui adjoindre des
&#233;l&#233;ments de description (desc) pour la documentation. De m&#234;me, un &#233;l&#233;ment lemmaref est
caract&#233;ris&#233; par ses champs name et cat, et peut &#234;tre compl&#233;t&#233; par une structure de traits fs.
</p>
<p>&lt;!ELEMENT morph (desc*,lemmaref+)&gt;
&lt;!ATTLIST morph lex CDATA #REQUIRED&gt;
&lt;!ELEMENT lemmaref (fs?)&gt;
&lt;!ATTLIST lemmaref name CDATA #REQUIRED
</p>
<p>cat CDATA #REQUIRED&gt;
</p>
<p>4En pratique, la distinction entre ancre et co-ancre n&#8217;est pas toujours tr&#232;s nette.
5http://atoll.inria.fr/~clerger/tag.dtd,xml</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>F. Barth&#233;lemy, P. Boullier, P. Deschamp, L. Kaouane et &#201;. V. de la Clergerie
</p>
<p>En respectant cette DTD, les composants de la figure 2 sont d&#233;crits par le fragment de XML
suivant, en omettant les structures de traits pour des raisons de place et de simplicit&#233;.
</p>
<p>&lt;morph lex=&quot;donne&quot;&gt;
&lt;lemmaref cat=&quot;v&quot; name=&quot;*DONNER*&quot;&gt;
</p>
<p>&lt;fs&gt;
&lt;f name=&quot;mode&quot;&gt;&lt;val&gt;ind&lt;/val&gt;&lt;/f&gt;
&lt;f name=&quot;num&quot;&gt;&lt;val&gt;sing&lt;/val&gt;&lt;/f&gt;
</p>
<p>&lt;/fs&gt;
&lt;/lemmaref&gt;
</p>
<p>&lt;/morph&gt;
&lt;lemma cat=&quot;v&quot; name=&quot;*DONNER*&quot;&gt;
</p>
<p>&lt;anchor tree_id=&quot;family[@name=tn1pn2]&quot;&gt;
&lt;coanchor node_id=&quot;p_2&quot;&gt; &lt;lex&gt;&#224;&lt;/lex&gt; &lt;/coanchor&gt;
&lt;equation node_id=&quot;np_0&quot; type=&quot;top&quot;&gt;
</p>
<p>&lt;fs&gt;&lt;f name=&quot;restr&quot;&gt;&lt;val&gt;plushum&lt;/val&gt;&lt;/f&gt;&lt;/fs&gt;
&lt;/equation&gt;
&lt;equation node_id=&quot;np_2&quot; type=&quot;top&quot;&gt;
</p>
<p>&lt;fs&gt;&lt;f name=&quot;restr&quot;&gt;&lt;val&gt;plushum&lt;/val&gt;&lt;/f&gt;&lt;/fs&gt;
&lt;/equation&gt;
</p>
<p>&lt;/anchor&gt;
&lt;/lemma&gt;
&lt;family name=&quot;tn1pn2&quot;&gt;
</p>
<p>&lt;tree name=&quot;tn1pn2&quot;&gt;
&lt;node cat=&quot;s&quot; adj=&quot;yes&quot; type=&quot;std&quot;&gt;
</p>
<p>&lt;node cat=&quot;np&quot; id=&quot;np_0&quot; adj=&quot;no&quot; type=&quot;subst&quot; /&gt;
&lt;node cat=&quot;vp&quot; adj=&quot;yes&quot; type=&quot;std&quot;&gt;
</p>
<p>&lt;node cat=&quot;v&quot; adj=&quot;yes&quot; type=&quot;anchor&quot; /&gt;
&lt;node cat=&quot;np&quot; adj=&quot;no&quot; type=&quot;subst&quot; /&gt;
&lt;node cat=&quot;pp&quot; adj=&quot;yes&quot; type=&quot;std&quot;&gt;
</p>
<p>&lt;node cat=&quot;p&quot; id=&quot;p_2&quot; adj=&quot;no&quot; type=&quot;subst&quot; /&gt;
&lt;node cat=&quot;np&quot; id=&quot;np_2&quot; adj=&quot;no&quot; type=&quot;subst&quot; /&gt;
</p>
<p>&lt;/node&gt;
&lt;/node&gt;
</p>
<p>&lt;/node&gt;
&lt;/tree&gt;
</p>
<p>&lt;/family&gt;
</p>
<p>Pour l&#8217;instant, nous disposons sous cette forme XML d&#8217;une petite grammaire du fran&#231;ais (50 sch&#233;-
mas d&#8217;arbres, 117 lemmes et entr&#233;es morphologiques) et d&#8217;une grammaire de l&#8217;anglais (456 sch&#233;-
mas d&#8217;arbres, 333 lemmes et 507 entr&#233;es morphologiques). Nous sommes en train de convertir
d&#8217;autres grammaires plus importantes (pour le fran&#231;ais et l&#8217;anglais).
</p>
<p>4.2 Code pour les d&#233;rivations
Pour une phrase non ambig&#252;e, un analyseur syntaxique TAG retourne soit le r&#233;sultat de l&#8217;ana-
lyse sous forme d&#8217;un arbre d&#8217;analyse, soit les &#233;tapes de l&#8217;analyse sous forme d&#8217;un arbre de
d&#233;rivation. Ces deux possibilit&#233;s sont illustr&#233;es pour la phrase (2) par les figures 3(a) et 3(b), la
figure 3(c) explicitant les arbres &#233;l&#233;mentaires impliqu&#233;s. L&#8217;arbre de d&#233;rivation indique quelles
op&#233;rations (substitutions et adjonctions) sont appliqu&#233;es sur quels n&#339;uds et quels arbres &#233;l&#233;men-
taires sont utilis&#233;s pour ce faire. Ainsi, l&#8217;arbre de la figure 3(b) signale par exemple l&#8217;adjonction
de l&#8217;arbre a
</p>
<p>&#0;
</p>
<p>joli &#1; sur le n&#339;ud NP &#2; (de npdn &#0; livre &#1; ). Noter que les arbres d&#8217;analyse peuvent
se construire &#224; partir des arbres de d&#233;rivation, ce qui motive notre int&#233;r&#234;t pour ces derniers.
</p>
<p>(2) Yves donne un joli livre &#224; Sabine
Dans le cas, tr&#232;s fr&#233;quent, d&#8217;ambig&#252;it&#233;, plusieurs ou m&#234;me une infinit&#233; d&#8217;arbres de d&#233;rivation
peuvent &#234;tre regroup&#233;s au sein d&#8217;une for&#234;t de taille polynomiale partageant les d&#233;rivations,
&#233;quivalente formellement &#224; une grammaire non contextuelle [Lang, 1991].</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Atelier ATOLL pour les grammaires d&#8217;arbres adjoints
</p>
<p>S
</p>
<p>NP
</p>
<p>Yves
</p>
<p>VP
</p>
<p>V
</p>
<p>donne
</p>
<p>NP
</p>
<p>NP
</p>
<p>D
</p>
<p>un
</p>
<p>N
</p>
<p>A
</p>
<p>joli
N
</p>
<p>livre
</p>
<p>PP
</p>
<p>P
</p>
<p>&#224;
</p>
<p>NP
</p>
<p>Sabine
</p>
<p>(a) Arbre d&#8217;analyse
</p>
<p>subst &#0; &#1;
tn1pn2(donne,&#224;)
</p>
<p>subst &#2;&#4;&#3; &#1;
np(Yves)
</p>
<p>subst &#2;&#4;&#3;&#6;&#5;
npdn(livre)
</p>
<p>subst &#7; &#1;
d(un)
</p>
<p>adj &#2; &#1;
a(joli)
</p>
<p>subst &#2;&#6;&#3;&#4;&#8;
np(Sabine)
</p>
<p>(b) Arbre de d&#233;rivation
</p>
<p>S tn1pn2(donne,&#224;)
</p>
<p>NP
&#9;
</p>
<p>VP
</p>
<p>V
</p>
<p>donne
</p>
<p>NP
&#9;
</p>
<p>PP
</p>
<p>P
</p>
<p>&#224;
</p>
<p>NP
&#9;
</p>
<p>NP np(Yves)
</p>
<p>Yves
NP np(Sabine)
</p>
<p>Sabine
</p>
<p>NP npdn(livre)
</p>
<p>D
&#9;
</p>
<p>N
</p>
<p>livre
</p>
<p>D d(un)
</p>
<p>un
</p>
<p>a(joli) N
A
</p>
<p>joli
N
&#10;
</p>
<p>(c) Arbres &#233;l&#233;mentaires
</p>
<p>FIG. 3: Arbres d&#8217;analyse et de d&#233;rivation pour &#171; Yves donne un joli livre &#224; Sabine &#187;
</p>
<p>&#11;&#4;&#12;
</p>
<p>&#13;&#15;&#14; &#16; &#17; &#18;&#20;&#19; &#13;&#15;&#14; &#16; &#17; &#18;&#15;&#21;
</p>
<p>&#22;
</p>
<p>&#11;
</p>
<p>&#13;&#15;&#14;
</p>
<p>&#19;
</p>
<p>&#11;&#23;&#12;
</p>
<p>&#16; &#14; &#24;
</p>
<p>&#19;
</p>
<p>&#22;
</p>
<p>&#11;
</p>
<p>&#13;&#15;&#14;
</p>
<p>&#21;
</p>
<p>&#11;&#23;&#12;
</p>
<p>&#16; &#14; &#24;
</p>
<p>&#21;
</p>
<p>&#22;
</p>
<p>&#11;
</p>
<p>&#13;&#15;&#14; &#25;
</p>
<p>&#11;&#23;&#12;
</p>
<p>&#16; &#14; &#24;
</p>
<p>&#25;
</p>
<p>&#13;&#15;&#14; &#16; &#17; &#18;
</p>
<p>&#25;
</p>
<p>FIG. 4: Structure d&#8217;une for&#234;t partag&#233;e de d&#233;rivation</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>F. Barth&#233;lemy, P. Boullier, P. Deschamp, L. Kaouane et &#201;. V. de la Clergerie
</p>
<p>Cette remarque a guid&#233; notre conception d&#8217;une DTD6 pour repr&#233;senter les for&#234;ts partag&#233;es de
d&#233;rivation. Cette DTD s&#8217;appuie sur les &#233;l&#233;ments principaux op, deriv et node ainsi que sur
l&#8217;&#233;l&#233;ment opref permettant de r&#233;f&#233;rencer un &#233;l&#233;ment op. L&#8217;articulation de ces &#233;l&#233;ments est
donn&#233;e par la figure 4 :
</p>
<p>op est identifi&#233; par son attribut id et d&#233;signe une op&#233;ration de substitution ou d&#8217;adjonction
sur une cat&#233;gorie syntaxique (attribut cat) et couvrant une certaine portion de la cha&#238;ne
d&#8217;entr&#233;e (attribut span). Un &#233;l&#233;ment op indique &#233;galement les valeurs des arguments
(&#233;l&#233;ments fs) relatives &#224; l&#8217;op&#233;ration.
</p>
<p>deriv indique comment r&#233;aliser une op&#233;ration avec un arbre lexicalis&#233; donn&#233; par un sch&#233;ma
d&#8217;arbres (attribut tree) et une ancre (attribut anchor).
</p>
<p>node sp&#233;cifie quelle op&#233;ration op est effectu&#233;e sur un n&#339;ud d&#8217;un arbre &#233;l&#233;mentaire nomm&#233;
par l&#8217;attribut node_id.
</p>
<p>Un arbre de d&#233;rivation peut s&#8217;exprimer de mani&#232;re ench&#226;ss&#233;e en n&#8217;utilisant que les &#233;l&#233;ments
principaux op, deriv et node. Une for&#234;t partag&#233;e va n&#233;cessiter l&#8217;emploi de opref pour
repr&#233;senter les multiples occurrences d&#8217;une m&#234;me op&#233;ration. Plus g&#233;n&#233;ralement, l&#8217;emploi de
opref permet une description &#171; plate &#187; des for&#234;ts.
Ainsi, l&#8217;arbre de d&#233;rivation pr&#233;c&#233;dent s&#8217;exprime sous une forme plate par le fragment de XML
suivant (sans les structures de traits).
</p>
<p>&lt;forest parser=&quot;Small French TAG - Light DyALog - Hybrid Strategy&quot;&gt;
&lt;sentence&gt; Yves donne un joli livre &#224; Sabine &lt;/sentence&gt;
&lt;op cat=&quot;s&quot; span=&quot;0 7&quot; id=&quot;1&quot; type=&quot;subst&quot;&gt;
</p>
<p>&lt;deriv tree=&quot;tn1pn2&quot; anchor=&quot;donne&quot;&gt;
&lt;node id=&quot;p_2&quot;&gt;&lt;opref ref=&quot;5&quot; /&gt;&lt;/node&gt;
&lt;node id=&quot;np_0&quot;&gt;&lt;opref ref=&quot;2&quot; /&gt;&lt;/node&gt;
&lt;node id=&quot;1&quot;&gt;&lt;opref ref=&quot;4&quot; /&gt;&lt;/node&gt;
&lt;node id=&quot;np_2&quot;&gt;&lt;opref ref=&quot;6&quot; /&gt;&lt;/node&gt;
</p>
<p>&lt;/deriv&gt;
&lt;/op&gt;
&lt;op cat=&quot;np&quot; span=&quot;0 1&quot; id=&quot;2&quot; type=&quot;subst&quot;&gt;
</p>
<p>&lt;deriv tree=&quot;np&quot; anchor=&quot;Yves&quot; /&gt;
&lt;/op&gt;
&lt;op cat=&quot;np&quot; span=&quot;2 5&quot; id=&quot;4&quot; type=&quot;subst&quot;&gt;
</p>
<p>&lt;deriv tree=&quot;npdn&quot; anchor=&quot;livre&quot;&gt;
&lt;node id=&quot;n_&quot;&gt;&lt;opref ref=&quot;10&quot; /&gt;&lt;/node&gt;
&lt;node id=&quot;0&quot;&gt;&lt;opref ref=&quot;8&quot; /&gt;&lt;/node&gt;
</p>
<p>&lt;/deriv&gt;
&lt;/op&gt;
&lt;op cat=&quot;p&quot; span=&quot;5 6&quot; id=&quot;5&quot; type=&quot;subst&quot;&gt; &lt;deriv tree=&quot;p&quot; anchor=&quot;&#224;&quot; /&gt; &lt;/op&gt;
&lt;op cat=&quot;np&quot; span=&quot;6 7&quot; id=&quot;6&quot; type=&quot;subst&quot;&gt; &lt;deriv tree=&quot;np&quot; anchor=&quot;Sabine&quot; /&gt; &lt;/op&gt;
&lt;op cat=&quot;d&quot; span=&quot;2 3&quot; id=&quot;8&quot; type=&quot;subst&quot;&gt; &lt;deriv tree=&quot;d&quot; anchor=&quot;un&quot; /&gt; &lt;/op&gt;
&lt;op cat=&quot;n&quot; span=&quot;3 5 4 5&quot; id=&quot;10&quot; type=&quot;adj&quot;&gt; &lt;deriv tree=&quot;an&quot; anchor=&quot;joli&quot; /&gt; &lt;/op&gt;
</p>
<p>&lt;/forest&gt;
</p>
<p>5 Outils de gestion
5.1 Pour les grammaires
La repr&#233;sentation en XML des grammaires est parfaite pour la gestion et l&#8217;&#233;change des sources.
Cependant, elle ne correspond pas aux formats d&#8217;entr&#233;e attendus pour la construction des ana-
lyseurs (voir section 6). Ainsi, le syst&#232;me DyALog exploite une repr&#233;sentation logique &#224; la
PROLOG tandis que le constructeur d&#8217;analyseurs RCG n&#233;cessite des clauses RCG.
</p>
<p>6http://atoll.inria.fr/~clerger/forest.dtd,xml</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Atelier ATOLL pour les grammaires d&#8217;arbres adjoints
</p>
<p>XTAG TAGXML
</p>
<p>RCG
</p>
<p>LP
</p>
<p>SQL
</p>
<p>LaTeX
</p>
<p>HTML
</p>
<p>Checker
</p>
<p>Analyzer
</p>
<p>Strip
</p>
<p>(a) Grammaires
</p>
<p>FOREST
</p>
<p>XML
</p>
<p>RCG LP XTAG
</p>
<p>HTML Tree Dep
</p>
<p>(b) For&#234;ts
</p>
<p>FIG. 5: Modules de gestion
</p>
<p>Nous avons donc d&#233;velopp&#233; en Perl des modules de conversion compl&#233;t&#233;s ensuite par d&#8217;autres
modules (figure 5(a)). Le module pivot TAG impl&#233;mente une repr&#233;sentation orient&#233;e objets de
la structure logique sp&#233;cifi&#233;e par la DTD. Les modules p&#233;riph&#233;riques ajoutent des m&#233;thodes
suppl&#233;mentaires pour telle ou telle t&#226;che.
Outre les modules de conversion d&#233;j&#224; cit&#233;s LP et RCG utilis&#233;s pour compiler les grammaires,
nous disposons aussi d&#8217;un module XML de lecture et &#233;criture du format XML. Le module Che-
cker v&#233;rifie la coh&#233;rence des grammaires et produit diverses statistiques. Le module Analyzer
extrait des informations utiles pour la compilation d&#8217;une grammaire. Le module Strip &#233;limine
les structures de traits d&#8217;une grammaire.
Le module SQL permet de charger une grammaire dans une base de donn&#233;es SQL (et de res-
taurer une grammaire &#224; partir de la base). Ce module peut &#234;tre utile pour v&#233;rifier des propri&#233;t&#233;s
d&#8217;une grammaire &#224; l&#8217;aide de requ&#234;tes en SQL7.
L&#8217;utilisation de Perl a &#233;t&#233; motiv&#233;e par la disponibilit&#233; de nombreux modules logiciels libres sur
les sites d&#8217;archivage, g&#233;rant par exemple l&#8217;analyse de XML ou l&#8217;acc&#232;s aux bases de donn&#233;es. Le
d&#233;veloppement d&#8217;un module en Perl est de plus tr&#232;s rapide, en g&#233;n&#233;ral de l&#8217;ordre de quelques
heures pour un prototype op&#233;rationnel. Nous avons ainsi r&#233;alis&#233; un prototype de module LaTeX,
utile pour construire une forme &#233;crite d&#8217;une grammaire. Nous envisageons &#233;galement un module
HTML pour produire une version consultable en ligne.
</p>
<p>5.2 Pour les for&#234;ts de d&#233;rivation
De fa&#231;on similaire, un jeu de modules en Perl permet de traiter les for&#234;ts de d&#233;rivation (fi-
gure 5(b)). Autour du module pivot FOREST viennent s&#8217;ajouter des modules de conversion.
Les modules LP, RCG et XTAG lisent les formats de sortie des for&#234;ts de nos analyseurs et
de l&#8217;analyseur XTAG. Les modules XML et HTML &#233;mettent les for&#234;ts sous forme XML et
HTML. Deux autres modules Tree et Dep construisent des sp&#233;cifications de graphes, visuali-
sables gr&#226;ce &#224; l&#8217;outil Graphviz8.
D&#8217;autres modules sont pr&#233;vus dans un futur proche, tels un module SQL de lecture et d&#8217;&#233;criture
dans une base de donn&#233;es servant de banque d&#8217;arbres, un module Strip d&#8217;&#233;limination des traits,
</p>
<p>7En fait, un prototype de &#171; serveur de grammaire &#187; au dessus d&#8217;une base de donn&#233;es MySQL est en cours de
finition pour lequel Java a &#233;t&#233; pr&#233;f&#233;r&#233; &#224; Perl. Ce serveur s&#8217;appuie n&#233;anmoins sur la DTD XML des grammaires.
</p>
<p>8http://www.research.att.com/sw/tools/graphviz</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>F. Barth&#233;lemy, P. Boullier, P. Deschamp, L. Kaouane et &#201;. V. de la Clergerie
</p>
<p>ou des modules pour l&#8217;extraction d&#8217;arbres dans les for&#234;ts.
</p>
<p>6 Analyse Syntaxique
6.1 Les analyseurs
Les analyseurs syntaxiques pour les TAG lexicalis&#233;es s&#8217;appuient g&#233;n&#233;ralement sur une phase
pr&#233;liminaire de s&#233;lection et d&#8217;instantiation d&#8217;un sous-ensemble d&#8217;arbres ancrables par les mots
de la phrase d&#8217;entr&#233;e. Nous avons choisi de ne pas suivre cette voie. Notre pari est de construire
des analyseurs efficaces &#224; partir de la compilation de la grammaire compl&#232;te et de r&#233;aliser l&#8217;an-
crage des sch&#233;mas d&#8217;arbres lors de l&#8217;analyse. Cela permet que notre travail s&#8217;applique &#233;galement
&#224; des TAG non lexicalis&#233;es (et non lexicalisables). Notons en outre que notre approche n&#8217;est pas
incompatible &#224; terme avec des techniques de filtrage.
Pour l&#8217;instant, nous avons exp&#233;riment&#233; plusieurs analyseurs, correspondant &#224; diverses approches
et strat&#233;gies d&#8217;analyse.
La premi&#232;re approche repose sur l&#8217;emploi du syst&#232;me DyALog pour compiler des analyseurs
tabulaires pour les TAG avec traits. DyALog est un syst&#232;me g&#233;n&#233;raliste permettant l&#8217;&#233;tude de
techniques de tabulation pour des programmes logiques et des formalismes grammaticaux &#224;
base d&#8217;unification. Nous l&#8217;avons &#233;tendu pour pouvoir traiter les TAG [&#201;ric Villemonte de la
Clergerie and Alonso Pardo, 1998, Alonso Pardo et al., 2000, &#201;ric Villemonte de la Clergerie,
2001]. En particulier, nous avons test&#233; deux sch&#233;mas de tabulation, ainsi que deux strat&#233;gies
d&#8217;analyse, &#224; savoir une strat&#233;gie strictement descendante v&#233;rifiant la propri&#233;t&#233; de validit&#233; des
pr&#233;fixes et une strat&#233;gie hybride descendante avec v&#233;rification ascendante des traits.
La seconde approche utilise les grammaires &#224; concat&#233;nation d&#8217;intervalles (Range Concatenation
Grammars &#8211; RCG) pour lesquelles nous construisons des analyseurs tr&#232;s efficaces [Boullier,
2000]. Cela n&#233;cessite la suppression des informations de traits et de co-ancrage des F-TAG,
puis la conversion des TAG obtenues en RCG [Boullier, 1998, 1999, Barth&#233;lemy et al., 2001].
La troisi&#232;me approche [Barth&#233;lemy et al., 2000] combine les deux premi&#232;res. En effet, la for&#234;t
partag&#233;e de d&#233;rivation produite par un analyseur RCG ( &#0;&#2;&#1; ) est utilis&#233;e pour guider un analyseur
DyALog
</p>
<p>&#0;&#4;&#3;
</p>
<p>modifi&#233;. L&#8217;analyseur &#0;&#4;&#3; v&#233;rifie les contraintes de traits et de co-ancrage tandis que
les informations fournies par &#0;&#5;&#1; rendent le traitement extr&#234;mement efficace.
</p>
<p>6.2 Le serveur d&#8217;analyseurs
&#201;tant donn&#233; le nombre croissant d&#8217;analyseurs que nous g&#233;rons, nous avons cherch&#233; &#224; faciliter
leur utilisation au moyen d&#8217;un serveur d&#8217;analyseurs, &#233;crit en Perl. Une fois la connexion &#233;tablie
avec ce serveur, l&#8217;utilisateur s&#233;lectionne un analyseur et envoie sa phrase ; le serveur retourne
alors la for&#234;t de d&#233;rivation correspondante. Trois formats de sortie pour les for&#234;ts sont actuelle-
ment disponibles, &#224; savoir &#171; sans formatage &#187; (la for&#234;t telle que produite par l&#8217;analyseur), format
XML et format HTML. Ce dernier est en particulier utilis&#233; par une interface WEB accessible
en ligne9.
</p>
<p>7 Visualisation des d&#233;rivations et des grammaires
En relation avec le serveur d&#8217;analyseurs et dans l&#8217;optique de comparer les r&#233;sultats produits par
nos analyseurs, nous [Kaouane, 2000] avons modifi&#233; et enrichi une interface de visualisation,
</p>
<p>9http://medoc.inria.fr/pub-cgi-bin/parser.cgi</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Atelier ATOLL pour les grammaires d&#8217;arbres adjoints
</p>
<p>originellement d&#233;velopp&#233;e par Patrice Lopez [Lopez, 2000] et r&#233;alis&#233;e en Java. Notre version lit
les grammaires et les for&#234;ts de d&#233;rivation donn&#233;es en XML selon nos DTD. Elle est &#233;galement
capable de se connecter au serveur d&#8217;analyseurs, d&#8217;envoyer une phrase et de r&#233;cup&#233;rer la for&#234;t
de d&#233;rivation.
</p>
<p>FIG. 6: Capture d&#8217;&#233;cran de l&#8217;outil de visualisation
</p>
<p>Les arbres de d&#233;rivation sont extraits de la for&#234;t partag&#233;e de d&#233;rivation et affich&#233;s, en regard avec
les arbres d&#8217;analyse correspondants. De plus, il est &#233;galement possible d&#8217;avancer et de reculer
dans les &#233;tapes de d&#233;rivation, en observant &#224; chaque pas l&#8217;arbre partiel de d&#233;rivation et l&#8217;arbre
partiel d&#8217;analyse (voir la figure 6).
Outre la visualisation des d&#233;rivations, l&#8217;interface permet la visualisation des diff&#233;rents compo-
sants d&#8217;une grammaire (lexiques et sch&#233;mas d&#8217;arbres). Cet outil nous sert &#224; &#233;tudier le compor-
tement des analyseurs en fonction des composants d&#8217;une grammaire mais il a &#233;galement un fort
potentiel p&#233;dagogique car il permet de montrer et d&#8217;expliquer les &#233;tapes d&#8217;une analyse TAG.
</p>
<p>Conclusion
Les exp&#233;riences men&#233;es confortent notre opinion que XML est un langage adapt&#233; pour repr&#233;-
senter et &#233;changer des ressources linguistiques. De plus, l&#8217;existence d&#8217;outils fond&#233;s sur l&#8217;emploi
de XML a permis le d&#233;veloppement rapide de nos outils sur une courte p&#233;riode (autres que les
analyseurs syntaxiques, bien entendu).
Nous continuons &#224; compl&#233;ter progressivement notre atelier ATOLL pour les TAG par de nou-
veaux modules et outils. En particulier, nous sommes en train de mettre en place un serveur
de grammaire permettant l&#8217;extraction de fragments de grammaires. D&#8217;autres extensions sont
&#233;galement envisag&#233;es pour la gestion de banques de for&#234;ts de d&#233;rivation.
Les outils et ressources pr&#233;sent&#233;s ici sont librement disponibles. Notre souhait est de voir
d&#8217;autres &#233;quipes compl&#233;ter cet atelier pour les TAG par leurs propres outils, t&#226;che facilit&#233;e
par son architecture modulaire.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>F. Barth&#233;lemy, P. Boullier, P. Deschamp, L. Kaouane et &#201;. V. de la Clergerie
</p>
<p>R&#233;f&#233;rences
Miguel Alonso Pardo, Djam&#233; Seddah, and &#201;ric Villemonte de la Clergerie. Practical aspects in
</p>
<p>compiling tabular TAG parsers. In Proceedings of the &#0; th International Workshop on Tree
Adjoining Grammars and Related Formalisms (TAG+5), pages 27&#8211;32, Universit&#233; Paris 7,
Jussieu, Paris, France, May 2000.
</p>
<p>F. Barth&#233;lemy, P. Boullier, Ph. Deschamp, and &#201;. de la Clergerie. Guided parsing of range
concatenation languages. In Proceedings of the 39th Annual Meeting of the Association
for Computational Linguistics (ACL&#8217;01), University of Toulouse, France, July 2001. to be
published.
</p>
<p>Fran&#231;ois Barth&#233;lemy, Pierre Boullier, Philippe Deschamp, and &#201;ric Villemonte de la Clergerie.
Shared forests can guide parsing. In Proceedings of TAPD&#8217;00, September 2000. En ligne en
ftp://ftp.inria.fr/INRIA/Projects/Atoll/Eric.Clergerie/tapd00.ps.gz.
</p>
<p>Patrick Bonhomme and Patrice Lopez. TagML : XML encoding of resources for lexicalized
tree adjoining grammars. In Proceedings of LREC 2000, Athens, 2000.
</p>
<p>Pierre Boullier. A generalization of mildly context-sensitive formalisms. In Proceedings of the
&#1; th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+4),
pages 17&#8211;20, University of Pennsylvania, Philadelphia, PA, USA, August 1998.
</p>
<p>Pierre Boullier. On TAG parsing et On multicomponent TAG parsing. In &#2; &#232;me conf&#233;rence
annuelle sur le Traitement Automatique des Langues Naturelles (TALN&#8217;99), pages 75&#8211;84 et
pages 321&#8211;326, Carg&#232;se, France, July 1999. Voir aussi le Rapport de recherche n &#3; 3668,
en ligne en http://www.inria.fr/RRRT/RR-3668.html, INRIA, France, Avril 1999, 39
pages.
</p>
<p>Pierre Boullier. Range concatenation grammars. In Proceedings of the &#2; th International Work-
shop on Parsing Technologies (IWPT2000), pages 53&#8211;64, Trento, Italy, February 2000. Voir
aussi le Rapport de recherche n &#3; 3342, en ligne en http://www.inria.fr/RRRT/RR-3342.
html, INRIA, France, January 1998, 41 pages.
</p>
<p>Aravind K. Joshi. An introduction to tree adjoining grammars. In Alexis Manaster-Ramer,
editor, Mathematics of Language, pages 87&#8211;115. John Benjamins Publishing Co., Amster-
dam/Philadelphia, 1987.
</p>
<p>Linda Kaouane. Adaptation et utilisation d&#8217;un environnement graphique pour les tag au dessus
du syst&#232;me dyalog. M&#233;moire de DEA, Universit&#233; d&#8217;Orl&#233;ans, 2000.
</p>
<p>Bernard Lang. Towards a uniform formal framework for parsing. In Masaru Tomita, editor,
Current issues in Parsing Technology, chapter 11. Kluwer Academic Publishers, 1991. Also
appeared in the Proceedings of International Workshop on Parsing Technologies &#8211; IWPT89.
</p>
<p>Patrice Lopez. LTAG workbench : A general framework for LTAG. In Proceedings of the
&#0; th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+5),
Paris, May 2000.
</p>
<p>&#201;ric Villemonte de la Clergerie. Refining tabular parsers for TAGs. In Proceedings of NAA-
CL&#8217;01, June 2001. &#192; paraitre.
</p>
<p>&#201;ric Villemonte de la Clergerie and Miguel Alonso Pardo. A tabular interpretation of a class
of 2-stack automata. In Proceedings of ACL/COLING&#8217;98, August 1998. En ligne en ftp:
//ftp.inria.fr/INRIA/Projects/Atoll/Eric.Clergerie/SD2SA.ps.gz.
</p>
<p>The XTAG Research Group. A lexicalized tree adjoining grammar for English. Technical
Report IRCS 95-03, Institute for Research in Cognitive Science, University of Pennsylvania,
Philadelphia, PA, USA, March 1995.</p>

</div></div>
</body></html>