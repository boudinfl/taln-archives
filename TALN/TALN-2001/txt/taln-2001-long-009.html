<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>L'interrogation de bases de donn&#233;es comme application des classes d'objets</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2001, Tours, 2-5 juillet 2001
</p>
<p>L'interrogation de bases de donn&#233;es
comme application des classes d'objets
</p>
<p>B&#233;atrice Bouchou, Julien Lerat, Denis Maurel
</p>
<p>LI, Universit&#233; Fran&#231;ois Rabelais
E3i, 64 avenue Jean Portalis, 37200 Tours
</p>
<p>(bouchou+maurel)@univ-tours.fr
</p>
<p>R&#233;sum&#233; &#8211; Abstract
En travaillant sur l'interrogation de bases de donn&#233;es en langue naturelle, nous sommes
amen&#233;s &#224; exploiter les propositions du Laboratoire de Linguistique Informatique (LLI) en
mati&#232;re de repr&#233;sentation de la langue : les classes d'objets. Un outil d'interrogation d&#233;finit
une application du langage vers le mod&#232;le de l'information stock&#233;e. Ici les classes d'objets et
leurs pr&#233;dicats appropri&#233;s mod&#233;lisent le langage source, tandis que le mod&#232;le relationnel sert
pour les donn&#233;es interrog&#233;es. Nous pr&#233;sentons d'abord ce contexte d'application, puis
comment nous utilisons les classes d'objets et pr&#233;dicats appropri&#233;s dans ce cadre.
We investigate how to use natural language to query a database from both the linguistic and
database points of view (but without AI considerations). In order to achieve this goal, we need
a natural language model which we can map on to a relational database model. We have
chosen to use the word classification called &#171; classes d'objets &#187; as proposed by the
Laboratoire de Linguistique Informatique (LLI). We present here the first results of this work.
</p>
<p>Mots cl&#233;s &#8211; keywords interrogation de BD en langage naturel, mod&#232;le relationnel,
classes d'objets &#8211; natural language database query, relational model, &#171; classes d'objets &#187;
</p>
<p>1. Introduction
Notre syst&#232;me est destin&#233; &#224; interpr&#233;ter la langue naturelle dans le cadre pr&#233;cis d'une
interrogation de bases de donn&#233;es. Ses grandes lignes sont pr&#233;sent&#233;es entre autres dans
(Bouchou, Maurel, 1999). En phase op&#233;rationnelle, l'utilisateur &#233;crit sa question en langage
naturel, puis le syst&#232;me lui fournit une r&#233;ponse issue de la base de donn&#233;es. Avant d'&#234;tre
op&#233;rationnel, le syst&#232;me est &quot;install&#233;&quot; sur la base de donn&#233;es cible. Le lien entre le sens de la
question et le sens des donn&#233;es stock&#233;es est &#233;tabli au cours de cette installation, sous la forme
d'un dictionnaire &#233;lectronique de mots cl&#233;s.
</p>
<p>La phase de configuration du syst&#232;me d'interrogation pour une base de donn&#233;es pr&#233;cise est
l'une des principales pierres d'achoppement des syst&#232;mes existants (Kaplan, 1984), (Sabah,
1997) : il faut qu'elle soit rapide, et surtout qu'elle ne n&#233;cessite pas l'intervention d'un expert
en linguistique, ni en intelligence artificielle. C'est ici que nous faisons intervenir les classes</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>B&#233;atrice Bouchou, Julien Lerat, et Denis Maurel
</p>
<p>d'objets et pr&#233;dicats appropri&#233;s, concepts mis au point par l'&#233;quipe de Gaston Gross au LLI
(Gross, 1994), (Gross, 1998), (Le Pesant, Mathieu-Colas, 1998), (Le Pesant, 2000). Les
classes d'objets d&#233;coulent de la th&#233;orie des op&#233;rateurs linguistiques, d&#233;velopp&#233;e par Z.S.
Harris (Harris, 1976) et d&#233;crite, pour le fran&#231;ais, par les nombreux travaux qui ont suivi
(Gross, 1975). Ces classements d&#233;finis en fonction des op&#233;rateurs linguistiques sp&#233;cifient les
conditions (syntaxiques) que ces mots doivent remplir pour faire sens avec les autres mots de
la question. Notre syst&#232;me s'attache &#224; associer ainsi &#224; la question le sens qu'impose la base.
</p>
<p>La phase d'installation consiste &#224; construire un dictionnaire de mots clefs :
&#8226; En entr&#233;e sont les mots susceptibles d'&#234;tre reconnus dans une question sur la base : ces
</p>
<p>mots sont rattach&#233;s &#224; des classes d'objets et/ou &#224; des pr&#233;dicats (ou classes de pr&#233;dicats).
&#8226; En sortie sont des codes qui indiquent :
</p>
<p>&#8226; d'une part les &#233;l&#233;ments de la base auxquels il est fait r&#233;f&#233;rence dans la question,
&#8226; et d'autre part les liens entre ces &#233;l&#233;ments dans la base, &#233;tablis &#224; partir des liens
</p>
<p>reconnus entre les mots dans la question.
</p>
<p>Nous disposons alors d'un syst&#232;me de mots cl&#233;s, combin&#233; &#224; la connaissance apport&#233;e par les
op&#233;rateurs linguistiques. Pour ce dictionnaire nous travaillons sur des transducteurs &#224; nombre
fini d'&#233;tats, minimaux, compact&#233;s (Revuz, 1991), (Mihov, 2000). Au contraire d'un syst&#232;me
d&#233;velopp&#233; avec ILLICO (Pasero, 1999), nous n'utilisons pas de logique : d'une part, la
connaissance de la langue (syntaxe/s&#233;mantique) se trouve dans les classes d'objets, et d'autre
part les mod&#232;les conceptuel et contextuel sont pr&#233;sents dans la base interrog&#233;e.
</p>
<p>Dans la section 2 de cette communication nous exposons ce que sont les liens entre donn&#233;es
dans une base de donn&#233;es relationnelle. Cela permet, dans la section 3, de pr&#233;ciser ce qui est
recherch&#233; dans la base lors d'une interrogation. Apr&#232;s cette sp&#233;cification de la cible, la section
4 revient sur la th&#233;orie utilis&#233;e pour repr&#233;senter la source (la question en langue naturelle),
puis pr&#233;sente la correspondance &#233;tablie entre les deux. Enfin, nous rapportons dans la section
5 des exemples de l'utilisation des classes d'objets lors de la construction du dictionnaire.
</p>
<p>2. Le &quot;sens&quot; des donn&#233;es stock&#233;es
Une base de donn&#233;es repr&#233;sente un syst&#232;me d&#8217;information. Le sens des donn&#233;es de la base est
fondamental pour concevoir un syst&#232;me d'interrogation : c&#8217;est de cela que parlera la question.
</p>
<p>2.1 Le mod&#232;le conceptuel d'une base de donn&#233;es
</p>
<p>Rappelons comment est con&#231;ue une base : la premi&#232;re &#233;tape consiste &#224; mod&#233;liser le syst&#232;me
d'information, c'est le mod&#232;le conceptuel (MCD). La figure 1 donne un exemple de r&#233;sultat
avec le formalisme E-A (&#171; Entit&#233;s-Associations &#187;) : on a 3 entit&#233;s, Station, Skieur et
Comp&#233;tition, avec leurs attributs, ainsi que 2 associations, est class&#233; et A lieu &#224;, la premi&#232;re
ayant pour attribut le rang de classement.
</p>
<p>Le syst&#232;me d'information ne saurait &#234;tre r&#233;duit aux seules entit&#233;s et associations. L&#8217;ensemble
des contraintes est &#233;galement une composante essentielle de sa description. Les principaux
types de contraintes conceptuelles sont :
</p>
<p>&#8226; Comment un sous-ensemble d'attributs d&#233;termine les valeurs d'une occurrence d'entit&#233;,
ce qui se traduit par la notion d'identifiant (la &quot;clef&quot; dans les BD relationnelles).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>L'interrogation de bases de donn&#233;es comme application des classes d'objets
</p>
<p>&#8226; Comment certains attributs d'une entit&#233; A sont li&#233;s &#224; certains attributs d'une entit&#233; B, ce
qui se traduit par la notion de cardinalit&#233; des associations.
</p>
<p>Skieur
</p>
<p>nomSkieur
sp&#233;cialit&#233;
</p>
<p>Comp&#233;tition
r&#233;fComp
nomComp
</p>
<p>Station
nomStat
paysStat
capacit&#233;
</p>
<p>Est class&#233;
rang
</p>
<p>A lieu &#224;
r&#233;fSkieur
</p>
<p>dateComp(0,n) (1,n) (1,1) (0,n)
</p>
<p>Figure 1. Un sch&#233;ma E-A.
</p>
<p>La cardinalit&#233; consiste en un couple d'informations : le nombre minimum d'occurrences de
l'entit&#233; dans l'association (choix restreint &#224; 0 ou 1), et le nombre maximum d'occurrences de
l'entit&#233; dans l'association (choix restreint &#224; 1 ou &quot;plusieurs&quot;, le second cas &#233;tant not&#233; &quot;n&quot;).
Revenons &#224; l'exemple de la figure 1 (notez que les identifiants des entit&#233;s ont &#233;t&#233; soulign&#233;s) :
le couple (0,n) du c&#244;t&#233; Skieur indique qu'un skieur participe &#224; &#233;ventuellement 0 et en g&#233;n&#233;ral
plusieurs comp&#233;titions, tandis que (1,n) c&#244;t&#233; Comp&#233;tition d&#233;note qu'une comp&#233;tition accueille
au moins 1 et en g&#233;n&#233;ral plusieurs skieurs. La cardinalit&#233; (1,1) c&#244;t&#233; Comp&#233;tition exprime
qu'une comp&#233;tition a lieu dans au moins une station et au plus une station.
</p>
<p>Une fois sp&#233;cifi&#233; le sch&#233;ma conceptuel du syst&#232;me d'information, il faut le traduire dans une
repr&#233;sentation op&#233;rationnelle du point de vue informatique : &#224; ce stade on peut utiliser soit un
mod&#232;le orient&#233; objet, soit un mod&#232;le hi&#233;rarchique, soit encore un mod&#232;le relationnel. Dans le
cas du mod&#232;le relationnel, les tables de la figure 2 sont d&#233;riv&#233;es du sch&#233;ma de la figure 1. On
voit qu'un certain nombre de r&#232;gles pr&#233;sident &#224; la traduction :
</p>
<p>&#8226; Une entit&#233; se traduit par une table, chacun de ses attributs devenant une colonne de la
table, et son identifiant devenant la clef (primaire) de la table.
</p>
<p>&#8226; Une association avec un maximum &#233;gal &#224; n des deux c&#244;t&#233;s se traduit par une table, dont la
clef est form&#233;e des clefs de chaque table correspondant aux entit&#233;s associ&#233;es. Chacun de
ses attributs devient une colonne de la table, cf. la table Classement.
</p>
<p>&#8226; Une association avec maximum &#233;gal &#224; 1 d'un c&#244;t&#233; se traduit par l'ajout, dans la table
&quot;d&#233;pendante&quot;, de la clef de l&#8217;autre table, cf. nomStat dans Comp&#233;tition.
</p>
<p>Comp&#233;tition(r&#233;fComp, nomComp, dateComp, nomStat)
Skieur(r&#233;fSkieur, nomSkieur, sp&#233;cialit&#233;)
Station(nomStat, paysStat, capacit&#233;)
Classement(r&#233;fComp, r&#233;fSkieur  , rang)  
</p>
<p>Figure 2 : Tables d&#233;riv&#233;es du sch&#233;ma E-A.
</p>
<p>2.2 Retrouver le sens des donn&#233;es d'une base en exploitation
</p>
<p>Le mod&#232;le relationnel est le mod&#232;le le plus largement r&#233;pandu dans les bases de donn&#233;es
actuelles. En relationnel &#171; pur &#187;, on ne dispose que des relations (les tables avec leurs
colonnes) : cela seul ne permet pas de retrouver le &#171; sens &#187; des donn&#233;es, c&#8217;est-&#224;-dire les liens
qui existent entre elles. Mais il a tr&#232;s vite &#233;t&#233; adjoint &#224; la th&#233;orie relationnelle de quoi</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>B&#233;atrice Bouchou, Julien Lerat, et Denis Maurel
</p>
<p>exprimer ce sens : ce sont les contraintes (Abiteboul et al., 1995). Dans notre probl&#233;matique,
les contraintes exprimant le mod&#232;le conceptuel &#224; l'origine de la base, nous nous en servons
pour d&#233;terminer l&#8217;image dans la base de donn&#233;es des liens s&#233;mantiques trouv&#233;s entre les mots
de la question (liens exprim&#233;s par les pr&#233;dicats).
Il est possible de retrouver automatiquement les contraintes d&#8217;une base de donn&#233;es en
exploitation : soit dans son catalogue (lequel contient les &#171; m&#233;ta-donn&#233;es &#187;) si le concepteur a
explicitement pos&#233; des contraintes sur la base, soit par des calculs sur le contenu des tables
(Novelli et al., 2000). C'est le cas en particulier pour les d&#233;pendances fonctionnelles.
D&#233;pendance fonctionnelle : Il y a une d&#233;pendance fonctionnelle lorsque la valeur d&#8217;un
attribut (ou d'un groupe d'attributs) d&#233;termine de fa&#231;on unique celle d&#8217;autres attributs. Nous
appelons df un tel lien entre un attribut et les autres attributs de la m&#234;me table. Dans notre
exemple, la r&#233;f&#233;rence de la comp&#233;tition en d&#233;termine la date et la station. De m&#234;me la
r&#233;f&#233;rence du skieur en d&#233;termine le nom et la sp&#233;cialit&#233;, etc.
</p>
<p>D&#233;pendance d'inclusion : Il y a une d&#233;pendance d'inclusion lorsque les valeurs d'un attribut
d'une table doivent appartenir &#224; l'ensemble des valeurs d'un attribut d&#8217;une autre table. Nous
appelons di un lien de d&#233;pendance d'inclusion. Par exemple, le nom de station de la
comp&#233;tition (dans Comp&#233;tition) doit appara&#238;tre dans la colonne nomStat de Station. Cette
information permet de d&#233;duire que, la r&#233;f&#233;rence de la comp&#233;tition d&#233;terminant la station (dans
Comp&#233;tition), elle en d&#233;termine &#233;galement le pays et la capacit&#233; d'accueil (dans Station).
Les contraintes n'expriment pas &#224; elles seules tous les liens entre les donn&#233;es de la base : un
certain nombre de ces liens ne sont pas stock&#233;s (statiques), mais calcul&#233;s (dynamiques). Ainsi
il existe dans tout SGBD des fonctions pr&#233;d&#233;finies, appel&#233;es fonctions d'agr&#233;gat, pour
calculer une somme, une moyenne, un maximum ou un minimum, ou encore compter un
ensemble de valeurs. Elles vont servir par exemple &#224; trouver la station offrant la plus grande
capacit&#233; d&#8217;accueil, &#224; d&#233;terminer la capacit&#233; moyenne des stations fran&#231;aises, etc.
</p>
<p>Les fonctions d'agr&#233;gat correspondent &#224; des pr&#233;dicats g&#233;n&#233;raux de la langue : nous avons
d&#233;velopp&#233; &#224; ce sujet un certain nombre d'exemples dans (Bouchou et al., 1999). Il y a
&#233;galement des fonctions programm&#233;es par le concepteur de la base : par exemple dans une
base d&#8217;inventaire de marchandise, il pourra y avoir une fonction pour calculer le stock
(produits re&#231;us - produits vendus) (Bouchou, Maurel, 1999). Qu&#8217;elles soient pr&#233;d&#233;finies ou
programm&#233;es, on peut trouver les fonctions d&#8217;une base dans de ses &#171; m&#233;ta-informations &#187;.
</p>
<p>En r&#233;sum&#233;, les informations que nous r&#233;cup&#233;rons dans la base sont :
</p>
<p>&#8226; les donn&#233;es : le contenu des tables,
&#8226; la structure g&#233;n&#233;rale : les noms des tables, les noms des colonnes,
&#8226; les liens entre les donn&#233;es : les d&#233;pendances (df et di), ainsi que les fonctions de calcul.
</p>
<p>3. Le &quot;sens&quot; des donn&#233;es pour l'utilisateur qui interroge la base
</p>
<p>3.1 Questions sur les &#171; entit&#233;s &#187;
C&#8217;est un fait &#233;tabli en IHM que tout utilisateur se forge un mod&#232;le mental de l&#8217;application
informatique qu&#8217;il utilise (cf. par exemple l'ouvrage ( Norman, 1986)). Ainsi l&#8217;utilisateur de la</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>L'interrogation de bases de donn&#233;es comme application des classes d'objets
</p>
<p>base a son propre mod&#232;le du syst&#232;me d'information qu'elle repr&#233;sente lorsqu&#8217;il l&#8217;interroge
(plus ou moins clair, complet, correct vis-&#224;-vis de l'implantation effective de la base&#8230;).
En particulier, il en imagine les &#171; entit&#233;s &#187; : c&#8217;est &#224; leur propos qu&#8217;il va poser ses questions,
lesquelles vont donc contenir des r&#233;f&#233;rences &#224; ces entit&#233;s. Nous devons donc savoir comment
l'utilisateur va faire r&#233;f&#233;rence &#224; l&#8217;entit&#233; &#171; skieur &#187;. Il va peut &#234;tre utiliser le mot skieur :
</p>
<p>Quels skieurs particip&#232;rent au Championnat d'Europe 2000 ?
</p>
<p>Pour le m&#234;me genre de question, il peut aussi utiliser un terme repr&#233;sentant des comp&#233;titeurs,
comme concurrent par exemple. Enfin, pour parler d'une occurrence particuli&#232;re de skieur, il
utilisera essentiellement les noms et pr&#233;noms de la personne :
</p>
<p>Quelles comp&#233;titions ont &#233;t&#233; remport&#233;es par Franck Picard ?
</p>
<p>Nous posons une d&#233;finition pour prendre en compte cette derni&#232;re possibilit&#233; : nous appelons
l'ensemble des valeurs caract&#233;ristiques utilis&#233;es dans la question pour parler d'une occurrence
pr&#233;cise d'une entit&#233; le &#171; repr&#233;sentant &#187; de l&#8217;entit&#233;. Cela se traduit dans la base par un attribut,
ou un ensemble d&#8217;attributs d&#8217;une table. Seules les tables qui correspondent &#224; des entit&#233;s ont
un repr&#233;sentant1. Dans notre exemple, une station est repr&#233;sent&#233;e par son nom, une
comp&#233;tition par son nom et sa date, un skieur par son nom (qui regroupe nom et pr&#233;nom).
Cette notion de repr&#233;sentant est n&#233;cessaire pour rep&#233;rer dans la question toute r&#233;f&#233;rence &#224; une
table, soit directe, par ce qu'elle repr&#233;sente (&#171; la station qui&#8230; &#187; fait r&#233;f&#233;rence &#224; la table
Station), soit par une valeur de son repr&#233;sentant (&#171; la capacit&#233; d&#8217;accueil de St Moritz &#187; fait
&#233;galement r&#233;f&#233;rence &#224; la table Station).
</p>
<p>3.2 Questions sur les caract&#233;ristiques des entit&#233;s
L&#8217;interrogation porte donc sur les tables qui correspondent aux entit&#233;s que peut imaginer
l'utilisateur. Plus pr&#233;cis&#233;ment, elle porte sur l&#8217;une ou l&#8217;autre des caract&#233;ristiques des entit&#233;s.
</p>
<p>&#8226; Dans notre exemple, on interrogera sur le pays d'une station, sa capacit&#233;, la sp&#233;cialit&#233; d'un
skieur, la date d'une comp&#233;tition, etc. On en d&#233;duit ainsi que chaque attribut d&#8217;une table T
correspond &#224; une des caract&#233;ristiques possibles de l&#8217;entit&#233; repr&#233;sent&#233;e par T.
</p>
<p>Formellement, il y a d&#233;pendance fonctionnelle (df) entre chaque attribut non-clef et la clef de
la table ; nous identifions la table (et son repr&#233;sentant) &#224; sa clef. Ainsi, connaissant les df,
nous connaissons une premi&#232;re partie des caract&#233;ristiques de l'entit&#233; qui pourront &#234;tre
interrog&#233;es.
</p>
<p>&#8226; Reprenons encore notre exemple : d&#8217;autres caract&#233;ristiques de l&#8217;entit&#233; sont stock&#233;es en
dehors de la table : le pays qui accueille la comp&#233;tition, ou la performance (le rang)
d&#8217;un skieur dans une comp&#233;tition.
</p>
<p>Ces caract&#233;ristiques-l&#224; sont &quot;rapport&#233;es&quot; par les d&#233;pendances d'inclusion (di).
</p>
<p>                                                
</p>
<p>1 Parenth&#232;se technique : cet ensemble d&#8217;attributs est souvent &#171; clef &#187; pour la table, mais c&#8217;est rarement la clef
primaire effective. Pour l'instant, ce repr&#233;sentant doit encore &#234;tre identifi&#233; par l&#8217;installateur.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>B&#233;atrice Bouchou, Julien Lerat, et Denis Maurel
</p>
<p>&#8226; Enfin, il y a les caract&#233;ristiques qui ne sont pas stock&#233;es, mais calcul&#233;es, &#224; savoir les
fonctions : le gagnant d'une comp&#233;tition, par exemple, s'obtient par un MIN sur le rang.
</p>
<p>Ainsi les images dans la base des caract&#233;ristiques interrog&#233;es s&#8217;expriment en termes de df, di
et fonctions, lesquelles mettent en relation tables, attributs, et valeurs.
</p>
<p>4. Projection de la question sur la base
</p>
<p>4.1 Classes d'objets et pr&#233;dicats appropri&#233;s pour repr&#233;senter la question
Nous s&#233;lectionnons dans la question un certain nombre de mots qui fournissent assez
d&#8217;informations pour construire une requ&#234;te SQL pertinente vis-&#224;-vis de la base. Pour cela, il
faut non seulement les mots, mais leurs liens, soit encore l'ensemble des conditions qu'ils
doivent remplir pour faire sens les uns avec les autres dans la question, ceci dans le contexte
de la base. Ces liens, les travaux de Zellig Harris, puis de Maurice Gross (LADL) et, enfin, de
Gaston Gross (LLI) montrent qu'ils sont donn&#233;s par les pr&#233;dicats linguistiques : des op&#233;rateurs
sur les phrases simples, dot&#233;s d'arguments (le sujet, les compl&#233;ments)...
Les classes d&#8217;objets sont pr&#233;sent&#233;es par leurs auteurs comme &#171; des classes s&#233;mantiques
construites &#224; partir de crit&#232;res syntaxiques &#187;2 (Gross, 1998), (Le Pesant, Mathieu-Colas,1998),
(Le Pesant, 2000). Il n'est pas dans notre propos de d&#233;tailler leur cadre th&#233;orique, &#233;labor&#233; au
LLI depuis une dizaine d'ann&#233;es, aussi nous ne faisons que rappeler leur d&#233;finition. Une
classe d&#8217;objets est d&#233;finie comme repr&#233;sentant le &#171; type &#187; d'un argument de pr&#233;dicat : en
d'autres termes, le pr&#233;dicat s&#233;lectionne son argument dans telle ou telle classe d'objets. Ainsi,
on peut d&#233;crire le sens d'un mot pr&#233;dicatif (verbe, nom, adjectif, ou adverbe) en indiquant les
classes d'objets qu'il s&#233;lectionne. Et inversement, une classe d'objets est d&#233;finie (en partie) par
les pr&#233;dicats qui lui sont sp&#233;cifiques : ce sont ses pr&#233;dicats appropri&#233;s. Cela permet de d&#233;crire
le sens d'un mot non pr&#233;dicatif par l'&#233;nonc&#233; des classes d'objets auxquelles il appartient.
Par exemple, comp&#233;tition appartient &#224; la classe des &lt;&#233;v&#233;nements&gt; : ce mot est s&#233;lectionn&#233; par
&#171; se d&#233;rouler &#187;, &#171; &#234;tre organis&#233; &#187;, &#171; avoir lieu &#187;, etc.
</p>
<p>(i) N0 a eu lieu &#224; N1 le N2 ici N1 est de la classe des &lt;toponymes&gt; (auquel
appartiennent les stations de ski, mais &#233;galement les pays), et N2 de la classe des dates.
</p>
<p>(ii) De m&#234;me, le mot skieur, de la classe des &lt;humains&gt; (&#224; ce titre il a un nom, donc il
peut &#234;tre s&#233;lectionn&#233; par &#171; &#234;tre nomm&#233; &#187;, &#171; avoir pour nom &#187;,&#8230;) est aussi de la (sous-)
classe des &lt;sportifs&gt;, ce qui le rend s&#233;lectionnable par :
</p>
<p>(iii) N0 a pour sp&#233;cialit&#233; N1 ; la sp&#233;cialit&#233; de N0 est N1.
(iv) Il est &#233;galement dans la classe des &lt;comp&#233;titeurs&gt;, qualifi&#233;e par &#171; &#234;tre vainqueur &#187;,
</p>
<p>&#171; perdre &#187;, &#171; se classer &#187;, &#171; avoir pour rang &#187;, etc.
</p>
<p>(v) Le mot station rel&#232;ve (entre autres) de la classe des &lt;villes&gt;, s&#233;lectionn&#233;es en
particulier par : N0 est dans &lt;pays&gt;, N0 en &lt;pays&gt;, N0 de &lt;pays&gt;. Il appartient
</p>
<p>                                                
</p>
<p>2 C'est en ceci nous semble-t-il que la d&#233;marche du LLI diff&#232;re de celle du DEC de Mel'cuk (Mel'cuk, 1995),
dans lequel la plupart des propri&#233;t&#233;s lexicographiques d'une lexie d&#233;coulent des d&#233;finitions s&#233;mantiques.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>L'interrogation de bases de donn&#233;es comme application des classes d'objets
</p>
<p>&#233;galement aux lieux g&#233;ographiques, caract&#233;ris&#233;s entre autres par leur altitude : N0 se situe
&#224; &lt;altitude&gt;.
</p>
<p>Dans les faits, les classes d'objets sont d&#233;finies en extension, par l'ensemble des mots qui les
composent, et l'ensemble de leurs pr&#233;dicats appropri&#233;s (verbes, adjectifs, noms ou adverbe).
Chaque mot est lui-m&#234;me associ&#233; &#224; des caract&#233;ristiques lexico-s&#233;mantiques : genre, trait,
domaine, etc. Les pr&#233;dicats sont d&#233;crits &#233;galement par leurs caract&#233;ristiques : cat&#233;gorie
grammaticale, classes des arguments , trait, domaine, etc.
</p>
<p>4.2 L'image dans la base des classes d'objets et pr&#233;dicats appropri&#233;s
Les classes d'objets nous servent &#224; construire le dictionnaire, en m&#234;me temps que les
informations issues de la base de donn&#233;es : ce dictionnaire met en relation des mots avec des
ensembles de codes, comme le sch&#233;matise la figure 3.
</p>
<p>mot {codes}DICTIONNAIRE
</p>
<p>Figure 3 : &#192; un mot correspond une liste de codes
Quels sont les mots en entr&#233;e du dictionnaire, mots qu'il faudra reconna&#238;tre dans la question ?
C'est la base de donn&#233;es qui d&#233;termine ce vocabulaire : on doit pouvoir reconna&#238;tre :
</p>
<p>&#8226; Toute r&#233;f&#233;rence aux entit&#233;s (tables).
</p>
<p>&#8226; Toute r&#233;f&#233;rence aux instances (valeurs stock&#233;es).
</p>
<p>&#8226; Toute r&#233;f&#233;rence aux caract&#233;ristiques de telle ou telle entit&#233; (relations entre attributs
d'une table &#8211;df&#8211;, ou relations entre attributs de diff&#233;rentes tables &#8211;di&#8211;, ou fonctions).
</p>
<p>Reprenons les exemples (i) &#224; (v) pr&#233;c&#233;dents :
</p>
<p>&#8226; Les mots qui parlent d'une table appartiennent &#224; une (ou plusieurs3) classe(s) d'objets
linguistiques. De m&#234;me, les valeurs (textuelles) prises par un attribut appartiennent &#224;
une (ou plusieurs) classe(s) d'objets : St Moritz, Gen&#232;ve ou Lausanne sont des &#233;l&#233;ments
de la classe des noms de villes.
</p>
<p>&#8226; Consid&#233;rons maintenant les attributs d'une table T : chacun correspond &#224; une
caract&#233;ristique de l'entit&#233; repr&#233;sent&#233;e (m&#234;me partiellement) par T. Chacun repr&#233;sente
donc un mot pr&#233;dicatif, qui s&#233;lectionne au moins deux arguments : le premier dans la
classe d'objets de la table, le deuxi&#232;me dans la classe d'objets des valeurs prises par
l'attribut. Voyez par exemple (i) : N0 a lieu &#224; N1, ou encore (iii) et (iv).
</p>
<p>&#8226; Lorsqu'une entit&#233; est repr&#233;sent&#233;e par un ensemble de tables, les attributs d'une table T1
qui d&#233;pendent des valeurs d'une table T2 correspondent &#233;galement &#224; des mots
pr&#233;dicatifs, lesquels s&#233;lectionnent un argument dans la classe d'objets de la table T2, et
les autres dans les classes des valeurs prises par l'attribut de T1. Ainsi la relation entre
</p>
<p>                                                
</p>
<p>3
 Du fait de la hi&#233;rarchie entre classes d'objets, un mot peut appara&#238;tre dans une classe et une sous-classe.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>B&#233;atrice Bouchou, Julien Lerat, et Denis Maurel
</p>
<p>l&#8217;attribut pays de la table Station avec la table Comp&#233;tition repr&#233;sente la forme N0 a
lieu en N1 : le championnat d&#8217;Europe a lieu en Autriche.
</p>
<p>&#8226; Par ailleurs les fonctions (nomm&#233;es selon le &#171; sens &#187; de leur r&#233;sultat : minimum,
somme, stock, vainqueur&#8230;, et caract&#233;ris&#233;es par leurs arguments et leur type) sont, elles
aussi, r&#233;f&#233;renc&#233;es dans la langue par des mots pr&#233;dicatifs. Par exemple la fonction qui
calcule un minimum repr&#233;sente la forme superlative le moins, ou le plus petit :
l'altitude la moins &#233;lev&#233;e, la plus petite capacit&#233; d'accueil.
</p>
<p>Ainsi les informations (valeurs stock&#233;es) et les m&#233;ta-informations (tables, attributs,
contraintes et fonctions) de la base de donn&#233;es conditionnent l'ensemble des mots &#224;
reconna&#238;tre dans la question. &#192; partir de ces conditions pos&#233;es par la base, notre d&#233;marche
consiste ensuite &#224; consulter la langue, structur&#233;e en classes d'objets et de pr&#233;dicats, pour
d&#233;terminer les mots qui seront utilis&#233;s pour l'interrogation.
</p>
<p>Sp&#233;cifions maintenant les codes &#224; associer aux mots du dictionnaire. Un mot est en entr&#233;e du
dictionnaire en tant qu'&#233;l&#233;ment d'une classe d'objet et/ou &#233;l&#233;ment d'une classe de pr&#233;dicats.
</p>
<p>&#8226; Si c'est un &#233;l&#233;ment d'une classe d'objets, alors c'est une r&#233;f&#233;rence soit &#224; une table, soit &#224;
une valeur d'un attribut d'une table4. Donc au moment o&#249; on ajoute le mot au
dictionnaire, on conna&#238;t la table ou la valeur d'attribut en question : on associe alors &#224;
ce mot une r&#233;f&#233;rence &#224; cette table (code T.nom_interne_de_la_table), ou &#224; cette valeur
(de cet attribut de cette table : code I.nom_de_la_table.nom_ de_l&#8217;attribut.valeur).
</p>
<p>&#8226; Si c'est un mot pr&#233;dicatif, alors il est en entr&#233;e du dictionnaire du fait d'une df, d'une di,
ou d'une fonction. De la m&#234;me fa&#231;on on peut lui associer un code qui repr&#233;sente cette
information dans la base. Par exemple, &#171; se d&#233;roule &#187; est associ&#233; au code
df(T.Comp&#233;tition, A.Comp&#233;tition.nomStat) au moment o&#249; cette df est trait&#233;e, puis au
code di(T.Comp&#233;tition, A.Station.paysStat) lorsque cette di est trait&#233;e &#224; son tour. Ce
terme, &#171; se d&#233;roule &#187;, est donc en entr&#233;e du dictionnaire du fait des relations df et di,
ET gr&#226;ce aux classes d'objets et de pr&#233;dicats associ&#233;s, qui fournissent les mots de la
langue5 qui expriment ces relations.
</p>
<p>On voit donc qu'&#224; chaque mot est associ&#233;e une liste de codes, ne serait-ce que parce qu'il est
rare qu'un mot n'ait qu'un emploi, m&#234;me dans un certain domaine. Le traitement d'une
question par le premier transducteur (qui applique le dictionnaire) g&#233;n&#232;re une liste de listes de
codes. L'essentiel du traitement ult&#233;rieur consiste &#224; mettre en regard les sous-listes : par
exemple, s'il y a le code df(T.Comp&#233;tition, A.Comp&#233;tition.nomStat) dans une sous-liste S1, et
s&#8217;il y a le code T.Comp&#233;tition dans une sous-liste S2 et enfin le code A.Comp&#233;tition.nomStat
dans une sous-liste S3, alors df(T.Comp&#233;tition, A.Comp&#233;tition.nomStat) est retenu, et ce code
n'est retenu qu'&#224; cette condition : nous ne retenons que les d&#233;pendances et fonctions
&#171; instanci&#233;es &#187; par une partie ou une autre de la question.
</p>
<p>Bien &#233;videmment, les principes qui viennent d'&#234;tre d&#233;crits ne sont applicables qu'en cas
d'attributs textuels : les bool&#233;ens, les nombres et les dates ne sauraient se trouver en entr&#233;e du
dictionnaire, et portent peu de s&#233;mantique en eux-m&#234;mes. Ces types d'attributs font l'objet
d'un traitement distinct que nous n'aborderons pas ici.
                                                
</p>
<p>4 Table ou valeur qui sont &#224; l'origine de la pr&#233;sence de ce mot en entr&#233;e du dictionnaire.
5 Et les r&#232;gles qui r&#233;gissent leur emploi, donc leur sens&#8230;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>L'interrogation de bases de donn&#233;es comme application des classes d'objets
</p>
<p>5. Construction du dictionnaire avec les classes d&#8217;objets
Dans la phase d&#8217;installation, il faut que les choses soient simples. Dans (Bouchou et al.,
1999), il est montr&#233; que notre syst&#232;me fait grosso-modo ce que le syst&#232;me TEAM faisait d&#233;j&#224;
en 1986 avec une approche de type intelligence artificielle (Grosz, 1986). Mais TEAM
demandait trop d&#8217;efforts et de comp&#233;tences pour son adaptation &#224; chaque nouvelle base. Pour
nous, compte-tenu de ce que nous extraions de la base elle-m&#234;me (dont les d&#233;pendances et les
fonctions), et de la connaissance de la langue fournie par les classes d&#8217;objets, il faut peu
d&#8217;efforts et peu de temps &#224; l&#8217;installateur. Voici quelques points qui tendent vers cet objectif :
Au d&#233;part, l'installateur donne :
</p>
<p>&#8226; un mot de la langue courante pour d&#233;signer chaque table (le nom interne des tables est
rarement parlant),
</p>
<p>&#8226; le &#171; repr&#233;sentant &#187; des tables qui correspondent &#224; des entit&#233;s.
</p>
<p>Pour chaque nom de table donn&#233;, T, les classes d&#8217;objets auxquelles il appartient sont
recherch&#233;es, et soumises &#224; l&#8217;installateur pour qu&#8217;il d&#233;signe la plus pertinente, CoT6.
</p>
<p>Par ailleurs, les classes d&#8217;objets auxquelles correspondent les valeurs de chaque attribut &#8211;
textuel&#8211; de chaque table sont &#233;galement recherch&#233;es. Chaque attribut Ai de T correspond &#224; une
colonne de valeurs : on recherche la plus petite classe d&#8217;objets qui contienne toutes ces
valeurs. Nous avons ici besoin de la hi&#233;rarchie des classes : si au plus petit niveau (le plus
pr&#233;cis) aucune classe ne contient toutes les valeurs de la colonne, alors il faut s&#233;lectionner une
classe d'un niveau sup&#233;rieur. Soit CoT.Ai la classe ainsi d&#233;termin&#233;e pour l'attribut Ai de T.
</p>
<p>Des techniques similaires sont utilis&#233;es pour les df, di et les fonctions : ainsi pour les df, on
recherche la classe de pr&#233;dicats &#224; laquelle correspond un attribut Ai de la table T. Il s'agit de
l&#8217;ensemble des pr&#233;dicats qui s&#233;lectionnent &#224; la fois un &#233;l&#233;ment de la classe CoT et un &#233;l&#233;ment
de la classe CoT.Ai. On note cet ensemble : CpT.Ai = {P/(CoT, CoT.Ai , P)}.
Gr&#226;ce &#224; de tels calculs, op&#233;r&#233;s automatiquement sur les fichiers qui d&#233;crivent les classes
d'objets et les pr&#233;dicats, l'installateur, apr&#232;s avoir &#171; amorc&#233; &#187; l'installation avec un nom pour
chaque table, n'a plus qu'un simple r&#244;le de s&#233;lection ou de validation.
</p>
<p>6. Bilan et perspectives
Nous ne pensons pas avoir &#233;puis&#233; les ressources offertes par les classes d'objets et pr&#233;dicats
associ&#233;s. Les techniques qui viennent d'&#234;tre pr&#233;sent&#233;es sont implant&#233;es dans notre prototype,
d&#233;velopp&#233; en Java. Celui-ci est test&#233; sur plusieurs bases, de domaines diff&#233;rents (la gestion de
stock, les vins, &#8230;), et l'exp&#233;rience m&#233;rite d'&#234;tre prolong&#233;e pour int&#233;grer des propositions
concernant l'organisation de la classification, comme l'usage des domaines et sous-domaines.
</p>
<p>Une perspective importante ouverte par ce travail, pour l'instant focalis&#233; sur les bases de
donn&#233;es relationnelles, consiste &#224; transposer les r&#233;flexions qui le sous-tendent vers des
</p>
<p>                                                
</p>
<p>6 Les classes sont &quot;soumises&quot; &#224; travers un &#233;chantillon de leurs pr&#233;dicats appropri&#233;s.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>B&#233;atrice Bouchou, Julien Lerat, et Denis Maurel
</p>
<p>collections de donn&#233;es semi structur&#233;es, par exemple en XML, et &#224; ouvrir notre application,
de ce fait, &#224; la recherche d'informations sur le Web.
</p>
<p>Remerciements
</p>
<p>Les auteurs tiennent &#224; remercier M. Gaston Gross pour leur avoir permis de tester les id&#233;es
pr&#233;sent&#233;es ici sur des fichiers de classes d'objets et de pr&#233;dicats d&#233;velopp&#233;s au LLI.
</p>
<p>R&#233;f&#233;rences
</p>
<p>Abiteboul S., Hull V., Vianu V. (1995), Foundations of Databases, Addison-Wesley.
Bouchou B., Maurel D. (1999), Une biblioth&#232;que d&#8217;op&#233;rateurs linguistiques pour la
consultation de base de donn&#233;es en langue naturelle, 6&#232;me Conf&#233;rence sur le Traitement
Automatique des Langues naturelles (TALN 1999), Carg&#232;se, actes pp 65-74.
Bouchou B., Maurel D., Kaltz B. (1999), Pr&#233;dicats logiques / pr&#233;dicats linguistiques pour la
consultation de base de donn&#233;es en langue naturelle, RISSH, U. de Li&#232;ge, Vol.35, pp 127-149.
Gross G. (1994), Classes d&#8217;objets et description des verbes, Langages 115, Larousse.
Gross G. (1998), Pour une v&#233;ritable fonction synonymie dans un traitement de texte,
Langages 131, Larousse.
Gross M. (1975), M&#233;thodes en syntaxe, Hermann, Paris.
Grosz B., Appelt D., Martin P., Peirera F.(1987), TEAM : an experiment in the design of
transportable natural language interfaces, Artificial Intelligence 32, pp 173-243.
Harris Z.S. (1976), Notes du cours de syntaxe, Paris, Le Seuil.
Kaplan S. J. (1984), Designing a Portable Natural Language Database Query System, ACM
Transactions on Database Systems, vol. 9, n&#176;1, march 1984, pp. 1-19.
Le Pesant D., Mathieu-Colas M. (1998), Introduction aux classes d&#8217;objets, Langages 131,
Larousse.
Le Pesant D. (2000), Introduction aux classes d&#8217;objets, Th&#232;se d'habilitation &#224; diriger des
recherches, Universit&#233; de Villetaneuse, d&#233;cembre 2000.
Mel'cuk I. A., Clas A., Polguere A. (1995), Introduction &#224; la lexicologie explicative et
combinatoire, &quot;champs linguistiques&quot;, Louvain La Neuve, Duculot.
Mihov S., Maurel D. (2000), Direct Construction of Minimal Acyclic Subsequential
Transducers, First Conference on Implementing and Application of Automata (CIAA&#8217;2000).
Norman, D. A., Draper, S. (Eds.), (1986). User Centered System Design: New Perspectives
on Human-Computer Interaction. Hillsdale, NJ: Lawrence Erlbaum Associates.
Novelli N., Cicchetti R. (2000), Mining functional and embedded dependencies using free
sets, 16&#232;me Conf&#233;rence Bases de Donn&#233;es Avanc&#233;es (BDA 2000), Blois.
Pasero R., Sabatier P. (1999), ILLICO : un syst&#232;me g&#233;n&#233;rique pour la compr&#233;hension d'un
sous-ensemble du fran&#231;ais, rapport Laboratoire d'Informatique de Marseille, 1999.
Revuz D. (1991), Dictionnaires et lexiques - M&#233;thodes et algorithmes, Th&#232;se de Doctorat en
Informatique (Universit&#233; Paris7).
Sabah G. (1997), Le sens dans le traitement automatique des langues, T.A.L. 38-2, pp. 91-133.</p>

</div></div>
</body></html>