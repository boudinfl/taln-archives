<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Formal Languages for Linguists: Classical and Nonclassical Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2001, Tours, 2-5 juillet 2001
</p>
<p>Formal Languages for Linguists: Classical and Nonclassical
Models
</p>
<p>Extended version of the chapter 8: C. Mart&#305;&#769;n-Vide, Formal grammars and languages, in R.
Mitkov, ed., Oxford Handbook of Computational Linguistics. Oxford University Press, Oxford,
</p>
<p>2001.
</p>
<p>Carlos Mart&#305;&#769;n-Vide
Research Group on Mathematical Linguistics
</p>
<p>Rovira i Virgili University
Pl. Imperial Ta&#768;rraco, 1
43005 Tarragona, Spain
</p>
<p>E-mail: cmv@correu.urv.es, cmv@nil.fut.es
Web: http://www.urv.es/centres/Grups/grlmc/grlmc.html
</p>
<p>Abstract
The basics of classical formal language theory are introduced, as well as a wide coverage is
given of some new nonstandard devices motivated in molecular biology, which are challenging
traditional conceptions, are making the theory revived and could have some linguistic relevance.
Only definitions and a few results are presented, without including any proof. The chapter
can be profitably read without any special previous mathematical background. A long list of
references completes the chapter, which intends to give a flavour of the field and to encourage
young researchers to go deeper into it.
</p>
<p>1 Languages
</p>
<p>1.1 Basic Notions
</p>
<p>An alphabet or vocabulary &#0; is a finite set of letters. By concatenating the letters from &#0; again
and again, one obtains &#0;&#2;&#1; , an infinite set of strings or words. The empty string is denoted by
&#3;
</p>
<p>and contains no letter: it is the unit element of &#0;&#2;&#1; under the concatenation operation. The
concatenation of strings is an associative and noncommutative operation, which closes &#0;&#4;&#1; , i.e.:
</p>
<p>for every &#5;&#7;&#6; &#8;&#10;&#9; &#0;&#2;&#1;&#12;&#11; &#5;&#13;&#8;&#10;&#9; &#0;&#7;&#1; &#14;
</p>
<p>The length of a string, denoted by &#15; &#5;&#4;&#15; , is the number of letters the string consists of. It is clear
that:
</p>
<p>&#16;
</p>
<p>&#15;
</p>
<p>&#3;
</p>
<p>&#15;&#18;&#17;&#20;&#19; ,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>&#0;&#2;&#1; &#3;&#5;&#4;&#6;&#1;&#8;&#7;&#9;&#1; &#3;&#10;&#1; &#11;&#2;&#1; &#4;&#12;&#1; &#13;
</p>
<p>&#3; is a substring or subword of &#4; if and only if there exist &#14;&#12;&#15; &#16; &#14;&#18;&#17; such that &#4;&#10;&#7; &#14;&#12;&#15; &#3; &#14;&#18;&#17; &#13; Special
cases of a substring include:
</p>
<p>&#0; if &#3;&#9;&#19;&#7;&#2;&#20; and &#3;&#9;&#19;&#7;&#21;&#4; , then &#3; is a proper substring of &#4; ,
&#0; if &#14;
</p>
<p>&#15;
</p>
<p>&#7;&#2;&#20;
</p>
<p>, then &#3; is a prefix or a head,
&#0; if &#14;&#18;&#17; &#7;&#2;&#20; , then &#3; is a suffix or a tail.
</p>
<p>The i-times iterated concatenation of &#3; is practically showed in the following:
</p>
<p>Example 1.1 If &#3;&#21;&#7;&#21;&#22;&#24;&#23; &#16; then &#3;&#5;&#25;&#26;&#7;fiff &#22;&#24;&#23; fl &#25;ffi&#7;&#21;&#22;&#31;&#23; &#22;&#31;&#23; &#22;&#31;&#23; &#13; ( &#3;&#5; &#26;&#7;&#2;&#20;&#6;&#13; )
</p>
<p>If &#3;&#21;&#7;!&#22;
&#15;
</p>
<p>&#22;
</p>
<p>&#17;
</p>
<p>&#13; &#13; &#13; &#22;&#8;&quot;
</p>
<p>, then its mirror image &#3;$# &#15; &#7;&#21;&#22;&#8;&quot;&#31;&#22;&#8;&quot;
#
</p>
<p>&#15;
</p>
<p>&#13; &#13; &#13; &#22;
</p>
<p>&#15;
</p>
<p>&#13; It is clear that:
</p>
<p>ff &#3;$#
</p>
<p>&#15;
</p>
<p>fl #
</p>
<p>&#15;
</p>
<p>&#7;&#21;&#3;
</p>
<p>,
ff &#3;$#
</p>
<p>&#15;
</p>
<p>fl %&#6;&#7;fiff &#3;ffi% fl #
</p>
<p>&#15; (for every &amp;('&#21;) ).
</p>
<p>Any subset *!+&#21;,.- (including both / and 0 &#20;&#6;1 ) is a language. One denotes ,32 &#7; ,3-5460 &#20;&#6;1&#31;&#13;
</p>
<p>Regarding cardinality (generally, the number of elements a set contains):
</p>
<p>&#0;
</p>
<p>,.- is denumerably infinite, i.e. &#1; ,3- &#1;&#31;&#7;&#21;7
 
</p>
<p>(the smallest transfinite number),
&#0;98:ff
</p>
<p>,3-
</p>
<p>fl is nondenumerably infinite, i.e. &#1; 8:ff ,3- fl &#1;&#31;&#7;&#21;;&#8;&lt; = (also called 7
&#15;
</p>
<p>).
</p>
<p>We do not go here deeper into the details of infinite sets, which would require an extensive
presentation.
</p>
<p>Examples of languages include:
</p>
<p>Example 1.2 * &#7; 0 &#22; &#16; &#23; &#16; &#20;&#6;1 , * &#7; 0 &#22;&#8;% &#16; &#23; %(&gt; &amp;5'&#21;) 1 , * &#7; 0 &#3;$&#3;$# &#15; &gt;&#24;&#3;@? ,3- 1 , * &#7; 0 &#22;
&quot; A
</p>
<p>&gt;&#24;B
</p>
<p>'@C
</p>
<p>1
</p>
<p>,
</p>
<p>*
</p>
<p>&#7;
</p>
<p>0
</p>
<p>&#3;&#2;&gt;&#31;&#3;&#2;?
</p>
<p>0
</p>
<p>&#22;
</p>
<p>&#16;
</p>
<p>&#23; 1
</p>
<p>2 and &#1; &#3;D&#1; Effi&#7;&#9;&#1; &#3;&#10;&#1; F 1 ( &#1; &#3;&#10;&#1; G denotes the number of occurrences of x in w).
</p>
<p>1.2 Chomsky Grammars. The Chomsky Hierarchy
</p>
<p>A (formal) grammar is a construct H &#7;@ff I &#16; Jffi&#16; KL&#16; M fl , where I &#16; J are alphabets, with I@N J &#7;
/ , K
</p>
<p>?@I and M is a finite set of pairs ff &#3; &#16; &#4;Ofl such that &#3; &#16; &#4;6?&#9;ff IQP J fl - and &#3; contains at
least one letter from IR&#13; ( ff &#3; &#16; &#4;&#24;fl uses to be written &#3;TSU&#4;O&#13; ) I is the nonterminal alphabet,
J the terminal alphabet, K the initial letter or axiom, and M the set of rewriting rules or
productions.
</p>
<p>Given H &#7;Vff I &#16; Jffi&#16; KL&#16; M fl and &#3; &#16; &#4;R?!ff IWP J fl - , an immediate or direct derivation (in 1 step)
&#3;!&#7;&#6;X6YZ&#4; holds if and only if:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>(i) there exist &#0;&#2;&#1; &#3; &#0;&#5;&#4;&#7;&#6;&#9;&#8; &#10;&#12;&#11;&#14;&#13;&#16;&#15; &#17; such that &#18;&#20;&#19; &#0;&#2;&#1; &#21;&#22;&#0;&#5;&#4; and &#23;&#24;&#19; &#0;&#2;&#1; &#25;&#26;&#0;&#5;&#4; , and
</p>
<p>(ii) there exists &#21;fiff&#26;flffi&#25;fi&#6; &#31;&#7;!
</p>
<p>Given &quot;#&#19; &#8; &#10;$&#3; &#13;%&#3; &amp;&#22;&#3; &#31;'&#15; and &#18; &#3; &#23; &#6;(&#8; &#10;)&#11; &#13;&#16;&#15; &#17; , a derivation &#18;*&#19;&#2;+ &#17;, &#23; holds if and only if
either &#18;-&#19;-&#23; or there exists . &#6;&#9;&#8; &#10;&#12;&#11;&#14;&#13;&#16;&#15; &#17; such that &#18;&#20;&#19;&#2;+ &#17;, . and ./&#19;&#2;+ , &#23; !
</p>
<p>&#19;&#2;+
</p>
<p>&#17;
</p>
<p>, denotes the reflexive transitive closure and &#19;&#26;+10, the transitive closure, respectively, of
&#19;&#2;+
</p>
<p>,
</p>
<p>!
</p>
<p>The language generated by a grammar is defined by:
</p>
<p>2
</p>
<p>&#8;
</p>
<p>&quot;
</p>
<p>&#15;
</p>
<p>&#19;43 &#18;&#20;5
</p>
<p>&amp;
</p>
<p>&#19;&#26;+
</p>
<p>&#17;
</p>
<p>,
</p>
<p>&#18; and &#18; &#6;6&#13; &#17; 7 !
</p>
<p>Example 1.3 Let &quot;8&#19; &#8; &#10;$&#3; &#13;%&#3; &amp;&#22;&#3; &#31;'&#15; be a grammar such that:
</p>
<p>&#10;
</p>
<p>&#19;43
</p>
<p>&amp;&#22;&#3; 9&#16;&#3; :
</p>
<p>7
</p>
<p>,
</p>
<p>&#13;
</p>
<p>&#19;43 ;
</p>
<p>&#3; &lt;
</p>
<p>7
</p>
<p>,
</p>
<p>&#31;
</p>
<p>&#19;=3
</p>
<p>&amp;&gt;ff&#26;fl
</p>
<p>;
</p>
<p>:&#24;&#3; &amp;#ff&#2;fl?&lt; 9'&#3; 9@ff&#26;fl
</p>
<p>;
</p>
<p>&#3; 9@ff&#2;fl
</p>
<p>;
</p>
<p>&amp;&#22;&#3; 9=ff&#2;fl?&lt; 9A9&#16;&#3; :Bff&#2;fl?&lt; &#3; :Bff&#2;fl
</p>
<p>&lt; &amp;&#22;&#3; :(ff&#26;fl
</p>
<p>;
</p>
<p>:':
</p>
<p>7
</p>
<p>!
</p>
<p>The language generated by G is the following:
</p>
<p>2
</p>
<p>&#8;
</p>
<p>&quot;
</p>
<p>&#15;
</p>
<p>&#19;43 &#18;&#20;5C&#18;
</p>
<p>&#6;
</p>
<p>3 ;
</p>
<p>&#3; &lt;
</p>
<p>7
</p>
<p>0 and D &#18;&#24;D E&#7;&#19;FD &#18;/D G 7 !
</p>
<p>Example 1.4 Let &quot;8&#19; &#8; &#10;$&#3; &#13;%&#3; &amp;&#22;&#3; &#31;'&#15; be a grammar such that:
</p>
<p>&#10;
</p>
<p>&#19;43
</p>
<p>&amp;&#22;&#3; 9&#16;&#3; :
</p>
<p>7
</p>
<p>,
</p>
<p>&#13;
</p>
<p>&#19;43 ;
</p>
<p>&#3; &lt; &#3; H
</p>
<p>7
</p>
<p>,
</p>
<p>&#31;
</p>
<p>&#19;I3
</p>
<p>&amp;Jff&#26;fl
</p>
<p>;
</p>
<p>&lt; H &#3; &amp;Jff&#2;fl
</p>
<p>;
</p>
<p>9%&lt; H &#3; 9%&lt;&#20;ff&#26;flK&lt; 9'&#3; 9%H4ff&#2;flK:/&lt; H H &#3; &lt; :Lff&#2;flK:/&lt; &#3;
</p>
<p>;
</p>
<p>:Lff&#2;fl
</p>
<p>;C;
</p>
<p>9&#16;&#3;
</p>
<p>;
</p>
<p>:(ff&#2;fl
</p>
<p>;C;
</p>
<p>7
</p>
<p>!
</p>
<p>The language generated by G is the following:
</p>
<p>2
</p>
<p>&#8;
</p>
<p>&quot;
</p>
<p>&#15;
</p>
<p>&#19;&#20;3 ;CM
</p>
<p>&lt;
</p>
<p>M
</p>
<p>H
</p>
<p>M/5CN O4P
</p>
<p>7
</p>
<p>!
</p>
<p>Grammars can be classified according to several criteria. The most spread one is the form of
their productions. According to it, a grammar is said to be of type:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>&#0; 0 (phrase-structure grammar, RE) if and only if there are no restrictions on the form of
the productions: everything at both the left-hand side and the right-hand side of the rules
is allowed.
</p>
<p>&#0; 1 (context-sensitive grammar, CS) if and only if every production is of the form:
</p>
<p>&#1;&#3;&#2; &#4;&#5;&#1;&#7;&#6;&#9;&#8;&#11;&#10;&#12;&#1;&#3;&#2; &#13;&#14;&#1;&#7;&#6; &#15;
</p>
<p>with &#1;&#3;&#2; &#15; &#1;&#7;&#6; &#15; &#13;&#17;&#16;&#19;&#18; &#20;&#22;&#21;&#24;&#23;&#5;&#25; &#26; , &#4;&#17;&#16;ff&#20; and &#13;&#22;fifl&#17;ffi (except possibly for the rule &#31; &#8;&#3;&#10; ffi , in
which case &#31; does not occur on any right-hand side of a rule).
&#0; 2 (context-free grammar, CF) if and only if every production is of the form:
</p>
<p>&#4; &#8;&#11;&#10;&#12;&#13;!&#15;
</p>
<p>with &#4; &#16;&quot;&#20; , &#13; &#16;#&#18; &#20;$&#21;%&#23;&amp;&#25; &#26; '
</p>
<p>&#0; 3 (regular or finite-state grammar, REG) if and only if every production is of any of
the forms:
</p>
<p>&#4; &#8;&#11;&#10;&#12;&#13;&#5;()&#15;
</p>
<p>&#4; &#8;&#11;&#10;&#12;&#13;!&#15;
</p>
<p>with &#4;&amp;&#15; ($&#16;&quot;&#20; , &#13; &#16;*&#23; &#26; '
</p>
<p>A language is said to be of type + ( + fl&#22;, &#15; -.&#15; /.&#15; 0 ) if it is generated by a type + grammar. The
family of type + languages is denoted by 132 '
</p>
<p>One of the most important and early results in formal language theory is the so-called Chomsky
hierarchy of languages: 1&#9;4&#14;5&#19;1 &#6; 561 &#2; 5&#19;1&#9;7 '
</p>
<p>Note that every grammar generates a unique language. However, one language can be generated
by several different grammars.
</p>
<p>Two grammars are said to be:
</p>
<p>&#0; (weakly) equivalent if they generate the same string language,
&#0; strongly equivalent if they generate both the same string language and the same tree
</p>
<p>language.
</p>
<p>(We shall see later that a context-free grammar generates not only a set of strings, but a set of
trees too: each one of the trees is associated with one string and pictures the way how this latter
is derived in the grammar.)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>1.3 Operations on Languages
</p>
<p>Usual set-theoretic operations on languages include:
</p>
<p>&#0; Union: &#1;&#3;&#2;&#5;&#4;&#6;&#1;&#8;&#7;&#3;&#9;&#11;&#10; &#12;&#14;&#13;&#15;&#12;&#11;&#16;&#17;&#1;&#3;&#2; or &#12;&#14;&#16;&#17;&#1;&#8;&#7; &#18;&#15;&#19;
</p>
<p>&#0; Intersection: &#1;&#3;&#2;&#5;&#20;&#21;&#1;&#8;&#7;&#22;&#9;&#11;&#10; &#12;&#14;&#13;&#15;&#12;&#14;&#16;&#17;&#1;&#3;&#2; and &#12;&#14;&#16;&#17;&#1;&#8;&#7; &#18;&#15;&#19;
</p>
<p>&#0; Difference:
&#1;
</p>
<p>&#2;&#24;&#23;
</p>
<p>&#1;
</p>
<p>&#7;
</p>
<p>&#9;&#11;&#10; &#12;&#14;&#13;&#15;&#12;&#14;&#16;&#17;&#1;
</p>
<p>&#2;
</p>
<p>and &#12;&#26;&#25;&#16;&#17;&#1; &#7; &#18;&#15;&#19;
</p>
<p>&#0; Complement of &#1;fiff&#14;fl&#31;ffi with respect to fl&#31;ffi &#13;&#8;!&#1;&quot;&#9;&#14;fl&#31;ffi &#23; &#1;&#22;&#19;
</p>
<p>Specific language-theoretic operations on languages include:
&#0; Concatenation: &#1;&#3;&#2; &#1;&#8;&#7;&#22;&#9;&#11;&#10; &#12; &#2; &#12;&#22;&#7; &#13;&#15;&#12; &#2;&#3;&#16;&#17;&#1;&#3;&#2; and &#12;&#22;&#7; &#16;&#17;&#1;&#8;&#7; &#18;&#15;&#19;
</p>
<p>&#0; Iteration:
&#1;&#8;#&#22;&#9;&#11;&#10;%$&amp;&#18;
</p>
<p>,
</p>
<p>&#1;
</p>
<p>&#2;
</p>
<p>&#9;'&#1;
</p>
<p>,
</p>
<p>&#1;
</p>
<p>&#7;
</p>
<p>&#9;'&#1;&#8;&#1;
</p>
<p>,
</p>
<p>&#19; &#19; &#19;
</p>
<p>&#1;&#8;ffi&#22;&#9;)(
</p>
<p>* +
</p>
<p>#
</p>
<p>&#1;
</p>
<p>* (closure of the iteration: Kleene star),
&#1;&#8;,&#17;&#9;
</p>
<p>(
</p>
<p>* +
</p>
<p>&#2;
</p>
<p>&#1;
</p>
<p>* (positive closure of the iteration: Kleene plus).
</p>
<p>Note that &#1;
,
</p>
<p>equals &#1;
ffi
</p>
<p>if $&#21;&#16;&#17;&#1; , and equals &#1;
ffi
</p>
<p>&#23;
</p>
<p>&#10;%$&amp;&#18; if $fi&#25;&#16;&#17;&#1;&#22;&#19;
</p>
<p>&#0; Mirror image:
&#1;&#3;-
</p>
<p>&#2;
</p>
<p>&#9;&#11;&#10; &#12;&#14;&#13;.&#12;/-
</p>
<p>&#2;
</p>
<p>&#16;&#17;&#1;&#22;&#18;&#15;&#19;
</p>
<p>Note that 0 &#1;&#3;-
&#2; 1
</p>
<p>-
</p>
<p>&#2;
</p>
<p>&#9;2&#1;
</p>
<p>and 0 &#1;&#3;-
&#2; 1
</p>
<p>*
</p>
<p>&#9;
</p>
<p>0
</p>
<p>&#1;
</p>
<p>*
</p>
<p>1
</p>
<p>-
</p>
<p>&#2;
</p>
<p>, for every 3&#8;425 &#19;
</p>
<p>&#0; Right quotient of
&#1;
</p>
<p>&#2;
</p>
<p>over
&#1;
</p>
<p>&#7;
</p>
<p>:
&#1;
</p>
<p>&#2;
</p>
<p>&#25; &#1;
</p>
<p>&#7;
</p>
<p>&#9;&#11;&#10; &#12;&#14;&#13;
</p>
<p>there exists 6
&#16;&#17;&#1;
</p>
<p>&#7;
</p>
<p>such that
&#12;
</p>
<p>6
</p>
<p>&#16;&#17;&#1;
</p>
<p>&#2;
</p>
<p>&#18;&#15;&#19;
</p>
<p>&#0; Right derivative of &#1; over 6 : 798: &#1;&quot;&#9;'&#1;&#3;&#25;&#15;&#10; 6 &#18;/&#9;&#11;&#10; &#12;&#14;&#13;.&#12; 6 &#16;&#17;&#1;&#22;&#18;&#15;&#19;
</p>
<p>&#0; Head of &#1;fiff'fl;ffi : &lt;&#6;=;&gt;/?&#17;0 &#1;
1
</p>
<p>&#9;&#11;&#10; &#12;&#14;&#16;@fl&#31;ffi &#13;
</p>
<p>there exists 6 &#16;@fl;ffi such that &#12; 6 &#16;&#17;&#1;&#22;&#18;&#15;&#19;
</p>
<p>Note that for every
&#1;fi&#13;&#15;&#1;fiff
</p>
<p>&lt;&#17;=;&gt; ?&#17;0
</p>
<p>&#1;
</p>
<p>1
</p>
<p>&#19;
</p>
<p>&#0; Left quotient of &#1;&#3;&#2; over &#1;&#8;&#7; : &#1;&#8;&#7; A%&#1;&#3;&#2;&#3;&#9;&#11;&#10; &#12;&#14;&#13; there exists 6 &#16;&#17;&#1;&#8;&#7; such that 6 &#12;&#14;&#16;&#17;&#1;&#3;&#2; &#18;&#15;&#19;
</p>
<p>&#0; Left derivative of
&#1;
</p>
<p>over 6 : 79B:
&#1;&quot;&#9;&#11;&#10;
</p>
<p>6
</p>
<p>&#18;%A%&#1;C&#9;&#11;&#10; &#12;&#14;&#13;
</p>
<p>6
</p>
<p>&#12;&#14;&#16;&#17;&#1;&#22;&#18;&#15;&#19;
</p>
<p>&#0; Tail of
&#1;fiff'fl&#31;ffi
</p>
<p>: D/&gt; E
&#1;
</p>
<p>0
</p>
<p>&#1;
</p>
<p>1
</p>
<p>&#9;&#11;&#10; &#12;&#14;&#16;@fl&#31;ffi &#13;
</p>
<p>there exists 6
&#16;@fl&#31;ffi
</p>
<p>such that 6
&#12;&#14;&#16;&#17;&#1;&#22;&#18;&#15;&#19;
</p>
<p>Note that for every &#1;fi&#13;&#15;&#1;fiff D/&gt; E &#1; 0 &#1;
1
</p>
<p>&#19;
</p>
<p>&#0; Morphism: Given two alphabets fl &#2; F fl &#7; , a mapping G &#13;9fl&#31;ffi&#2; &#23;IH fl;ffi&#7; is a morphism if and
only if:
</p>
<p>(i) for every &#12;&#14;&#16;@fl&#31;ffi&#2; , there exists 6 &#16;@fl;ffi&#7; such that 6 &#9; GI0 &#12;
1
</p>
<p>and 6 is unique,
(ii) for every &#12; F J &#16;@fl&#31;ffi&#2; &#13; GI0 &#12; J
</p>
<p>1
</p>
<p>&#9;
</p>
<p>GI0
</p>
<p>&#12;
</p>
<p>1
</p>
<p>GI0
</p>
<p>J
</p>
<p>1
</p>
<p>&#19;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>A morphism is called
&#0;
</p>
<p>-free if, for every &#1;&#3;&#2;&#5;&#4;&#7;&#6;&#8; , if &#1;&#10;&#9;&#11;
&#0;
</p>
<p>then &#12;&#14;&#13; &#1;&#16;&#15;&#17;&#9;&#11;
&#0;&#14;&#18;
</p>
<p>&#19; Morphic image: &#12;&#14;&#13; &#20;&#21;&#15; &#11;&#23;&#22; &#24; &#2;&#5;&#4;&#16;&#6;&#25;ff&#26; &#24;fi&#11; &#12;&#14;&#13; &#1;&#16;&#15; fl for some &#1;&#3;&#2;ffi&#20; &#31;
&#18;
</p>
<p>&#19; A morphism is called an isomorphism if, for every &#1;&#7;fl !&#3;&#2;&#10;&#4;fi&#6;&#8; , if &#12;&#14;&#13; &#1;&#16;&#15; &#11; &#12;&#14;&#13; !&quot;&#15; then
&#1;
</p>
<p>&#11;
</p>
<p>!
</p>
<p>&#18;
</p>
<p>Example 1.5 An isomorphism between &#4; &#8; &#11;#&#22; $ fl %&amp;fl '(fl
&#18; &#18; &#18;
</p>
<p>fl )*&#31; and &#4; &#25; &#11;+&#22; $ fl %&amp;&#31; is the
binary coded decimal representation of the integers:
</p>
<p>&#12;&#14;&#13;
</p>
<p>$
</p>
<p>&#15;
</p>
<p>&#11;,$-$&amp;$-$
</p>
<p>fl &#12;&#14;&#13; %&amp;&#15;
</p>
<p>&#11;,$&amp;$-$
</p>
<p>%-fl
</p>
<p>&#18; &#18; &#18;
</p>
<p>fl &#12;&#14;&#13; )-&#15;
</p>
<p>&#11;
</p>
<p>%
</p>
<p>$&amp;$
</p>
<p>%
</p>
<p>&#18;
</p>
<p>Union, concatenation and Kleene star are called regular operations.
</p>
<p>Theorem 1.6 Each of the language families . / , for every 0&#5;&#2; &#22; $ fl %&amp;fl '(fl 1(&#31; , is closed under
regular operations.
</p>
<p>A systematic study of the common properties of language families has led to the theory of
abstract families of languages (AFL&#8217;s). An abstract family of languages is a class of those
languages that satisfy certain specified closure axioms. If one fixes an AFL, one can prove
general theorems about all languages in the family.
</p>
<p>A few simple closure properties are depicted next:
</p>
<p>REG CF CS RE
union + + + +
</p>
<p>intersection + &#8211; + +
complement + &#8211; + &#8211;
</p>
<p>concatenation + + + +
Kleene star + + + +
</p>
<p>intersection with regular languages + + + +
morphisms + + &#8211; +
</p>
<p>left/right quotient + &#8211; &#8211; +
left/right quotient with regular languages + + &#8211; +
</p>
<p>left/right derivative + + + +
mirror image + + + +
</p>
<p>The table must be interpreted in the following way. Using the first 2 to the left as an example,
it means that the union of two regular languages is always a regular language. And so on.
</p>
<p>2 Grammars
</p>
<p>2.1 Context-Free Grammars
</p>
<p>Theorem 2.1 For every CF grammar 3 , one can find an equivalent CF grammar 3&#7;4 such that
the right-hand sides of its productions are all different from &#0; except when &#0; &#2;5&#20;&#17;&#13; 3&#7;&#15; &#18; In this</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>latter case,
&#0;&#2;&#1;&#4;&#3;&#6;&#5;
</p>
<p>is the only rule with the right-hand side
&#5;
</p>
<p>, but then
&#0;
</p>
<p>does not occur on
any right-hand side of the rules. (This is also true for REG grammars.)
</p>
<p>A grammar is said to be
&#5;
</p>
<p>-free if none of its rules has the right-hand side
&#5;&#4;&#7;
</p>
<p>An CF grammar is said to be in Chomsky normal form (CNF) if each of its rules has either of
the two following forms:
</p>
<p>&#8;&#10;&#9;
</p>
<p>&#1;&#11;&#3;&#13;&#12;
</p>
<p>,
&#9;&#15;&#14;&#17;&#16;
</p>
<p>,
</p>
<p>&#12;
</p>
<p>&#14;&#19;&#18;
</p>
<p>,
</p>
<p>&#8;&#10;&#9;
</p>
<p>&#1;&#11;&#3;&#13;&#20;&#22;&#21;
</p>
<p>,
&#9;&#17;&#23;
</p>
<p>&#20;
</p>
<p>&#23;
</p>
<p>&#21;
</p>
<p>&#14;&#24;&#16;
</p>
<p>&#7;
</p>
<p>Theorem 2.2 For every
&#5;
</p>
<p>-free CF grammar, one can effectively (algorithmically) find an equiv-
alent grammar in CNF.
</p>
<p>Theorem 2.3 For every CF grammar G, it is decidable whether or not an arbitrary strings &#25;
belongs to &#26;fiff fl&#31;ffi .
</p>
<p>Corollary 2.4 Given an CF grammar fl and a finite language &#26; , both &#26;! &quot;&#26;fiff fl&#22;ffi and &#26;$#
&#26;fiff fl&#22;ffi&amp;%(' are solvable.
</p>
<p>2.2 Derivation Trees
</p>
<p>A very common and practical representation of the derivation process in a grammar (particu-
larly, in an CF grammar) is a tree.
</p>
<p>A derivation tree is defined as &#18; %)ff * &#23; + ffi , where * is a set of nodes or vertices and + is a
dominance relation, which is a binary relation in * that satisfies:
</p>
<p>(i) D is a weak order:
</p>
<p>(i.a) reflexive: for every &#12; &#14; *-, &#12; + &#12; ,
(i.b) antisymmetric: for every &#12; &#23; ./&#14; * , if &#12; +0. and . + &#12; , then &#12; % . ,
(i.c) transitive: for every &#12; &#23; . &#23; 1/&#14; * , if &#12; +0. and . +01 , then &#12; +01 &#7;
</p>
<p>(ii) root condition: there exists 2 &#14; * such that for every ./&#14; *-,32 +0. ,
(iii) nonbranching condition: for every &#12; &#23; &#12;34 &#23; ./&#14; * , if &#12; +0. and &#12;54 +0. , then &#12; + &#12;34 or &#12;54 + &#12;6&#7;
</p>
<p>Special cases of the dominance relation include, for every
&#12;
</p>
<p>&#23; ./&#14;
</p>
<p>* :
</p>
<p>&#8;
</p>
<p>&#12;
</p>
<p>strictly dominates . ( &#12;7&#0; +0. ) if and only if &#12; +0. and &#12;&#17;8% . ; so &#0; + is a strict order in * :
</p>
<p>(i) irreflexive: it is not the case that &#12;9&#0; + &#12; ,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>(ii) asymmetric: if &#0;&#2;&#1;&#4;&#3;&#6;&#5; , then it is not the case that &#5; &#1;&#4;&#3;&#6;&#0; ,
(iii) transitive: if &#0;&#2;&#1;&#4;&#3;&#6;&#5; and &#5; &#1;&#4;&#3;&#6;&#7; , then &#0;&#2;&#1;&#4;&#3;&#6;&#7; &#8;
</p>
<p>&#9;&#10;&#0; immediately dominates &#5; ( &#0;&#12;&#11;&#2;&#3;&#6;&#5; ) if and only if &#0;&#2;&#1;&#4;&#3;&#6;&#5; and there does not exist any &#7;
such that &#0;&#2;&#1;&#4;&#3;&#6;&#7; and &#7; &#1;&#4;&#3;&#6;&#5; &#8;
</p>
<p>The degree of a node &#13;&#12;&#14; &#15;&#17;&#16; &#5; &#18;&#4;&#19;&#21;&#20; &#22; &#0;&#24;&#23;&#26;&#25;&#21;ff&#12;&#5; &#11;&#2;&#3;&#6;&#0;flfifl&#20; &#8; Consequences of this definition are:
</p>
<p>&#9;&#10;&#5; is a terminal node or a leaf if and only if &#13;&#2;&#14; &#15;ffi&#16; &#5; &#18;&#31;&#19;! ,
&#9;&#10;&#5; is a unary node if and only if &#13;&#12;&#14; &#15;&#17;&#16; &#5; &#18;&#4;&#19;#&quot; ,
&#9;&#10;&#5; is a branching node if and only if &#13;&#2;&#14; &#15;ffi&#16; &#5; &#18;%$!&quot; ,
&#9;'&amp; is an n-ary derivation tree if and only if all its nonterminal nodes are of degree ( &#8;
</p>
<p>Two nodes &#0;fl) &#5; are independent of each other: &#0;&#2;&#11;&#12;*+&#3;&#6;&#5; if and only if neither &#0;&#12;&#3;&#6;&#5; nor &#5; &#3;&#6;&#0;fl&#8;
</p>
<p>Some family relations among nodes include:
</p>
<p>&#9;&#10;&#0; is a mother node of &#5; : &#0;fl,!&#5; if and only if &#0;&#2;&#11;&#12;&#3;&#6;&#5; ,
&#9;&#10;&#0; is a sister node of &#5; : &#0;&#2;&#1;&#4;&#5; if and only if there exists &#13; such that &#13; ,!&#0; and &#13; ,!&#5; &#8;
</p>
<p>The mother relation has the following features:
</p>
<p>(i) there does not exist any &#0;&#24;&#23;&#26;&#25; such that &#0;&#2;,!- ,
(ii) if &#5;/.&#19;!- , then it has just one mother node.
</p>
<p>Given &amp;0&#19; &#16; &#25;&#4;) &#3;1&#18; , for every &#5;&#6;&#23;2&#25; , a derivation subtree or a constituent is &amp;ffi34&#19; &#16; &#25;53 ) &#3;63 &#18; ,
where &#25; 3 &#19;7&#22; &#7;4&#23;&#26;&#25;8ff&#2;&#5; &#3;&#6;&#7; fi and 9 &#3; 3 : if and only if 9 &#23;&#26;&#25; 3 and : &#23;&#26;&#25; 3 and 9 &#3; : &#8;
</p>
<p>Given &amp;!&#19; &#16; &#25;&#4;) &#3;1&#18; , for every &#0;fl) &#5;4&#23;&#26;&#25; : &#0; c-commands &#5; (aCCb) if and only if:
</p>
<p>(i) &#0;&#12;&#11;&#2;*+&#3;&#6;&#5; ,
(ii) there exists a branching node that strictly dominates &#0; ,
</p>
<p>(iii) every branching node that strictly dominates &#0; dominates &#5; &#8;
</p>
<p>&#0; asymmetrically c-commands &#5; if and only if &#0;&#12;;/;&lt;&#5; and it is not the case that &#5; ;/;&lt;&#0;5&#8;
</p>
<p>Given two derivation trees &amp;!&#19; &#16; &#25;&#4;) &#3;1&#18; , &amp;&gt;=fl&#19; &#16; &#25;4= ) &#3;&#24;= &#18; and ? ff&#2;&#25;#@A&#25;4=5ff
</p>
<p>&#9;
</p>
<p>? preserves &#3; if and only if for every &#0;fl) &#5;4&#23;&#26;&#25;8ff&#12;&#0;&#2;&#3;&#6;&#5;B@ ?ffi&#16; &#0;&#2;&#18; &#3;&#6;= ?ffi&#16; &#5; &#18; &#8;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0;&#2;&#1; is an isomorphism of &#3; in &#3;&#5;&#4;&#7;&#6; &#3;&#9;&#8;&#9;&#3;&#10;&#4; &#11; if and only if &#1; is a bijection and preserves &#12;&#14;&#13;
(Note that a mapping &#15;&#17;&#16;&#19;&#18;&#9;&#20;&#22;&#21; is a bijection if and only if:
</p>
<p>(i) &#15; is one-to-one or injective: for every &#23;&#25;&#24; &#26;fifffl&#18;ffi&#24; if &#23; &#31;! &#26; then &#15;&quot;&#6; &#23;&#25;&#11;&#17;&#31;! &#15;#&#6; &#26;$&#11; or,
equivalently, if &#15;&quot;&#6; &#23;&#25;&#11; ! &#15;#&#6; &#26;$&#11; then &#23; ! &#26; ,
</p>
<p>(ii) &#15; is onto or exhaustive: for every %&amp;ff&#17;&#21; &#16; there exists &#23;&#17;ff&#17;&#18; such that &#15;&quot;&#6; &#23;&#25;&#11; ! %'&#13; )
</p>
<p>Any two isomorphic derivation trees share all their properties:
</p>
<p>&#0;)('*
</p>
<p>&#12;,+ if and only if &#1; &#6; ( &#11; * &#12;&amp;&#4; &#1; &#6; + &#11; ,
&#0;)(&#19;-
</p>
<p>&#12;,+ if and only if &#1; &#6; ( &#11; - &#12;&amp;&#4; &#1; &#6; + &#11; ,
&#0;).&#19;/ 0
</p>
<p>&#6;
</p>
<p>(
</p>
<p>&#11;
</p>
<p>!
</p>
<p>.'/ 0
</p>
<p>&#6;
</p>
<p>&#1;
</p>
<p>&#6;
</p>
<p>(
</p>
<p>&#11; &#11; ,
</p>
<p>&#0;)(&#19;1ffi1
</p>
<p>+ if and only if &#1; &#6; ( &#11; 1ffi1ffi&#1; &#6; + &#11; ,
&#0;)( is the root of &#3; if and only if &#1; &#6; ( &#11; is the root of &#3;&#5;&#4; ,
&#0;).&#19;/ 2'3 &#1;
</p>
<p>&#6;
</p>
<p>(
</p>
<p>&#11;
</p>
<p>!
</p>
<p>.'/ 2$3 &#1;
</p>
<p>&#6;
</p>
<p>&#1;
</p>
<p>&#6;
</p>
<p>(
</p>
<p>&#11; &#11; ,
</p>
<p>( .&#19;/ 2'3 &#1; &#6; ( &#11; !54 6 +&#5;ff875&#16;&#19;+ &#12; (&#7;9 4 :fi; &#13; )
&#0;&#2;&#1;$/ &lt; 0$&#1;'3
</p>
<p>&#6; &#3;=&#11;
</p>
<p>!
</p>
<p>&#1;$/ &lt; 0&#7;&#1;'3
</p>
<p>&#6; &#3;&#5;&#4; &#11; &#13;
</p>
<p>( &#1;$/ &lt; 0$&#1;'3 &#6; &#3;=&#11; !&#9;&gt; ( &#23; 6 .'/ 2$3 &#1; &#6; ( &#11;?&#16; ( ff87 9 &#13; ]
</p>
<p>Once one has an &#3; ! &#6; 7#&#24; &#12;@&#11; , one may enrich its definition to get a labelled derivation tree
&#3;
</p>
<p>!
</p>
<p>&#6; 7#&#24; &#12;&#14;&#24; A?&#11; , where &#6; 7#&#24; &#12;@&#11; is a derivation tree and A is a mapping from 7 to a specified set
of labels.
</p>
<p>Given &#3; ! &#6; 7#&#24; &#12;&#14;&#24; A?&#11; and &#3;&#10;&#4; ! &#6; 7B&#4; &#24; &#12;&amp;&#4; &#24; A#&#4; &#11; , one says &#3;&#9;&#8;&#9;&#3;&#10;&#4; if and only if:
</p>
<p>(i) &#1; &#16;'7C&#20;D7=&#4; is a bijection,
(ii) &#1; preserves &#12; ,
</p>
<p>(iii) for every ( &#24; +=ff87fl&#16;&#19;A&#5;&#6; ( &#11; ! A&#5;&#6; + &#11; if and only if AE&#4; &#6; &#1; &#6; ( &#11; &#11; ! A#&#4; &#6; &#1; &#6; + &#11; &#11; &#13;
</p>
<p>A terminally ordered derivation tree is &#3; ! &#6; 7#&#24; &#12;&#14;&#24; F=&#11; , where &#6; 7#&#24; &#12;@&#11; is a derivation tree and
F is a strict total (or linear) order on the terminal nodes of 7 , i.e. a relation that is:
</p>
<p>(i) irreflexive: for every ( terminal: it is not the case that ( F ( ,
(ii) asymmetric: if ( Ffi+ , then it is not the case that +&#5;F ( ,
</p>
<p>(iii) transitive: if ( Ffi+ and +=FfiG , then ( FfiG ,
(iv) connected: either ( Ffi+ or +&#5;F ( &#13;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Given &#0;&#2;&#1;&#4;&#3; &#5;&#7;&#6; &#8;&#9;&#6; &#10;&#12;&#11; , for every &#13; &#6; &#14; &#6; &#15;&#16;&#6; &#17;&#19;&#18;&#20;&#5;&#22;&#21; &#13; &#10;&#24;&#23;&#16;&#14; ( &#13; precedes &#14; ) if and only if:
</p>
<p>if &#13; &#8;&#25;&#15; , &#15; is terminal, &#14; &#8;&#25;&#17; and &#17; is terminal, then &#15;&#26;&#10;ff&#17;flfi
</p>
<p>The following exclusivity condition completely orders a tree. Given &#0;ffi&#1;&#22;&#3; &#5;&#7;&#6; &#8;&#9;&#6; &#10;&#12;&#11; , for every
&#13;
</p>
<p>&#6; &#15;&#31;&#18;ff&#5;
</p>
<p>, if &#13;  &quot;! &#8;&#25;&#15; , then either &#13; &#10;&#24;&#23;#&#15; or &#15;&#31;&#10;&#24;&#23; &#13; &#11; fi Consequently, every two nodes of the tree
must hold one, and only one, of the dominance and precedence relations.
</p>
<p>2.3 More about Context-Free Languages
</p>
<p>An CF grammar is called redundant if it contains useless nonterminal letters. A nonterminal
letter is useless if:
</p>
<p>(i) either no terminal string is derivable from it: inactive or dead letter,
</p>
<p>(ii) or it does not occur in any string derivable from $ : unreachable letter.
</p>
<p>Theorem 2.5 For any CF grammar %
&#1;&#4;&#3;
</p>
<p>!
</p>
<p>&#6; &#0;&#24;&#6;
</p>
<p>$
</p>
<p>&#6; &amp;'&#11;
</p>
<p>:
</p>
<p>(*)
</p>
<p>&#18;
</p>
<p>! is inactive if and only if the language generated by %,+ &#1;-&#3; ! &#6; &#0;&#24;&#6; ) &#6; &amp;,&#11; is empty.
(*) is unreachable if and only if the language generated by %'.
</p>
<p>+
</p>
<p>&#1;&#4;&#3; &#3;
</p>
<p>!&#2;/10
</p>
<p>),2
</p>
<p>&#11;fl34&#0;&#24;&#6;
</p>
<p>0
</p>
<p>),2
</p>
<p>&#6;
</p>
<p>$
</p>
<p>&#6;
</p>
<p>&amp;&#7;563
</p>
<p>0 798;:
</p>
<p>&#21;
</p>
<p>7
</p>
<p>&#18;*&#3;
</p>
<p>!&lt;/=0
</p>
<p>),2
</p>
<p>&#11;&gt;3&#25;&#0;
</p>
<p>2
</p>
<p>&#11; ( &amp;&#7;5 being the set of rules remaining after having
removed from &amp; the productions that have ) on their left-hand sides) is 0fl: 2 fi
</p>
<p>An CF grammar is nonredundant or reduced if each of its nonterminal letters is both active
and reachable.
</p>
<p>Theorem 2.6 For every CF grammar, one can effectively (algorithmically) find an equivalent
nonredundant grammar.
</p>
<p>Given an CF grammar %
&#6; ?@&#18;ffA4&#3;
</p>
<p>%
</p>
<p>&#11;
</p>
<p>is an ambiguous string if and only if ? has at least two
derivation trees in % fi % is said to be an ambiguous grammar if and only if there exists some
string in A4&#3; % &#11; that is ambiguous. A is an inherently ambiguous context-free language if and
only if every CF grammar generating A is ambiguous.
</p>
<p>An example of ambiguity is the following:
</p>
<p>Example 2.7 Given %
&#1;&#4;&#3;
</p>
<p>0fl$
</p>
<p>2
</p>
<p>&#6;
</p>
<p>0 B
</p>
<p>&#6; C,&#6; D
</p>
<p>2
</p>
<p>&#6;
</p>
<p>$
</p>
<p>&#6;
</p>
<p>0fl$&#31;8;$
</p>
<p>C
</p>
<p>$
</p>
<p>&#6;
</p>
<p>$E8;$
</p>
<p>D
</p>
<p>$
</p>
<p>&#6;
</p>
<p>$E8FB
</p>
<p>2
</p>
<p>&#11; &#6; ?&#2;&#1;
</p>
<p>B
</p>
<p>D
</p>
<p>B
</p>
<p>C
</p>
<p>B
</p>
<p>has two different derivation trees in % :</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>S S
&#0;
</p>
<p>&#0;
</p>
<p>&#0;
</p>
<p>&#0;
</p>
<p>&#1;
</p>
<p>&#1;
</p>
<p>&#1;
</p>
<p>&#1;
</p>
<p>S &#2; S
</p>
<p>&#0;
</p>
<p>&#0;
</p>
<p>&#0;
</p>
<p>&#0;
</p>
<p>&#1;
</p>
<p>&#1;
</p>
<p>&#1;
</p>
<p>&#1;
</p>
<p>S &#3; S
&#4;
</p>
<p>&#4;
</p>
<p>&#5;
</p>
<p>&#5;
</p>
<p>S &#3; S
</p>
<p>&#6;
</p>
<p>&#6; &#7;
</p>
<p>&#7;
</p>
<p>S &#2; Sa a
</p>
<p>a a a a
</p>
<p>An example of inherent ambiguity is the following:
</p>
<p>Example 2.8 Let &#8;&#10;&#9;&#12;&#11; &#13;&#15;&#14;&#17;&#16; &#14;&#19;&#18; &#20;&#22;&#21;&#24;&#23;&#26;&#25; ffflfi&#12;ffi &#31;&quot;!#&#11; &#13; &#14;&#17;&#16; &#20;&#15;&#18; &#20;&#22;&#21;&#24;&#23;$&#25; ff%fi&amp;ffi&#15;&#31;&#15;' Every CF grammar
generating it will produce two different derivation trees for the strings of the form &#13;(&#20;&#15;&#16; &#20; &#18; &#20; (which
belong to both components of the language).
</p>
<p>The Bar-Hillel pumping lemma for CF languages allows one to prove that a language is not
CF just looking at the structure of the strings:
</p>
<p>for every &#8;#)&#26;*,+ there exist -.&#25; /,)&#26;0 such that for every 12)3&#8;&#19;&#25; if 4 154(67-.&#25; then 1,&#9;
859(:&#19;;=&lt;
</p>
<p>&#25; where 8 &#25; 9 &#25; : &#25; ; &#25; &lt; )$&gt;@? &#25; 4 9(:&#19;; 4&#15;AB/(&#25; 9 ;7C&#9;flD.&#25; and 859&#15;E :&#19;;5E &lt; )&#26;&#8; , for every FGfiIH('
</p>
<p>Since not all languages satisfy the pumping lemma above, the following corollary is obvious.
</p>
<p>Corollary 2.9 There are noncontext-free languages.
</p>
<p>Examples of this include:
</p>
<p>&#11; &#13; &#20;&#15;&#16; &#20;&#15;&#18; &#20;2&#21;(ff&#26;fiflffi&#15;&#31; ,
</p>
<p>&#11; &#13; &#20; J&#19;&#21;&#15;ff&#26;fi%ffi&#15;&#31; ,
</p>
<p>&#11; &#13; &#20;&#15;&#16; &#14;&#19;&#18; &#20; K&#15;&#14;B&#21;&#15;&#23;&#26;&#25; ff&#26;fiflffi&#15;&#31;&#15;'
</p>
<p>2.4 Linear and Regular Languages
</p>
<p>An CF grammar is called linear (LIN) if each production has either of the forms:
</p>
<p>L&#22;MflN.OP:
</p>
<p>,
M
</p>
<p>)&#26;0 ,
:
</p>
<p>)$&gt;Q? ,
</p>
<p>L&#22;MflN.OP:@R S2:&#19;T
</p>
<p>,
M
</p>
<p>&#25;
</p>
<p>S
</p>
<p>)&#26;0 ,
:@R
</p>
<p>&#25;
</p>
<p>:&#19;T
</p>
<p>)$&gt;
</p>
<p>?
</p>
<p>'
</p>
<p>Further, it is called left-linear (LLIN) (respectively, right-linear (RLIN)) if : R (respectively,
:
</p>
<p>T ) is D in every rule of the second form.
</p>
<p>Thus, the class of right-linear grammars exactly coincides with REG. Also:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Theorem 2.10 Every LLIN grammar generates an REG language.
</p>
<p>And now, one can pose the following question: do all linear grammars generate languages in
&#0;&#2;&#1;
</p>
<p>? The answer is: no!, and a counterexample is next.
</p>
<p>Example 2.11 Consider the languages:
</p>
<p>&#3;&#2;&#4;&#2;&#5;&#7;&#6; &#8;&#10;&#9;&#12;&#11; &#9;&#10;&#13; &#14;&#16;&#15;&#10;&#17;&#19;&#18;&#21;&#20;&#12;&#22; &#23;&#24;&#18;&#7;&#20;&#10;&#25;
</p>
<p>,
</p>
<p>&#3;ff&#26;fi&#5;&#7;&#6; &#8;fl&#14; &#11; &#9;&#10;&#13; &#9;ffi&#15;&#10;&#17;&#19;&#18;&#21;&#20;&#12;&#22; &#23;&#24;&#18;&#7;&#20;&#10;&#25;&#10;&#31;
</p>
<p>Both are generated by linear grammars. For instance, the first one by:
</p>
<p> 
</p>
<p>&#5;&#21;! &#6;&#12;&quot;#&#22; $%&#25;&#10;&#22; &#6; &#8;&amp;&#22; &#11; &#22; &#13; &#25;&#10;&#22; &quot;#&#22; 'ffi&#25;&#10;&#22; '&#7;&#5;&#21;&#6;&#12;&quot;)(+*,&quot;-&#13; &#22; &quot;.(/*0$1&#13; &#22; $&#7;(/*2&#8;fl&#11; &#22; $&#21;(+*0&#8;fl$1&#11; &#25;&#10;&#31;
</p>
<p>However, could one build a regular grammar generating any of them? Since:
</p>
<p>&#3;&#2;&#4;#34&#3;ff&#26;&#2;&#5;&#21;&#6; &#8;
</p>
<p>&#9;
</p>
<p>&#11;
</p>
<p>&#9;
</p>
<p>&#13;
</p>
<p>&#9;
</p>
<p>&#15;&#10;&#17;&#19;&#18;&#21;&#20;&#12;&#25;65
</p>
<p>7&#19;8:9
</p>
<p>and it is known that CF 3 REG = CF, one gets that neither &#3;fi&#4; nor &#3;ff&#26; can be REG.
</p>
<p>Theorem 2.12 Every language in
&#0;
</p>
<p>&#1;
</p>
<p>can be generated by a grammar having the following two
types of productions: ; (+*0&#8;&#10;&lt;ff&#22; ; (/*2&#8; , with ; &#22; &lt; 7&#19;= &#22; &#8; 74&gt; &#31;
</p>
<p>An CF grammar
 
</p>
<p>&#5;?!
</p>
<p>=
</p>
<p>&#22;
</p>
<p>&gt;
</p>
<p>&#22; &quot;#&#22; '%@
</p>
<p>is said to be self-embedding if there exists an $ 7.= such
that
</p>
<p>$&#7;&#5;+ACB
</p>
<p>;
</p>
<p>$&#16;&lt;
</p>
<p>, for some ;
&#22; &lt;
</p>
<p>7
</p>
<p>!
</p>
<p>=ED&#24;&gt;
</p>
<p>@ F-&#31;
</p>
<p>Theorem 2.13 If an CF grammar is reduced and not self-embedding, then &#3;1!  @ 7 &#0; &#1; &#31;
</p>
<p>Thus, self-embedding is the very characteristic feature of 8%9 languages which separates them
from smaller language classes. Since that feature (it is the case with relative sentences, for
instance) does appear in natural languages (being the source for its recursiveness leading to the
infinite set of sentences which a natural language is), it is obvious that a natural language cannot
be smaller than an 8%9 language. This discussion will continue later.
</p>
<p>An CF grammar is said to be in Greibach normal form (GNF) if each rule is of the form:
</p>
<p>$&#7;(/*2&#8;
</p>
<p>;
</p>
<p>&#22; $
</p>
<p>7&#19;=
</p>
<p>&#22; &#8;
</p>
<p>74&gt;
</p>
<p>&#22;
</p>
<p>;
</p>
<p>7G=
</p>
<p>B
</p>
<p>&#31;
</p>
<p>Theorem 2.14 For every H -free CF grammar, one can find an equivalent grammar in GNF.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>Given a finite alphabet &#0; , a regular expression is inductively defined as follows:
</p>
<p>(i) &#1; is a regular expression,
(ii) for every &#2;&#4;&#3; &#0; , &#2; is a regular expression,
</p>
<p>(iii) if &#5; is a regular expression, then so is &#5;&#7;&#6; ,
(iv) if &#8;&#10;&#9; &#5; are regular expressions, then so are &#8;&#7;&#5; and &#8;&#12;&#11;&#13;&#5;&#10;&#14;
</p>
<p>Every regular expression denotes an REG language. For example:
</p>
<p>&#1; denotes &#15;&#16;&#1;&#18;&#17; ,
</p>
<p>&#2; denotes &#15; &#2;&#19;&#17; ,
</p>
<p>&#2;&#7;&#11;&#13;&#20; denotes &#15; &#2;&#19;&#9; &#20; &#17; ,
</p>
<p>&#2;&#21;&#20; denotes &#15; &#2;&#22;&#20; &#17; ,
</p>
<p>&#2;&#21;&#6; denotes &#15; &#2;&#23;&#17; &#6; ,
&#24;
</p>
<p>&#2;&#7;&#11;&#13;&#20; &#25; &#6; denotes &#15; &#2;&#23;&#9; &#20; &#17; &#6; ,
&#24;
</p>
<p>&#2;&#7;&#11;&#13;&#20; &#25; &#2;&#22;&#6; denotes &#15; &#2;&#19;&#9; &#20; &#17; &#2;&#21;&#6;ff&#26;&#12;&#2;&#21;&#2;&#22;&#6;fi&#11;&#13;&#20; &#2;&#21;&#6;ff&#26;fl&#15; &#2;&#21;&#2;&#22;&#6; &#9; &#20; &#2;&#22;&#6; &#17;&#21;&#14;
</p>
<p>The following question now arises: is every REG language describable by means of a regular
expression? The answer is simply yes!
</p>
<p>Theorem 2.15 Every regular expression denotes a language in ffi &#31; and, conversely, every lan-
guage in ffi
</p>
<p>&#31;
</p>
<p>is denoted by a regular expression.
</p>
<p>A short list of valid equations for all regular expressions !ff&#9; &#8;&#10;&#9; &#5; includes:
</p>
<p>!&quot;&#11;
</p>
<p>&#24;
</p>
<p>&#8;&quot;&#11;&#13;&#5;#&#25;$&#26;
</p>
<p>&#24;
</p>
<p>!&quot;&#11;&#13;&#8;&#10;&#25;&#18;&#11;&#13;&#5; ,
</p>
<p>!
</p>
<p>&#24;
</p>
<p>&#8;#&#5;&#7;&#25;$&#26;
</p>
<p>&#24;
</p>
<p>!&#7;&#8;&#10;&#25; &#5; ,
</p>
<p>!&quot;&#11;%&#8;fl&#26;&#12;&#8;&quot;&#11;%! ,
</p>
<p>!
</p>
<p>&#24;
</p>
<p>&#8;&#12;&#11;&#13;&#5;#&#25;fi&#26;&#12;!#&#8;&quot;&#11;&#13;!#&#5; ,
</p>
<p>&#24;
</p>
<p>!&quot;&#11;&#13;&#8;&#10;&#25; &#5;&amp;&#26;&#12;!#&#5;'&#11;&#13;&#8;#&#5; ,
</p>
<p>!&#7;&#6;ff&#26;&amp;&#1;#&#11;&#13;!#!&#7;&#6; ,
</p>
<p>&#1;&#19;!fl&#26;&#12;!&#10;&#1;(&#26;&#12;! ,
</p>
<p>!&#7;&#6;ff&#26;
</p>
<p>&#24;
</p>
<p>&#1;#&#11;&#13;!&#10;&#25; &#6; &#14;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>The concept of a regular expression suggests the operation on languages called substitution.
</p>
<p>Given a finite alphabet &#0; , let &#0;&#2;&#1; denote an alphabet and &#3;&#5;&#4; &#6;&#8;&#7;&#10;&#9; &#0;&#12;&#11;&#1; a language for each &#6;&#14;&#13; &#0;&#16;&#15;
</p>
<p>For each string &#17;&#19;&#18;&#20;&#6;&#8;&#21; &#6;&#5;&#22;
&#15; &#15; &#15;
</p>
<p>&#6;&#24;&#23;&#25;&#13;
</p>
<p>&#0;&#26;&#11;
</p>
<p>, one defines the substitution:
</p>
<p>&#3;&#5;&#4; &#17;&#26;&#7;&#16;&#18;ff&#3;&#5;&#4; &#6;
</p>
<p>&#21;
</p>
<p>&#7; &#3;&#5;&#4; &#6;
</p>
<p>&#22;
</p>
<p>&#7;
</p>
<p>&#15; &#15; &#15;
</p>
<p>&#3;&#5;&#4; &#6;
</p>
<p>&#23;
</p>
<p>&#7;
</p>
<p>as the concatenation of the languages corresponding to the letters of &#17; &#15; This is extended to any
fi
</p>
<p>&#9;
</p>
<p>&#0;&#26;&#11; by:
</p>
<p>&#3;&#5;&#4;
</p>
<p>fi
</p>
<p>&#7;fl&#18;&#31;ffi  &#25;!&#5; &#25;&#13;&quot;&#3;&#5;&#4; &#17;&#26;&#7; # for some &#17;ff&#13;
fi&#10;$&#5;&#15;
</p>
<p>The family %&#10;&amp; is closed under substitution, i.e. the set of regular expressions is closed under
substitution of a regular expression for each of its letters. Substitution can be regarded as the
generalization of the notion of morphism.
</p>
<p>As for CF languages, for both families LIN and REG there are necessary conditions in the form
of pumping lemmata.
</p>
<p>Pumping lemma for linear languages:
</p>
<p>for every fi &#13; fifl'&#5;( , there exist )*# +&#12;&#13; ( such that for every ,&#25;&#13; fi # if - ,.-&#5;/0) then ,1&#18;
2
</p>
<p> 3&#17;&#10;4.5&#2;# where 2 #  &#8;# &#17;&#12;# 4*# 51&#13;76 &#11; #&#24;- 2  &#24;4.5*-&#24;8&#19;+&#5;#  &#5;409&#18;ff:.# and 2  &#24;; &#17;&lt;4&#8;; 5=&#13; fi , for every &gt;fl?&#20;@ &#15;
</p>
<p>Pumping lemma for regular languages:
</p>
<p>for every
fi
</p>
<p>&#13;BA&#26;C&#12;D , there exist )*# +&#12;&#13;
(
</p>
<p>such that for every
,&#25;&#13;
</p>
<p>fi
</p>
<p># if - ,.-3/&quot;) then ,&#12;&#18; 2  3&#17;&#26;# where 2 #  &#8;# &#17;ff&#13;76 &#11; #&#24;- 2  .-&#5;8&#19;+&#5;#  79&#18;ff:*# and 2  &#5;; &#17;&#31;&#13; fi , for
every &gt;&#16;?&#19;@
</p>
<p>&#15;
</p>
<p>2.5 Semilinear, Context-Sensitive and
Mildly Context-Sensitive Languages
</p>
<p>Whether or not natural languages are context-free sets of sentences was a much discussed issue
in the eighties. To enter the discussion&#8217;s core, cfr. the following papers: Gazdar (1981), Bres-
nan, Kaplan, Peters and Zaenen (1982), Pullum and Gazdar (1982), Culy (1985), and Shieber
(1985) (all of them were collected in Savitch, Bach, Marsh and Safran-Naveh 1987).
Today, there is a relative agreement that natural languages are not context-free. However, how
large they are continues to be a not so simple matter. There are two main noncompatible options.
A natural language:
</p>
<p>(i) either forms a class of sentences that includes the context-free family but is larger than it
(so still comfortably placed within the Chomsky hierarchy),</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>(ii) or occupies a position eccentric with respect to that hierarchy, in such a way that it does
not contain any whole family in the hierarchy but is spread along all of them.
</p>
<p>Following the first alternative gave origin to a new family of languages, which is of a clear
linguistic interest.
</p>
<p>A family of mildly context-sensitive languages (MCS) is a family &#0; such that:
</p>
<p>(i) each language in &#0; is semilinear,
(ii) for each language in &#0; , the membership problem (whether or not a string belongs to the
</p>
<p>language) is solvable in deterministic polynomial time,
(iii) &#0; contains the following three nonCF languages:
</p>
<p>&#1;&#3;&#2;&#3;&#4;&#6;&#5; &#7;&#9;&#8;&#11;&#10; &#8;&#11;&#12; &#8;&#14;&#13;&#9;&#15;&#17;&#16;&#19;&#18;&#21;&#20; : multiple agreements,
&#1;&#3;&#2;&#3;&#4;&#6;&#5; &#7;&#9;&#8;&#11;&#10; &#22;&#23;&#12; &#8;&#9;&#24;&#11;&#22;&#25;&#13;&#9;&#15;ff&#26; fifl&#16;&#25;&#18;ffi&#20; : crossed dependencies,
&#1;&#3;&#2;&#3;&#4;&#6;&#5; &#31; &#31;&#19;&#13;&#21;&#31;&quot;!#&#5; &#7;ffi&#26; &#10; &#20; $ &#20; : duplications.
</p>
<p>MCS is a linguistically-motivated family, as both it contains the above three languages, which
are more or less agreed to represent structures that exist in natural languages, and enjoys good
complexity conditions (i.e. fast processing), as stated by the deterministic polynomial time
requirement.
</p>
<p>In order to see what a semilinear language is, let us assume % &#4;&#6;&#5; &#7;'&amp; &#26; &#7;&#21;( &#26; ) ) ) &#26; &#7;&#9;*&#11;&#20;&#9;) Being + the
set of integers, the Parikh mapping of a string is:
</p>
<p>,
</p>
<p>&#13;
</p>
<p>%
</p>
<p>$.-0/
</p>
<p>+
</p>
<p>*
</p>
<p>,21
</p>
<p>&#31; 34&#4;
</p>
<p>1 5
</p>
<p>&#31;
</p>
<p>5 6 7
</p>
<p>&#26;
</p>
<p>5
</p>
<p>&#31;
</p>
<p>5 6 8
</p>
<p>&#26; ) ) ) &#26;
</p>
<p>5
</p>
<p>&#31;
</p>
<p>5 6 9
</p>
<p>3 &#26; &#31;&quot;!
</p>
<p>%
</p>
<p>$
</p>
<p>)
</p>
<p>Given a language, its Parikh set is:
</p>
<p>,21
</p>
<p>&#2;&#23;34&#4;&#6;&#5;
</p>
<p>,21
</p>
<p>&#31; 3&#23;&#13;&#9;&#31;&quot;!&#17;&#2;.&#20;&#9;)
</p>
<p>A linear set is a set :&lt;;&#19;+
*
</p>
<p>such that:
</p>
<p>:
</p>
<p>&#4;&#6;&#5; =&#11;&gt;ff?
</p>
<p>&#22;
</p>
<p>@ A
</p>
<p>B
</p>
<p>&amp;
</p>
<p>=
</p>
<p>A C'A
</p>
<p>&#13;
</p>
<p>C'A
</p>
<p>!
</p>
<p>+
</p>
<p>&#26; for some =&#11;&gt; &#26; =&#11;&amp; &#26; ) ) ) &#26; =
&#22;
</p>
<p>!
</p>
<p>+
</p>
<p>*
</p>
<p>&#20;&#9;)
</p>
<p>A semilinear set is a finite union of linear sets. A semilinear language is an &#2; such that
,21
</p>
<p>&#2;&#23;3
</p>
<p>is a semilinear set.
</p>
<p>A phrase-structure grammar is called length-increasing if, for every production &#31; -0/ =&#14;!ED ,
one has
</p>
<p>5
</p>
<p>&#31;
</p>
<p>5&#9;FG5
</p>
<p>=
</p>
<p>5
</p>
<p>) This is clear for every CS grammar. Moreover:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Theorem 2.16 Every length-increasing grammar generates an CS language.
</p>
<p>The length-increasing property is, therefore, equivalent to context-sensitivity with the sole ex-
ception of the rule
</p>
<p>&#0;&#2;&#1;&#4;&#3;&#6;&#5;
</p>
<p>, which is needed only to derive
&#5;&#8;&#7;
</p>
<p>A length-increasing grammar is said to be in Kuroda normal form (KNF) if each of its pro-
ductions is of any of the following forms:
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#1;&#8;&#3;&#12;&#11;
</p>
<p>,
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#1;&#8;&#3;&#12;&#13;
</p>
<p>,
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#1;&#8;&#3;&#12;&#13;&#15;&#14;
</p>
<p>,
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#13;&#16;&#1;&#4;&#3;&#17;&#14;&#19;&#18;
</p>
<p>,
</p>
<p>for &#10;&#19;&#20;
&#13;
</p>
<p>&#20;
</p>
<p>&#14;
</p>
<p>&#20;
</p>
<p>&#18;
</p>
<p>nonterminals and
&#11;
</p>
<p>terminal.
</p>
<p>Theorem 2.17 For every length-increasing grammar, one can find an equivalent grammar in
KNF.
</p>
<p>Corollary 2.18 Every &#5; -free CS language can be generated by a grammar in KNF.
</p>
<p>A
&#5;
</p>
<p>-free CS grammar is said to be in Penttonen or one-sided normal form (PNF) if each of
its productions is of any of the following forms:
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#1;&#8;&#3;&#12;&#11;
</p>
<p>,
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#1;&#8;&#3;&#12;&#13;
</p>
<p>,
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#1;&#8;&#3;&#12;&#13;&#15;&#14;
</p>
<p>,
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#13;&#16;&#1;&#4;&#3;
</p>
<p>&#10;
</p>
<p>&#14;
</p>
<p>,
</p>
<p>&#9;&#2;&#10;
</p>
<p>&#13;&#16;&#1;&#4;&#3;&#17;&#13;
</p>
<p>&#10;
</p>
<p>&#7;
</p>
<p>An example of an CS grammar generating a nonCF language is the following:
</p>
<p>Example 2.19 Let G = (N, T, S, P) be a grammar such that:
&#21;&#23;&#22;&#25;&#24;
</p>
<p>&#0;
</p>
<p>&#20; &#10;ff&#26; &#20; &#10;fffi &#20;
</p>
<p>&#13;
</p>
<p>&#26; &#20;
</p>
<p>&#13;
</p>
<p>fi &#20;
</p>
<p>&#14;
</p>
<p>&#26; &#20;
</p>
<p>&#14;
</p>
<p>fi fl
</p>
<p>,
</p>
<p>ffi&#31;&#22;&#25;&#24;
</p>
<p>&#11;
</p>
<p>&#20;  &#20; ! fl
</p>
<p>,
</p>
<p>&quot;&#25;&#22;&#25;&#24;
</p>
<p>&#0;#&#1;&#8;&#3;
</p>
<p>&#10;ff&#26;
</p>
<p>&#13;
</p>
<p>&#26;
</p>
<p>&#14;
</p>
<p>&#26; &#20; $%&#10;ff&#26;
</p>
<p>&#1;&#4;&#3;&#17;&#11;
</p>
<p>&#10;fffi
</p>
<p>&#13;
</p>
<p>fi &#20;
</p>
<p>&#13;
</p>
<p>fi
</p>
<p>&#13;
</p>
<p>&#26;
</p>
<p>&#1;&#4;&#3;&#17;&#13;
</p>
<p>fi
</p>
<p>&#13;
</p>
<p>fi &#20;
</p>
<p>&#13;
</p>
<p>fi
</p>
<p>&#14;
</p>
<p>&#26;
</p>
<p>&#1;&#4;&#3;&#17;&#13;
</p>
<p>fi
</p>
<p>&#14;
</p>
<p>fi ! &#20;
</p>
<p>$ &#10;&amp;fi
</p>
<p>&#1;&#8;&#3;'&#11;
</p>
<p>&#10;(&#26;
</p>
<p>&#13;
</p>
<p>&#26; &#20;
</p>
<p>&#13;
</p>
<p>&#26;
</p>
<p>&#13;
</p>
<p>fi
</p>
<p>&#1;&#4;&#3;'&#13;
</p>
<p>&#26;
</p>
<p>&#13;
</p>
<p>&#26; &#20;
</p>
<p>&#13;
</p>
<p>&#26;
</p>
<p>&#14;
</p>
<p>fi
</p>
<p>&#1;&#8;&#3;'&#13;
</p>
<p>&#26;
</p>
<p>&#14;
</p>
<p>&#26; ! &#20; &#10;(&#26;
</p>
<p>&#1;&#4;&#3;'&#11;
</p>
<p>&#20;
</p>
<p>&#13;
</p>
<p>&#26;
</p>
<p>&#1;&#4;&#3;
</p>
<p> &#20;
</p>
<p>&#14;
</p>
<p>&#26;
</p>
<p>&#1;&#4;&#3;
</p>
<p>! &#20; &#10;&amp;fi
</p>
<p>&#1;&#4;&#3;&#17;&#11;
</p>
<p>&#20;
</p>
<p>&#13;
</p>
<p>fi
</p>
<p>&#1;&#8;&#3;
</p>
<p> &#20;
</p>
<p>&#14;
</p>
<p>fi
</p>
<p>&#1;&#8;&#3;
</p>
<p>! fl
</p>
<p>&#7;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>The generated language is:
</p>
<p>&#0;&#2;&#1; &#3;&#5;&#4;&#7;&#6;&#9;&#8; &#10;&#12;&#11;&#14;&#13; &#11;&#14;&#15; &#11;&#17;&#16;&#12;&#18;&#20;&#19;&#9;&#21;&#14;&#22;&#24;&#23;
</p>
<p>&#25;&#20;&#26;fiffffifl
</p>
<p>As is easily seen, every application of the rules marked with &#31; sends a signal through the  &#8217;s to
&#26;ffi!
</p>
<p>or
&#26;ffi&quot;
</p>
<p>on their right, which may be killed on its way or reach the &#26; &#8217;s, where it deposits a &#15; fl
</p>
<p>3 Automata
</p>
<p>3.1 Finite Automata
</p>
<p>Grammars are generating devices which may simulate the productive (i.e. speaking) behaviour
of speakers/hearers. Automata are recognizing devices which may simulate the receptive (i.e.
hearing) behaviour of them. Each class of mechanisms serves to model one of the two aspects
of human linguistic capacity. As well, there are surprising, strong formal connections between
grammar theory and automata theory. Let us see.
</p>
<p>A finite automaton (FA) is a construct:
#
</p>
<p>&#6;$&#1; %&#17;&amp; 'ffi&amp; ()&amp; * + &amp;
</p>
<p>ff
</p>
<p>&#4; &amp;
</p>
<p>with:
</p>
<p>,
</p>
<p>%
</p>
<p>a finite nonempty set of states,
,
</p>
<p>'
</p>
<p>a finite alphabet of input letters,
,
</p>
<p>(
</p>
<p>a transition function:
%.-&#24;')/0%&#5;&amp;
</p>
<p>,
</p>
<p>* +
</p>
<p>&#25;
</p>
<p>%
</p>
<p>the initial state,
,
</p>
<p>ff$1
</p>
<p>%
</p>
<p>the set of final (accepting) states.
</p>
<p>#
</p>
<p>accepts or recognizes a string if it reads until the last letter of it and enters a final state.
</p>
<p>Example 3.1
#
</p>
<p>&#6;&#9;&#1; %&#17;&amp; 'ffi&amp; ()&amp; *
</p>
<p>+
</p>
<p>&amp;
</p>
<p>ff
</p>
<p>&#4;2&#16;
</p>
<p>%&#9;&#6;&#9;&#8; * + &amp; *
</p>
<p>!
</p>
<p>&amp; *
</p>
<p>&quot;
</p>
<p>&amp; * 3 &#22;
</p>
<p>,
</p>
<p>')&#6;&#9;&#8; &#10;4&amp; &#13; &#22;
</p>
<p>,
</p>
<p>ff
</p>
<p>&#6;&#9;&#8; * + &#22;
</p>
<p>,
</p>
<p>($&#1; *
</p>
<p>+
</p>
<p>&amp; &#10;5&#4;2&#6;)*
</p>
<p>&quot;
</p>
<p>,
</p>
<p>($&#1; *
</p>
<p>+
</p>
<p>&amp; &#13; &#4;2&#6;)*
</p>
<p>!
</p>
<p>,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>&#0;&#2;&#1; &#3; &#4; &#5; &#6;&#8;&#7;&#10;&#9;&#11;&#3; &#12;
</p>
<p>,
</p>
<p>&#0;&#2;&#1; &#3; &#4; &#5; &#13; &#7;&#10;&#9;&#11;&#3; &#14;
</p>
<p>,
</p>
<p>&#0;&#2;&#1; &#3; &#15; &#5; &#6;&#8;&#7;&#10;&#9;&#11;&#3; &#14;
</p>
<p>,
</p>
<p>&#0;&#2;&#1; &#3; &#15; &#5; &#13; &#7;&#10;&#9;&#11;&#3; &#12;
</p>
<p>,
</p>
<p>&#0;&#2;&#1; &#3; &#12; &#5; &#6;&#8;&#7;&#10;&#9;&#11;&#3; &#4;
</p>
<p>,
</p>
<p>&#0;&#2;&#1; &#3; &#12; &#5; &#13; &#7;&#10;&#9;&#11;&#3; &#15; &#16;
</p>
<p>The transition table and the transition graph for A are, respectively:
</p>
<p>M a b
&#3; &#14;&#17;&#3; &#15;&#17;&#3; &#4;
</p>
<p>&#3; &#4;&#18;&#3; &#12;&#17;&#3; &#14;
</p>
<p>&#3; &#15;&#17;&#3; &#14;&#17;&#3; &#12;
</p>
<p>&#3; &#12;&#17;&#3; &#4;&#18;&#3; &#15;
</p>
<p>&#19;&#21;&#20;
</p>
<p>&#22;&#21;&#23;
</p>
<p>&#19;&#10;&#20;
</p>
<p>&#22;&#10;&#23;
</p>
<p>&#19;&#10;&#20;
</p>
<p>&#22;&#10;&#23;
</p>
<p>&#24;&#26;&#25;
</p>
<p>ff&#26;fi
</p>
<p>&#19; &#20;
</p>
<p>&#22; &#23; fl
</p>
<p>fl
</p>
<p>fl
</p>
<p>fl&#31;ffi
</p>
<p>fl
</p>
<p>fl
</p>
<p>fl
</p>
<p>fl  
</p>
<p>!
</p>
<p>!
</p>
<p>!
</p>
<p>!&#31;&quot;
</p>
<p>!
</p>
<p>!
</p>
<p>!
</p>
<p>! #
</p>
<p>fl
</p>
<p>fl
</p>
<p>fl
</p>
<p>fl&#31;ffi
</p>
<p>fl
</p>
<p>fl
</p>
<p>fl  
</p>
<p>!
</p>
<p>!
</p>
<p>!
</p>
<p>! #
</p>
<p>!
</p>
<p>!
</p>
<p>!
</p>
<p>!&#31;&quot;
</p>
<p>a b
a b
b a
</p>
<p>b a
</p>
<p>&#3;
</p>
<p>&#15;
</p>
<p>&#3;
</p>
<p>&#14;
</p>
<p>&#3;
</p>
<p>&#12;
</p>
<p>&#3;
</p>
<p>&#4;
</p>
<p>One can check that $ &#1; %&amp;&#7;&#10;&#9;(' )+*,' &#6;-&#5; &#13; . /1032 )&#26;2 4 is even, 2 )&#26;2 5 is even .&#31;&#16;
</p>
<p>If &#0; is a one-valued function, the finite automaton is called deterministic (DFA). Otherwise, it
is called nondeterministic (NFA). In the first case, &#0; contains exactly one transition with the
same left-hand side. Notice that the definition of &#0; does not require &#0; to be a total function,
i.e.
&#0;
</p>
<p>may well be not defined for some combinations of a state and a letter.
</p>
<p>The symbols 6 and 6 / for transitions are, respectively, equivalent to the symbols &#9;37 and &#9;879/
</p>
<p>for derivations in grammars.
</p>
<p>The language accepted by a finite automaton is:
</p>
<p>$
</p>
<p>&#1; %:&#7;&#10;&#9;+' )+*&lt;;
</p>
<p>/
</p>
<p>0&#8;&#3; &#14; )
</p>
<p>6
</p>
<p>/8=
</p>
<p>&#5;
</p>
<p>=
</p>
<p>*?&gt;@.&#31;&#16;
</p>
<p>Take notice that A * $ &#1; %:&#7; if and only if &#3; &#14;CB&#17;&gt;ED&#9;&#11;FG&#16;
</p>
<p>Theorem 3.2 For every NFA, one can find an equivalent REG grammar.
</p>
<p>Theorem 3.3 For every REG grammar, one can find an equivalent NFA.
</p>
<p>Corollary 3.4 H &#12; coincides with the family of languages accepted by NFA&#8217;s.
</p>
<p>The following question arises now: is there some language in H &#12; that cannot be accepted by
any DFA? The answer is simply no! Consequently, one can always simulate the behaviour of
an NFA by means of an DFA (with more states).
</p>
<p>A number of important consequences for the languages in H &#12; follow from the concept of an FA,
among others:
</p>
<p>I
</p>
<p>H
</p>
<p>&#12; is a Boolean algebra,
I it is decidable whether two REG grammars are equivalent, etc.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>3.2 Pushdown Automata
</p>
<p>Let us introduce now a new element in the definition of an automaton: memory. Pushdown
automata result.
</p>
<p>input tape
</p>
<p>control
device
</p>
<p>pushdown store
</p>
<p>&#0;
</p>
<p>&#1;
</p>
<p>&#2;
</p>
<p>&#3;
</p>
<p>&#2;
</p>
<p>read
</p>
<p>read and write
</p>
<p>moving
direction
</p>
<p>storing direction
clearing directionFILO: first in, last out method
</p>
<p>A pushdown automaton (PDA) is a construct &#4;&#6;&#5;&#8;&#7; &#9;&#11;&#10; &#12;&#13;&#10; &#14;&#11;&#10; &#15;&#16;&#10; &#17; &#18; &#10; &#19; &#18; &#10; &#20;&#22;&#21; , with:
</p>
<p>&#23;
</p>
<p>&#9;
</p>
<p>a finite alphabet of pushdown letters,
&#23;
</p>
<p>&#12;
</p>
<p>a finite set of internal states,
&#23;
</p>
<p>&#14;
</p>
<p>a finite set of input letters,
&#23;
</p>
<p>&#15;
</p>
<p>the transition function:
</p>
<p>&#9;&#6;&#24;&#25;&#12;&#26;&#24;ff&#7; &#14;fffiffifl&#13;&#21; &#31;&quot;!$#&#11;% &amp; '(&#7; &#9;*)&#11;&#24;&#25;&#12;&#22;&#21; &#10;
</p>
<p>&#23;
</p>
<p>&#17; &#18;*+,&#9;
</p>
<p>the initial letter,
&#23;
</p>
<p>&#19; &#18;*+&#25;&#12;
</p>
<p>the initial state,
&#23;
</p>
<p>&#20;&#8;-&#16;&#12;
</p>
<p>a set of final or accepting states.
</p>
<p>A configuration of an PDA is a string
&#17;.&#19;
</p>
<p>, where
&#17;&#13;+,&#9;
</p>
<p>) is the current contents of the pushdown
store and
</p>
<p>&#19;/+&#25;&#12;
</p>
<p>is the present state of the control device.
</p>
<p>A nondeterministic pushdown automaton (NPDA) may reach a finite number of different
new configurations from one configuration in one move:
</p>
<p>&#15;&#8;&#7; &#17;0&#10; &#19;1&#10; 20&#21;3&#5;546&#7; 7*8 &#10; 9&quot;8 &#21; &#10; &#7; 7&#11;: &#10; 90: &#21; &#10; ; ; ; &#10; &#7; 7 &lt;*&#10; 96&lt;*&#21; =1&#10; 2&gt;+ffi&#14;
</p>
<p>,
</p>
<p>7
</p>
<p>&amp;
</p>
<p>+,&#9;
</p>
<p>)
</p>
<p>,
</p>
<p>9
</p>
<p>&amp;
</p>
<p>+&#25;&#12;&#13;&#10; ?A@CB3@CD&#25;;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>There may be
&#0;
</p>
<p>-moves too, which make it possible for the PDA to change its configuration
without reading any input.
</p>
<p>For a string to be accepted, the three following conditions must hold:
</p>
<p>(i) the control device read the whole string,
(ii) the PDA reached a final state,
</p>
<p>(iii) the pushdown store is empty.
</p>
<p>Note that only the existence of at least one sequence of moves leading to an accepting configu-
ration is required, while others may lead to nonaccepting ones.
</p>
<p>Example 3.5 To accept &#1;&#3;&#2;&#5;&#4; &#6;&#8;&#7;&#10;&#9; &#7;&#12;&#11;&#8;&#13;&#15;&#14;&#5;&#16;&#8;&#17; , the following PDA is adequate:
</p>
<p>&#18;
</p>
<p>&#2;&#20;&#19; &#4; &#21; &#22; &#23; &#6;&#24;&#17;&#8;&#23; &#4; &#25; &#22; &#23; &#25; &#26; &#23; &#25; ff &#17;&#8;&#23; &#4; &#6;fi&#23; &#9; &#17;&#8;&#23; flffi&#23; &#21; &#22; &#23; &#25; &#22; &#23; &#4; &#25; ff &#17;&#10;&#31; &#23;
</p>
<p>with:
</p>
<p>M a b  
( &#21; &#22; &#23; &#25; &#22; ) ( &#21; &#22; &#6;&#24;&#23; &#25; &#22; ) ! !
( &#6;&#24;&#23; &#25; &#22; ) ( &#6;&#8;&#6;&#24;&#23; &#25; &#22; ) ( &#0; &#23; &#25; &#26; ) !
</p>
<p>( &#21; &#22; &#23; &#25; &#26; ) ! ! ( &#0; &#23; &#25; ff )
( &#6;&#24;&#23; &#25; &#26; ) ! ( &#0; &#23; &#25; &#26; ) !
</p>
<p>( &#21; &#22; &#23; &#25; ff ) ! ! !
( &#6;&#24;&#23; &#25; ff ) ! ! !
</p>
<p>An PDA
&#18;
</p>
<p>&#2;&#20;&#19; &quot;#&#23; $&#12;&#23; %#&#23; flffi&#23; &#21; &#22; &#23; &#25; &#22; &#23; &amp;&#12;&#31; is said to be deterministic (DPDA) if and only if for every
&#19; &#21;'&#23; &#25;&#10;&#31;)(*&quot;,+&#15;$ :
</p>
<p>(i) either fl&#20;&#19; &#21;'&#23; &#25;'&#23; &#6;'&#31; contains exactly one element, for every &#6;-(.% , while fl&#20;&#19; &#21;'&#23; &#25;'&#23; &#0; &#31;/&#2;0! ,
(ii) or fl&#20;&#19; &#21;'&#23; &#25;'&#23; &#0; &#31; contains exactly one element, while fl&#20;&#19; &#21;'&#23; &#25;'&#23; &#6;'&#31;)&#2;ffi! , for every &#6;1(.%32
</p>
<p>Theorem 3.6 The family of languages accepted by DPDA&#8217;s is strictly contained in the family
of languages accepted by NPDA&#8217;s.
</p>
<p>To illustrate this, let us observe the following:
</p>
<p>Example 3.7
&#1;
</p>
<p>&#26;
</p>
<p>&#2;&#5;&#4; 465 467
</p>
<p>&#26;
</p>
<p>&#11;'4,(8&#4; &#6;fi&#23; &#9; &#17; 9 &#17;&#8;&#23;
</p>
<p>&#1;/ff3&#2;&#5;&#4; 4#4
</p>
<p>7
</p>
<p>&#26;
</p>
<p>&#11;&#8;4,(8&#4; &#6;&#24;&#23; &#9; &#17;
</p>
<p>9
</p>
<p>&#17;&#8;2
</p>
<p>While &#1;)&#26; belongs to both NPDA and DPDA, &#1;)ff belongs only to NPDA.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>The following results establish the relationship of &#0;&#2;&#1;&#4;&#3;&#6;&#5;&#8;&#7; &#9; to &#10;&#4;&#11; languages.
</p>
<p>Theorem 3.8 NPDA = CF.
</p>
<p>Theorem 3.9 For every CF grammar, an algorithm exists to transform it into an equivalent
NPDA.
</p>
<p>Theorem 3.10 For every PDA, an algorithm exists to transform it into an equivalent CF gram-
mar.
</p>
<p>Turing machines are the most powerful recognizing devices, and are able to recognize any
&#12;&#14;&#13; language. They are the foundation of computation theory and involve a lot of complexities
which cannot be addressed here.
</p>
<p>4 Regulated and Parallel Rewriting
</p>
<p>4.1 A Sample of Regulated Rewriting
</p>
<p>Next, a few important types of regulated grammars are presented, without being exhaustive at
all. In order to have a regulated (i.e. controlled) grammar, one more or less modifies/restricts
the notion of a grammar, and as a consequence one usually gets either a different (often greater)
generative capacity or a simpler method of generation.
</p>
<p>A matrix grammar is:
</p>
<p>&#15;&#4;&#16;&#18;&#17;&#18;&#19;
</p>
<p>&#0;&#21;&#20; &#22;&#8;&#20; &#23;&#24;&#20; &#25;ff&#26; &#20;
</p>
<p>where
&#25;
</p>
<p>is a finite set of finite nonempty sequences (matrices) of the form:
</p>
<p>fiffifl &#31; ! &quot;
</p>
<p>&#20;
</p>
<p>! #
</p>
<p>&#20; $ $ $ &#20;
</p>
<p>! %'&amp;
</p>
<p>&#20; (*),+
</p>
<p>,
</p>
<p>with:
</p>
<p>! -&#24;fl/.0-&#24;102435-
</p>
<p>,
.0-&#24;6
</p>
<p>&#19;
</p>
<p>&#0;87&#6;&#22;9&#26; : &#0;
</p>
<p>&#19;
</p>
<p>&#0;;7&#6;&#22;9&#26; :
</p>
<p>,
35-&#24;6
</p>
<p>&#19;
</p>
<p>&#0;87&#6;&#22;9&#26; : $
</p>
<p>A derivation in a matrix grammar is as follows:
</p>
<p>for every &lt;
&#20; =
</p>
<p>6
</p>
<p>&#19;
</p>
<p>&#0;;7&#6;&#22;&#14;&#26; : &#20;
</p>
<p>&lt;
</p>
<p>&#17;0&gt;@?5A
</p>
<p>=
</p>
<p>if and only if there exist &lt;CB &#20; &lt; &quot; &#20; $ $ $ &#20; &lt; % 6
&#19;
</p>
<p>&#0;87&#21;&#22;&#14;&#26; :
</p>
<p>and
there exist &#31; ! &quot;
</p>
<p>&#20;
</p>
<p>!
</p>
<p>#
</p>
<p>&#20; $ $ $ &#20;
</p>
<p>!
</p>
<p>%
</p>
<p>&amp;06
</p>
<p>&#25;D&#20;
</p>
<p>!
</p>
<p>-
</p>
<p>fl/.
</p>
<p>-
</p>
<p>10243
</p>
<p>-
</p>
<p>&#20; +9EGFHED(&#24;&#20;
</p>
<p>such that &lt; - I &quot;
&#17;
</p>
<p>&lt;
</p>
<p>&#7;
</p>
<p>- I5&quot;
</p>
<p>.
</p>
<p>-
</p>
<p>&lt;
</p>
<p>&#7; &#7;
</p>
<p>- I5&quot; and
&lt;
</p>
<p>-
</p>
<p>&#17;
</p>
<p>&lt;
</p>
<p>&#7;
</p>
<p>- I5&quot;
</p>
<p>3
</p>
<p>-
</p>
<p>&lt;
</p>
<p>&#7; &#7;
</p>
<p>- I &quot;
</p>
<p>&#20;
</p>
<p>for some &lt;
&#7;
</p>
<p>- I5&quot;
</p>
<p>&#20;
</p>
<p>&lt;
</p>
<p>&#7; &#7;
</p>
<p>- I5&quot;
</p>
<p>6
</p>
<p>&#19;
</p>
<p>&#0;87&#6;&#22;9&#26; : &#20; JKEDFLED(
</p>
<p>1
</p>
<p>+'$</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Example 4.1 The grammar
&#0;&#2;&#1;
</p>
<p>with the following matrices:
</p>
<p>&#3;&#5;&#4;&#7;&#6;&#9;&#8; &#10;&#12;&#11;&#9;&#13;&#15;&#14;&#17;&#16;&#19;&#18;&#21;&#20;
</p>
<p>,
</p>
<p>&#3;&#23;&#22;&#17;&#6;&#9;&#8; &#14;&#24;&#11;&#9;&#13;&#15;&#25;&#26;&#14;&#2;ff &#16;fi&#11;&#9;&#13;&#15;fl &#16;ffiff &#18;fi&#11;&#9;&#13;&#15;&#31; &#18;&#21;&#20;
</p>
<p>,
</p>
<p>&#3;&#23; &#17;&#6;&#9;&#8; &#14;&#24;&#11;&#9;&#13;&#15;&#25;!ff &#16;fi&#11;&quot;&#13;&#15;fl ff &#18;#&#11;&quot;&#13;&#15;&#31; &#20;
</p>
<p>,
</p>
<p>yield $&#17;%
&#0;
</p>
<p>&#1;&#19;&amp;('&#24;)
</p>
<p>&#25;&#26;*+fl *+&#31; *ffi&#6;&#26;,.-0/&#26;1&#26;2
</p>
<p>A programmed grammar is:
</p>
<p>&#0;&#2;3
</p>
<p>'
</p>
<p>% 4
</p>
<p>ff 5&#17;ff &#10;6ff 7
</p>
<p>&amp;
</p>
<p>ff
</p>
<p>where 7 is a finite set of triples ( 8 &#6;&#26;9&#12;&#11;&quot;&#13;&#15;:;ff &lt; % 8 &amp; ff = % 8 &amp; ), 8 is a label, 8 &#6;&gt;9&#12;&#11;&#9;&#13;&#15;:@? % 4BA 5 &amp; C
and &lt; % 8 &amp; , = % 8 &amp; are two sets of labels of rules.
</p>
<p>An immediate derivation in a programmed grammar is as follows:
</p>
<p>for every % D ff 8 &#4; &amp; ff % E ff 8 &#22; &amp; ? % 4FA 5 &amp;
C&#17;G
</p>
<p>$
</p>
<p>&#25;&#26;fl
</p>
<p>%
</p>
<p>7
</p>
<p>&amp;
</p>
<p>&#6;
</p>
<p>% D
</p>
<p>ff
</p>
<p>8
</p>
<p>&#4;
</p>
<p>&amp;;'&quot;HJI!K
</p>
<p>% E
</p>
<p>ff
</p>
<p>8
</p>
<p>&#22;
</p>
<p>&amp; if and only if &#6;
</p>
<p>(i) either D ' D &#4; 9 D &#22; and E ' D &#4; : D &#22; % D &#4; ff D &#22;&#7;? % 4fiA 5 &amp; C &amp; and % 8 &#4; &#6;&gt;9@&#11;&#9;&#13;&#15;:(ff &lt; % 8 &#4; &amp; ff = % 8 &#4; &amp; &amp; ?
7
</p>
<p>&amp;
</p>
<p>and 8 &#22; ?.&lt; % 8 &#4; &amp; ,
</p>
<p>(ii) or D ' E and 8 &#4; &#6;!9J&#11;&#9;&#13;L: (for ( 8 &#4; &#6;!9&#12;&#11;&quot;&#13;L:;ff &lt; % 8 &#4; &amp; ff = % 8 &#4; &amp; &amp; ?@7 &amp; cannot be applied to D
and 8 &#22;&#17;?M= % 8 &#4; &amp; 2
</p>
<p>The language generated by a programmed grammar is:
</p>
<p>$&#17;%
</p>
<p>&#0;
</p>
<p>3&quot;&amp;('&#24;)
</p>
<p>D
</p>
<p>&#6;
</p>
<p>D
</p>
<p>?N5
</p>
<p>C
</p>
<p>and there exist 8 &#4; ff 8 &#22;&#7;? $ &#25;&gt;fl % 7 &amp; such that % &#10;6ff 8 &#4; &amp;('&#9;H
C
</p>
<p>IOK
</p>
<p>% D
</p>
<p>ff
</p>
<p>8
</p>
<p>&#22;
</p>
<p>&amp;
</p>
<p>1&#26;2
</p>
<p>Example 4.2 The grammar
&#0;
</p>
<p>3
</p>
<p>with the following productions:
</p>
<p>% 8
</p>
<p>&#4;
</p>
<p>&#6;!&#10;&#12;&#11;&#9;&#13;&#15;&#14;&#17;&#14;&#2;ff
</p>
<p>)
</p>
<p>8
</p>
<p>&#4;
</p>
<p>1&#26;ff
</p>
<p>)
</p>
<p>8
</p>
<p>&#22; ff
</p>
<p>8
</p>
<p> 
</p>
<p>1
</p>
<p>&amp;
</p>
<p>,
</p>
<p>% 8
</p>
<p>&#22;
</p>
<p>&#6;&gt;&#14;0&#11;&quot;&#13;&#15;&#10;6ff
</p>
<p>)
</p>
<p>8
</p>
<p>&#22;
</p>
<p>1&#26;ff
</p>
<p>)
</p>
<p>8
</p>
<p>&#4; 1
</p>
<p>&amp;
</p>
<p>,
</p>
<p>% 8
</p>
<p> 
</p>
<p>&#6;&gt;&#14;0&#11;&quot;&#13;P&#25;Off
</p>
<p>)
</p>
<p>8
</p>
<p> 
</p>
<p>1&#26;ff Q
</p>
<p>&amp;
</p>
<p>,
</p>
<p>yield $&#17;%
&#0;&#2;3
</p>
<p>&amp;('&#24;)
</p>
<p>&#25;
</p>
<p>&#22; R
</p>
<p>&#6;&gt;,.-0/&#26;1&#26;2
</p>
<p>A random context grammar is:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0;&#2;&#1;&#4;&#3;&#6;&#5;&#8;&#7; &#9;&#11;&#10; &#12;&#13;&#10; &#14;&#15;&#10; &#16;&#18;&#17; &#10;
</p>
<p>where
&#16;
</p>
<p>is a finite set of rules of the form
&#7; &#19;&#21;&#20;&#23;&#22;&#25;&#24;&#26;&#10; ff&#18;&#10; fifl&#17;
</p>
<p>, with
&#19;&#21;&#20;ffi&#22;&#31;&#24;! &quot;&#7; &#9;&#8;#&#2;&#12;&#2;&#17; $
</p>
<p>,
</p>
<p>ff&amp;%'&#9;
</p>
<p>,
fi(%'&#9;*)
</p>
<p>An immediate derivation in a random context grammar is as follows:
</p>
<p>for every +
&#10; ,- &quot;&#7; &#9;.#-&#12;&#2;&#17; $&#13;/
</p>
<p>+
</p>
<p>&#5;&#23;021&#4;3 4-,
</p>
<p>if and only if +
&#5;
</p>
<p>+&#4;5
</p>
<p>&#19;
</p>
<p>+65 5 and
,7&#5;
</p>
<p>+&#4;5
</p>
<p>&#24;
</p>
<p>+65 5
</p>
<p>&#7;
</p>
<p>+65
</p>
<p>&#10;
</p>
<p>+&#4;5 5
</p>
<p> &quot;&#7; &#9;8#-&#12;9&#17; $ &#17;
</p>
<p>and
&#7; &#19;&#21;&#20;ffi&#22;&#31;&#24;:&#10; ff7&#10; fi&#2;&#17;; &#6;&#16;
</p>
<p>and for every &lt;
 &#6;ff=/
</p>
<p>&lt;
</p>
<p> 
</p>
<p>+&#4;5 +65 5 and
for every &gt;
</p>
<p> &#6;fi&amp;/
</p>
<p>&gt;!?
</p>
<p> 
</p>
<p>+65 +&#4;5 5
</p>
<p>)
</p>
<p>Example 4.3 The grammar
&#0;
</p>
<p>&#1;&#4;&#3;
</p>
<p>with the following productions:
&#7; &#14;&quot;&#20;ffi&#22;&#31;@A@fl&#10; B&#4;&#10; C D7&#10; E&#11;FG&#17;
</p>
<p>,
</p>
<p>&#7; @(&#20;&#23;&#22;&#25;D-&#10; B&#4;&#10; CG&#14;&#15;&#10; E&#11;FG&#17;
</p>
<p>,
</p>
<p>&#7; D=&#20;&#23;&#22;&#31;&#14;&#15;&#10; B&#4;&#10; C @fl&#10; E&#11;FG&#17;
</p>
<p>,
</p>
<p>&#7; @(&#20;&#23;&#22;&#25;E&#11;&#10; B&#4;&#10; CG&#14;&#15;&#10; D-FG&#17;
</p>
<p>,
</p>
<p>&#7; EH&#20;ffi&#22;&#31;I&#4;&#10; B&#4;&#10; CG&#14;&#15;&#10; @fl&#10; D7FG&#17;
</p>
<p>,
</p>
<p>yield J
&#7; &#0;
</p>
<p>&#1;K&#3;
</p>
<p>&#17;&#26;&#5;&#8;C IML Nfl/KO&#6;P(QMFM)
</p>
<p>A grammar with regular control is:
</p>
<p>&#0;fl&#1;KR61&#11;&#5;&amp;&#7; &#9;&#11;&#10; &#12;&#13;&#10; &#14;&#15;&#10; &#16;&#13;&#10; fifl&#17; &#10;
</p>
<p>where
fi
</p>
<p>is a regular language over
&#16;&#13;)
</p>
<p>The language generated by an
&#0;
</p>
<p>&#1;KR61
</p>
<p>consists of the strings resulting from a derivation:
</p>
<p>&#14;!&#5;&#23;0&#21;S T
</p>
<p>1&#4;3 UGV-WAX
</p>
<p>&#5;&#23;0&#21;S Y
</p>
<p>1&#4;3 UGV-W
</p>
<p>L
</p>
<p>&#5;&#23;021&#4;3 UGV&#11;) ) )K&#5;ffi0&#21;S
</p>
<p>N
</p>
<p>163 UGV7W;Z
</p>
<p>&#5;
</p>
<p>W
</p>
<p> &#11;&#12;
</p>
<p>$
</p>
<p>such that [ X [ L
) ) )
</p>
<p>[
</p>
<p>Z
</p>
<p> &#6;fi&#18;)
</p>
<p>Example 4.4 The grammar
&#0;
</p>
<p>&#1;&#4;R61
</p>
<p>consisting of:
&#9;\&#5;&#8;CG&#14;&#15;&#10; @&#2;&#10; D-F
</p>
<p>,
</p>
<p>&#12;'&#5;&#8;C I&#4;&#10; ] &#10; ^ F
</p>
<p>,
</p>
<p>&#16;&#8;&#5;&#8;C
</p>
<p>[
</p>
<p>X
</p>
<p>/K&#14;&quot;&#20;ffi&#22;&#31;@AD-&#10;
</p>
<p>[
</p>
<p>L
</p>
<p>/M@&#8;&#20;ffi&#22;&#31;IM@9] &#10;
</p>
<p>[6_
</p>
<p>/MD=&#20;&#23;&#22;&#31;Dfl&#770; &#10;
</p>
<p>[&#4;`
</p>
<p>/M@&#8;&#20;ffi&#22;&#31;IM] &#10;
</p>
<p>[&#4;a
</p>
<p>/MD.&#20;ffi&#22;&#31;^ F
</p>
<p>,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>&#0;&#2;&#1;&#4;&#3; &#5;&#7;&#6; &#8;&#9;&#3; &#5;&#11;&#10; &#5;&#11;&#12; &#8; &#13; &#3; &#5;&#15;&#14; &#5;&#11;&#16; &#8;
</p>
<p>,
</p>
<p>generates:
</p>
<p>&#17;&#19;&#18; &#20;&#22;&#21;&#24;&#23;&#11;&#25;ff&#26;fi&#1;&#2;&#3; fl&#9;ffi &#31; ffi&#9;! ffi#&quot;&#9;$&amp;%&#4;' &#8;&#9;(
</p>
<p>An additive valence grammar is:
</p>
<p>&#20;*)&#15;+&amp;&#1;,&#18; -/. 0&#19;. 1ff. 23. 4&#24;&#26; .
</p>
<p>where 45&quot;&#24;2,6&#7;798:&#18; 8 is the set of integers).
</p>
<p>The language generated by an &#20;&#22;)&#24;+ is:
</p>
<p>&#17;&#19;&#18; &#20;&#22;)&#24;+;&#26;fi&#1;&#4;&#3; &lt;=&quot;&#24;&lt;&#2;&gt;?0&#19;&#13;
</p>
<p>and 1@&#1;&#7;A@B C&#25;&#11;D E &lt; &#6; &#1;&#7;A@B F&#25;&#11;D E &lt; &#10; &#1;&#7;AG&#25;&#11;D E?( ( (&#24;&#1;HA@B I&#25;&#15;D E &lt; ffi &#1;=&lt; and
4&#11;&#18; &#5;
</p>
<p>&#6;
</p>
<p>&#26;HJK4&#7;&#18; &#5;
</p>
<p>&#10;
</p>
<p>&#26;HJL( ( ( JK4&#7;&#18; &#5;
</p>
<p>ffi
</p>
<p>&#26;;&#1;=M&#15;&#8;&#9;(
</p>
<p>Example 4.5 The grammar &#20;
)&#15;+
</p>
<p>consisting of:
-N&#1;&#4;&#3; 1ff. O*. PQ&#8;
</p>
<p>,
</p>
<p>0=&#1;&#4;&#3; fl&#15;. &#31; . ! &#8;
</p>
<p>,
</p>
<p>2&#4;&#1;&#4;&#3; &#5;&#11;&#6;3&quot;&#24;1K6&#7;79O&#19;PQ. &#5;&#15;&#10;&#19;&quot;&#9;O&#4;6&#7;79fl&#9;O&#22;. &#5;&#15;&#12;&#19;&quot;&#9;PR6&#7;79&#31; P#! . &#5;&#24;&#14;:&quot;&#9;O&#4;6&#7;79fl&#15;. &#5;&#11;&#16;3&quot;&#24;PS6H7T&#31; ! &#8;
</p>
<p>,
</p>
<p>4&#11;&#18; &#5;
</p>
<p>&#6;
</p>
<p>&#26;fi&#1;=4&#7;&#18; &#5;
</p>
<p>&#14;
</p>
<p>&#26;;&#1;=4&#7;&#18; &#5;
</p>
<p>&#16;
</p>
<p>&#26;fi&#1;LM
</p>
<p>,
</p>
<p>4&#11;&#18; &#5;
</p>
<p>&#10;
</p>
<p>&#26;fi&#1;&#4;'
</p>
<p>,
</p>
<p>4&#11;&#18; &#5;
</p>
<p>&#12;
</p>
<p>&#26;;&#1;&#4;6&#22;'
</p>
<p>,
</p>
<p>generates:
</p>
<p>&#17;&#19;&#18; &#20;
</p>
<p>)&#15;+
</p>
<p>&#26;fi&#1;&#4;&#3; fl
</p>
<p>ffi
</p>
<p>&#31;
</p>
<p>ffi
</p>
<p>!
</p>
<p>ffi
</p>
<p>&quot;&#24;$&amp;%&#2;'&#9;&#8;&#9;(
</p>
<p>Notice that the rules &#5;&#15;&#10; and &#5;&#15;&#12; must be applied the same number of times.
</p>
<p>A multiplicative valence grammar is:
</p>
<p>&#20;&#22;U:+&amp;&#1;,&#18; -?. 03. 1ff. 23. 4&#15;&#26; .
</p>
<p>where
45&quot;&#24;2,6&#7;79V*W ( V is the set of rational numbers).
</p>
<p>The language generated by an &#20;&#22;U:+ is:
</p>
<p>&#17;&#19;&#18; &#20;*U*+ff&#26;fi&#1;&#4;&#3; &lt;&#2;&quot;&#9;&lt;&#2;&gt;?0:&#13;
</p>
<p>and 1@&#1;&#7;A B C&#25;&#11;XffE &lt; &#6; &#1;HA B F&#25;&#15;X;E &lt; &#10; &#1;HAG&#25;&#15;X;E?( ( (&#24;&#1;HA B I&#25;&#15;X;E &lt; ffi &#1;L&lt; and
4&#11;&#18; &#5;
</p>
<p>&#6;
</p>
<p>&#26; 4&#7;&#18; &#5;
</p>
<p>&#10;
</p>
<p>&#26;&#11;( ( ( 4&#7;&#18; &#5;
</p>
<p>ffi
</p>
<p>&#26;fi&#1;&#2;'&#9;&#8;&#9;(</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>Example 4.6 As
&#0;&#2;&#1;&#4;&#3;
</p>
<p>, take
&#0;&#2;&#5;&#6;&#3;
</p>
<p>in the last example, with the following specific valence map-
ping:
</p>
<p>&#7;&#9;&#8; &#10;&#12;&#11; &#13;&#15;&#14;&#16;&#7;&#12;&#8; &#10;&#6;&#17; &#13;&#18;&#14;&#16;&#7;&#12;&#8; &#10;&#20;&#19; &#13;&#15;&#14;&#22;&#21;
</p>
<p>,
</p>
<p>&#7;&#9;&#8; &#10;&#9;&#23; &#13;&#15;&#14;&#22;&#24;
</p>
<p>,
</p>
<p>&#7;&#9;&#8; &#10;&#9;&#25; &#13;&#15;&#14;&#26;&#21;fifffi&#24;&#6;fl
</p>
<p>It generates:
</p>
<p>ffi
</p>
<p>&#8;
</p>
<p>&#0;
</p>
<p>&#1;&#4;&#3;
</p>
<p>&#13;&#15;&#14;&#22;&#31;  &quot;!fi# !&quot;$ !&amp;%&quot;')(&#26;&#21;fi*&quot;fl
</p>
<p>An ordered grammar is:
</p>
<p>&#0;&#2;+
</p>
<p>&#14;&#26;&#8; ,.- /0- 12- 30- 4&#4;&#13;
</p>
<p>,
</p>
<p>where 4 is a strict partial order (i.e. irreflexive, asymmetric and transitive) over 30fl
</p>
<p>An immediate derivation in an ordered grammar 5 &#14;7698&#20;:&lt;; holds if and only if:
</p>
<p>(i) there exist 5 &#11; - 5 &#23;0= &#8; ,?&gt;&lt;/&#4;&#13; @ such that 5 &#14; 5 &#11; A 5 &#23; and ;&amp;&#14; 5 &#11; B 5 &#23; ,
(ii) A&#22;C7DEB = 3 and there does not exist any substring AGF of 5 such that there exists BfiF such
</p>
<p>that A F C&#12;DEB F = 3 and A F C7DHB F&#12;I A&#22;C7DHB&#20;fl
</p>
<p>Thus, the production that is utilized at each step is maximal in the ordered set of rules.
</p>
<p>Example 4.7 The ordered grammar:
</p>
<p>&#0;
</p>
<p>+
</p>
<p>&#14;J&#8; &#31;fi12- K&#2;- LM- K
</p>
<p>F
</p>
<p>- L
</p>
<p>F
</p>
<p>- K
</p>
<p>F F
</p>
<p>- N&#26;*&quot;- &#31;  &#20;- # - $ *&quot;- 12- 30- 4&#4;&#13; -
</p>
<p>where 3&#26;&#14;J&#31;&#6;&#8; &#21; &#13; KGF F&#12;C7DON9- &#8; &#24;&quot;&#13; LPC&#12;DO# $ - &#8; Q&#6;&#13; K0F&#12;C7DON9- &#8; R&#6;&#13; LSF&#12;C7DEL&lt;- &#8; Tfi&#13; K&#26;C&#12;DUN9- &#8; V&#6;&#13; LPC&#12;D
# LSF $ - &#8; Wfi&#13; L&#2;FXC&#12;DYN9- &#8; Z&#6;&#13; K?C7D[K0F F - &#8; \&quot;&#13; K]C&#12;D[ &quot;KGF - &#8; &#21; ^&#6;&#13; L_C&#12;DYN&#16;- &#8; &#21;fi&#21;fi&#13; K0F FXC&#12;D[ &#9;- &#8; &#21; &#24;&quot;&#13; K0FXC&#12;D
</p>
<p>KS- &#8; &#21; Q&#6;&#13; 1`C&#12;DEKGL&lt;* and the order relation is satisfied by the following pairs:
</p>
<p>&#8; &#24;fi&#13;X4&#26;&#8; Q&quot;&#13;
</p>
<p>,
&#8; &#24;&quot;&#13;&#15;4&#26;&#8; T&quot;&#13;
</p>
<p>,
&#8; R&#6;&#13;&#15;4&#26;&#8; Q&#6;&#13;
</p>
<p>,
&#8; V&#6;&#13;X4&#22;&#8; &#21;fi&#13; -&#20;&#8; V&quot;&#13;X4&#26;&#8; Tfi&#13;
</p>
<p>,
&#8; Z&quot;&#13;X4&#26;&#8; Wfi&#13;
</p>
<p>,
&#8; \&#6;&#13;&#15;4&#26;&#8; W&quot;&#13;
</p>
<p>,
&#8; &#21;&quot;&#21; &#13;X4&#26;&#8; &#21; ^&#6;&#13; -
</p>
<p>&#8; &#21; &#24;&quot;&#13;&#15;4&#26;&#8; &#21; ^&#6;&#13; -
</p>
<p>generates:
</p>
<p>ffi
</p>
<p>&#8;
</p>
<p>&#0;
</p>
<p>+
</p>
<p>&#13;&#15;&#14;&#22;&#31;  &quot;!fi# !fi$ !M%&quot;')(&#26;&#21;fi*&quot;fl</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Generally speaking, there exist two main types of grammar derivations:
</p>
<p>&#0; sequential: as is the case with grammars in the Chomsky hierarchy as well as all other
ones presented in this chapter so far;
</p>
<p>&#0; parallel: which appear in several mechanisms, particularly in:
</p>
<p>(i) Indian parallel grammars: at each step of the derivation, every occurrence of one
letter is rewritten (by using the same production),
</p>
<p>(ii) Lindenmayer systems: at each step of the derivation, all occurrences of all letters
are rewritten (using different productions for different occurrences of one letter is
allowed: see below for details).
</p>
<p>An Indian parallel grammar is a construct:
&#1;&#3;&#2; &#4;&#6;&#5;&#8;&#7; &#9;&#11;&#10; &#12;&#13;&#10; &#14;&#15;&#10; &#16;&#3;&#17; &#18;
</p>
<p>The immediate derivation runs as follows:
</p>
<p>for every &#19;&#6;&#20;
&#7; &#9;&#22;&#21;&#23;&#12;&#24;&#17; &#25;
</p>
<p>, for every &#26;&#23;&#20;
&#7; &#9;ff&#21;&#23;&#12;fi&#17; fl&#31;ffi
</p>
<p>&#19;
</p>
<p>&#5;! #&quot;%$ &amp;
</p>
<p>&#26; if and only if:
</p>
<p>(i) &#19; &#5; &#19;!' (&#31;&#19;*) ( &#18; &#18; &#18; &#19;,+-(&#13;&#19;%+ &#25; ' , (.&#20; &#9; , &#19;%/&#15;&#20; &#7; &#7; &#9;&#22;&#21;&#23;&#12;&#24;&#17;&#15;021 (&#3;3 &#17; fl , 4fi5768579;:24 ,
(ii) &#26; &#5; &#19;!' &lt;&#31;&#19;*) &lt; &#18; &#18; &#18; &#19;,+-&lt;&#13;&#19;%+ &#25; ' ,
</p>
<p>(iii) ( 0!= &lt;&gt;&#20; &#16;&#31;&#18;
</p>
<p>Example 4.8 The Indian parallel grammar:
</p>
<p>&#1;&#3;&#2; &#4;&#6;&#5;&#8;&#7; 1-&#14;
</p>
<p>3
</p>
<p>&#10; 1 ?
</p>
<p>3
</p>
<p>&#10; &#14;&#15;&#10; 1-&#14;@0!=A&#14;B&#14;&#15;&#10; &#14;C0*=A?
</p>
<p>3
</p>
<p>&#17;
</p>
<p>yields D
&#7; &#1;fi&#2; &#4;&#15;&#17;8&#5;.1 ?
</p>
<p>) E
</p>
<p>ffi
</p>
<p>9GF2H%3
</p>
<p>&#18;
</p>
<p>A Russian parallel grammar is a construct:
&#1;fiI%&#4;&#6;&#5;&#8;&#7; &#9;&#11;&#10; &#12;&#13;&#10; &#14;&#15;&#10; &#16;&#3;&#17;
</p>
<p>,
</p>
<p>where
&#16;.&#5;7&#16;
</p>
<p>'
</p>
<p>&#21;&#11;&#16;
</p>
<p>) ,
</p>
<p>&#16;
</p>
<p>'&#15;J
</p>
<p>&#16;
</p>
<p>)
</p>
<p>&#5;7K%&#18;
</p>
<p>An immediate derivation in a Russian parallel grammar is:
</p>
<p>&#19;
</p>
<p>&#5;* #&quot;,L &amp;
</p>
<p>&#26; if and only if:
</p>
<p>(i) either &#19; &#5; &#19;!' (&#31;&#19;*) and &#26; &#5; &#19;*' &lt;&#13;&#19;,) &#7; &#19;!' &#10; &#19;,)&#13;&#20; &#7; &#9;ff&#21;&#23;&#12;fi&#17; fl &#17; and ( 0*= &lt;&gt;&#20; &#16; ' ,
(ii) or &#19; &#5; &#19;*' (&#13;&#19;,) ( &#18; &#18; &#18; &#19;%+M(&#31;&#19;,+ &#25; ' and &#26; &#5; &#19;*' &lt;&#13;&#19;,) &lt; &#18; &#18; &#18; &#19;%+M&lt;&#31;&#19;,+ &#25; ' ( &#19;%/fi&#20; &#7; &#7; &#9;N&#21;G&#12;fi&#17;B0&gt;1 (&#3;3 &#17; fl ,
</p>
<p>4fi5768579;:24
</p>
<p>&#17;
</p>
<p>and (
0*=
</p>
<p>&lt;&gt;&#20;
</p>
<p>&#16;
</p>
<p>)
</p>
<p>&#18;
</p>
<p>If
&#16;
</p>
<p>'
</p>
<p>&#5;2K
</p>
<p>, one gets an
&#1;
</p>
<p>&#2; &#4;
</p>
<p>&#18;
</p>
<p>If
&#16;
</p>
<p>)
</p>
<p>&#5;7K
</p>
<p>, one gets an CF.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>4.2 Lindenmayer Systems
</p>
<p>The motivation behind Lindenmayer systems ( &#0; systems for short) is biological. They are
intended to model the (parallel) growth of living beings.
An interactionless Lindenmayer system ( &#1; &#0; ) is a context-free pure (without a nonterminal
alphabet) grammar with parallel derivations:
</p>
<p>&#2;&#4;&#3;&#4;&#5; &#6;&#8;&#7; &#9;&#10;&#7; &#11;&#13;&#12; &#7;
</p>
<p>where
&#6;
</p>
<p>is an alphabet,
&#9;&#15;&#14;&#16;&#6;&#18;&#17;
</p>
<p>is an axiom and
&#11;
</p>
<p>is a finite set of rules of the form &#19;&#21;&#20;&#23;&#22; ,
with &#19;
</p>
<p>&#14;&#24;&#6;
</p>
<p>and &#22;
&#14;&#24;&#6;
</p>
<p>&#17;
</p>
<p>such that for each &#19;
&#14;&#24;&#6;
</p>
<p>there is at least one rule &#19;&#25;&#20;&#26;&#22; in
&#11; ( &#11; is said
</p>
<p>to be complete).
</p>
<p>Given
&#9;fiff &#7; &#9;ffiflffi&#14;&#24;&#6;&#18;&#17;
</p>
<p>, one writes
&#9;fiff&#31;&#3;! &quot;&#9;ffifl
</p>
<p>if and only if
&#9;fiff#&#3;
</p>
<p>&#19;
</p>
<p>ff
</p>
<p>&#19;
</p>
<p>fl%$ $ $
</p>
<p>&#19;'&amp; and
&#9;ffifl#&#3;
</p>
<p>&#22;
</p>
<p>ff
</p>
<p>&#22;
</p>
<p>fl!$ $ $
</p>
<p>&#22; &amp; ,
</p>
<p>for &#19;)(!&#20;&quot;&#22; (
&#14;&#21;&#11;ffi&#7; *&#10;+-,&#8;+-.%$
</p>
<p>The generated language is:
</p>
<p>&#0;
</p>
<p>&#5; &#2;&#18;&#12;&#31;&#3;0/ 1&#21;&#14;&#24;&#6;&#10;&#17;ffi23&#9;-&#3;4 &#16;&#17;&#31;1!5'$
</p>
<p>There are several important variants of &#0; systems:
</p>
<p>6 if for each rule &#19;&#13;&#20;&quot;&#22;
&#14;&#21;&#11;
</p>
<p>one has &#22;87
&#3;:9
</p>
<p>, then
&#2;
</p>
<p>is propagating (nonerasing);
6 if for each &#19;
</p>
<p>&#14;&#24;&#6;
</p>
<p>there is only one rule &#19;&#13;&#20;&quot;&#22;
&#14;&#21;&#11;
</p>
<p>, then
&#2;
</p>
<p>is deterministic;
6 if a subset ; of
</p>
<p>&#6;
</p>
<p>is distinguished and &#0;
&#5; &#2;&#18;&#12;
</p>
<p>is defined as the set
/ 1&lt;&#14;
</p>
<p>;
</p>
<p>&#17;&#10;2=&#9;0&#3;! &#16;&#17;ffi1!5
</p>
<p>,
</p>
<p>then
&#2;
</p>
<p>is extended.
</p>
<p>Regarding the generative power of &#0; systems, many results are known, among others the fol-
lowing ones:
</p>
<p>6 The family of deterministic &#1; &#0; languages is incomparable with &gt;&#10;?3@
&#7; A&#10;B&#18;&#2;&#13;&#7;
</p>
<p>&#0;
</p>
<p>?3@
</p>
<p>&#7; C
</p>
<p>&gt;
</p>
<p>( &gt;&#18;?'@ is the family of finite languages).
6
</p>
<p>C
</p>
<p>&gt; is a strict subset of the family of extended &#1; &#0; languages.
6 All &#0; languages are contained in
</p>
<p>C&#13;D
</p>
<p>.
</p>
<p>A remarkable feature of a deterministic &#1; &#0; system
&#2;
</p>
<p>is that it generates its language in a se-
quence
</p>
<p>&#0;
</p>
<p>&#5; &#2;&#18;&#12;&#31;&#3;-&#9;-&#3;-&#9;ffiE &#7; &#9;
</p>
<p>ff
</p>
<p>&#7; &#9;
</p>
<p>fl
</p>
<p>&#7; $ $ $
</p>
<p>such that
&#9;ffiEffi&#3;4 &quot;&#9;
</p>
<p>ff
</p>
<p>&#3;4 &quot;&#9;
</p>
<p>fl
</p>
<p>&#3;4 F$ $ $
</p>
<p>Thus, one can define
the growth function of
</p>
<p>&#2;
</p>
<p>, denoted G=H I
&#9;ffiJ K=L&#21;2'M:N
</p>
<p>&#20; , by:
</p>
<p>G=H I
</p>
<p>&#9;ffiJ K
</p>
<p>L
</p>
<p>&#5; .!&#12;&#8;&#3;PO &#9;
</p>
<p>&amp;
</p>
<p>O &#7; .&#21;Q
</p>
<p>&#1;
</p>
<p>$</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>5 Nonstandard Generative Mechanisms
</p>
<p>5.1 Contextual Grammars
</p>
<p>A contextual grammar is a construct:
</p>
<p>&#0;&#2;&#1;&#2;&#3; &#4;&#6;&#5; &#7;&#8;&#5; &#3; &#9;&#11;&#10; &#5; &#12;&#13;&#10; &#14; &#5; &#3; &#9;&#16;&#15; &#5; &#12;&#17;&#15; &#14; &#5; &#18; &#18; &#18; &#5; &#3; &#9;&#20;&#19;&#21;&#5; &#12;&#22;&#19;&#23;&#14; &#14; &#5;
</p>
<p>consisting of:
</p>
<p>&#24;
</p>
<p>&#4;
</p>
<p>an alphabet,
&#24;
</p>
<p>&#7;&#26;&#25;ff&#4;flfi
</p>
<p>a finite set: the base or the set of axioms,
&#24;
</p>
<p>&#9;&#20;ffi&#31;&#25; &#4;!fi
</p>
<p>selectors,
</p>
<p>&#24;
</p>
<p>&#12;
</p>
<p>ffi
</p>
<p>&#25; &#4;!fi&#17;&quot;#&#4;!fi
</p>
<p>contexts,
</p>
<p>&#24;
</p>
<p>&#3; &#9;&#20;ffi &#5; &#12;&#22;ffi &#14;
</p>
<p>productions, $!%'&amp;(%')
&#18;
</p>
<p>In a contextual grammar, one considers two main types of immediate derivation:
</p>
<p>&#24; external derivation:
for every *
</p>
<p>&#5; +-,#&#4;flfi&#17;.
</p>
<p>*
</p>
<p>&#1;&#11;/10 23+
</p>
<p>if and only if
+&#8;&#1;'4
</p>
<p>*&#16;5
</p>
<p>&#5;
</p>
<p>*
</p>
<p>,#&#9;&#20;ffi &#5; &#3; 4&#11;&#5; 67&#14;(,8&#12;&#22;ffi &#5;
</p>
<p>$fl% &amp;&#6;% )
</p>
<p>&#18;
</p>
<p>&#24; internal derivation:
</p>
<p>for every *
&#5; +-,#&#4;flfi&#13;.
</p>
<p>*
</p>
<p>&#1;&#16;/
</p>
<p>ffi
</p>
<p>&#19;fl+
</p>
<p>if and only if *
&#1;
</p>
<p>*
</p>
<p>&#10;
</p>
<p>*
</p>
<p>&#15;
</p>
<p>*&#20;9 and
+:&#1;
</p>
<p>*
</p>
<p>&#10;
</p>
<p>4
</p>
<p>*
</p>
<p>&#15;
</p>
<p>6
</p>
<p>*
</p>
<p>9
</p>
<p>&#5;
</p>
<p>*
</p>
<p>&#15;
</p>
<p>,#&#9;&#20;ffi &#5; &#3; 4&#11;&#5; 67&#14;(,8&#12;&#22;ffi &#5;
</p>
<p>$!%'&amp;(%')
</p>
<p>&#18;
</p>
<p>The language generated by an internal contextual grammar is:
</p>
<p>;
</p>
<p>ffi
</p>
<p>&#19;
</p>
<p>&#3; &#0;!&#14;(&#1;=&lt; &gt;&#8;,#&#4;
</p>
<p>fi
</p>
<p>such that there exists5
,8&#7;
</p>
<p>such that 5
&#1;&#16;/
</p>
<p>fi
</p>
<p>ffi
</p>
<p>&#19;
</p>
<p>&gt;&#21;?&#23;&#18;
</p>
<p>Another way of defining ;
ffi
</p>
<p>&#19;&#20;&#3; &#0;:&#14;
</p>
<p>is to say that it is the smallest language ; such that:
</p>
<p>(i) &#7;&#26;&#25; ; ,
</p>
<p>(ii) for every * , ; . if * &#1; * &#10; * &#15; *
9
</p>
<p>and * &#15;
,#&#9;&#20;ffi
</p>
<p>, for some &amp; , $!%'&amp;(% ) , then *
&#10;
</p>
<p>4
</p>
<p>*
</p>
<p>&#15;
</p>
<p>6
</p>
<p>*
</p>
<p>9
</p>
<p>,
</p>
<p>;
</p>
<p>,
</p>
<p>for every
&#3; 4&#11;&#5; 67&#14;(,8&#12;&#22;ffi &#18;
</p>
<p>If one introduces several different restrictions, the following natural variants of derivation arise:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0; minimal local derivation:
</p>
<p>for every &#1;&#3;&#2; &#4;&#6;&#5;&#8;&#7;&#10;&#9;&#12;&#11;&#13;&#1;&#15;&#14;&#3;&#16;&#18;&#17;&#20;&#19;&#21;&#4; if and only if &#11;
</p>
<p>(i) &#1;&#22;&#14;&#23;&#1;&#25;&#24; &#1;&#25;&#26; &#1;&#25;ff ,
(ii) &#4;fi&#14;fl&#1;&#3;&#24; ffi&#21;&#1;&#31;&#26;  &#13;&#1;&#31;ff&#12;! &#1;&#25;&#26;&quot;&#5;&#8;#&#31;$ &#2; ! ffi&#3;&#2;  &amp;%'&#5;)(*$ &#2; +&#10;,.-&#20;,./&#3;% , and
</p>
<p>(iii) there do not exist &#1;&#31;0
&#24;
</p>
<p>&#2; &#1;&#21;0
</p>
<p>&#26;
</p>
<p>&#2; &#1;&#21;0
</p>
<p>ff
</p>
<p>&#5;&#8;&#7;
</p>
<p>&#9;
</p>
<p>such that &#1;&#15;&#14;&#23;&#1;&#21;0
&#24;
</p>
<p>&#1;&#31;0
</p>
<p>&#26;
</p>
<p>&#1;&#21;0
</p>
<p>ff
</p>
<p>and &#1;&#21;0
&#26;
</p>
<p>&#5;&#8;#&#31;$ and 1 &#1;&#31;0
&#24;
</p>
<p>1&amp;231 &#1;&#25;&#24; 1
</p>
<p>and 1 &#1;&#21;0
ff
</p>
<p>1&amp;241 &#1;&#25;ff 1 and 1 &#1;&#31;0
&#26;
</p>
<p>1&amp;541 &#1;&#31;&#26;61 7
</p>
<p>A context is adjoined to a selector provided this is minimal (i.e. the shortest one) in such
a position.
</p>
<p>&#0; maximal local derivation:
</p>
<p>for every&#1;8&#2; &#4;fi&#5;&#8;&#7;9&#9;&#12;&#11;&#13;&#1;&#15;&#14;&#3;&#16;fl:;&#19;&#21;&#4; if and only if &#11;
</p>
<p>(i) &#1;&#22;&#14;&#23;&#1;&#25;&#24; &#1;&#25;&#26; &#1;&#25;ff ,
(ii) &#4;fi&#14;fl&#1;&#3;&#24; ffi&#21;&#1;&#31;&#26;  &#13;&#1;&#31;ff&#12;! &#1;&#25;&#26;&quot;&#5;&#8;#&#31;$ &#2; ! ffi&#3;&#2;  &amp;%'&#5;)(*$ &#2; +&#10;,.-&#20;,./&#3;% , and
</p>
<p>(iii) there do not exist &#1;&#31;0
&#24;
</p>
<p>&#2; &#1;&#21;0
</p>
<p>&#26;
</p>
<p>&#2; &#1;&#21;0
</p>
<p>ff
</p>
<p>&#5;&#8;&#7;
</p>
<p>&#9;
</p>
<p>such that &#1;&#15;&#14;&#23;&#1;&#21;0
&#24;
</p>
<p>&#1;&#31;0
</p>
<p>&#26;
</p>
<p>&#1;&#21;0
</p>
<p>ff
</p>
<p>and &#1;&#21;0
&#26;
</p>
<p>&#5;&#8;#&#31;$ and 1 &#1;&#31;0
&#24;
</p>
<p>1&amp;,31 &#1;&#25;&#24; 1
</p>
<p>and 1 &#1;&#21;0
ff
</p>
<p>1&amp;,41 &#1;
</p>
<p>ff
</p>
<p>1 and 1 &#1;&#31;0
&#26;
</p>
<p>1&amp;&lt;41 &#1;
</p>
<p>&#26;
</p>
<p>1 7
</p>
<p>A context is adjoined to a selector provided this is maximal (i.e. the longest one) in such
a position.
</p>
<p>&#0; minimal global derivation ( &#14;&#3;&#16;
&#17;8=
</p>
<p>): In the definition of &#14;&#25;&#16;
&#17;&#20;&#19;
</p>
<p>, one replaces &#1;&#21;0
&#26;
</p>
<p>&#5;4#&#31;$
</p>
<p>with &#1;&#31;0
&#26;
</p>
<p>&#5;&#8;#&#21;&gt; , for every ?fi&#11;&#21;+&#10;,fl?fi,&#23;/87 Note that the chosen selector has to be the shortest
one among all the selectors.
</p>
<p>&#0; maximal global derivation ( &#14;&#25;&#16;
:&quot;=
</p>
<p>): In the definition of &#14;&#3;&#16;
:;&#19;
</p>
<p>, the same substitution
as above is introduced. Note that the chosen selector has to be the longest one among all
the selectors.
</p>
<p>Given @A&#5;AB C&#15;D &#2; C&#6;E&#31;&#2; F.D &#2; F&#23;E&#31;G , the language generated by the contextual grammar is:
</p>
<p>H'I
</p>
<p>! J9%'&#14;KB LM&#5;&#8;&#7;
</p>
<p>&#9;
</p>
<p>such that there exist NO&#5;)P such that N.&#14;&#3;&#16;
&#9;
</p>
<p>I
</p>
<p>L&amp;G&#13;7
</p>
<p>If all the languages in #&#31;$ belong to the same family Q of languages in the Chomsky hierarchy,
J is said to be a contextual grammar with selection of type Q .
</p>
<p>Example 5.1 The contextual grammar:
</p>
<p>JK&#14;4! B R&#31;&#2; S G&#13;&#2; B R&amp;S R&amp;S G&#13;&#2; ! R&amp;S T&#3;R&#31;&#2; B&amp;! R&#21;&#2; R&#21;% G6% &#2; ! S R&amp;T&#25;S &#2; B&amp;! S &#2; S % G6% %
</p>
<p>generates:
</p>
<p>H
</p>
<p>$ U&#21;! JM%'&#14;
</p>
<p>H
</p>
<p>&#17;8=
</p>
<p>! J9%'&#14;KB R
</p>
<p>U
</p>
<p>S
</p>
<p>&#17;
</p>
<p>R
</p>
<p>U
</p>
<p>S
</p>
<p>&#17;
</p>
<p>&#11;&#13;/8&#2; CV2O+&#13;G&#13;7</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Example 5.2 The language:
</p>
<p>&#0;&#2;&#1;&#4;&#3; &#5;&#7;&#6;&#9;&#8; &#10; &#6;&#7;&#5;&#9;&#11;&#12;&#8; &#10; &#11;&#14;&#13;&#16;&#15;&#18;&#17; &#19;&#21;&#20;&#23;&#22;&#9;&#24;
</p>
<p>is generated by:
</p>
<p>&#25;ff&#26;
</p>
<p>&#6;
</p>
<p>&#1;&#23;fi &#3; &#5;fl&#17; &#10; &#17; &#8; &#24;&#7;&#17; &#3; &#8; &#8; &#24;&#7;&#17; fi &#8; &#17; &#3;&#16;fi &#5;fl&#17; &#10; ffi &#24;&#9;ffi ffi &#31;
</p>
<p>Example 5.3 The language:
</p>
<p>&#0;&#2;&#1;&#23;&#3; &#5;&#16; &#18;&#24;&#12;!&quot;&#3; &#5;&#7;&#6;&#9;&#10; &#6;#&#13;&#16;&#15;&quot;&#20;&#4;&#22;&#7;&#24;
</p>
<p>is generated by:
</p>
<p>&#25;%$'&amp;
</p>
<p>&#1;(fi &#3; &#5;fl&#17; &#10; &#24;&#7;&#17; &#3; &#5;fl&#17; &#5;&#7;&#10; &#24;&#7;&#17; fi &#5;)&#17; &#3;&#16;fi *+&#17; &#5;&#16;ffi &#24;&#9;ffi &#17; fi &#5;
</p>
<p> 
</p>
<p>&#10; &#17; &#3;&#16;fi &#5;)&#17; &#10; ffi &#24;&#9;ffi ffi &#31;
</p>
<p>Contextual grammars allow one to produce families of languages that are eccentric with respect
to the Chomsky hierarchy, as shall be seen below. This seems to be a very relevant feature from
a linguistic viewpoint, as natural languages could possibly occupy an eccentric position with
regard to that hierarchy.
</p>
<p>5.2 Grammar Systems
</p>
<p>Grammar systems are complex, modular generating architectures intended for either increasing
the generative power or decreasing the complexity of the generative strategy of the mechanism.
Several types can be distinguished.
</p>
<p>A cooperating distributed grammar system (CDGS) is a construct:
</p>
<p>,&quot;&#1;(fi -.&#17; /&#12;&#17; 0&#18;&#17; 132 &#17; 154 &#17; &#31; &#31; &#31; &#17; 1
</p>
<p>&#6;
</p>
<p>ffi &#17;
</p>
<p>where:
</p>
<p>6
</p>
<p>-879/:&#1;:;
</p>
<p>,
</p>
<p>6
</p>
<p>0&#2;&lt;&quot;-
</p>
<p>,
</p>
<p>6
</p>
<p>1
</p>
<p>2
</p>
<p>&#17; 1
</p>
<p>4
</p>
<p>&#17; &#31; &#31; &#31; &#17; 1
</p>
<p>&#6; are finite sets of rewriting rules: the components of the system.
</p>
<p>Several modes of derivation can be considered (being = the set of integers):
</p>
<p>6 in exactly &gt; steps:
&#1;+?A@)B
</p>
<p>C D
</p>
<p>fi
</p>
<p>&gt;
</p>
<p>&lt;
</p>
<p>=
</p>
<p>ffi
</p>
<p>,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0; in at most
&#1;
</p>
<p>steps: &#2;&#4;&#3;&#6;&#5;&#8;&#7;&#9; &#10; ,
&#0; in at least
</p>
<p>&#1;
</p>
<p>steps: &#2;&#11;&#3;&#6;&#12;&#13;&#7;&#9; &#10; ,
&#0; arbitrary derivation: &#2;&#11;&#3;&#15;&#14;&#9; &#10; ,
&#0; terminal or maximal derivation: &#2;&#4;&#3;&#17;&#16;&#9; &#10; &#18;
</p>
<p>&#19;
</p>
<p>&#2;&#4;&#3;
</p>
<p>&#16;
</p>
<p>&#9; &#10;&#11;&#20; if and only if &#19; &#2;&#4;&#3;&#6;&#12;&#13;&#21;&#9; &#10;&#22;&#20; and there does not exist any &#23;&#25;&#24;&#17;&#26; ffflfi&#31;ffi! &#14; such that
&#20;
</p>
<p>&#2;&#4;&#3;
</p>
<p>&#9; &#10;
</p>
<p>&#23;&#8;&quot;
</p>
<p>Given a mode of derivation #$&#24;&amp;%'&#2;)(+*&#8;, - ./fi&#22;(10
&#1;
</p>
<p>, &#2;
</p>
<p>&#1;
</p>
<p>, 2
</p>
<p>&#1;
</p>
<p>&#18;
</p>
<p>&#1;
</p>
<p>2)31. , the language generated
by an CDGS is:
</p>
<p>465
</p>
<p>&#26; 78 /&#2;9( :)&#24;$ffi
</p>
<p>&#14;
</p>
<p>&#18;&#8;;
</p>
<p>&#2;&#11;&#3;
</p>
<p>5&lt;
</p>
<p>&#10; =
</p>
<p>:
</p>
<p>&#21;
</p>
<p>&#2;&#11;&#3;
</p>
<p>5&lt;
</p>
<p>&#10; &gt;
</p>
<p>:@?A&#2;&#4;&#3;B&quot; &quot; &quot;&#13;&#2;&#11;&#3;
</p>
<p>5&lt;
</p>
<p>&#10; C
</p>
<p>:AD&#15;&#2;E:!, FG293+, 3!0EH IJ0EK8, 3!0&#15;L&#25;0&#6;F&amp;.1&quot;
</p>
<p>Thus, five languages are associated with 7/&quot;
</p>
<p>Example 5.4 The CDGS:
</p>
<p>7&amp;&#2;M&#26; (
</p>
<p>;
</p>
<p>, NO, N@P , Q&#25;, QOP .1, ( RS, T , U .1,
</p>
<p>;
</p>
<p>, V
</p>
<p>&#21;
</p>
<p>, V
</p>
<p>?
</p>
<p> 
</p>
<p>consisting of:
</p>
<p>V
</p>
<p>&#21;
</p>
<p>&#2;9(
</p>
<p>;XW&#4;YZ;
</p>
<p>,
</p>
<p>;&#17;W&#4;Y
</p>
<p>N[Q&#25;, N
</p>
<p>P
</p>
<p>W&#4;Y
</p>
<p>NO, Q
</p>
<p>P
</p>
<p>W&#11;Y
</p>
<p>Q&#31;. ,
</p>
<p>V8?@&#2;9( N
</p>
<p>W&#11;Y
</p>
<p>R&#8;N
</p>
<p>P
</p>
<p>T , Q
</p>
<p>W&#11;Y
</p>
<p>U Q
</p>
<p>P
</p>
<p>, N
</p>
<p>W&#4;Y
</p>
<p>R1T , Q
</p>
<p>W&#4;Y
</p>
<p>U . ,
</p>
<p>generates:
</p>
<p>4/\
</p>
<p>? &#26; 78 /&#2;9( R+]1T ]1U ]&#8;, K&amp;293+.1,
</p>
<p>4
</p>
<p>\
</p>
<p>&#7;
</p>
<p>&#26; 76 /&#2;
</p>
<p>4
</p>
<p>&#12;&#13;&#7;
</p>
<p>&#26; 76 /&#2;&#6;^&#13;, _J` a b
</p>
<p>&#1;
</p>
<p>2&#6;c&#13;&quot;
</p>
<p>Example 5.5 The CDGS:
</p>
<p>7d&#2;9&#26; (
</p>
<p>;
</p>
<p>, NO, N@P .1, ( R&#13;, T .1,
</p>
<p>;
</p>
<p>, V
</p>
<p>&#21;
</p>
<p>, V
</p>
<p>?
</p>
<p>, V8e  
</p>
<p>consisting of:
</p>
<p>V
</p>
<p>&#21;
</p>
<p>&#2;9(
</p>
<p>;XW&#4;YZ;
</p>
<p>,
</p>
<p>;&#17;W&#4;Y
</p>
<p>N[N!, N
</p>
<p>P
</p>
<p>W&#4;Y
</p>
<p>NO. ,
</p>
<p>V8?@&#2;9( N
</p>
<p>W&#11;Y
</p>
<p>R&#8;N
</p>
<p>P
</p>
<p>, N
</p>
<p>W&#4;Y
</p>
<p>RS. ,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>&#0;&#2;&#1;&#4;&#3;&#6;&#5; &#7;&#9;&#8;&#11;&#10;&#13;&#12; &#7;&#4;&#14; &#15; &#7;&#9;&#8;&#16;&#10;&#17;&#12; &#18;
</p>
<p>,
</p>
<p>generates:
</p>
<p>&#19;&#21;&#20;&#23;&#22; &#24; &#25;ff&#26;ff&#3;fi&#19;ffifl&#23;&#22; &#24; &#25;ff&#26;&#21;&#3;&#9;&#5; &#31; &#31;&#9;!&quot;&#31;&#9;#$&#5; %&amp;&#15; &#12; &#18; 'ff&#18;&quot;(
</p>
<p>Let )+*+,
&#24; -&#11;&#26; denote the family of languages generated by CDGS&#8217;s of degree (the number of
</p>
<p>components) at most . ( .&#9;/10 ) working in the mode -&#23;( If the number of components is not
limited, one writes 2 instead of . ( The union of all families )+*43 &#24; &#3;&#9;5&#23;&#26; (respectively, )6*43 &#24; /
57&#26;
</p>
<p>, )6* 3
</p>
<p>&#24; 8&#9;5&#23;&#26; ), 5 /&#9;0 , is denoted by )+* 3 &#24; &#3;6&#26; (respectively, )+* 3 &#24; / &#26; , )+* 3 &#24; 86&#26; ). If 9 -rules
are accepted, one writes )6*;:
</p>
<p>,
</p>
<p>&#24; -&#16;&#26;
</p>
<p>, )+*&lt;:
3
</p>
<p>&#24; -&#16;&#26;
</p>
<p>, etc. Many results on CDGS&#8217;s&#8217; generative capacity
are known:
</p>
<p>=
</p>
<p>)6*43
</p>
<p>&#24; -&#16;&#26;ff&#3;
</p>
<p>)+&gt; , for every
-?#$&#5;A@7&#15; B &#15; &#3;
</p>
<p>0
</p>
<p>&#15;
</p>
<p>/&#6;0
</p>
<p>&#18;&#4;CD&#5;&quot;8&#9;5&lt;!75
</p>
<p>/&#9;0
</p>
<p>&#18;&quot;(
</p>
<p>=
</p>
<p>)6&gt;
</p>
<p>&#3;
</p>
<p>)6*&lt;E
</p>
<p>&#24; -&#16;&#26;&#4;F
</p>
<p>)+*
</p>
<p>&#22; &#24; -&#11;&#26;HG
</p>
<p>)6*JI
</p>
<p>&#24; -&#11;&#26;HG
</p>
<p>)+*
</p>
<p>3
</p>
<p>&#24; -&#11;&#26;
</p>
<p>, for every -$#K&#5;A&#3;&#6;5&amp;&#15; / 5?!&amp;5 /ML &#18; ,
N
</p>
<p>/fiO
</p>
<p>(
</p>
<p>=
</p>
<p>)6*JI
</p>
<p>&#24; &#3;&#9;5&#23;&#26;&#21;G
</p>
<p>)+*+I
</p>
<p>&#24; &#3;&#9;P 5&#23;&#26;
</p>
<p>, for every 5&amp;&#15; N &#15; P /&#6;0 (
</p>
<p>=
</p>
<p>)6*
</p>
<p>I
</p>
<p>&#24;
</p>
<p>/
</p>
<p>5&#23;&#26;ffiG
</p>
<p>)6*
</p>
<p>I
</p>
<p>&#24;
</p>
<p>/
</p>
<p>56Q
</p>
<p>0
</p>
<p>&#26;
</p>
<p>, for every
5&amp;&#15;
</p>
<p>N
</p>
<p>/&#6;0
</p>
<p>(
</p>
<p>=
</p>
<p>)6*
</p>
<p>3
</p>
<p>&#24;
</p>
<p>/
</p>
<p>&#26;ffiG
</p>
<p>)+*
</p>
<p>3
</p>
<p>&#24; &#3;6&#26; (
</p>
<p>=
</p>
<p>)6&gt;
</p>
<p>&#3;
</p>
<p>)+*
</p>
<p>E
</p>
<p>&#24; B &#26;ff&#3;
</p>
<p>)+*
</p>
<p>&#22;
</p>
<p>&#24; B &#26;ffiF
</p>
<p>)6*
</p>
<p>&#1;
</p>
<p>&#24; B &#26;&#21;&#3;
</p>
<p>)6*43
</p>
<p>&#24; B &#26; (
</p>
<p>= All the six relations above are also true for )6* : systems.
</p>
<p>A parallel communicating grammar system (PCGS) is a construct:
</p>
<p>&#25;D&#3;M&#24; R;&#15; SD&#15; T&#4;&#15; &#24; &#0;
</p>
<p>E
</p>
<p>&#15; U
</p>
<p>E
</p>
<p>&#26; &#15; &#24; &#0;
</p>
<p>&#22;
</p>
<p>&#15; U
</p>
<p>&#22;
</p>
<p>&#26; &#15; ( ( ( &#15; &#24; &#0;
</p>
<p>,
</p>
<p>&#15; U
</p>
<p>,
</p>
<p>&#26; &#26; &#15;
</p>
<p>where:
</p>
<p>=
</p>
<p>R;&#15; TH&#15; S
</p>
<p>are pairwise disjoint alphabets,
=
</p>
<p>S&#13;&#3;V&#5; W
</p>
<p>E
</p>
<p>&#15; W6&#22; &#15; ( ( ( &#15; W
</p>
<p>,
</p>
<p>&#18;
</p>
<p>are query letters (the subindex associates the letter to the corre-
sponding component),
</p>
<p>=
</p>
<p>U&amp;X&#2;#DR
</p>
<p>,
</p>
<p>=
</p>
<p>&#0;
</p>
<p>X
</p>
<p>are finite sets of productions over RVC;SYC&lt;T , 0 8fiZff8 . (
</p>
<p>Given [7\ &#3;]&#24; RYC^S]C?T6&#26; , every . -uple &#24; _ E &#15; _&#11;&#22; &#15; ( ( ( &#15; _ , &#26; , _
X
</p>
<p>#
</p>
<p>[6`
</p>
<p>\
</p>
<p>, is a configuration of the
system.
</p>
<p>Given two configurations
&#24; _
</p>
<p>E
</p>
<p>&#15; _
</p>
<p>&#22;
</p>
<p>&#15; ( ( ( &#15; _
</p>
<p>,
</p>
<p>&#26;
</p>
<p>,
</p>
<p>&#24; a
</p>
<p>E
</p>
<p>&#15; a
</p>
<p>&#22;
</p>
<p>&#15; ( ( ( &#15; a
</p>
<p>,
</p>
<p>&#26;
</p>
<p>,
</p>
<p>_&amp;X &#15; a X&#2;#
</p>
<p>[6`
</p>
<p>\
</p>
<p>, 0
</p>
<p>8fiZ&#21;8
</p>
<p>. , one defines
the immediate derivation
</p>
<p>&#24; _
</p>
<p>E
</p>
<p>&#15; _
</p>
<p>&#22;
</p>
<p>&#15; ( ( ( &#15; _
</p>
<p>,
</p>
<p>&#26;;&#3;&#11;b
</p>
<p>\
</p>
<p>&#24; a
</p>
<p>E
</p>
<p>&#15; a
</p>
<p>&#22;
</p>
<p>&#15; ( ( ( &#15; a
</p>
<p>,
</p>
<p>&#26;
</p>
<p>if and only if either of the
following situations occur:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>(i) either ( &#0; &#1;&#3;&#2; &#0; &#4;&#6;&#5;&#8;&#7; ) and (( &#1;&#9;&#2;&#10;&#5;&#10;&#11;&#6;&#12; &#13;&#15;&#14; &#2; &#16; or &#17; &#1;&#3;&#2;&#19;&#18;&#21;&#20;&#23;&#22; and &#1;&#3;&#2;&#10;&#5;&#24;&#14; &#2; )), &#25;ff&#26;&#24;fifl&#26;&#24;ffi ,
(ii) or there exists fi &#31; &#25;&#21;&#26; fi!&#26;&quot;ffi such that &#0; &#1; &#2; &#0; &#4;&quot;# &#7; ; in such a case, for every fi one writes
&#1;&#9;&#2;fl&#5;%$ &amp; '&#23;&#2; ( $ ) '!&#2; *&#10;+ + + $ , '&#23;&#2; - $ , .&#15;&amp;
</p>
<p>, /&#23;01&#25; ,
</p>
<p>$ 2!&#18;43!&#22;
</p>
<p>5 ,
</p>
<p>&#0; $ 26&#0; &#4;&#8;&#5;%&#7;
</p>
<p>, &#25;7&#26;&#8;89&#26;&#8;/;:&#8;&#25; ; if
&#0; &#1;&#3;&#2; &lt;6&#0; &#4;&#8;&#5;%&#7;
</p>
<p>,
</p>
<p>&#25;=&#26;&gt;8&#21;&#26;&gt;/ , then
&#14; &#2;;&#5;1$6&amp; &#1;&#3;&#2; ( $ ) &#1;&#9;&#2; *&#10;+ + + $ , &#1;&#3;&#2; - $ , .&#15;&amp; [and &#14; &#2; &lt;!&#5;@?&#3;&#2; &lt; , &#25;A&#26;&#8;8&#21;&#26;%/ ]; if, for some 8 ,
</p>
<p>&#25;ff&#26;&#24;8A&#26;&#8;/ ,
</p>
<p>&#0; &#1;
</p>
<p>&#2; &lt;
</p>
<p>&#0;
</p>
<p>&#4;1B
</p>
<p>&#5;&gt;&#7;
</p>
<p>, then
&#14;
</p>
<p>&#2;
</p>
<p>&#5;&#8;&#1;
</p>
<p>&#2;
</p>
<p>; for every fi , &#25;ff&#26;&gt;fiC&#26;&gt;ffi , for which
&#14;
</p>
<p>&#2;
</p>
<p>is not specified
above, one has
</p>
<p>&#14;
</p>
<p>&#2;
</p>
<p>&#5;&#24;&#1;
</p>
<p>&#2;
</p>
<p>.
</p>
<p>(i) is a rewriting step, (ii) is a communication step: the latter has a priority over the former (i.e.
if both are possible at a certain stage of the derivation process, communication must be applied
before).
</p>
<p>The blocking of an PCGS may happen in either of the following cases:
</p>
<p>D when one component
&#1;&#3;&#2;
</p>
<p>in &#17;
&#1;&#15;&amp;
</p>
<p>&#31;
</p>
<p>+ + +
</p>
<p>&#31;
</p>
<p>&#1;&#9;EF&#16;
</p>
<p>is not terminal but cannot be rewritten according
to G
&#2;
</p>
<p>, or
</p>
<p>D when a circular query occurs: G
&#2; (
</p>
<p>introduces
'&#23;&#2; *
</p>
<p>, G
</p>
<p>&#2; *
</p>
<p>introduces
'!&#2; H
</p>
<p>&#31;
</p>
<p>+ + +
</p>
<p>&#31; G
</p>
<p>&#2; I J
</p>
<p>(
</p>
<p>introduces
'&#23;&#2; I
</p>
<p>, and G
&#2; I
</p>
<p>introduces
'!&#2; ( (communication has priority but it cannot take place, because
</p>
<p>strings to be communicated must contain no query letters at all).
</p>
<p>The language generated by an PCGS is:
</p>
<p>K
</p>
<p>&#17; L
</p>
<p>&#16;fl&#5;%M &#1;&#21;&#18;&#21;&#20;&#23;&#22;ON
</p>
<p>&#17;
</p>
<p>?
</p>
<p>&amp;
</p>
<p>&#31;
</p>
<p>?
</p>
<p>)
</p>
<p>&#31;
</p>
<p>+ + +
</p>
<p>&#31;
</p>
<p>?
</p>
<p>E
</p>
<p>&#16;fl&#5;&#10;&#11;&#6;&#22;
</p>
<p>&#17;
</p>
<p>&#1;
</p>
<p>&#31; P
</p>
<p>)
</p>
<p>&#31;
</p>
<p>+ + +
</p>
<p>&#31; P
</p>
<p>E
</p>
<p>&#16;
</p>
<p>&#31; P
</p>
<p>&#2;
</p>
<p>&#18;Q3!&#22;
</p>
<p>5
</p>
<p>&#31; Rff&#26;&#8;fi;&#26;&#8;ffi&#19;S .
</p>
<p>Thus, the language of the system is the language of the master component, which is the first
component of the system:
</p>
<p>?&#19;&amp;
</p>
<p>.
</p>
<p>An PCGS is said to be centralized if and only if G
&#2;&#19;T
</p>
<p>&#17; U&#6;V
</p>
<p>&#20;!&#16; &#22;&#3;W
</p>
<p>&#17; U&#6;V
</p>
<p>&#20;&#23;&#16; &#22;
</p>
<p>, R7&#26;&#24;fifl&#26;&#24;ffi (i.e. only
the master is allowed to introduce query letters). Otherwise, it is said to be noncentralized.
</p>
<p>An PCGS is called returning if and only if, after communication, each component that has
communicated goes back to its axiom and starts again. Otherwise, it is called nonreturning.
An PCGS L will produce two languages, KflX &#17; L
</p>
<p>&#16;
</p>
<p>and K
E
</p>
<p>X
</p>
<p>&#17; L
</p>
<p>&#16;
</p>
<p>&#31; according to the returning or non-
returning mode of working, respectively.
</p>
<p>By default, one understands that an PCGS works in a noncentralized, returning mode. Some
conventional notations include:
</p>
<p>G!Y
</p>
<p>E6Z
</p>
<p>: family of languages generated by noncentralized, returning PCGS&#8217;s with at most
ffi components of type
</p>
<p>Z
</p>
<p>,
</p>
<p>Z[&#18;\M ]&#23;&#770;ff_
</p>
<p>&#31;
</p>
<p>Kfl`
</p>
<p>U&#21;&#31; Y!aO&#31; Y
</p>
<p>?
</p>
<p>&#31;
</p>
<p>]&#23;^
</p>
<p>S ,
</p>
<p>Y!GffY
</p>
<p>E
</p>
<p>Z
</p>
<p>: G!Y
E
</p>
<p>Z
</p>
<p>: centralized mode,
</p>
<p>U&#21;G!Y
</p>
<p>E6Z
</p>
<p>: G!Y
E Z
</p>
<p>: nonreturning mode,
</p>
<p>U&#21;Y!GffY
</p>
<p>E
</p>
<p>Z
</p>
<p>: Y!GffY
E
</p>
<p>Z
</p>
<p>: nonreturning mode,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>&#0;&#2;&#1;&#4;&#3;&#6;&#5;&#8;&#7;&#10;&#9;&#12;&#11; &#13;&#15;&#14;&#16;&#0;&#2;&#1;
</p>
<p>&#11;
</p>
<p>&#5; (analogously for &#1;&#2;&#0;&#17;&#1;&#4;&#3;&#6;&#5; , &#18; &#0;&#2;&#1;&#4;&#3;&#19;&#5; , &#18; &#1;&#2;&#0;&#17;&#1;&#4;&#3;&#6;&#5; ).
</p>
<p>Example 5.6 The PCGS:
</p>
<p>&#20;&#21;&#7;&#23;&#22; &#24;&#26;&#25;
</p>
<p>&#14; ff
</p>
<p>&#25;flfi
</p>
<p>ff
</p>
<p>&#25;flffi &#31;
</p>
<p>ff  !ff
</p>
<p>&#24; &quot;
</p>
<p>ff #
</p>
<p>&#31;
</p>
<p>ff
</p>
<p>&#22; &#0;
</p>
<p>&#14; ff
</p>
<p>&#25;
</p>
<p>&#14; $ ff
</p>
<p>&#22; &#0;%fi
</p>
<p>ff
</p>
<p>&#25;flfi
</p>
<p>$ ff
</p>
<p>&#22; &#0;&amp;ffi
</p>
<p>ff
</p>
<p>&#25;flffi
</p>
<p>$ $
</p>
<p>consisting of:
&#0;
</p>
<p>&#14;
</p>
<p>&#7;'&#24;&#26;&#25;
</p>
<p>&#14;)(+*
</p>
<p>&quot;&#16;&#25;
</p>
<p>&#14; ff
</p>
<p>&#25;
</p>
<p>&#14;)(fl*
</p>
<p>&quot;
</p>
<p>ffi ,
</p>
<p>fi
</p>
<p>ff
</p>
<p>&#25;flfi
</p>
<p>(+*-#
</p>
<p>fi ,
</p>
<p>ffi
</p>
<p>ff
</p>
<p>&#25;flffi
</p>
<p>(+*/.
</p>
<p>&#31;
</p>
<p>,
</p>
<p>&#0;&amp;fi&#4;&#7;'&#24;&#26;&#25;flfi
</p>
<p>(+*-#
</p>
<p>&#25;flfi &#31;
</p>
<p>,
</p>
<p>&#0;&amp;ffi&#4;&#7;'&#24;&#26;&#25;flffi
</p>
<p>(+*-.
</p>
<p>&#25;flffi &#31;
</p>
<p>,
</p>
<p>generates:
</p>
<p>0%1 &#22; &#20;
</p>
<p>$
</p>
<p>&#7;&#10;0
</p>
<p>&#11;
</p>
<p>1 &#22; &#20;
</p>
<p>$
</p>
<p>&#7;'&#24; &quot;
</p>
<p>&#11;
</p>
<p>#
</p>
<p>&#11;
</p>
<p>.
</p>
<p>&#11;&#12;243&#21;576
</p>
<p>&#31;98
</p>
<p>Example 5.7 The PCGS:
</p>
<p>&#20;&#21;&#7;&#23;&#22; &#24;&#26;&#25;
</p>
<p>&#14;
</p>
<p>ff
</p>
<p>&#25;
</p>
<p>fi
</p>
<p>&#31;
</p>
<p>ff  &#21;ff
</p>
<p>&#24; &quot;
</p>
<p>ff #
</p>
<p>&#31;
</p>
<p>ff
</p>
<p>&#22; &#0;
</p>
<p>&#14;
</p>
<p>ff
</p>
<p>&#25;
</p>
<p>&#14;
</p>
<p>$ ff
</p>
<p>&#22; &#0;
</p>
<p>fi
</p>
<p>ff
</p>
<p>&#25;
</p>
<p>fi
</p>
<p>$ $
</p>
<p>consisting of:
</p>
<p>&#0;
</p>
<p>&#14;
</p>
<p>&#7;'&#24;&#26;&#25;
</p>
<p>&#14;
</p>
<p>(+*
</p>
<p>&#25;
</p>
<p>&#14;
</p>
<p>ff
</p>
<p>&#25;
</p>
<p>&#14;
</p>
<p>(+*
</p>
<p>,
</p>
<p>fi
</p>
<p>,
</p>
<p>fi
</p>
<p>&#31;
</p>
<p>,
</p>
<p>&#0;
</p>
<p>fi
</p>
<p>&#7;'&#24;&#26;&#25;
</p>
<p>fi
</p>
<p>(+*
</p>
<p>&quot;&#16;&#25;
</p>
<p>fi
</p>
<p>ff
</p>
<p>&#25;
</p>
<p>fi
</p>
<p>(fl*/#
</p>
<p>&#25;
</p>
<p>fi
</p>
<p>ff
</p>
<p>&#25;
</p>
<p>fi
</p>
<p>(fl*
</p>
<p>&quot;
</p>
<p>ff
</p>
<p>&#25;
</p>
<p>fi
</p>
<p>(fl*/#
</p>
<p>&#31;
</p>
<p>,
</p>
<p>generates:
</p>
<p>0
</p>
<p>1
</p>
<p>&#22; &#20;
</p>
<p>$
</p>
<p>&#7;:0
</p>
<p>&#11;
</p>
<p>1
</p>
<p>&#22; &#20;
</p>
<p>$
</p>
<p>&#7;'&#24; ;&#6;;
</p>
<p>2
</p>
<p>;7&lt;=&#24; &quot;
</p>
<p>ff #
</p>
<p>&#31; &gt;&amp;&#31;98
</p>
<p>Let ?
&#7;&#23;&#24; &#0;&#17;&#1;
</p>
<p>ff
</p>
<p>&#1;&#2;&#0;&#17;&#1;
</p>
<p>ff
</p>
<p>&#18;
</p>
<p>&#0;&#2;&#1;
</p>
<p>ff
</p>
<p>&#18;
</p>
<p>&#1;&#17;&#0;&#2;&#1;@&#31;
</p>
<p>. The following results about PCGS&#8217;s&#8217; generative power
are known:
</p>
<p>ACB
</p>
<p>&#11;
</p>
<p>&#1;&#17;&#25;%DE&#7;GF&#19;H
</p>
<p>, for every
3
</p>
<p>, for every B
&lt;
</p>
<p>? , where
&#1;&#12;&#25;%D
</p>
<p>indicates that productions of
arbitrary type are utilized.
</p>
<p>ACB
</p>
<p>&#11;
</p>
<p>F&#19;H&#17;I
</p>
<p>(
</p>
<p>0KJ
</p>
<p>&#18;ML
</p>
<p>&#7;&#10;N
</p>
<p>,
B
</p>
<p>&#11;
</p>
<p>0KJ
</p>
<p>&#18;
</p>
<p>(
</p>
<p>&#1;&#17;O
</p>
<p>L
</p>
<p>&#7;&#10;N@&#22;
</p>
<p>3P57Q
</p>
<p>$
</p>
<p>, and B
&#11;
</p>
<p>F&#2;H&#17;I
</p>
<p>(
</p>
<p>&#1;&#2;O
</p>
<p>L
</p>
<p>&#7;&#10;N@&#22;
</p>
<p>3P5&#10;R
</p>
<p>$
</p>
<p>, for
every B
</p>
<p>&lt;
</p>
<p>? .
</p>
<p>ACB
</p>
<p>&#11;
</p>
<p>F&#19;H&#17;I
</p>
<p>(
</p>
<p>&#1;&#2;O
</p>
<p>L
</p>
<p>&#7;&#10;N
</p>
<p>,
</p>
<p>3&#21;5&#10;Q
</p>
<p>, for every B
&lt;=&#24;
</p>
<p>&#18;
</p>
<p>&#0;&#17;&#1;
</p>
<p>ff
</p>
<p>&#18;
</p>
<p>&#1;&#2;&#0;&#17;&#1;
</p>
<p>$
</p>
<p>.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0;&#2;&#1;&#4;&#3;&#6;&#5;&#8;&#7;&#10;&#9; &#11;&#13;&#12;&#14;&#11;&#16;&#15;&#18;&#17;&#18;&#19;&#14;&#20;&#10;&#21;&#22;&#5;&#23;&#11;&#14;&#12;&#13;&#11;&#16;&#15;&#18;&#17;&#13;&#19;&#14;&#20;&#14;&#24;&#18;&#25;
</p>
<p>&#26;&#10;ff
</p>
<p>.
</p>
<p>&#0;&#2;&#11;&#13;&#12;&#14;&#11;&#16;fi &#17;&#13;&#19;&#14;&#20;ffifl&#10;&#11;&#13;&#31;
</p>
<p>,
&#12;&#14;&#11;&#16;fi &#17;&#13;&#19;&#14;&#20;ffi &#10;&#11;&#13;&#31;&#16;!
</p>
<p>&#0;&#2;&#11;&#13;&#12;&#14;&#11;
</p>
<p>&#15;
</p>
<p>&#17;&#18;&#19;&#14;&#20; contains only semilinear languages.
&#0;&#2;&#11;&#13;&#12;&#14;&#11;&#16;fi &#11;&#14;&#31; contains nonsemilinear languages.
&#0; If &#1;&#10; #&quot;&#14;$ , &#1;&#10;%&amp;&#11;&#13;&#12;&#14;&#11;(')&#17;&#18;&#19;&#14;&#20; , then there exists a constant * such that for every + %&amp;&#1; , if
,
</p>
<p>+
</p>
<p>,.-
</p>
<p>* then + &#26;0/21 3&#6;1 / fi 3 fi4! ! ! /.5&#16;3 5&#4;/.57621 , 8&#13;9&#10;:;9&#10;&lt; , 3 = &#25;&#26;?&gt; , 8&#14;9&#10;@79&#10;: , and for every
ACB
</p>
<p>8&#14;D
</p>
<p>/41 3FE
</p>
<p>1
</p>
<p>/
</p>
<p>fi
</p>
<p>3FE
</p>
<p>fi
</p>
<p>! ! !
</p>
<p>/.5&#16;3FE
</p>
<p>5
</p>
<p>/.57621
</p>
<p>%G&#1;&#16;!
</p>
<p>&#0;&#2;&#11;&#13;&#12;&#14;&#11;(')&#17;&#13;&#19;&#14;&#20;ffifl0&#11;&#14;&#12;&#13;&#11;('
</p>
<p>6H1
</p>
<p>&#17;&#18;&#19;&#14;&#20;
</p>
<p>, &lt;
</p>
<p>B
</p>
<p>8
</p>
<p>!
</p>
<p>&#0;&#2;&#12;&#13;&#11;
</p>
<p>'
</p>
<p>&#17;&#18;&#19;&#14;&#20;ffifl&#10;&#12;&#14;&#11;
</p>
<p>'
</p>
<p>621
</p>
<p>&#17;&#18;&#19;&#14;&#20;
</p>
<p>, &lt;
</p>
<p>B
</p>
<p>8
</p>
<p>!
</p>
<p>&#0;&#2;&#11;&#13;&#12;&#14;&#11;(')&#17;&#13;&#19;&#14;&#20;ffifl0&#11;&#14;&#12;&#13;&#11;('&#6;&#1;&#4;&#3;&#6;&#5;Ifl&#10;&#11;&#13;&#12;&#14;&#11;(')&#11;&#13;&#31;
</p>
<p>, &lt;
</p>
<p>B
</p>
<p>8
</p>
<p>!
</p>
<p>&#0;&#2;&#5;&#23;&#11;&#13;&#12;&#14;&#11;&#16;&#15;&#18;&#11;&#14;&#31;J I&#12;&#13;&#11;&#16;&#15;&#18;&#11;&#14;&#31; (i.e. a centralized + nonreturning working mode is weaker
than a noncentralized + returning one).
</p>
<p>&#0;&#2;&#11;&#14;K
</p>
<p>&#26;&#10;L
</p>
<p>'
</p>
<p>&#11;&#14;K
</p>
<p>&#26;&#10;L
</p>
<p>&#15;
</p>
<p>&#11;MK
</p>
<p>, &lt;
</p>
<p>B
</p>
<p>8 , for every L %&amp;N &#11;&#13;&#12;&#14;&#11;&#13;O &#5;&#23;&#11;&#13;&#12;&#14;&#11;MP (i.e. by using centralized
CS PCGS&#8217;s, one does not go beyond the family CS).
</p>
<p>&#0;&#2;&#11;&#14;K
</p>
<p>&#26;
</p>
<p>&#12;&#13;&#11;
</p>
<p>1
</p>
<p>&#11;&#14;K
</p>
<p>&#26;
</p>
<p>&#12;&#13;&#11;
</p>
<p>fi
</p>
<p>&#11;MKQfl;&#12;&#14;&#11;&#16;R &#11;&#14;K
</p>
<p>&#26;
</p>
<p>&#12;&#13;&#11;
</p>
<p>&#15;
</p>
<p>&#11;MK
</p>
<p>&#26;
</p>
<p>&#17;&#13;&#19; (noncentralized returning
PCGS&#8217;s with three CS components suffice to generate every RE).
</p>
<p>&#0;&#2;&#11;&#14;K
</p>
<p>&#26;
</p>
<p>&#5;&#23;&#12;&#13;&#11;
</p>
<p>1
</p>
<p>&#11;&#14;KSflT&#5;&#23;&#12;&#14;&#11;
</p>
<p>fi
</p>
<p>&#11;MK
</p>
<p>&#26;
</p>
<p>&#5;&#23;&#12;&#14;&#11;
</p>
<p>&#15;
</p>
<p>&#11;&#14;K
</p>
<p>&#26;
</p>
<p>&#17;&#18;&#19; (noncentralized nonreturning
PCGS&#8217;s with just two CS components are enough to generate every RE).
</p>
<p>&#0; Given U ' &#11;&#14;K7V , &lt;
B
</p>
<p>8 , U
%WN &#12;&#13;&#11;&#13;O &#11;&#14;&#12;&#13;&#11;&#13;O &#5;&#23;&#12;&#14;&#11;&#13;O &#5;&#23;&#11;&#13;&#12;&#14;&#11;MP
</p>
<p>D
</p>
<p>&#11;MK
</p>
<p>&#26;
</p>
<p>U
</p>
<p>1
</p>
<p>&#11;MK7V&#14;fl
</p>
<p>U
</p>
<p>fi
</p>
<p>&#11;&#14;K7V
</p>
<p>&#26;
</p>
<p>U
</p>
<p>'
</p>
<p>&#11;&#14;K7V
</p>
<p>&#26;
</p>
<p>&#17;&#18;&#19;
</p>
<p>, for every &lt;
B&#10;X
</p>
<p>.
</p>
<p>5.3 Grammar Ecosystems
</p>
<p>The postulates behind the notion of a grammar ecosystem are the following:
</p>
<p>a) An ecosystem consists of an environment and some agents. The state of the environment
as well as the states of the agents are all described by means of strings of letters from
certain alphabets.
</p>
<p>b) There exists one universal clock for the evolution of both the environment and the agents.
c) Both the environment and the agents have specific evolution rules, which are Linden-
</p>
<p>mayer rules (i.e. they are applied in parallel to all the letters describing the states of the
environment and of the agents).
</p>
<p>d) The rules for the evolution of the environment are independent from the agents and from
the state of the environment. The rules for the evolution of the agents depend on the state
of the environment in such a way that, at each step of the derivation, a specific appropriate
subset of rules is selected from the set of rules of each agent.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>e) The agents act on the environment through action rules, which are sequential (i.e. non-
parallel) rewriting rules. The selection of the specific action rule to be applied at each
step depends on the current state of the agent.
</p>
<p>f) Agents&#8217; action on the environment has a priority over the environment&#8217;s evolution. At
each step, the rules for the evolution of the environment rewrite in a parallel way only the
environment letters that are not affected by agent&#8217;s actions.
</p>
<p>A grammar ecosystem is a construct:
</p>
<p>&#0;&#2;&#1;&#4;&#3; &#5;&#7;&#6; &#8;&#10;&#9; &#6; &#8;&#12;&#11; &#6; &#13; &#13; &#13; &#6; &#8;&#15;&#14;&#17;&#16;
</p>
<p>consisting of:
</p>
<p>&#18;
</p>
<p>&#5;&#4;&#1;&#4;&#3; &#19;&#21;&#20;&#22;&#6; &#23;&#24;&#20;&#24;&#16;
</p>
<p>, with:
</p>
<p>(i) &#19;&#25;&#20; a finite alphabet,
(ii) &#23;&#22;&#20; a finite set of 0L rules over &#19;&#25;&#20; (evolution rules of &#5; ).
</p>
<p>&#18;
</p>
<p>&#8;&#15;&#26;ff&#1;&#4;&#3; &#19;&#21;&#26; &#6; &#23;ff&#26; &#6; fifl&#26; &#6; ffiff&#26; &#6; &#31;&#24;&#26; &#16;
</p>
<p>,  &#10;!#&quot;$!#% , with:
</p>
<p>(i) &#19; &#26; a finite alphabet,
(ii) &#23;&#24;&#26; a finite set of 0L rules over &#19;&#21;&#26; (evolution rules of the agent &quot; ),
</p>
<p>(iii) fifl&#26; a finite set of rules &amp;('*) , with &amp;,+ &#19;&#10;-&#20; , ).+ &#19;&#10;/&#20; (action rules of the agent &quot; ),
(iv) ffiff&#26;&#24;0&#21;&#19;&#10;/&#20;21 '43 &#3; &#23;ff&#26; &#16; (it selects the rules for the current evolution of the agent &quot; ),
(v) &#31; &#26; 0ff&#19; -&#26; 1 '53 &#3; fi &#26; &#16; ,  .!6&quot;fl!&#4;% (it selects the rules for the current action of &#8; &#26; on
</p>
<p>the environment).
</p>
<p>A grammar ecosystem works by modifying the strings representing the agents as well as the
environment.
</p>
<p>A state of a grammar ecosystem is:
</p>
<p>7
</p>
<p>&#1;&#4;&#3; 8&#15;&#20;&#22;&#6; 8
</p>
<p>&#9;
</p>
<p>&#6; 8
</p>
<p>&#11;
</p>
<p>&#6; &#13; &#13; &#13; &#6; 8
</p>
<p>&#14;
</p>
<p>&#16; &#6;
</p>
<p>where:
</p>
<p>&#18;
</p>
<p>8&#15;&#20;
</p>
<p>+
</p>
<p>&#19;&#10;/
</p>
<p>&#20;
</p>
<p>,
</p>
<p>&#18;
</p>
<p>8
</p>
<p>&#26;
</p>
<p>+
</p>
<p>&#19;&#10;/
</p>
<p>&#26;
</p>
<p>,  &#10;!9&quot;&#22;!9% .
</p>
<p>Given 7 &#1;:&#3; 8&#15;&#20;&#22;&#6; 8
&#9;
</p>
<p>&#6; 8
</p>
<p>&#11;
</p>
<p>&#6; &#13; &#13; &#13; &#6; 8
</p>
<p>&#14;
</p>
<p>&#16;
</p>
<p>,
</p>
<p>&#8;
</p>
<p>&#26;
</p>
<p>is an active agent in 7 if and only if &#31;
&#26;
</p>
<p>&#3; 8
</p>
<p>&#26;
</p>
<p>&#16;,;&#1;=&lt;
</p>
<p>. An
action of
</p>
<p>&#8;fl&#26;
</p>
<p>in 7 is an application of &gt;6+
&#31;ff&#26; &#3; 8?&#26; &#16;
</p>
<p>on
8
</p>
<p>&#20;
</p>
<p>. A simultaneous action of the
agents
</p>
<p>&#8;fl&#26; @ &#6; &#8;fl&#26; A &#6; &#13; &#13; &#13; &#6; &#8;&#15;&#26; B
</p>
<p>, C &quot;
</p>
<p>&#9; &#6;
</p>
<p>&quot;
</p>
<p>&#11; &#6; &#13; &#13; &#13; &#6;
</p>
<p>&quot; D E&#10;F6CG 
</p>
<p>&#6; H&#17;&#6; &#13; &#13; &#13; &#6;
</p>
<p>%&#24;E
</p>
<p>&#6;
</p>
<p>on the environment is a 1-step parallel
derivation 8 &#20; &#1;ffI&#2;J&#7;8flK&#20; such that:</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>(i) &#0;&#2;&#1;&#4;&#3;&#6;&#5;&#8;&#7; &#9;&#10;&#7; &#5;&#10;&#11; &#9;&#12;&#11;&#10;&#13; &#13; &#13; &#9;&#15;&#14; &#5;&#15;&#14; &#16;&#10;&#7; ,
</p>
<p>(ii) &#0;&#2;&#17;&#1; &#3;&#6;&#5;&#8;&#7; &#18;&#19;&#7; &#5;&#12;&#11; &#18;&#19;&#11;&#8;&#13; &#13; &#13; &#18; &#14; &#5;&#12;&#14; &#16;&#12;&#7; , and
</p>
<p>(iii) &#9;&#21;&#20;&#2;&#22;&#23;&#18; &#20;&#25;&#24;ff&#26;flfi ffi &#31; &#0; fi ffi ! , &quot;$#&amp;%'#)( , &#5;&#15;fifl&#24;+*$,&#1; , &quot;$#&#6;-.#&#6;(&#25;/&#6;&quot; &#13;
</p>
<p>A state change of a grammar ecosystem is an 0L evolution of the states of all the agents (i.e.
&#0;
</p>
<p>fi
</p>
<p>&#3;&#8;021'&#0;&#25;&#17;
</p>
<p>fi
</p>
<p>, according to the productions in 3 fi &#31; &#0;&#2;&#1;&#8;! , &quot;$#)-.#)4 ) together with an 0L evolution
of the environment in all its points (i.e. &#0; &#1; &#3;&#10;0 1 &#0;&#2;&#17;&#1; , according to the productions in 5 &#1; ),
except those ones that are currently affected by the agents&#8217; actions (according to the productions
in &#26;flfi ).
</p>
<p>Given two states in 6 , 7 &#3;8&#31; &#0; &#1;fl9 &#0; &#7; 9 &#0; &#11; 9 &#13; &#13; &#13; 9 &#0; :;! , 7 &#17;&lt;&#3;=&#31; &#0;&#25;&#17;&#1; 9 &#0;&#2;&#17;&#7; 9 &#0;&#25;&#17;&#11; 9 &#13; &#13; &#13; 9 &#0;&#25;&#17;: ! , one says that 7
changes to 7 &#17; (or 7 &#17; directly derives from 7 : 7 &#3;&#8;021 7 &#17; ) if and only if:
</p>
<p>(i) &#0; &#1; &#3;)&gt; &#7; &#5; &#7; &gt; &#11; &#5; &#11; &#13; &#13; &#13; &gt; ? &#5;&#15;?&#2;&gt; ? &#16;&#10;&#7; and &#0;&#2;&#17;&#1; &#3;)&gt; &#17;&#7; @ &#7; &gt; &#17;&#11; @ &#11; &#13; &#13; &#13; &gt;&#19;&#17;? @ ? &gt;&#19;&#17;? &#16;&#12;&#7; and &gt; &#7; &#5; &#7; &gt; &#11; &#5; &#11; &#13; &#13; &#13; &gt; ? &#5;&#15;?&#2;&gt; ? &#16;&#10;&#7; &#3;&#10;0 1
&gt; &#7;
</p>
<p>@
</p>
<p>&#7; &gt; &#11;
</p>
<p>@
</p>
<p>&#11;&#8;&#13; &#13; &#13; &gt;
</p>
<p>?
</p>
<p>@
</p>
<p>?
</p>
<p>&gt;
</p>
<p>?
</p>
<p>&#16;&#10;&#7; is a simultaneous action of all the agents A fi B 9 A fi C 9 &#13; &#13; &#13; 9 A fi D , E - &#7; 9 - &#11; 9 &#13; &#13; &#13; 9 - ?&#25;F$G
E;&quot;
</p>
<p>9 H&#21;9
</p>
<p>&#13; &#13; &#13;
</p>
<p>9
</p>
<p>4
</p>
<p>F
</p>
<p>, that are active in 7 and &gt;&#19;&#17;&#7; &gt;&#19;&#17;&#11; &#13; &#13; &#13; &gt;&#19;&#17;? &gt;&#19;&#17;? &#16;&#12;&#7; is an evolution from &gt; &#7; &gt; &#11;&#8;&#13; &#13; &#13; &gt; ? &gt; ? &#16;&#12;&#7; 9
</p>
<p>(ii) &#0;&#2;&#17;fi is an evolution of A fi from &#0; fi , &quot;I#)-&lt;#)4 .
</p>
<p>The sequences of states characterize the evolutionary behaviour of 6 . Let 7&#10;J be an initial state.
One may define:
</p>
<p>K The set of sequences of states of 6 :
L&lt;M N
</p>
<p>&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7&#15;J
</p>
<p>!.&#3;
</p>
<p>E;E 7
</p>
<p>fi F O
</p>
<p>fi P
</p>
<p>J&#2;Q
</p>
<p>7&#15;J
</p>
<p>&#3;&#8;021
</p>
<p>7
</p>
<p>&#7; &#3;&#8;021
</p>
<p>7
</p>
<p>&#11; &#3;&#8;021R&#13; &#13; &#13;
</p>
<p>F
</p>
<p>&#13;
</p>
<p>K The set of sequences of states of S :
L&lt;M N
</p>
<p>&#1;.&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7&#15;J
</p>
<p>!.&#3;
</p>
<p>E;E
</p>
<p>&#0;&#2;&#1;&#21;T
</p>
<p>F
</p>
<p>O
</p>
<p>fi P
</p>
<p>J&#25;Q
</p>
<p>E 7
</p>
<p>&#20; F
</p>
<p>O
</p>
<p>&#20; P
</p>
<p>J
</p>
<p>&#24;
</p>
<p>L&lt;M N
</p>
<p>&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7&#12;J
</p>
<p>! and 7 &#20; &#3;U&#31; &#0;&#2;&#1; ffi 9 &#0;&#25;&#7; ffi 9 &#0;&#2;&#11; ffi 9 &#13; &#13; &#13; 9 &#0; : ffi ! F &#13;
</p>
<p>K The set of sequences of states of A &#20; ( &quot;I#2%'#&#6;4 ):
L&lt;M N
</p>
<p>&#20; &#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7
</p>
<p>J
</p>
<p>!.&#3;
</p>
<p>E;E
</p>
<p>&#0;.&#20; V
</p>
<p>F OW
</p>
<p>P
</p>
<p>J
</p>
<p>Q
</p>
<p>E 7
</p>
<p>W
</p>
<p>F OW
</p>
<p>P
</p>
<p>J
</p>
<p>&#24;
</p>
<p>L&lt;M N
</p>
<p>&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7
</p>
<p>J
</p>
<p>! and 7 W &#3;U&#31; &#0; &#1; V 9 &#0; &#7; V 9 &#13; &#13; &#13; 9
&#0;.&#20; V
</p>
<p>9
</p>
<p>&#13; &#13; &#13;
</p>
<p>9
</p>
<p>&#0; : V !
</p>
<p>F
</p>
<p>&#13;
</p>
<p>K The language of the environment:
X
</p>
<p>&#1;.&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7&#15;J
</p>
<p>!.&#3;
</p>
<p>E
</p>
<p>&#0;&#2;&#1;ff&#24;+*$,
</p>
<p>&#1;
</p>
<p>Q
</p>
<p>E 7
</p>
<p>&#20; F O
</p>
<p>&#20; P
</p>
<p>J
</p>
<p>&#24;
</p>
<p>L&lt;M N
</p>
<p>&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7&#15;J
</p>
<p>! and 7 &#20; &#3;Y&#31; &#0;&#2;&#1; 9 &#0;&#25;&#7; 9 &#0;&#2;&#11; 9 &#13; &#13; &#13; 9 &#0; : ! F &#13;
</p>
<p>K The language of the agent A fi ( &quot;$#&#6;-.#&#6;4 ):
X
</p>
<p>fi
</p>
<p>&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7&#12;J
</p>
<p>!.&#3;
</p>
<p>E
</p>
<p>&#0;
</p>
<p>fi
</p>
<p>&#24;+*
</p>
<p>,
</p>
<p>fi
</p>
<p>Q
</p>
<p>E 7
</p>
<p>&#20; F
</p>
<p>O
</p>
<p>&#20; P
</p>
<p>J
</p>
<p>&#24;
</p>
<p>L&lt;M N
</p>
<p>&#31;
</p>
<p>6
</p>
<p>9
</p>
<p>7&#12;J
</p>
<p>! and 7 &#20; &#3;U&#31; &#0;&#2;&#1; 9 &#0;&#25;&#7; 9 &#13; &#13; &#13; 9 &#0; fi 9 &#13; &#13; &#13; 9 &#0; : ! F &#13;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Example 5.8 The grammar ecosystem:
</p>
<p>&#0;&#2;&#1;&#4;&#3; &#5;&#7;&#6; &#8;&#10;&#9; &#11;
</p>
<p>with:
</p>
<p>&#5;&#4;&#1;&#4;&#3; &#12;&#14;&#13;&#15;&#6; &#16;&#17;&#13;&#17;&#11;
</p>
<p>, where:
&#12;
</p>
<p>&#13;
</p>
<p>&#1;&#19;&#18; &#20;&#22;&#21;
</p>
<p>,
</p>
<p>&#16;
</p>
<p>&#13;
</p>
<p>&#1;&#19;&#18; &#20;&#7;&#23;&#25;&#24;&#26;&#20;&#14;&#21;
</p>
<p>.
</p>
<p>&#8;
</p>
<p>&#9;
</p>
<p>&#1;&#4;&#3; &#12;
</p>
<p>&#9;
</p>
<p>&#6; &#16;
</p>
<p>&#9;
</p>
<p>&#6; ff
</p>
<p>&#9;
</p>
<p>&#6; fi
</p>
<p>&#9;
</p>
<p>&#6; fl
</p>
<p>&#9;
</p>
<p>&#11;
</p>
<p>, where:
&#12;ffi&#9;&#31;&#1;&#19;&#18;  &#21;
</p>
<p>,
</p>
<p>&#16;&#31;&#9;&#31;&#1;&#19;&#18;  &#10;&#23;ffi&#24;&#26; &#21;
</p>
<p>,
</p>
<p>ff
</p>
<p>&#9;
</p>
<p>&#1;&#19;&#18; &#20;&#7;&#23;&#25;&#24;!&#20;#&quot; &#21;
</p>
<p>,
</p>
<p>fi
</p>
<p>&#9;
</p>
<p>&#3; $&#10;&#11;&#31;&#1;%&#16;
</p>
<p>&#9;
</p>
<p>, for every $'&amp;(&#12;*)&#13; ,
fl
</p>
<p>&#9;
</p>
<p>&#3; +ffi&#11;&#15;&#1;%ff
</p>
<p>&#9;
</p>
<p>, for every +,&amp;-&#12;*.&#9; .
</p>
<p>produces:
</p>
<p>/&#15;0 1
</p>
<p>&#3; &#0;2&#6; 3&#14;4 &#11;&#31;&#1;&#19;&#18;5&#3; &#20;&#14;&#6;  &#11; &#6; &#3; &#20;
</p>
<p>&quot;
</p>
<p>&#6;  &#11; &#6; &#3; &#20;#6 &#6;  &#11; &#6; 7 7 7 &#6; &#3; &#20;#8 9
</p>
<p>.
</p>
<p>&#9;
</p>
<p>&#6;  &#11; &#6; 7 7 7 &#21;
</p>
<p>,
</p>
<p>:&#31;&#13;&#31;&#3; &#0;2&#6; 3
</p>
<p>4
</p>
<p>&#11;&#31;&#1;&#19;&#18; &#20;
</p>
<p>8 9
</p>
<p>.
</p>
<p>&#9;
</p>
<p>&#6; ;&#31;&lt;&gt;=&#14;&#21;
</p>
<p>,
</p>
<p>:
</p>
<p>&#9;
</p>
<p>&#3; &#0;2&#6; 3&#14;4 &#11;&#31;&#1;&#19;&#18;  &#21;
</p>
<p>.
</p>
<p>If &#16;&#31;&#9; above is replaced by &#16;*?&#9; &#1;@&#18;  A&#23;ffi&#24;CB&#25;&#21; , the agent becomes inactive after the first step and
therefore does not act on the environment anymore:
</p>
<p>/&#15;0 1
</p>
<p>&#3; &#0;2&#6; 3
</p>
<p>4
</p>
<p>&#11;&#31;&#1;&#19;&#18;5&#3; &#20;&#14;&#6;  &#11; &#6; &#3; &#20;D&quot; &#6; Bffi&#11; &#21;
</p>
<p>,
</p>
<p>:
</p>
<p>&#13;
</p>
<p>&#3; &#0;2&#6; 3&#14;4 &#11;&#31;&#1;&#19;&#18; &#20;&#22;&#6; &#20;D&quot; &#21;#7
</p>
<p>Example 5.9 The grammar ecosystem:
</p>
<p>&#0;&#2;&#1;&#4;&#3; &#5;&#7;&#6; &#8;
</p>
<p>&#9;
</p>
<p>&#11;
</p>
<p>with:
</p>
<p>&#5;&#4;&#1;&#4;&#3; &#12;
</p>
<p>&#13;
</p>
<p>&#6; &#16;
</p>
<p>&#13;
</p>
<p>&#11;
</p>
<p>, where:
&#12;&#22;&#13;E&#1;&#19;&#18;
</p>
<p>0
</p>
<p>&#6; F&#25;&#21;
</p>
<p>,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0;&#2;&#1;&#4;&#3;&#6;&#5; &#7;&#9;&#8;&#11;&#10;&#12;&#7;&#14;&#13; &#15;&#4;&#8;&#11;&#10;&#12;&#15;&#17;&#16;
</p>
<p>.
</p>
<p>&#18;&#20;&#19;
</p>
<p>&#3;&#22;&#21; &#23;
</p>
<p>&#19;
</p>
<p>&#13; &#0;
</p>
<p>&#19;
</p>
<p>&#13; &#24;
</p>
<p>&#19;
</p>
<p>&#13; &#25;
</p>
<p>&#19;
</p>
<p>&#13; &#26;
</p>
<p>&#19; ff
</p>
<p>, where:
</p>
<p>&#23;
</p>
<p>&#19;
</p>
<p>&#3;&#6;&#5; fifl&#16;
</p>
<p>,
</p>
<p>&#0;
</p>
<p>&#19;
</p>
<p>&#3;&#6;&#5; fiffi&#8;&#11;&#10;&#31;fifl&#13; fiffi&#8;&#11;&#10;&#31;fi! &#16;
</p>
<p>,
</p>
<p>&#25;
</p>
<p>&#19;
</p>
<p>&#21; &#7;
</p>
<p>ff
</p>
<p>&#3;&#6;&#5; fiffi&#8;&#11;&#10;&#12;fi&quot; &#16;
</p>
<p>,
</p>
<p>&#25;
</p>
<p>&#19;
</p>
<p>&#21; &#15;
</p>
<p>ff
</p>
<p>&#3;&#6;&#5; fiffi&#8;&#11;&#10;&#31;fifl&#16;
</p>
<p>,
</p>
<p>&#24;
</p>
<p>&#19;
</p>
<p>&#3;&#6;&#5; &#7;&#9;&#8;&#11;&#10;&#12;&#15;fl&#13; &#15;&#4;&#8;#&#10;$&#15;&#11;&#16;
</p>
<p>,
</p>
<p>&#26;
</p>
<p>&#19;
</p>
<p>&#21; fi
</p>
<p>ff
</p>
<p>&#3;&#6;&#5; &#7;&#9;&#8;&#11;&#10;&#12;&#15;&#17;&#16;
</p>
<p>,
</p>
<p>&#26;
</p>
<p>&#19;
</p>
<p>&#21; fi&quot; 
</p>
<p>ff
</p>
<p>&#3;&#6;&#5;&#14;&#15;&#4;&#8;#&#10;$&#15;&#11;&#16;
</p>
<p>.
</p>
<p>produces:
</p>
<p>%
</p>
<p>&#19;
</p>
<p>&#21; &amp;'&#13; &#21; &#7;&#14;&#13; fi
</p>
<p>ff ff
</p>
<p>&#3;&#6;&#5; fi(&#13; fi
</p>
<p> 
</p>
<p>&#16;&quot;)
</p>
<p>5.4 Why Nonstandard Generative Mechanisms
</p>
<p>5.4.1 Adjoining
</p>
<p>Let *&quot;+
%'&#21; ,
</p>
<p>ff
</p>
<p>,
</p>
<p>,.-/&#5; ,
</p>
<p>*&quot;0
</p>
<p>&#13; &#24;&#20;132ffi&#16;
</p>
<p>, denote the family of languages generated by contextual
grammars with selection of type
</p>
<p>,
</p>
<p>. Some major results concerning the generative capacity of
contextual grammars are the following:
</p>
<p>4
</p>
<p>*&quot;+
</p>
<p>%'&#21; ,
</p>
<p>*!0
</p>
<p>ff65
</p>
<p>*!+
</p>
<p>%'&#21; &#24;&#9;132
</p>
<p>ff65
</p>
<p>*&quot;+
</p>
<p>%'&#21;
</p>
<p>+
</p>
<p>,
</p>
<p>ff65
</p>
<p>*!+
</p>
<p>%'&#21;
</p>
<p>+87
</p>
<p>ff95
</p>
<p>*&quot;+
</p>
<p>%'&#21; &#24;&#20;1
</p>
<p>ff
</p>
<p>)
</p>
<p>4
</p>
<p>&#24;&#20;132
</p>
<p>5
</p>
<p>*!+
</p>
<p>%'&#21; ,
</p>
<p>*&quot;0
</p>
<p>ff
</p>
<p>)
</p>
<p>4
</p>
<p>%
</p>
<p>*&quot;0 and + , are incomparable with all families *!+ %'&#21; ,
ff
</p>
<p>&#13;!,:-;&#5; &#24;&#20;132ffi&#13;
</p>
<p>+
</p>
<p>,&lt;&#13;
</p>
<p>+87
</p>
<p>&#13; &#24;&#20;1ffi&#16;&quot;&#13;
</p>
<p>but *!+ %'&#21; +87
ff95
</p>
<p>+37
</p>
<p>) (Incomparability, meaning that the respective differences are nonempty,
leads to eccentricity, which seems to be a linguistically valuable point to take into ac-
count.)
</p>
<p>4
</p>
<p>*&quot;+
</p>
<p>%'&#21; ,
</p>
<p>*!0
</p>
<p>ff
</p>
<p>is an abstract anti-family of languages, i.e. a set closed to none of the six
AFL operations: union, concatenation, Kleene star, morphisms, inverse morphisms and
intersection with regular languages.
</p>
<p>The latter result makes natural the question of finding the smallest AFL containing *&quot;+ %'&#21; , *!0
ff
</p>
<p>.
</p>
<p>The result is surprising.
</p>
<p>Theorem 5.10 For every %=-&gt;&#24;&#20;1@?!%A&#3;B%
&#19; C
</p>
<p>%9D
</p>
<p>,
</p>
<p>%
</p>
<p>&#19;
</p>
<p>-&gt;&#24;&#9;132
</p>
<p>,
</p>
<p>%9D'-
</p>
<p>*!+
</p>
<p>%'&#21; ,
</p>
<p>*&quot;0
</p>
<p>ff
</p>
<p>.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>So, iterated adjoining of contexts (i.e. paste), as selected by finite sets of strings, plus a left
quotient (i.e. cut) by a regular language are able to simulate any Turing machine. What is
needed is both: context-sensing and erasing abilities.
</p>
<p>The same could be got by using a one-sided internal contextual grammar, all whose contexts
are of the form
</p>
<p>&#0; &#1;&#3;&#2; &#4;&#6;&#5;
</p>
<p>. The family of languages generated by one-sided internal contextual
grammars is denoted by &#7; &#8;&#10;&#9;&#12;&#11;
</p>
<p>&#0; &#13;&#12;&#5; (with selection of type F).
</p>
<p>Theorem 5.11 For every &#11;&#15;&#14;&#17;&#16;&#19;&#18;&#21;&#20;&#6;&#11;&#23;&#22;
&#0;
</p>
<p>&#11;&#25;&#24; &#26;ff&#11;flfi
</p>
<p>&#5;&#3;ffi &#31;&quot;!
</p>
<p>, &#11;#&#24;&#25;&#14;&#17;&#16;&#19;&#18;&#12;$ , &#11;flfi&#25;&#14;%&#7; &#8;&#10;&#9;&#12;&#11;
</p>
<p>&#0;
</p>
<p>&#9;
</p>
<p>&#13;&amp;&#5;
</p>
<p>.
</p>
<p>5.4.2 Inserting
</p>
<p>An insertion grammar is a construct:
</p>
<p>$'&#22;
</p>
<p>&#0; &#31;(&#2; )&quot;&#2; *&amp;&#5;
</p>
<p>,
</p>
<p>where:
</p>
<p>+
</p>
<p>&#31;
</p>
<p>is an alphabet,
+
</p>
<p>)
</p>
<p>is a finite set of axioms,
+
</p>
<p>*
</p>
<p>is a finite set of triples
&#0; ,&#3;&#2; -.&#2; &#4;&#6;&#5;
</p>
<p>,
</p>
<p>,&#3;&#2; -&#3;&#2; &#4;
</p>
<p>&#14;
</p>
<p>&#31;&#12;! (insertion rules).
</p>
<p>The immediate derivation works as follows:
</p>
<p>/ 0ff1 2 3&#10;2 1 465
</p>
<p>&#2; 7
</p>
<p>&#14;
</p>
<p>&#31;
</p>
<p>!
</p>
<p>&#20;
</p>
<p>5
</p>
<p>&#22;&#3;8
</p>
<p>7
</p>
<p>if and only if
5
</p>
<p>&#22;
</p>
<p>5
</p>
<p>&#24;
</p>
<p>,9&#4;
</p>
<p>5
</p>
<p>fi
</p>
<p>&#2; 7
</p>
<p>&#22;
</p>
<p>5
</p>
<p>&#24;
</p>
<p>,6-:&#4;
</p>
<p>5
</p>
<p>fi
</p>
<p>&#2;
</p>
<p>5
</p>
<p>&#24;
</p>
<p>&#2;
</p>
<p>5
</p>
<p>fi&#25;&#14;
</p>
<p>&#31;
</p>
<p>!
</p>
<p>&#2; &#0; ,&#3;&#2; -.&#2; &#4;&#6;&#5;
</p>
<p>&#14;
</p>
<p>*&#25;;
</p>
<p>For an insertion grammar $ , one defines its weight
5
</p>
<p>:
</p>
<p>5
</p>
<p>&#0;
</p>
<p>$
</p>
<p>&#5;
</p>
<p>&#22;=&lt;?&gt;
</p>
<p>-&#3;@6A ,(A
</p>
<p>&#20;
</p>
<p>&#0; ,&#3;&#2; -.&#2; &#4;&#6;&#5;
</p>
<p>&#14;
</p>
<p>*
</p>
<p>0&#10;1
</p>
<p>&#0; &#4;9&#2; -&#3;&#2; ,:&#5;
</p>
<p>&#14;
</p>
<p>*&amp;B&#10;;
</p>
<p>The family of languages generated by insertion grammars of weight at most C , C&#17;DFE , is denoted
by &#8;&#6;G&#17;H9I . The union of all those families is &#8;&#10;G&#17;H&#3;J . The following results are known:
</p>
<p>+
</p>
<p>&#13;
</p>
<p>&#8;&#6;GLKF&#8;&#6;G&#17;H:MNKF&#8;&#6;G&#17;H
</p>
<p>&#24;
</p>
<p>K
</p>
<p>; ; ;
</p>
<p>K=&#8;&#10;G&#17;H
</p>
<p>J
</p>
<p>KF&#9;&amp;H
</p>
<p>;
</p>
<p>+
</p>
<p>&#16;&#19;&#18;&#12;$ is incomparable with all families &#8;&#10;G&#17;H I , C D'&#7; , and &#16;&#19;&#18;&#12;$&#21;KF&#8;&#6;G&#17;H J .
+
</p>
<p>&#8;&#10;G&#17;H&#3;&#24;&#25;K=&#9;
</p>
<p>&#13;
</p>
<p>, but &#9;
&#13;
</p>
<p>is incomparable with all families &#8;&#6;G&#17;H9I , C&#17;DPO , and &#8;&#6;G&#17;H:J .
+
</p>
<p>&#11;fl&#8;&#10;G is incomparable with all families &#8;&#10;G&#17;H:I , C&#17;D'&#7; , and &#8;&#10;G&#17;H:J .</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0; All families &#1;&#3;&#2;&#5;&#4;&#7;&#6; , &#8;&#5;&#9;&#11;&#10; , are anti-AFL&#8217;s.
</p>
<p>Theorem 5.12 For every &#12;&#14;&#13;&#5;&#15;&#17;&#16;&#19;&#18;&#20;&#12;&#22;&#21;&#11;&#12;&#24;&#23; &#25;&#26;&#12;fiff , &#12;fl&#23;fl&#13;&#5;&#15;ffi&#16; &#31; , &#12;fiff!&#13;
&#1;&#20;&#2;&#5;&#4;
</p>
<p>&#6;
</p>
<p>, &#8;&#5;&#9;#&quot; .
</p>
<p>What one does in this case is first to make use of insertion operations, and then to cut a prefix
of the string by means of a quotient with respect to a regular language. If the cutting operation
is introduced into the grammar, the so-called insertion-deletion grammars are obtained.
</p>
<p>An insertion-deletion grammar is a construct:
</p>
<p>&#31;$&#21;&amp;% ')( *ffi( +), ( +)-fi. ,
</p>
<p>where:
</p>
<p>&#0;
</p>
<p>' is an alphabet,
</p>
<p>&#0;
</p>
<p>* is a set of axioms,
</p>
<p>&#0;
</p>
<p>+/, is a set of insertion rules (a finite subset of ' 0!12'ffi0!12'ffi0 ),
&#0;
</p>
<p>+/- is a set of deletion rules (a finite subset of 'ffi0!12'ffi0!12'ffi0 ).
</p>
<p>The immediate derivation works as follows:
</p>
<p>for every 3ffi( 45&#13;2' 0 &#18;&#3;36&#21;8794 if and only if &#18;
</p>
<p>(i) either 36&#21;63!&#23; :&#7;;&#20;3&#24;ff ( 4&lt;&#21;&#11;3!&#23; :&gt;=&#7;;&#20;3&#24;ff ( % :?( =/( ;&#20;.fi&#13;2+/, ( 3!&#23; ( 3&#24;ff!&#13;2'ffi0 ,
</p>
<p>(ii) or 36&#21;63 &#23; :&gt;=8;&#3;3 ff ( 4 &#21;63 &#23; :&#7;;&#3;3 ff ( % :?( =/( ;&#20;.fl&#13;&#5;+ - ( 3 &#23; ( 3 ff &#13;2'ffi0 .
</p>
<p>The family of languages generated by insertion-deletion grammars is denoted by &#1;&#20;&#2;&#5;&#4;)@ &#16; &#12; .
</p>
<p>Theorem 5.13 For every &#12;&#14;&#13;&#5;&#15;&#17;&#16; , &#12;&#22;&#21;6&#12;fiA&#3;BC'ffi0 , for some &#12;)A8&#13; &#1;&#3;&#2;&#5;&#4;)@ &#16; &#12; .
</p>
<p>If the length of the strings that are inserted/deleted is taken into consideration, one can be more
precise: &#12;)A8&#13; &#1;&#20;&#2;&#5;&#4; ff
</p>
<p>&#23;
</p>
<p>@
</p>
<p>&#16; &#12;
</p>
<p>&#23;
</p>
<p>&#23;
</p>
<p>(i.e. strings of length at most one are inserted in contexts of weight
at most two, and strings of length at most one are deleted from contexts of weight at most one).
As well, &#12;)A belongs to both &#1;&#20;&#2;&#5;&#4; &#23;
</p>
<p>ff
</p>
<p>@
</p>
<p>&#16; &#12;fiD
</p>
<p>ff
</p>
<p>and &#1;&#20;&#2;&#5;&#4; ff
&#23;
</p>
<p>@
</p>
<p>&#16; &#12;fiD
</p>
<p>ff
</p>
<p>.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>5.4.3 Splicing
</p>
<p>A splicing rule over an alphabet &#0; is a string &#1;&#3;&#2;&#5;&#4;&#7;&#6; &#8;&#9;&#4;&#11;&#10; &#12; &#4;&#11;&#13; &#8;&#9;&#4;&#15;&#14; , &#4;&#15;&#16;&#18;&#17; &#0;&#20;&#19; , &#21;&#3;&#22;&#24;&#23;&#25;&#22;&#24;&#26; ,
&#8;fiff &#12;ffifl&#17;
</p>
<p>&#0;
</p>
<p>.
</p>
<p>The immediate derivation relation runs as follows:
</p>
<p>for every&#31;&#7;ff  &#11;ff !fi&#17; &#0;
&#19;#&quot;&#11;$
</p>
<p>&#31;&#7;ff  &#15;%'&amp;&#11;()! if and only if
&quot;
</p>
<p>(i) &#31;ffi&#2;&#3;&#31;
&#6;
</p>
<p>&#4;
</p>
<p>&#6;
</p>
<p>&#4;
</p>
<p>&#10;
</p>
<p>&#31;
</p>
<p>&#10;
</p>
<p>,
</p>
<p>(ii)  &#9;&#2;* +&#6; &#4;&#11;&#13; &#4;&#15;&#14;  ,&#10; ,
</p>
<p>(iii) !&#9;&#2;&#3;&#31;&#7;&#6; &#4;-&#6; &#4;&#15;&#14;  ,&#10; ,
</p>
<p>with &#31;&#7;&#6; ff &#31;-&#10; ff  +&#6; ff  ,&#10;.&#17; &#0;/&#19; .
</p>
<p>An 0 scheme is a pair 1ffi&#2;
$
</p>
<p>&#0;
</p>
<p>ff 2&#20;% , 243
</p>
<p>&#0;&#20;&#19;
</p>
<p>&#8;
</p>
<p>&#0;&#20;&#19;
</p>
<p>&#12;
</p>
<p>&#0;&#20;&#19;
</p>
<p>&#8;
</p>
<p>&#0;&#20;&#19; 5
</p>
<p>Given 16&#2;
$
</p>
<p>&#0;
</p>
<p>ff 2/% and a language 7&#3;3 &#0;&#20;&#19; , one defines:
</p>
<p>8
</p>
<p>1
</p>
<p>$
</p>
<p>7)%'&#2;49 !fi&#17;
</p>
<p>&#0;&#20;&#19;
</p>
<p>&quot;&#11;$
</p>
<p>&#31;:ff  &#15;%;&amp;
</p>
<p>(
</p>
<p>!&#15;ff &#31;&#7;ff  &#18;&#17;67.ff &#1;/&#17;62&#9;&lt; ,
</p>
<p>8
</p>
<p>1-=
</p>
<p>$
</p>
<p>7)%'&#2;*7 ,
</p>
<p>8
</p>
<p>1
</p>
<p>&#16; &gt;-&#6;
</p>
<p>$
</p>
<p>7)%'&#2;?1
</p>
<p>&#16;
</p>
<p>$
</p>
<p>7)%&#7;@&#25;1
</p>
<p>$
</p>
<p>1
</p>
<p>&#16;
</p>
<p>$
</p>
<p>7)% % ff &#23;;A*B ,
</p>
<p>8
</p>
<p>1
</p>
<p>&#19;
</p>
<p>$
</p>
<p>7)%'&#2;DC
</p>
<p>&#16; E&#15;F
</p>
<p>1
</p>
<p>&#16;
</p>
<p>$
</p>
<p>7)% .
</p>
<p>This allows the introduction of a new generative mechanism. An extended 0 system is a
construct:
</p>
<p>G
</p>
<p>&#2;
</p>
<p>$
</p>
<p>&#0;
</p>
<p>ff H.ff I/ff 2&#20;% ,
</p>
<p>where:
</p>
<p>8
</p>
<p>&#0; is an alphabet,
</p>
<p>8
</p>
<p>HD3
</p>
<p>&#0; is a set of terminal letters,
</p>
<p>8
</p>
<p>ID3
</p>
<p>&#0;&#20;&#19;
</p>
<p>is a set of axioms,
</p>
<p>8
</p>
<p>243
</p>
<p>&#0;&#20;&#19;
</p>
<p>&#8;
</p>
<p>&#0;/&#19;
</p>
<p>&#12;
</p>
<p>&#0;&#20;&#19;
</p>
<p>&#8;
</p>
<p>&#0;/&#19;
</p>
<p>.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>( &#0;&#2;&#1;&#4;&#3; &#5;&#7;&#6; &#8;&#10;&#9; is the underlying H scheme of &#11; .)
</p>
<p>The language generated by &#11; is:
</p>
<p>&#12;
</p>
<p>&#3;
</p>
<p>&#11;
</p>
<p>&#9;&#13;&#1;&#14;&#0;&#16;&#15; &#3; &#17;&#18;&#9;&#16;&#19;&#21;&#20;&#22;&#15; &#23;
</p>
<p>Given two families of languages &#24;&#13;&#25; &#6; &#24;ff&#26; , fiffifl &#3; &#24;&#13;&#25; &#6; &#24;&#7;&#26; &#9; denotes the family of languages &#12; &#3; &#11; &#9; &#6;
&#11;
</p>
<p>&#1;&#4;&#3; &#5;&#7;&#6; &#20;&#31;&#6; &#17;ffi&#6; &#8;&#10;&#9;
</p>
<p>, with &#17;! &#24;&#13;&#25; , &#8;&quot; &#24;&#7;&#26; . A surprising result is obtained again.
</p>
<p>Theorem 5.14 fiffifl &#3; &#24; &#25; &#6; &#24; &#26; &#9;&#7;&#1;#&#8; fi &#6; for every &#24; &#25; &#6; &#24; &#26;&#31;$ &#24;ffi%'&amp;)(#&#24; &#25; &#6;*&#8; fiffi+&#4;(#&#24; &#26; .
</p>
<p>Thus, by using nonstandard resources the greatest generative power is achieved, while keeping
the complexity of the mechanism at a very low level.
</p>
<p>6 Papers Cited
, Bresnan, J., R.M. Kaplan, S. Peters and A. Zaenen. 1982. &#8221;Cross-serial dependencies in
</p>
<p>Dutch&#8221;. Linguistic Inquiry, 13(4), 613&#8211;635.
, Culy, C. 1985. &#8221;The complexity of the vocabulary of Bambara&#8221;. Linguistics and Philos-
</p>
<p>ophy, 8, 345&#8211;351.
, Gazdar, G. 1981. &#8221;Unbounded dependencies and coordinate structure&#8221;. Linguistic In-
</p>
<p>quiry, 12(2), 155&#8211;184.
, Pullum, G.K. and G. Gazdar. 1982. &#8221;Natural languages and context-free languages&#8221;.
</p>
<p>Linguistics and Philosophy, 4, 471&#8211;504.
, Shieber, S.M. 1985. &#8221;Evidence against the context-freeness of natural language&#8221;. Lin-
</p>
<p>guistics and Philosophy, 8, 333&#8211;343.
</p>
<p>7 Further Reading and Relevant Resources
</p>
<p>Generally speaking, for a linguist wishing to be introduced into the field of mathematical meth-
ods in linguistics, which is a scope notably larger than the one taken in the present chapter,
Partee, ter Meulen and Wall (1990) is strongly recommended. It is a book thought for initiating
mathematically nontrained students. Brainerd (1971), Wall (1972) and Partee (1978) may be
still valid references, too. One chapter in Cole, Varile and Zampolli (1997) explains the main
trends for connecting different mathematical models with computational developments.
</p>
<p>The most comprehensive and updated handbook of classical as well as nonclassical formal
languages is Rozenberg and Salomaa (1997).
Very cited treatises in classical formal language theory (with different levels of difficulty)
include Aho and Ullman (1971-1973), Davis, Sigal and Weyuker (1994), Harrison (1978),
Hopcroft and Ullman (1979), Re&#769;ve&#769;sz (1991), Salomaa (1988), and Wood (1987). Other good</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>books (not all of them having a completely general scope) are Brookshear (1989), Dassow and
Pa&#774;un (1989), Drobot (1989), Floyd and Beigel (1994), Gurari (1989), Howie (1991), Kelley
(1995), Lewis and Papadimitriou (1981), Linz (1990), McNaughton (1982), Moll, Arbib and
Kfoury (1988), and Sudkamp (1988).
Some of the developments in nonstandard formal language theory can be found in Csuhaj-
Varju&#769;, Dassow, Kelemen and Pa&#774;un (1994), Pa&#774;un (1995), Pa&#774;un (1997), and Pa&#774;un, Rozenberg and
Salomaa (1998).
The present state-of-the-art of the field is well pictured in Mart&#305;&#769;n-Vide and Mitrana (2001a),
and Mart&#305;&#769;n-Vide and Mitrana (2001b).
The following references may be of help to the reader interested in knowing more about lin-
guistic applications of formal language theory: Kolb and Mo&#776;nnich (1999), Levelt (1974),
Manaster Ramer (1987), Mart&#305;&#769;n-Vide (1994), Mart&#305;&#769;n-Vide (1998), Mart&#305;&#769;n-Vide (1999), Mart&#305;&#769;n-
Vide and Pa&#774;un (2000), Pa&#774;un (1994), Savitch, Bach, Marsh and Safran-Naveh (1987), Savitch
and Zadrozny (1994), Sells, Shieber and Wasow (1991), and Zadrozny, Manaster Ramer and
Moshier (1993).
</p>
<p>References
</p>
<p>8 Books
</p>
<p>Aho, A.V., J.E. Hopcroft and J.D. Ullman. 1974. The design and analysis of computer algo-
rithms. Reading, MA: Addison-Wesley.
</p>
<p>Aho, A.V., R. Sethi and J.D. Ullman. 1986. Compilers: principles, techniques, and tools.
Reading, MA: Addison-Wesley.
</p>
<p>Aho, A.V. and J.D. Ullman. 1971-1973. The theory of parsing, translation and compiling, 2
vols. Englewood Cliffs, NJ: Prentice-Hall.
</p>
<p>Aho, A.V. and J.D. Ullman. 1977. Principles of compiler design. Reading, MA: Addison-
Wesley.
</p>
<p>Amos, M. 2001. Theoretical and experimental DNA computation. Berlin: Springer.
</p>
<p>Arbib, M.A. 1969. Theories of abstract automata. Englewood Cliffs, NJ: Prentice-Hall.
Atallah, M.J. (Editor). 1998. CRC handbook of algorithms and theory of computation. Boca
Raton, FL: CRC.
</p>
<p>Bavel, Z. 1983. Introduction to the theory of automata. Reston, VA: Reston.
Berstel, J. 1979. Transductions and context-free languages. Stuttgart: Teubner.
Berstel, J. and C. Reutenauer. 1988. Rational series and their languages. Berlin: Springer.
</p>
<p>Book, R.V. (Editor). 1980. Formal language theory: perspectives and open problems. New
York, NY: Academic Press.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>Booth, T.L. 1967. Sequential machines and automata theory. New York, NY: John Wiley.
</p>
<p>Brainerd, B. 1971. Introduction to the mathematics of language study. New York, NY: Elsevier.
Brainerd, W.S. and L.H. Landweber. 1974. Theory of computation. New York, NY: John Wiley.
Brookshear, J.G. 1989. Theory of computation: formal languages, automata, and complexity.
Redwood City, CA: Benjamin/Cummings.
Carroll, J. and D. Long. 1989. Theory of finite automata. Englewood Cliffs, NJ: Prentice-Hall.
Cohen, D.I.A. 1986. Introduction to computer theory. New York, NY: John Wiley. (2nd ed.,
1991.)
Cole, R., G.B. Varile and A. Zampolli (Editors). 1997. Survey of the state of the art in human
language technology. Cambridge: Cambridge University Press.
</p>
<p>Csuhaj-Varju&#769;, E., J. Dassow, J. Kelemen and Gh. Pa&#774;un. 1994. Grammar systems: a grammat-
ical approach to distribution and cooperation. London: Gordon and Breach.
</p>
<p>Dassow, J. and Gh. Pa&#774;un. 1989. Regulated rewriting in formal language theory. Berlin:
Springer.
</p>
<p>Davis, M.D. (Editor). 1965. The undecidable: basic papers on undecidable propositions, un-
solvable problems and computable functions. New York, NY: Raven.
Davis, M.D., R. Sigal and E.J. Weyuker. 1983. Computability, complexity, and languages: fun-
damentals of theoretical computer science. New York, NY: Academic Press. (2nd ed., 1994.)
Denning, P.J., J.B. Dennis and J.E. Qualitz. 1978. Machines, languages, and computation.
Englewood Cliffs, NJ: Prentice-Hall.
</p>
<p>Drobot, V. 1989. Formal languages and automata theory. Rockville, MD: Computer Science
Press.
</p>
<p>Eilenberg, S. 1974-1976. Automata, languages, and machines, 2 vols. New York, NY: Aca-
demic Press.
</p>
<p>Engeler, E. 1968. Formal languages. Chicago, IL: Markham.
</p>
<p>Floyd, R.W. and R. Beigel. 1994. The language of machines: an introduction to computability
and formal languages. Rockville, MD: Computer Science Press.
Ge&#769;cseg, F. and I. Pe&#769;ak. 1972. Algebraic theory of automata. Budapest: Akade&#769;miai Kiado&#769;.
Ge&#769;cseg, F. and M. Steinby. 1984. Tree automata. Budapest: Akade&#769;miai Kiado&#769;.
</p>
<p>Gill, A. 1962. Introduction to the theory of finite-state machines. New York, NY: McGraw-
Hill.
</p>
<p>Ginsburg, S. 1962. An introduction to mathematical machine theory. Reading, MA: Addison-
Wesley.
</p>
<p>Ginsburg, S. 1966. The mathematical theory of context-free languages. New York, NY:
McGraw-Hill.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Ginsburg, S. 1975. Algebraic and automata-theoretic properties of formal languages. Amster-
dam: North-Holland.
</p>
<p>Ginsburg, S., S. Greibach and J.E. Hopcroft. 1969. Studies in abstract families of languages.
Providence, RI: American Mathematical Society.
</p>
<p>Ginzburg, A. 1968. Algebraic theory of automata. New York, NY: Academic Press.
Gurari, E. 1989. An introduction to the theory of computation. New York, NY: Computer
Science Press.
</p>
<p>Harrison, M.A. 1965. Introduction to switching and automata theory. New York, NY:
McGraw-Hill.
</p>
<p>Harrison, M.A. 1969. Lectures on linear sequential machines. New York, NY: Academic Press.
</p>
<p>Harrison, M.A. 1978. Introduction to formal language theory. Reading, MA: Addison-Wesley.
Hennie, F.C. 1968. Finite-state models for logical machines. New York, NY: John Wiley.
Herken, R. (Editor). 1988. The universal Turing machine. Oxford: Oxford University Press.
Herman, G.T. and G. Rozenberg. 1975. Developmental systems and languages. Amsterdam:
North-Holland.
</p>
<p>Hofstadter, D.R. 1979. Go&#776;del, Escher, Bach: an eternal golden braid. New York, NY: Basic
Books.
</p>
<p>Hopcroft, J.E. and J.D. Ullman. 1969. Formal languages and their relation to automata. Read-
ing, MA: Addison-Wesley.
</p>
<p>Hopcroft, J.E. and J.D. Ullman. 1979. Introduction to automata theory, languages, and com-
putation. Reading, MA: Addison-Wesley.
</p>
<p>Howie, J.M. 1991. Automata and languages. Oxford: Oxford University Press.
</p>
<p>Ito, M. and H. Ju&#776;rgensen (Editors). 1994. Words, languages and combinatorics 2. Singapore:
World Scientific.
</p>
<p>Karhuma&#776;ki, J., H.A. Maurer, Gh. Pa&#774;un and G. Rozenberg (Editors). 1999. Jewels are forever.
Berlin: Springer.
</p>
<p>Karhuma&#776;ki, J., H.A. Maurer and G. Rozenberg (Editors). 1994. Results and trends in theoret-
ical computer science. Berlin: Springer.
</p>
<p>Kelley, D. 1995. Automata and formal languages: an introduction. Englewood Cliffs, NJ:
Prentice-Hall.
</p>
<p>Kolb, H.-P. and U. Mo&#776;nnich (Editors). 1999. The mathematics of syntactic structure: trees and
their logics. Berlin: Mouton de Gruyter.
</p>
<p>Kuich, W. and A. Salomaa. 1986. Formal power series and languages. Berlin: Springer.
</p>
<p>Kuich, W. and A. Salomaa. 1986. Semirings, automata, languages. Berlin: Springer.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>Leeuwen, J. van (Editor). 1990. Handbook of theoretical computer science, 2 vols. Amster-
dam/Cambridge, MA: North-Holland/MIT Press.
</p>
<p>Levelt, W.J.M. 1974. Formal grammars in linguistics and psycholinguistics, 3 vols. The
Hague: Mouton.
</p>
<p>Lewis, H.R. and C.H. Papadimitriou. 1981. Elements of the theory of computation. Englewood
Cliffs, NJ: Prentice-Hall.
</p>
<p>Linz, P. 1990. An introduction to formal languages and automata. Lexington, MA: D.C. Heath.
(2nd ed., 1996.)
Manaster Ramer, A. (Editor). 1987. Mathematics of language. Amsterdam: John Benjamins.
Marcus, S. 1967. Algebraic linguistics: analytical models. New York, NY: Academic Press.
</p>
<p>Mart&#305;&#769;n-Vide, C. (Editor). 1994. Current issues in mathematical linguistics. Amsterdam:
North-Holland.
</p>
<p>Mart&#305;&#769;n-Vide, C. (Editor). 1998. Mathematical and computational analysis of natural lan-
guage. Amsterdam: John Benjamins.
Mart&#305;&#769;n-Vide, C. (Editor). 1999. Issues in mathematical linguistics. Amsterdam: John Ben-
jamins.
Mart&#305;&#769;n-Vide, C. and V. Mitrana (Editors). 2001a. Grammars and automata for string pro-
cessing: from mathematics and computer science to biology, and back. London: Gordon and
Breach.
</p>
<p>Mart&#305;&#769;n-Vide, C. and V. Mitrana (Editors). 2001b. Where mathematics, computer science, lin-
guistics and biology meet. Dordrecht: Kluwer.
</p>
<p>Mart&#305;&#769;n-Vide, C. and Gh. Pa&#774;un (Editors). 2000. Recent topics in mathematical and computa-
tional linguistics. Bucharest: Editura Academiei Roma&#770;ne.
</p>
<p>McNaughton, R. 1982. Elementary computability, formal languages, and automata. Engle-
wood Cliffs, NJ: Prentice-Hall.
</p>
<p>Minsky, M.L. 1967. Computation: finite and infinite machines. Englewood Cliffs, NJ:
Prentice-Hall.
</p>
<p>Moll, R.N., M.A. Arbib and A.J. Kfoury. 1988. An introduction to formal language theory.
Berlin: Springer.
</p>
<p>Moore, E.F. (Editor). 1964. Sequential machines: selected papers. Reading, MA: Addison-
Wesley.
</p>
<p>Nelson, R.J. 1968. Introduction to automata. New York, NY: John Wiley.
</p>
<p>Nijholt, A. 1980. Context-free grammars: covers, normal forms and parsing. Berlin: Springer.
Nijholt, A. 1988. Computers and languages: theory and practice. Amsterdam: North-Holland.
Papadimitriou, C.H. 1994. Computational complexity. Reading, MA: Addison-Wesley.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Partee, B.H. 1978. Foundations of mathematics for linguistics. Harrisburg, PA: Greylock.
Partee, B.H., A.G.B. ter Meulen and R.E. Wall. 1990. Mathematical methods in linguistics.
Dordrecht: Kluwer.
</p>
<p>Pa&#774;un, Gh. (Editor). 1994. Mathematical aspects of natural and formal languages. Singapore:
World Scientific.
</p>
<p>Pa&#774;un, Gh. (Editor). 1995. Artificial life: grammatical models. Bucharest: Black Sea University
Press.
</p>
<p>Pa&#774;un, Gh. 1997. Marcus contextual grammars. Dordrecht: Kluwer.
</p>
<p>Pa&#774;un, Gh. (Editor). 1998. Computing with bio-molecules: theory and experiments. Singapore:
Springer.
</p>
<p>Pa&#774;un, Gh., G. Rozenberg and A. Salomaa. 1998. DNA computing: new computing paradigms.
Berlin: Springer.
</p>
<p>Pa&#774;un, Gh. and A. Salomaa (Editors). 1997. New trends in formal languages: control, cooper-
ation, and combinatorics. Berlin: Springer.
</p>
<p>Pa&#774;un, Gh. and A. Salomaa (Editors). 1999. Grammatical models of multi-agent systems. Lon-
don: Gordon and Breach.
</p>
<p>Paz, A. 1971. Introduction to probabilistic automata. New York, NY: Academic Press.
</p>
<p>Pin, J.-E. 1986. Varieties of formal languages. Oxford: Plenum. (Orig., 1984.)
Re&#769;ve&#769;sz, G.E. 1983. Introduction to formal languages. New York, NY: McGraw-Hill. (2nd ed.:
New York, NY: Dover, 1991.)
Rozenberg, G. and A. Salomaa. 1980. The mathematical theory of L systems. New York, NY:
Academic Press.
</p>
<p>Rozenberg, G. and A. Salomaa (Editors). 1986. The book of L. Berlin: Springer.
Rozenberg, G. and A. Salomaa (Editors). 1992. Lindenmayer systems: impacts on theoretical
computer science, computer graphics and developmental biology. Berlin: Springer.
</p>
<p>Rozenberg, G. and A. Salomaa (Editors). 1997. Handbook of formal languages, 3 vols. Berlin:
Springer.
</p>
<p>Rozenberg, G. and W. Thomas (Editors). 2000. Developments in language theory: founda-
tions, applications and perspectives. Singapore: World Scientific.
</p>
<p>Salomaa, A. 1969. Theory of automata. Oxford: Pergamon.
Salomaa, A. 1973. Formal languages. New York, NY: Academic Press.
</p>
<p>Salomaa, A. 1981. Jewels of formal language theory. Rockville, MD: Computer Science Press.
Salomaa, A. 1985. Computation and automata. Cambridge: Cambridge University Press.
</p>
<p>Salomaa, A. and M. Soittola. 1978. Automata-theoretic aspects of formal power series. Berlin:
Springer.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>Savitch, W.J., E.W. Bach, W. Marsh and G. Safran-Naveh (Editors). 1987. The formal com-
plexity of natural language. Dordrecht: Reidel.
Savitch, W.J. and W. Zadrozny (Editors). 1994. Mathematics of language, Linguistics and
Philosophy, 17(6). Dordrecht: Kluwer.
Sells, P., S.M. Shieber and T. Wasow (Editors). 1991. Foundational issues in natural language
processing. Cambridge, MA: MIT Press.
</p>
<p>Sikkel, K. 1996. Parsing schemata: a framework for specification and analysis of parsing
algorithms. Berlin: Springer.
</p>
<p>Sippu, S. and E. Soisalon-Soininen. 1988-1990. Parsing theory, 2 vols. Berlin: Springer.
</p>
<p>Sudkamp, T.A. 1988. Languages and machines. Reading, MA: Addison-Wesley.
</p>
<p>Trakhtenbrot, B.A. and Y.M. Barzdin. 1973. Finite automata. Amsterdam: North-Holland.
</p>
<p>Turing, A.M. 1992. Mechanical intelligence, ed. by D.C. Ince. Amsterdam, North-Holland.
</p>
<p>Wall, R.E. 1972. Introduction to mathematical linguistics. Englewood Cliffs, NJ: Prentice-
Hall.
</p>
<p>Wood, D. 1980. Grammar and L forms: an introduction. Berlin: Springer.
Wood, D. 1987. Theory of computation. New York, NY: John Wiley.
Zadrozny, W., A. Manaster Ramer and M.A. Moshier (Editors). 1993. Mathematics of lan-
guage, Annals of Mathematics and Artificial Intelligence, 8(1-2). Basel: J.C. Baltzer.
</p>
<p>9 Journals
Acta Cybernetica
</p>
<p>Acta Informatica
BioSystems
</p>
<p>Bulletin of the European Association for Theoretical Computer Science
Communications of the Association for Computing Machinery
Computational Intelligence
</p>
<p>Computational Linguistics
</p>
<p>Computers and Artificial Intelligence
Discrete Mathematics
</p>
<p>Fundamenta Informaticae
Grammars. A Journal of Mathematical Research on Formal and Natural Languages</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Carlos Mart&#305;&#769;n-Vide
</p>
<p>Information and Computation (before, Information and Control)
Information Processing Letters
International Journal of Computer Mathematics
International Journal of Foundations of Computer Science
Journal of Automata, Languages and Combinatorics
Journal of Computer and System Sciences
Journal of Logic, Language and Information
Journal of the Association for Computing Machinery
Journal of Universal Computer Science
Kybernetika
</p>
<p>Linguistics and Philosophy
</p>
<p>Mathematical Structures in Computer Science (before, Mathematical Systems Theory)
New Generation Computing
</p>
<p>Revue Franaise d&#8217;Automatique, Informatique et Recherche Ope&#769;rationelle (RAIRO): Informa-
tique The&#769;orique
</p>
<p>Revue Roumaine de Mathe&#769;matiques Pures et Applique&#769;es
</p>
<p>Theoretical Computer Science
</p>
<p>10 Major Conferences
&#0; ACL Annual Meeting of the Association for Computational Linguistics
&#0; AFL Conference on Automata and Formal Languages
&#0; AMiLP Algebraic Methods in Language Processing
&#0; CIAA International Conference on Implementation and Application of Automata
&#0; CLIN Computational Linguistics in the Netherlands Meeting
&#0; COLING International Conference on Computational Linguistics
&#0; DCAGRS Workshop on Descriptional Complexity of Automata, Grammars and Related
</p>
<p>Structures
&#0; DIMACS International Meeting on DNA Based Computing
&#0; DLT International Conference Developments in Language Theory
&#0; ESSLLI European Summer School of Logic, Language and Information</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Formal Languages for Linguists: Classical and Nonclassical Models
</p>
<p>&#0; FCT Fundamentals of Computation Theory
&#0; GS International Workshop Grammar Systems
&#0; ICALP International Colloquium on Automata, Languages and Programming
&#0; ICWLC International Colloquium on Words, Languages and Combinatorics
&#0; IWPT International Workshop on Parsing Technologies
&#0; LACL International Conference on Logical Aspects of Computational Linguistics
&#0; MCU International Conference on Machines, Computations and Universality
&#0; MFCS International Symposium on Mathematical Foundations of Computer Science
&#0; MOL Meeting on Mathematics of Language
&#0; UMC Conference on Unconventional Models of Computing
</p>
<p>11 Professional Associations
&#0; Association for Computational Linguistics, Special Interest Group on Mathematics of
</p>
<p>Language, http://www.cis.upenn.edu/ ircs/mol/mol.html
&#0; Association for Computing Machinery, Special Interest Group on Algorithms and Com-
</p>
<p>puting Theory, http://sigact.acm.org/
&#0; European Association for Theoretical Computer Science, http://www.eatcs.org/
</p>
<p>12 Web Sites
&#0; American Mathematical Society Preprint Server, http://www.ams.org/preprints/
&#0; Collection of Computer Science Bibliographies, http://liinwww.ira.uka.de/bibliography/index.html
&#0; Computing Research Repository, http://xxx.lanl.gov/archive/cs/intro.html
&#0; Mathematics WWW Virtual Library, http://euclid.math.fsu.edu/Science/math.html
&#0; Networked Computer Science Technical Reference Library, http://www.ncstrl.org/
</p>
<p>13 Research Centres
&#0; Leiden Institute of Advanced Computer Science, http://www.wi.leidenuniv.nl/CS/
&#0; Turku Centre for Computer Science, http://www.tucs.fi/</p>

</div></div>
</body></html>