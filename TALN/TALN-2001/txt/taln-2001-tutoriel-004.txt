
Formal Languages for Linguists: Classical and Nonclassical
Models
Extended version of the chapter 8: C. Mart́ın-Vide, Formal grammars and languages, in R.
Mitkov, ed., Oxford Handbook of Computational Linguistics. Oxford University Press, Oxford,
2001.
Carlos Mart́ın-Vide
Research Group on Mathematical Linguistics
Rovira i Virgili University
Pl. Imperial Tàrraco, 1
43005 Tarragona, Spain
E-mail: cmv@correu.urv.es, cmv@nil.fut.es
Web: http://www.urv.es/centres/Grups/grlmc/grlmc.html
Abstract
The basics of classical formal language theory are introduced, as well as a wide coverage is
given of some new nonstandard devices motivated in molecular biology, which are challenging
traditional conceptions, are making the theory revived and could have some linguistic relevance.
Only definitions and a few results are presented, without including any proof. The chapter
can be profitably read without any special previous mathematical background. A long list of
references completes the chapter, which intends to give a flavour of the field and to encourage
young researchers to go deeper into it.
1 Languages

1.1 Basic Notions

✂✁
An alphabet or vocabulary is a finite set of letters. By concatenating the letters from again
✄ and contains no letter: it is the unit element of  ✂✁ under the concatenation operation. The
and again, one obtains , an infinite set of strings or words. The empty string is denoted by
☎✁
concatenation of strings is an associative and noncommutative operation, which closes , i.e.:

for every ✆✞✝   ✟✡✠  ✂✁☞☛ ✆✌✟✡✠  ✞✁ ✍
The length of a string, denoted by   ✎ ✆☎✎ , is the number of letters the string consists of. It is clear
that:

✏ ✎ ✄ ✒✎ ✑✔✓   ,
Carlos Mart́ın-Vide
✂✁ ✄✆☎✝✁✟✞✠✁ ✄✡✁ ☛✂✁ ☎☞✁ ✌
✄ is a substring or subword of         ☎   if and only if there exist   ✍☞✎ ✏ ✍✒✑ such that ☎✡✞ ✍☞✎ ✄ ✒✍ ✑ ✌ Special
cases of a substring include:

if ✄✠✞✂✓ ✔ and ✄✠✞✕✓ ☎ , then ✄ is a proper substring of ☎ ,
if ✍ ✎ ✞✂✔ , then ✄ is a prefix or a head,
if ✍✒✑ ✞✂✔ , then ✄ is a suffix or a tail.
The i-times iterated concatenation of ✄ is practically showed in the following:

Example 1.1 If ✄✕✞✕✖✘✗ ✏ then ✄✆✙✚✞✜✛ ✖✘✗ ✢ ✙✣✞✕✖✤✗ ✖✤✗ ✖✤✗ ✌ (✄✆✥✚✞✂✔✝✌ )

If ✄✕✞✦✖ ✎ ✖ ✑ ✌ ✌ ✌ ✖✟✧ , then its mirror image ✄✩★ ✞✕✖✟✧✤✖✟✧ ★ ✎ ✌ ✌ ✌ ✖ ✎ ✌ It is clear that:

✛ ✄✩★ ✎ ✢ ★ ✎ ✞✕✄ , ✛ ✄✩★ ✎ ✢ ✪✝✞✜✛ ✄✣✪ ✢ ★ ✎ (for every ✫✭✬✕✮ ).
Any subset     ✯✦✰✕✱✳✲                       ✴
(including both and     ✵ ✔✝✶ ) is a language. One denotes ✱✸✷ ✞ ✱✸✲✺✹✻✵ ✔✝✶✤✌
Regarding cardinality (generally, the number of elements a set contains):

✳✱ ✲ is denumerably infinite, i.e. ✁ ✱✸✲ ✁✤✞✕✼ ✥ (the smallest transfinite number),
✾✽✿✛ ✱✸✲ ✢ is nondenumerably infinite, i.e. ✁ ✽✿✛ ✱✸✲ ✢ ✁✤✞✕❀✟❁ ❂ (also called ✼ ✎ ).
We do not go here deeper into the details of infinite sets, which would require an extensive
presentation.

Examples of languages include:

✯  ✞ ✵ ✖ ✏ ✗ ✏ ✔✝✶ , ✯ ✞ ✵ ✖✟✪ ✏ ✗ ✪✭❃ ✫✺✬✕✮ ✶ , ✯ ✞ ✵ ✄✩✄✩★ ✎ ❃✘✄❅❄ ✱✸✲ ✶ , ✯ ✞ ✵ ✖ ✧ ❆ ❃✘❇ ✬❅❈ ✶ ,
✯ ✞ ✵ ✄✂❃✤✄✂❄ ✵ ✖ ✏ ✗ ✶ ✷ and ✁ ✄❉✁ ❊✣✞✠✁ ✄✡✁ ❋ ✶ ( ✁ ✄✡✁ ● denotes the number of occurrences of x in w).
Example 1.2
1.2 Chomsky Grammars. The Chomsky Hierarchy

❍ ❅ ✞ ✛ ■ ✏ ❏✣✏ ❑▲✏ ▼ ✢     ■ ✏ ❏ are alphabets, with ■❅◆ ❏ ✞
✴ ❑ ❄❅■          ▼ ■❘✌ ✛ ✄ ☎✘✢                ✛ ✄   ☎ ❖ ✢      ✄
✏ ✄❚❙❯☎❖✌ ✏ ■ ❄✠✛ ■◗ ❏ ✢ ✲ and ✄ contains at
☎ ✻
A (formal) grammar is a construct                   , where

,         and is a finite set of pairs       such that

❏                             ❑                                      ▼ the set of rewriting rules or
least one letter from   (       uses to be written        )             is the nonterminal alphabet,
the terminal alphabet, the initial letter or axiom, and
productions.

Given ❍ ✞❱✛ ■ ✏ ❏✣✏ ❑▲✏ ▼ ✢ and ✄ ✏ ☎❘❄✦✛ ■❲ ❏ ✢ ✲ , an immediate or direct derivation (in 1 step)
✄✦✞✝❳✻❨❩☎ holds if and only if:
Formal Languages for Linguists: Classical and Nonclassical Models
(i) there exist  ✂✁ ✄  ✆☎✞✝✠✟ ✡☞☛✍✌✏✎ ✑ such that ✒✔✓            ✂✁ ✕✖ ✆☎ and ✗✘✓  ✂✁ ✙✚ ✆☎ , and

(ii) there exists ✕✜✛✚✢✣✙✜✝✥✤✞✦
Given ✧★✓ ✟ ✡✩✄ ✌✪✄ ✫✖✄ ✤✬✎ and ✒ ✄ ✗ ✝✭✟ ✡✮☛✥✌✏✎ ✑ , a derivation ✒✯✓✂✰ ✑✱ ✗ holds if and only if
either ✒✲✓✲✗ or there exists ✳ ✝✠✟ ✡☞☛✍✌✏✎ ✑ such that ✒✔✓✂✰ ✑✱ ✳ and ✳✴✓✂✰
✱ ✗ ✦

✓✂✰ ✱✑ denotes the reflexive transitive closure and ✓✚✰✶✱✵ the transitive closure, respectively, of
✓✂✰ ✱ ✦

The language generated by a grammar is defined by:

✷ ✟ ✎
✧ ✓✹✸ ✒✔✺ ✫ ✓✚✰ ✱✑ ✒ and✒ ✝✻✌ ✑ ✼ ✦
Example 1.3 Let ✧✽✓            ✟ ✡✩✄ ✌✪✄ ✫✖✄ ✤✬✎ be a grammar such that:

✡  ✓✹✸ ✫✖✄ ✾✏✄ ✿ ✼ ,
✌ ✓✹✸ ❀ ✄ ❁ ✼ ,
✤     ✓❂✸ ✫❃✛✚✢ ❀ ✘ ✿ ✄ ✫★✛✂✢❄❁ ✾✬✄ ✾❅✛✚✢               ❀ ✄ ✾❅✛✂✢    ❀ ✫✖✄ ✾❂✛✂✢❄❁ ✾❆✾✏✄ ✿❇✛✂✢❄❁ ✄ ✿❇✛✂✢
❁ ✫✖✄ ✿✭✛✚✢ ❀ ✿✬✿ ✼ ✦

The language generated by G is the following:

✷ ✟ ✎
✧ ✓✹✸ ✒✔✺❈✒ ✝ ✸ ❀ ✄ ❁ ✼ ✵ and ❉ ✒✘❉ ❊✞✓❋❉ ✒✴❉ ● ✼ ✦
Example 1.4 Let ✧✽✓            ✟ ✡✩✄ ✌✪✄ ✫✖✄ ✤✬✎ be a grammar such that:

✡  ✓✹✸ ✫✖✄ ✾✏✄ ✿ ✼ ,
✌ ✓✹✸ ❀ ✄ ❁ ✄ ❍ ✼ ,
✤     ✓ ✸ ✫❏✛✚✢
■                ❀ ❁ ❍ ✄ ✫❏✛✂✢     ❀ ✾✪❁ ❍ ✄ ✾✪❁✔✛✚✢❑❁ ✾✬✄ ✾✪❍✹✛✂✢❑✿✴❁ ❍ ❍ ✄ ❁ ✿▲✛✂✢❑✿✴❁ ✄ ❀ ✿▲✛✂✢
❈❀ ❀ ✾✏✄ ❀ ✿✭✛✂✢ ❈❀ ❀    ✼ ✦
The language generated by G is the following:

✷ ✟ ✎
✧ ✓✔✸ ❀❈▼ ❁ ▼ ❍ ▼✴✺❈◆✥❖✹ ✼ ✦

Grammars can be classified according to several criteria. The most spread one is the form of
their productions. According to it, a grammar is said to be of type:
Carlos Mart́ın-Vide
0 (phrase-structure grammar, RE) if and only if there are no restrictions on the form of
the productions: everything at both the left-hand side and the right-hand side of the rules
is allowed.
1 (context-sensitive grammar, CS) if and only if every production is of the form:

✁✄✂ ☎✆✁✞✝✠✟☛✡☞✁✄✂ ✌✍✁✞✝ ✎

with ✁✄✂ ✎ ✁✞✝ ✎ ✌✑✏✓✒ ✔✖✕✘✗✆✙ ✚ , ☎✑✏✛✔ and ✌✖✢✑
✜ ✣ (except possibly for the rule ✤   ✟✄✡   ✣ , in
which case ✤ does not occur on any right-hand side of a rule).
2 (context-free grammar, CF) if and only if every production is of the form:

☎✥✟☛✡☞✌✦✎

with ☎✥✏✧✔ , ✌✥✏★✒ ✔✩✕✪✗✫✙ ✚ ✬
3 (regular or finite-state grammar, REG) if and only if every production is of any of
the forms:

☎✥✟☛✡☞✌✆✭✮✎
☎✥✟☛✡☞✌✦✎

with ☎✫✎ ✭✩✏✧✔ , ✌✥✏✯✗ ✚ ✬
A language is said to be of type ✰ (✰ ✢✖✱ ✎ ✳✲ ✎ ✴✳✎ ✵ ) if it is generated by a type ✰ grammar. The
family of type ✰ languages is denoted by ✶✸✷ ✬

One of the most important and early results in formal language theory is the so-called Chomsky
hierarchy of languages: ✶✠✹✍✺✓✶ ✝ ✺✻✶ ✂ ✺✓✶✠✼ ✬

Note that every grammar generates a unique language. However, one language can be generated
by several different grammars.

Two grammars are said to be:

(weakly) equivalent if they generate the same string language,
strongly equivalent if they generate both the same string language and the same tree
language.
(We shall see later that a context-free grammar generates not only a set of strings, but a set of
trees too: each one of the trees is associated with one string and pictures the way how this latter
is derived in the grammar.)
Formal Languages for Linguists: Classical and Nonclassical Models
1.3 Operations on Languages

Usual set-theoretic operations on languages include:

✁✄✂✆☎✝✁✟✞✄✠☛✡ ☞✍✌✎☞☛✏✑✁✄✂ ☞✍✏✑✁✟✞ ✒✎✓
Union:              or
Intersection: ✁✄✂✆✔✕✁✟✞✖✠☛✡ ☞✍✌✎☞✍✏✑✁✄✂ and ☞✍✏✑✁✟✞ ✒✎✓
Difference: ✁ ✂✘✗ ✁ ✞ ✠☛✡ ☞✍✌✎☞✍✏✑✁ ✂ and ☞✚✏✑
✙ ✁ ✞ ✒✎✓
Complement of ✁✜✛✍✢✤✣ with respect to ✢✤✣✥✌✟✧    ✦✁ ✠✍✢✤✣ ✗ ✁✖✓

Specific language-theoretic operations on languages include:
✁✄✂ ✁✟✞✖✠☛✡ ☞✥✂ ☞✖✞✥✌✎☞✥✂✄✏✑✁✄✂            ☞✖✞✥✏✑✁✟✞ ✒✎✓
Concatenation:                                              and
Iteration:
✁✟★✖✠☛✡✪✩✫✒ ,
✁ ✂ ✠✬✁ ,
✁ ✞ ✠✬✁✟✁
✓✓✓
✁✟✣✖✠✮✭ ✁ ✯
✯ ✰ ★ (closure of the iteration: Kleene star),
✁✟✱✑✠ ✭ ✁ ✯ (positive closure of the iteration: Kleene plus).
✯✰ ✂
✁ ✱                     ✁ ✣ ✩✕✏✑✁                       ✁ ✣ ✗ ✡✪✩✫✒ ✩✜✏✑    ✙ ✁✖✓
Note that          equals               if           , and equals                if
✁✄✲ ✂ ✠☛✡ ☞✍✌✳☞✴✲ ✂ ✏✑✁✖✒✎✓
Mirror image:
✁ ✄ ✲ ✂ ✶ ✲ ✂ ✠✷✁                 ✁ ✄ ✲  ✂✶✯ ✠ ✁ ✯✶✲ ✂                         ✓
Note that ✵                             and ✵                 ✵      , for every ✸✟✹✷✺
✁ ✂          ✁ ✞ ✁ ✂ ✙ ✁ ✞ ✠☛✡ ☞✍✌                          ✏✑✁ ✞             ☞ ✏✑✁ ✂ ✒✎✓
Right quotient of                      over :                          there exists ✻            such that ✻
✁                  ✁✧✠✬✁✄✙✎✡ ✻ ✒✴✠☛✡ ☞✍✌✳☞ ✻ ✏✑✁✖✒✎✓
Right derivative of over ✻ : ✼✾✿ ✽
✁   ✛ ✬  ❀
✢   ✣                    ✁   ✶ ✠☛✡ ☞✍✏❅✢✤✣✥✌                        ✏❅✢❀✣ such that ☞ ✻ ✏✑✁✖✒✎✓
: ❁✝❂❀❃✴❄✑✵                               there exists ✻
Head of
✁✜✌✎✁✜✛ ❁✑❂❀❃✥❄✑✵ ✁ ✓          ✶
Note that for every
✁✄✂ over ✁✟✞ : ✁✟✞ ❆✪✁✄✂✄✠☛✡ ☞✍✌ there exists ✻ ✏✑✁✟✞ such that ✻ ☞✍✏✑✁✄✂ ✒✎✓
Left quotient of
✁                    ✁✧✠☛✡ ✻ ✒✪❆✪✁❈✠☛✡ ☞✍✌ ✻ ☞✍✏✑✁✖✒✎✓
Left derivative of over ✻ : ✼✾✿ ❇
✁✜✛✬✢✤✣ ❉✴❃✥❊ ✁ ✵ ✁ ✶ ✠☛✡ ☞✍✏❅✢✤✣✥✌                                       ✏❅✢✤✣                  ☞✍✏✑✁✖✒✎✓
Tail of              :                                      ✶     there exists ✻             such that ✻
Note that for every
✁✜✌✎✁✜✛ ❉✴❃✥❊ ✁ ✵ ✁ ✓
✢ ✂❋✢✞                ● ✌✾✢✤✂ ✣ ✗■❍ ✢❀✞ ✣
Morphism: Given two alphabets                          , a mapping                            is a morphism if and
only if:
☞✍✏❅✢✤✂ ✣                      ✏
❅  ✢
❀ ✞ ✣             ✠     ☞ ✶
, there exists ✻              such that ✻   ●■✵             and ✻ is unique,
☞ ❋ ❏ ✏❅✢✤✂ ✣ ✌ ●■✵ ☞ ❏ ✶ ✠ ●■✵ ☞ ✶ ■● ✵ ❏ ✶ ✓
(i)   for every
(ii)   for every
Carlos Mart́ın-Vide
✄✁ ✂✆☎✞✟ ✝ , if ✁✡☛ ✠   then ☞✍✌ ✁✏✎✑☛ ✠  ✍✒
✓ Morphic image: ☞✍✌ ✔✕✎ ☛✗✖ ✘ ✂✆☎✏✙✛✝ ✚ ✘✜☛ ☞✍✌ ✁✏✎ ✢ for some ✁✄✂✣✔✥✤ ✒
A morphism is called -free if, for every
✓ A morphism
✒    is called an isomorphism if, for every ✁✞✢ ✦✄✂✡☎✜✟ ✝ , if ☞✍✌ ✁✏✎ ☛ ☞✍✌ ✦✧✎ then
✁ ☛ ✦
Example 1.5 An isomorphism between ☎ ✟ ☛★✖ ✩ ✢ ✪✫✢ ✬✭✢
✒ ✒ ✒ ✢ ✮✯✤ and ☎ ✙ ☛✰✖ ✩ ✢ ✪✫✤ is the
binary coded decimal representation of the integers:

☞✍✌ ✩ ✎ ☛✱✩✲✩✫✩✲✩ ✢ ☞✍✌ ✪✫✎ ☛✱✩✫✩✲✩ ✪✲✢ ✒ ✒ ✒ ✢ ☞✍✌ ✮✲✎ ☛ ✪ ✩✫✩ ✪ ✒
Union, concatenation and Kleene star are called regular operations.

Theorem 1.6 Each of the language families                 ✳✥✴ , for every ✵✆✂ ✖ ✩ ✢ ✪✫✢ ✬✭✢ ✶✭✤ , is closed under
regular operations.

A systematic study of the common properties of language families has led to the theory of
abstract families of languages (AFL’s). An abstract family of languages is a class of those
languages that satisfy certain specified closure axioms. If one fixes an AFL, one can prove
general theorems about all languages in the family.

A few simple closure properties are depicted next:

REG        CF CS            RE
union            +         +  +             +
intersection           +         –  +             +
complement              +         –  +             –
concatenation             +         +  +             +
Kleene star           +         +  +             +
intersection with regular languages              +         +  +             +
morphisms             +         +  –             +
left/right quotient            +         –  –             +
left/right quotient with regular languages              +         +  –             +
left/right derivative            +         +  +             +
mirror image             +         +  +             +

The table must be interpreted in the following way. Using the first to the left as an example,
it means that the union of two regular languages is always a regular language. And so on.
2 Grammars

2.1 Context-Free Grammars

Theorem 2.1 For every CF grammar , one can find an equivalent CF grammar                               ✂✺✔✑✸✞✌ ✸✞✹ such
✒✎ In that
the right-hand sides of its productions are all different from except when                                               this
Formal Languages for Linguists: Classical and Nonclassical Models
latter case,
✂✁☎✄✝✆                                                 ✆
is the only rule with the right-hand side , but then
does not occur on
any right-hand side of the rules. (This is also true for REG grammars.)

A grammar is said to be -free if none of its rules has the right-hand side
✆☎✞
An CF grammar is said to be in Chomsky normal form (CNF) if each of its rules has either of
the two following forms:

✟✡✠ ☛✁ ✄✌☞ , ✠✎✍✑✏ , ☞ ✍✓✒ ,
✟✡✠ ☛✁ ✄✌✔✖✕ , ✠✑✗ ✔ ✗ ✕ ✘✍ ✏ ✞
Theorem 2.2 For every -free CF grammar, one can effectively (algorithmically) find an equiv-
alent grammar in CNF.

✚✜✛ ✢✤✣
Theorem 2.3 For every CF grammar G, it is decidable whether or not an arbitrary strings
belongs to   .

✢                             ✚        ✚✦✥✧✚✜✛ ✢✖✣          ✚✩★
✚✜✛ ✢✖✣✫✪✭✬
Corollary 2.4 Given an CF grammar                and a finite language , both                     and
are solvable.
2.2 Derivation Trees

A very common and practical representation of the derivation process in a grammar (particu-
larly, in an CF grammar) is a tree.
✒ ✪✮✛ ✯ ✗ ✰ ✣           ✯                                       ✰
A derivation tree is defined as             , where is a set of nodes or vertices and                    is a
dominance relation, which is a binary relation in that satisfies:

(i) D is a weak order:
☞ ✍ ✲✯☞✱☞✰ ☞, ☞                     ☞ ☞
(i.b) antisymmetric: for every ✗ ✳✴✍ ✯ , if ✰✵✳ and ✳ ✰ , then ✪ ✳ ,
(i.a) reflexive: for every

(i.c) transitive: for every ✗ ✳ ✗ ✶✴✍ ✯ , if ✵
☞ ✰ ✳ and ✳ ✰✵✶ , then ☞ ✰✵✶ ✞
(ii) root condition: there exists ✷ ✍ ✯ such that for every ✳✴✍ ✯✲✱✸✷ ✰✵✳ ,
☞ ☞✸✹              ☞
(iii) nonbranching condition: for every ✗ ✗ ✳✴✍ ✯ , if ✰✵✳ and ✰✵✳ , then ✰
☞✺✹     ☞ ☞✸✹ or ☞✺✹ ✰ ☞✻✞
Special cases of the dominance relation include, for every ✗ ✳✴✍ ✯ :
✟ ☞ strictly dominates ✳ (☞✼  ✰✵✳ ) if and only if ☞ ✰✵✳ and ☞✑✪ ✽ ✳ ; so   ✰ is a strict order in ✯        :
☞✾  ☞
(i) irreflexive: it is not the case that ✰ ,
Carlos Mart́ın-Vide
(ii) asymmetric: if  ✂✁☎✄✝✆ , then it is not the case that ✆ ✁☎✄✝  ,
(iii) transitive: if  ✂✁☎✄✝✆ and ✆ ✁☎✄✝✞ , then  ✂✁☎✄✝✞ ✟
✠✡  immediately dominates ✆ ( ☞☛✂✄✝✆ ) if and only if  ✂✁☎✄✝✆ and there does not exist any ✞
such that  ✂✁☎✄✝✞ and ✞ ✁☎✄✝✆ ✟
The degree of a node ✌☞✍ ✎✑✏ ✆ ✒☎✓✕✔ ✖  ✘✗✚✙✕✛☞✆ ☛✂✄✝ ✢✜✢✔ ✟ Consequences of this definition are:

✠✡✆ is a terminal node or a leaf if and only if ✌✂✍ ✎✣✏ ✆ ✒✤✓✦✥ ,
✠✡✆ is a unary node if and only if ✌☞✍ ✎✑✏ ✆ ✒☎✓★✧ ,
✠✡✆ is a branching node if and only if ✌✂✍ ✎✣✏ ✆ ✒✪✩✦✧ ,
✠✬✫ is an n-ary derivation tree if and only if all its nonterminal nodes are of degree ✭ ✟
Two nodes  ✢✮ ✆ are independent of each other:  ✂☛☞✯✰✄✝✆ if and only if neither  ☞✄✝✆ nor ✆ ✄✝ ✢✟

Some family relations among nodes include:

✠✡  is a mother node of ✆ :  ✢✱✦✆ if and only if  ✂☛☞✄✝✆ ,
✠✡  is a sister node of ✆ :  ✂✁☎✆ if and only if there exists ✌ such that ✌ ✱✦  and ✌ ✱✦✆ ✟
The mother relation has the following features:

(i) there does not exist any  ✘✗✚✙       such that  ✂✱✦✲ ,

(ii) if ✆✴✓✦
✳ ✲ , then it has just one mother node.
Given ✫✵✓ ✏ ☎ ✙ ✮ ✄✶✒ , for every ✆✝✗✷✙ , a derivation subtree or a constituent is ✫✣✸✹✓                   ✏ ✙✺✸ ✮ ✄✻✸ ✒ ,
where ✙ ✸ ✓✼✖ ✹✞ ✗✚✙✽✛✂✆ ✄✝✞ ✜ and ✾ ✄ ✸ ✿ if and only if ✾ ✗✚✙ ✸ and ✿ ✗✚✙ ✸ and ✾ ✄ ✿ ✟

Given ✫✦✓    ✏ ✙☎✮ ✄✶✒ , for every  ✢✮ ✆✹✗✚✙ :   c-commands ✆ (aCCb) if and only if:

(i)  ☞☛✂✯✰✄✝✆ ,

(ii) there exists a branching node that strictly dominates   ,

(iii) every branching node that strictly dominates   dominates ✆ ✟

asymmetrically c-commands ✆ if and only if  ☞❀✴❀❁✆ and it is not the case that ✆ ❀✴❀❁ ✺✟

Given two derivation trees ✫✦✓      ✏ ✙☎✮ ✄✶✒ , ❃
✫ ❂✢✓   ✏ ✙✹❂ ✮ ✄✘❂ ✒ and ❄ ✛✂✙★❅❆✙✹❂✺✛

✠ ❄ preserves ✄     if and only if for every  ✢✮ ✆✹✗✚✙✽✛☞ ✂✄✝✆❇❅         ❄✣✏  ✂✒ ✄✝❂ ❄✣✏ ✆ ✒ ✟
Formal Languages for Linguists: Classical and Nonclassical Models
✂✁   is an isomorphism of       ✄ in ✄✆☎✞✝ ✄✠✟✠✄✡☎ ☛ if and only if ✁ is a bijection and preserves ☞✍✌
(Note that a mapping ✎✑✏✓✒✠✔✖✕ is a bijection if and only if:

(i) ✎ is one-to-one or injective: for every ✗✙✘ ✚✜✛✢✒✣✘ if ✗✥✦ ✤ ✚ then ✎✧✝ ✗✙☛✑✦ ✤ ✎★✝ ✚✩☛ or,
equivalently, if ✎✧✝ ✗✙☛ ✦ ✎★✝ ✚✩☛ then ✗ ✦ ✚ ,
(ii) ✎ is onto or exhaustive: for every ✪✫✛✑✕✥✏ there exists ✗✑✛✑✒ such that ✎✧✝ ✗✙☛ ✦ ✪✬✌ )
Any two isomorphic derivation trees share all their properties:

✮✭✬✯ ☞✱✰ if and only if ✁ ✝ ✭ ☛ ✯ ☞✫☎ ✁ ✝ ✰ ☛ ,
✮✭✓✲ ☞✱✰ if and only if ✁ ✝ ✭ ☛ ✲ ☞✫☎ ✁ ✝ ✰ ☛ ,
✮✳✓✴ ✵ ✝ ✭ ☛ ✦ ✳✬✴ ✵ ✝ ✁ ✝ ✭ ☛ ☛ ,
✮✭✓✶✣✶ ✰ if and only if ✁ ✝ ✭ ☛ ✶✣✶✣✁ ✝ ✰ ☛ ,
✮✭ is the root of ✄ if and only if ✁ ✝ ✭ ☛ is the root of ✄✆☎ ,
✮✳✓✴ ✷✬✸ ✁ ✝ ✭ ☛ ✦ ✳✬✴ ✷✩✸ ✁ ✝ ✁ ✝ ✭ ☛ ☛ ,
(✳✓✴ ✷✬✸ ✁ ✝ ✭ ☛ ✦✺✹ ✻ ✰✆✛✽✼✺✏✓✰ ☞ ✭✞✾ ✹ ✿✜❀ ✌ )
✂✁✩✴ ❁ ✵✩✁✬✸ ✝ ✄❂☛ ✦ ✁✩✴ ❁ ✵✞✁✬✸ ✝ ✄✆☎ ☛ ✌
( ✁✩✴ ❁ ✵✩✁✬✸ ✝ ✄❂☛ ✦✠❃ ✭ ✗ ✻ ✳✬✴ ✷✩✸ ✁ ✝ ✭ ☛❄✏ ✭ ✛✽✼ ✾ ✌ ]
Once one has an ✄ ✦ ✝ ✼★✘ ☞❅☛ , one may enrich its definition to get a labelled derivation tree
✄ ✦ ✝ ✼★✘ ☞✍✘ ❆❄☛ , where ✝ ✼★✘ ☞❅☛ is a derivation tree and ❆ is a mapping from ✼ to a specified set
of labels.

Given   ✄ ✦ ✝ ✼★✘ ☞✍✘ ❆❄☛ and ✄✡☎ ✦ ✝ ✼❇☎ ✘ ☞✫☎ ✘ ❆★☎ ☛ , one says ✄✠✟✠✄✡☎ if and only if:
(i) ✁ ✏✬✼❈✔❉✼❂☎ is a bijection,

(ii) ✁ preserves ☞ ,

(iii) for every ✭ ✘ ✰❂✛✽✼✢✏✓❆✆✝ ✭ ☛ ✦ ❆✆✝ ✰ ☛ if and only if ❆❊☎ ✝ ✁ ✝ ✭ ☛ ☛ ✦ ❆★☎ ✝ ✁ ✝ ✰ ☛ ☛ ✌
A terminally ordered derivation tree is ✄ ✦ ✝ ✼★✘ ☞✍✘ ❋❂☛ , where ✝ ✼★✘ ☞❅☛ is a derivation tree and
❋ is a strict total (or linear) order on the terminal nodes of ✼ , i.e. a relation that is:
(i) irreflexive: for every ✭ terminal: it is not the case that ✭ ❋ ✭ ,

(ii) asymmetric: if ✭ ❋✜✰ , then it is not the case that ✰✆❋ ✭ ,

(iii) transitive: if ✭ ❋✜✰ and ✰❂❋✜● , then ✭ ❋✜● ,

(iv) connected: either ✭ ❋✜✰ or ✰✆❋ ✭ ✌
Carlos Mart́ın-Vide
Given
✂✁☎✄ ✆✞✝ ✟✠✝ ✡☞☛ , for every ✌ ✝ ✍ ✝ ✎✏✝ ✑✓✒✔✆✖✕ ✌ ✡✘✗✏✍ (✌ precedes ✍ ) if and only if:
if ✌
✟✙✎ , ✎ is terminal, ✍ ✟✙✑ and ✑ is terminal, then ✎✚✡✛✑✢✜
✣✁✖✄ ✆✞✝ ✟✠✝ ✡☞☛
✌ ✝ ✎✤✒✛✆        ✌ ✥✧✦ ✟✙✎                 ✌ ✡✘✗★✎ ✎✤✡✘✗ ✌ ☛ ✜
The following exclusivity condition completely orders a tree. Given             , for every
, if       , then either      or         Consequently, every two nodes of the tree
must hold one, and only one, of the dominance and precedence relations.
2.3 More about Context-Free Languages

An CF grammar is called redundant if it contains useless nonterminal letters. A nonterminal
letter is useless if:
(i) either no terminal string is derivable from it: inactive or dead letter,

(ii) or it does not occur in any string derivable from : unreachable letter.
Theorem 2.5 For any CF grammar                 ✪ ☎
✁ ✄ ✦ ✝  ✘✝ ✩ ✝ ✫✬☛ :
✭✯✮ ✒ ✦ is inactive if and only if the language generated by ✪✱✰ ✁✲✄ ✦ ✝  ✘✝ ✮ ✝ ✫✱☛ is empty.
✭✯✫✞✮ ✺✻is✸ unreachable✕ if ✒✯and✄ only if the☛❃✸✙language  generated by ✪✬✳✰
✁☎✄ ✄ ✦✂✴✶✵ ✮✱✷ ☛✢✸✹ ✘✝ ✵ ✮✱✷ ✝ ✩ ✝
☛ ✞
✫ ✺
✵ ✼✾✽❀✿ ✫ ✼ ✦❁✴❂✵ ✮✱✷ ✷ ( ✮ being the set of rules remaining✷ ✜ after having
removed from the productions that have on their left-hand sides) is ✵✢✿
An CF grammar is nonredundant or reduced if each of its nonterminal letters is both active
and reachable.
Theorem 2.6 For every CF grammar, one can effectively (algorithmically) find an equivalent
nonredundant grammar.
✪✜ ✝ ❄❅✒✛❆✹✄ ✪ ☛                                                    ❄
✪ ✪
Given an CF grammar                     is an ambiguous string if and only if has at least two
❆✹✄ ✪ ☛
derivation trees in
is said to be an ambiguous grammar if and only if there exists some
string in
that is ambiguous. is an inherently ambiguous context-free language if and
only if every CF grammar generating is ambiguous.

An example of ambiguity is the following:
✪ ☎
✁ ✄ ✢✵ ✩ ✷ ✝ ✵ ❇ ✝ ❈✱✝ ❉ ✷ ✝ ✩ ✝ ✵✢✩✤✽❀✩ ❈ ✩ ✝ ✩❊✽❀✩ ❉ ✩ ✝ ✩❊✽❋❇ ✷ ☛ ✝ ❄✂✁ ❇ ❉ ❇ ❈ ❇
✪:
Example 2.7 Given
has two different derivation trees in
Formal Languages for Linguists: Classical and Nonclassical Models
✁✁✁                    ✄✁ ✁ ✁
S                      S

✂ ✆ ✆ S☎ ☎ ✝ ✝ S✞
S
✄ SS✂ S
S
a     S                           a

a         a a            a

An example of inherent ambiguity is the following:

✟✡✠☞☛ ✌✎✍✑✏ ✍✓✒ ✔✖✕✘✗✚✙ ✛✢✜☞✣✥✤✧✦★☛ ✌✥✍✑✏ ✔✎✒ ✔✖✕✘✗✩✙ ✛✪✜✫✣✎✤✎✬
✌✭✔✎✏ ✔✥✒ ✔
Example 2.8 Let                                                                 Every CF grammar
generating it will produce two different derivation trees for the strings of the form      (which
belong to both components of the language).
The Bar-Hillel pumping lemma for CF languages allows one to prove that a language is not
CF just looking at the structure of the strings:
✺✽ ✾✭for✿✓❀❂every ✟★✮✚✽ ✯✱✰ ✾ there
❁ ✙ where                exist ✲✳✙ ✴✱✮✚✵ such that for every ✶✷✮✸✟✓✙ if ✹ ✶✺✹✭✻✼✲✳✙ then ✶✱✠
✙ ✙ ✙ ✙ ✮✩❃❅❄ ✙✥✹ ✾✭✿✓❀ ✹✎❆❇✴✭✙ ✾✥❀✼✠✢❈ ❉✳✙ and ✽✺✾✎❊ ✿✓❀✺❊ ❁ ✮✚✟ , for every ❋●✜■❍✭✬
✿  ❀  ❁
Since not all languages satisfy the pumping lemma above, the following corollary is obvious.

Corollary 2.9 There are noncontext-free languages.

Examples of this include:

☛ ✌✥✔✎✏ ✔✎✒ ✔✷✕✭✛✚✜✢✣✎✤ ,
☛ ✌✥✔ ❏✓✕✎✛✚✜✪✣✎✤ ,
☛ ✌✥✔✎✏ ✍✓✒ ✔✥❑✎✍❇✕✎✗✚✙ ✛✚✜✢✣✎✤✎✬
2.4 Linear and Regular Languages

An CF grammar is called linear (LIN) if each production has either of the forms:

▲✖▼✢◆✳❖✿ , ▼ ✮✚✵ , ✿ ✩✮ ❃◗❄ ,
▲✖▼✢◆✳❖✿❅❘ ❙✷✿✓❚ , ▼ ✙ ❙ ✚✮ ✵ , ✿❅❘ ✙ ✿✓❚ ✮✩❃ ❄ ✬
✿❘
✿❚ ❉
Further, it is called left-linear (LLIN) (respectively, right-linear (RLIN)) if
) is in every rule of the second form.
(respectively,
Thus, the class of right-linear grammars exactly coincides with REG. Also:
Carlos Mart́ın-Vide
Theorem 2.10 Every LLIN grammar generates an REG language.
✂✁
And now, one can pose the following question: do all linear grammars generate languages in
? The answer is: no!, and a counterexample is next.
Example 2.11 Consider the languages:

✄✂☎✂✆✞✝ ✟✡✠☞☛ ✠✡✌ ✍✏✎✡✑✓✒✕✔☞✖ ✗✘✒✞✔✡✙
✄✛✚✜✆✞✝ ✟✢✍ ☛ ✠✡✌ ✠✣✎✡✑✓✒✕✔☞✖ ✗✘✒✞✔✡✙✡✤
Both are generated by linear grammars. For instance, the first one by:

✥ ✆✕✦ ✝☞✧★✖ ✩✪✙✡✖ ✝ ✟✫✖ ☛ ✖ ✌ ✙✡✖ ✧★✖ ✬✣✙✡✖ ✬✞✆✕✝☞✧✮✭✰✯✱✧✲✌ ✖ ✧✳✭✴✯✵✩✶✌ ✖ ✩✞✭✴✯✷✟✢☛ ✖ ✩✕✭✰✯✵✟✢✩✶☛ ✙✡✤

However, could one build a regular grammar generating any of them? Since:

✄✂☎★✸✹✄✛✚✂✆✕✝ ✟ ✠ ☛ ✠ ✌ ✠ ✎✡✑✓✒✕✔☞✙✻✼✓
✺ ✽✿✾
✸                                          ✄✜☎         ✄✛✚
and it is known that CF          REG = CF, one gets that neither              nor         can be REG.
✭✰✯✵✟✡❁✛✖
Theorem 2.12 Every language in
✭✴✯✷  ✟          ✖ ❁ ✼✓❂ ✖ ✟ ✼✹❃ ✤
can be generated by a grammar having the following two
types of productions: ❀           ❀                 , with ❀

✥ ✆❄✦ ❂ ✖ ❃ ✖ ✧★✖ ✬✪❅                                                    ✩ ✼✳❂
✩✞✆✰❆❈❇ ❀ ✩✏❁
An CF grammar
✖ ❁ ✼ is ✦ said to be self-embedding if there exists an
❂❊❉✘❃  ❅ ❋
✲ ✤                                                   such
that               , for some ❀

✄✶✦ ✥ ❅ ✼   ✁ ✤
Theorem 2.13 If an CF grammar is reduced and not self-embedding, then

Thus, self-embedding is the very characteristic feature of
✽✪✾
languages which separates them
from smaller language classes. Since that feature (it is the case with relative sentences, for
instance) does appear in natural languages (being the source for its recursiveness leading to the
infinite set of sentences which a natural language is), it is obvious that a natural language cannot
be smaller than an
✽✪✾ language. This discussion will continue later.

An CF grammar is said to be in Greibach normal form (GNF) if each rule is of the form:

✩✞✭✴✯✷✟ ❀ ✖ ✩ ✼✓❂ ✖ ✟ ✼✹❃ ✖ ❀ ✼●❂ ❇ ✤

Theorem 2.14 For every ❍ -free CF grammar, one can find an equivalent grammar in GNF.
Formal Languages for Linguists: Classical and Nonclassical Models
Given a finite alphabet
, a regular expression is inductively defined as follows:

(i)   ✁   is a regular expression,

(ii) for every         ✂☎✄   , ✂    is a regular expression,

(iii) if   ✆     is a regular expression, then so is           ✆✞✝ ,
(iv) if    ✟✡✠ ✆     are regular expressions, then so are              ✟✞✆   and   ✟☞☛✌✆✡✍

Every regular expression denotes an REG language. For example:

✁   denotes        ✎✏✁✒✑ ,
✂ denotes ✎ ✂✓✑ ,
✂✞☛✌✔ denotes ✎ ✂✓✠ ✔ ✑ ,
✂✕✔ denotes ✎ ✂✖✔ ✑ ,
✂✕✝ denotes ✎ ✂✗✑ ✝ ,
✘ ✂✞☛✌✔ ✙ ✝ denotes ✎ ✂✗✠ ✔ ✑ ✝ ,
✘ ✂✞☛✌✔ ✙ ✂✖✝ denotes ✎ ✂✓✠ ✔ ✑ ✂✕✝✛✚☞✂✕✂✖✝✜☛✌✔ ✂✕✝✛✚✢✎ ✂✕✂✖✝ ✠ ✔ ✂✖✝ ✑✕✍

The following question now arises: is every REG language describable by means of a regular
expression? The answer is simply yes!
Theorem 2.15 Every regular expression denotes a language in                                   ✣✥✤   and, conversely, every lan-
guage in        ✣ ✤
is denoted by a regular expression.
A short list of valid equations for all regular expressions                       ✦✛✠ ✟✡✠ ✆   includes:

✦✧☛ ✘ ✟✧☛✌✆★✙✩✚ ✘ ✦✧☛✌✟✡✙✒☛✌✆              ,

✦ ✘ ✟★✆✞✙✩✚ ✘ ✦✞✟✡✙ ✆ ,
✦✧☛✪✟✢✚☞✟✧☛✪✦ ,
✦ ✘ ✟☞☛✌✆★✙✜✚☞✦★✟✧☛✌✦★✆           ,
✘ ✦✧☛✌✟✡✙ ✆✫✚☞✦★✆✬☛✌✟★✆       ,

✦✞✝✛✚✫✁★☛✌✦★✦✞✝ ,
✁✓✦✢✚☞✦✡✁✭✚☞✦ ,
✦✞✝✛✚ ✘ ✁★☛✌✦✡✙ ✝ ✍
Carlos Mart́ın-Vide
The concept of a regular expression suggests the operation on languages called substitution.
✂✁                                                      ☞✁ ☛                                ✏✎
Given a finite alphabet , let          denote an alphabet and ✄✆☎ ✝✟✞✡✠     a language for each ✝✍✌
✎✎✎          ✚☛
For each string ✑✓✒✔✝✟✕ ✝✆✖     ✘✝ ✗✙✌      , one defines the substitution:

✎✎✎
✄✆☎ ✑✚✞✏✒✛✄✆☎ ✝ ✕ ✞ ✄✆☎ ✝ ✖ ✞         ✄✆☎ ✝ ✗ ✞
as the concatenation of the languages corresponding to the letters of ✑                                         This is extended to any
✜     ✚☛
✠     by:

✜                                      ✜✡✩✆✎
✄✆☎ ✢✞ ✒✤✣ ✥✙✦✆✥✙✌✧✄✆☎ ✑✚✞ ★ for some ✑✛✌

The family ✪✡✫ is closed under substitution, i.e. the set of regular expressions is closed under
substitution of a regular expression for each of its letters. Substitution can be regarded as the
generalization of the notion of morphism.
As for CF languages, for both families LIN and REG there are necessary conditions in the form
of pumping lemmata.

Pumping lemma for linear languages:

✜     ✜✢✬✆✭                               ✭                                           ✜
for every ✌             , there exist ✮✯★ ☞  ✰ ✌       such that for every ✱✙✌          ★ if ✜ ✲ ✱✳✲✆✴✵✮ then ✱✶✒ ✎
✷ ✥✸✑✡✹✳✺✂★ where ✷ ★ ✥✟★ ✑☞★ ✹✯★ ✺✶✌✼✻ ☛ ★✘✲ ✷ ✘✥ ✹✳✺✯✲✘✽✓✰✆★ ✥✆✹✵✒✛
✾ ✿✳★ and ✷ ✥✘❀ ✑❁✹✟❀ ✺❂✌ , for every ❃✢❄✔❅

Pumping lemma for regular languages:

✜                                               ✭
for every ❇✌ ❆✚❈☞❉ , there exist ✮✯★ ✰☞✌ ☛       such that for every
✜                                                                                                  ✜
✱✙✌       ★ if ✲ ✱✳✲✸✴✧✮ then ✱☞✒ ✷ ✸✥ ✑✚★ where ✷ ★ ✥✟★ ✑✛✌✼✻ ✎ ★✘✲ ✷ ✥✳✲✆✽✓✆✰ ★ ✥✼✒✛
✾ ✿✯★ and ✷ ✥✆❀ ✑✤✌ , for
every ❃✏❄✓❅
2.5 Semilinear, Context-Sensitive and
Mildly Context-Sensitive Languages

Whether or not natural languages are context-free sets of sentences was a much discussed issue
in the eighties. To enter the discussion’s core, cfr. the following papers: Gazdar (1981), Bres-
nan, Kaplan, Peters and Zaenen (1982), Pullum and Gazdar (1982), Culy (1985), and Shieber
(1985) (all of them were collected in Savitch, Bach, Marsh and Safran-Naveh 1987).
Today, there is a relative agreement that natural languages are not context-free. However, how
large they are continues to be a not so simple matter. There are two main noncompatible options.
A natural language:

(i) either forms a class of sentences that includes the context-free family but is larger than it
(so still comfortably placed within the Chomsky hierarchy),
Formal Languages for Linguists: Classical and Nonclassical Models
(ii) or occupies a position eccentric with respect to that hierarchy, in such a way that it does
not contain any whole family in the hierarchy but is spread along all of them.

Following the first alternative gave origin to a new family of languages, which is of a clear
linguistic interest.
A family of mildly context-sensitive languages (MCS) is a family                                            such that:

(i) each language in
is semilinear,

(ii) for each language in , the membership problem (whether or not a string belongs to the
language) is solvable in deterministic polynomial time,

(iii)
contains the following three nonCF languages:
✁✄✂✄☎✝✆ ✞✠✟☛✡ ✟☛☞ ✟✍✌✠✎✑✏✓✒✕✔ : multiple agreements,
✁✄✂✄☎✝✆ ✞✠✟☛✡ ✖✗☞ ✟✠✘☛✖✙✌✠✎✛✚ ✜✢✏✙✒✣✔ : crossed dependencies,
✁✄✂✄☎✝✆ ✤✥✤✓✌✕✤✧✦★✆ ✞✣✚ ✡ ✔ ✩ ✔ : duplications.
MCS is a linguistically-motivated family, as both it contains the above three languages, which
are more or less agreed to represent structures that exist in natural languages, and enjoys good
complexity conditions (i.e. fast processing), as stated by the deterministic polynomial time
requirement.

In order to see what a semilinear language is, let us assume                                ✪ ☎✝✆ ✞✬✫ ✚ ✞✕✭ ✚ ✮ ✮ ✮ ✚ ✞✠✯☛✔✠✮ Being ✰     the
set of integers, the Parikh mapping of a string is:

✱ ✌ ✪ ✩✳✲✵✴ ✰ ✯
✱✷✶ ✤✥✸✹☎ ✶ ✺ ✤ ✺ ✻ ✼ ✚ ✺ ✤ ✺ ✻ ✽ ✚ ✮ ✮ ✮ ✚ ✺ ✤ ✺ ✻ ✾ ✸ ✚ ✤✧✦ ✪ ✩ ✮
Given a language, its Parikh set is:

✱✷✶ ✂✗✸✹☎✝✆ ✱✷✶ ✤✥✸✗✌✠✤✧✦✑✂✳✔✠✮
A linear set is a set           ✿❁❀✓✰ ✯    such that:

✖ ❆ ❈✬❆ ❈✬❆
❅ ❆
✿ ☎✝✆ ❂☛❃✛❄ ❇ ✫ ❂ ✌ ✦ ✰ ✚                    for some        ❂☛❃ ✚ ❂☛✫ ✚ ✮ ✮ ✮ ✚ ❂ ✖ ✦ ✰ ✯ ✔✠✮

A semilinear set is a finite union of linear sets. A semilinear language is an                                         ✂   such that
✱✷✶ ✂✗✸
is a semilinear set.
✤ ✵✲ ✴ ✍❂ ✦❊❉
✺ ✤ ✠✺ ❋●✺ ❂ ✺ ✮
A phrase-structure grammar is called length-increasing if, for every production
one has           This is clear for every CS grammar. Moreover:
Carlos Mart́ın-Vide
Theorem 2.16 Every length-increasing grammar generates an CS language.
✂✁☎✄✝✆                                                  ✆✟✞
The length-increasing property is, therefore, equivalent to context-sensitivity with the sole ex-
ception of the rule       , which is needed only to derive

A length-increasing grammar is said to be in Kuroda normal form (KNF) if each of its pro-
ductions is of any of the following forms:

✠✂✡      ✁✟✄☞☛ ,
✠✂✡      ✁✟✄☞✌ ,
✠✂✡      ✁✟✄☞✌✎✍ ,
✠✂✡  ✌✏✁☎✄✑✍✓✒ ,
✌ ✍ ✒
for ✡✓✔ ✔ ✔ nonterminals and
☛                 terminal.
Theorem 2.17 For every length-increasing grammar, one can find an equivalent grammar in
KNF.
Corollary 2.18 Every -free CS language can be generated by a grammar in KNF.

A -free CS grammar is said to be in Penttonen or one-sided normal form (PNF) if each of
its productions is of any of the following forms:

✠✂✡         ✁✟✄☞☛ ,
✠✂✡         ✁✟✄☞✌ ,
✠✂✡         ✁✟✄☞✌✎✍ ,
✠✂✡    ✌✏✁☎✄ ✡ ✍ ,
✠✂✡    ✌✏✁☎✄✑✌ ✡ ✞

An example of an CS grammar generating a nonCF language is the following:

Example 2.19 Let G = (N, T, S, P) be a grammar such that:

✕ ✖✙✘   ✔ ✡✛✚ ✔ ✡✛✜ ✔ ✌ ✚ ✔ ✌ ✜ ✔ ✍ ✚ ✔ ✍ ✜ ✢ ,
✣✤✖✙✘ ☛ ✔ ✥ ✔ ✦ ✢ ,
✧✙✖✙✘  ★✁✟✄ ✡✛✚ ✌ ✚ ✍ ✚ ✔ ✩✪✡✛✚ ✁☎✄✑☛ ✡✛✜ ✌ ✜ ✔ ✌         ✜ ✌ ✁✟✚ ✄✬
✁☎✄✑✌ ✜ ✌ ✜ ✔ ✌ ✜ ✍ ✚ ✁☎✄✑✌      ✜ ✍ ✁☎✜ ✦✄ ✔ ✍ ✁☎✄
✩ ✡✫✜ ✁✟✁☎✄✬ ☛ ✡✭✚ ✌ ✚ ✔ ✌ ✚ ✌ ✜ ✁☎✄✬✌ ✚ ✌ ✚ ✔ ✌ ✚ ✍   ✜             ✌ ✚ ✍ ✚ ✦ ✔ ✡✭✚ ✁☎✄✬☛ ✔ ✌   ✚              ✥✔ ✚
✦ ✔ ✡✫✜ ✄✑☛ ✔ ✌ ✜ ✁✟✄ ✥ ✔ ✍ ✜ ✁✟✄ ✦ ✢ ✞
Formal Languages for Linguists: Classical and Nonclassical Models
The generated language is:

✂✁ ✄✆☎✞✝✠✟ ✡☞☛✍✌ ☛✍✎ ☛✑✏☞✒✔✓✠✕✍✖✘✙✔
✗ ✚✜✛✣✢

As is easily seen, every application of the rules marked with ✤ sends a signal through the ✥ ’s to
✚✣✦ or ✚✣✧ on their right, which may be killed on its way or reach the ✚ ’s, where it deposits a ✎ ✢
3 Automata

3.1 Finite Automata

Grammars are generating devices which may simulate the productive (i.e. speaking) behaviour
of speakers/hearers. Automata are recognizing devices which may simulate the receptive (i.e.
hearing) behaviour of them. Each class of mechanisms serves to model one of the two aspects
of human linguistic capacity. As well, there are surprising, strong formal connections between
grammar theory and automata theory. Let us see.

A finite automaton (FA) is a construct:

★ ✝✩✁ ✪✑✫ ✬✣✫ ✭✮✫ ✯ ✰ ✫ ✛ ☎ ✫

with:

✱ ✪    a finite nonempty set of states,
✱ ✬   a finite alphabet of input letters,
✱ ✭ a transition function: ✪✳✲✘✬✮✴✵✪✆✫
✱ ✯ ✰ ✙ ✪ the initial state,
✱ ✛✩✶ ✪ the set of final (accepting) states.

accepts or recognizes a string if it reads until the last letter of it and enters a final state.
Example 3.1                                           ★ ✝✠✁ ✪✑✫ ✬✣✫ ✭✮✫ ✯ ✰ ✫ ✛ ☎✷✏
✪ ✝✠✟ ✯ ✰ ✫ ✯ ✦ ✫ ✯ ✧ ✫ ✯ ✸ ✖ ,
✬✮✝✠✟ ✡✹✫ ✌ ✖ ,
✛ ✝✠✟ ✯ ✰ ✖ ,
✭✩✁ ✯ ✰ ✫ ✡✺☎✷✝✮✯ ✧ , ✩       ✭ ✁ ✯ ✰ ✫ ✌ ☎✷✝✮✯ ✦ ,
Carlos Mart́ın-Vide
✂✁ ✄ ☎ ✆ ✝✟✞✡✠☛✄ ☞          ✂✁ ✄ ☎ ✆ ✌ ✞✡✠☛✄ ✍ ,
✂✁ ✄ ✎ ✆ ✝✟✞✡✠☛✄ ✍          ✂✁ ✄ ✎ ✆ ✌ ✞✡✠☛✄ ☞ ,
✂✁ ✄ ☞ ✆ ✝✟✞✡✠☛✄ ☎          ✂✁ ✄ ☞ ✆ ✌ ✞✡✠☛✄ ✎ ✏

The transition table and the transition graph for A are, respectively:
✄ ✍✑✄ ✎✑✄ ☎                                     ✖✕✓✕✄ ✗✔✎ ✦
a ✢ ✢✤✢ ✣             ✦★ ✦ ✦✦ ✦ b✦✤✧
M a b
✄ ☎✒✄ ☞✑✄ ✍                      ✢    ✢
✖✡✓✡✄ ✗✔✍✢ ✢✦✥★ ✦ ✢ a b ✦ ✖✡✓✡✄ ✗✔☞
✄ ✎✑✄ ✍✑✄ ☞             ✦ ✦ ✦ b✦ a✢ ✢ ✢ ✢✤✣
✄ ☞✑✄ ☎✒✄ ✎                           ✦ ✦✤✧ ✛✚✜ ✢✥
b ✘✚✄ ✙ ☎ ✢ ✢ a
One can check that ✩
✁ ✪✫✞✡✠✭✬ ✮✰✯✱✬ ✝✲✆ ✌ ✳ ✴✶✵✸✷ ✮✚✷ ✹ is even, ✷ ✮✚✷ ✺ is even ✳✤✏
is a one-valued function, the finite automaton is called deterministic (DFA). Otherwise, it
If
contains exactly one transition with the
is called nondeterministic (NFA). In the first case,
to be a total function,
may well be not defined for some combinations of a state and a letter.
same left-hand side. Notice that the definition of
i.e.
does not require

The symbols ✻ and ✻ for transitions are, respectively, equivalent to the symbols
✠✸✼ and ✠✽✼✾✴
for derivations in grammars.

The language accepted by a finite automaton is:
✩ ✁ ✪✿✞✡✠✰✬ ✮✰✯❁❀ ✴ ✵✟✄ ✍ ✮ ✻ ✴✽❂ ✆ ❂ ✯❄❃❅✳✤✏
Take notice that ❆
✯ ✩ ✁ ✪✿✞ if and only if ✄ ✍❈❇✑❃❊✠☛❉ ❋●✏
Theorem 3.2 For every NFA, one can find an equivalent REG grammar.
Theorem 3.3 For every REG grammar, one can find an equivalent NFA.
Corollary 3.4 ❍ ☞ coincides with the family of languages accepted by NFA’s.
The following question arises now: is there some language in ❍ that cannot be accepted by
any DFA? The answer is simply no! Consequently, one can always simulate the behaviour of
an NFA by means of an DFA (with more states).

A number of important consequences for the languages in                    ❍ ☞ follow from the concept of an FA,
among others:
■ ❍ ☞ is a Boolean algebra,
■    it is decidable whether two REG grammars are equivalent, etc.
Formal Languages for Linguists: Classical and Nonclassical Models
3.2 Pushdown Automata

Let us introduce now a new element in the definition of an automaton: memory. Pushdown
automata result.
moving ✂                    input tape
direction

read
control
device
✁   read and write
✄ storing directionFILO: first in, last out method
pushdown store          ✂            clearing direction

A pushdown automaton (PDA) is a construct
☎✝✆✟✞ ✠☛✡ ☞✌✡ ✍☛✡ ✎✏✡ ✑ ✒ ✡ ✓ ✒ ✡ ✔✖✕ , with:
✗ ✠      a finite alphabet of pushdown letters,
✗ ☞     a finite set of internal states,
✗ ✍    a finite set of input letters,
✗ ✎       the transition function:

✠✝✘✙☞✚✘✛✞ ✍✛✜✣✢✌✕✥✤✧✦✩★☛✪ ✫ ✬✭✞ ✠✯✮☛✘✙☞✖✕ ✡
✗ ✑ ✒✯✰✱✠       the initial letter,
✗ ✓ ✒✯✰✙☞      the initial state,
✗ ✔✟✲✏☞        a set of final or accepting states.

✑✳✓            ✑✌✰✱✠ ✮
✓✴✰✙☞
A configuration of an PDA is a string , where
store and
is the current contents of the pushdown
is the present state of the control device.

A nondeterministic pushdown automaton (NPDA) may reach a finite number of different
new configurations from one configuration in one move:

✎✟✞ ✑✵✡ ✓✶✡ ✷✵✕✸✆✺✹✻✞ ✼✯✽ ✡ ✾✧✽ ✕ ✡ ✞ ✼☛✿ ✡ ✾✵✿ ✕ ✡ ❀ ❀ ❀ ✡ ✞ ✼✥❁✯✡ ✾✻❁✯✕ ❂✶✡ ✷❃✰✣✍ , ✼ ✫ ✰✱✠ ✮ , ✾ ✫ ✰✙☞✌✡ ❄❆❅❈❇✸❅❈❉✙❀
Carlos Mart́ın-Vide
There may be -moves too, which make it possible for the PDA to change its configuration
without reading any input.

For a string to be accepted, the three following conditions must hold:

(i) the control device read the whole string,
(ii) the PDA reached a final state,

(iii) the pushdown store is empty.
Note that only the existence of at least one sequence of moves leading to an accepting configu-
ration is required, while others may lead to nonaccepting ones.
Example 3.5 To accept                   ✁✄✂✆☎ ✝✟✞✡✠ ✞☞☛✟✌✎✍✆✏✟✑ , the following PDA is adequate:
✒ ✂✔✓ ☎ ✕ ✖ ✗ ✝✘✑✟✗ ☎ ✙ ✖ ✗ ✙ ✚ ✗ ✙ ✛ ✑✟✗ ☎ ✝✜✗ ✠ ✑✟✗ ✢✣✗ ✕ ✖ ✗ ✙ ✖ ✗ ☎ ✙ ✛ ✑✡✤ ✗
with:

M                 a             b            ✥
( ✕✖✗✙✖    ) (✕ ✖ ✝✘✗ ✙ ✖   )
✗ ✙ ✚ ✦)    ✦
✝✘✗ ✙ ✖
(      ) (  ✝✟✝✘✗ ✙ ✖   )   (
(✕ ✖ ✗ ✙ ✚ )                ✦       ✦ ( ✗ ✙ ✛ ✦)
(✝✘✗ ✙ ✚ )                ✦   ( ✗ ✙ ✚)
(✕ ✖ ✗ ✙ ✛ )                ✦            ✦       ✦
(✝✘✗ ✙ ✛  )                ✦              ✦       ✦
An PDA
✒ ✂✔✓ ✧★✗ ✩☞✗ ✪★✗ ✢✣✗ ✕ ✖ ✗ ✙ ✖ ✗ ✫☞✤ is said to be deterministic (DPDA) if and only if for every
✓ ✕✬✗ ✙✡✤✮✭✯✧✱✰✎✩ :

(i) either ✢✔✓ ✕✬✗ ✙✬✗ ✝✬✤ contains exactly one element, for every ✝✲✭✳✪ , while ✢✔✓ ✕✬✗ ✙✬✗ ✤✴✂✵✦ ,

(ii) or ✢✔✓ ✕✬✗ ✙✬✗ ✤ contains exactly one element, while ✢✔✓ ✕✬✗ ✙✬✗ ✝✬✤✮✂✣✦ , for every ✝✶✭✳✪✸✷
Theorem 3.6 The family of languages accepted by DPDA’s is strictly contained in the family
of languages accepted by NPDA’s.

To illustrate this, let us observe the following:
✁ ✚ ✂✆☎ ✹✻✺ ✹✻✼ ✚ ☛✬✹✱✭✽☎ ✝✜✗ ✠ ✑ ✾ ✑✟✗
Example 3.7

✁✴✛✸✂✆☎ ✹★✹ ✼ ✚ ☛✟✹✱✭✽☎ ✝✘✗ ✠ ✑ ✾ ✑✟✷
While ✮
✁ ✚ belongs to both NPDA and DPDA, ✁✮✛ belongs only to NPDA.
Formal Languages for Linguists: Classical and Nonclassical Models
The following results establish the relationship of
✂✁☎✄✝✆✟✞ ✠ to ☎✡ ☛      languages.

Theorem 3.8 NPDA = CF.

Theorem 3.9 For every CF grammar, an algorithm exists to transform it into an equivalent
NPDA.

Theorem 3.10 For every PDA, an algorithm exists to transform it into an equivalent CF gram-
mar.
☞✍✌
Turing machines are the most powerful recognizing devices, and are able to recognize any
language. They are the foundation of computation theory and involve a lot of complexities
which cannot be addressed here.
4 Regulated and Parallel Rewriting

4.1 A Sample of Regulated Rewriting

Next, a few important types of regulated grammars are presented, without being exhaustive at
all. In order to have a regulated (i.e. controlled) grammar, one more or less modifies/restricts
the notion of a grammar, and as a consequence one usually gets either a different (often greater)
generative capacity or a simpler method of generation.

A matrix grammar is:

✎☎✏✒✑✒✓  ✕✔ ✖✟✔ ✗✘✔ ✙✛✚ ✔

where
✙   is a finite set of finite nonempty sequences (matrices) of the form:

✜✣✢✥✤ ✦ ✧ ✔ ✦ ★ ✔ ✩ ✩ ✩ ✔ ✦ ✪✬✫ ✔ ✭✯✮✱✰ ,
with:

✦ ✲✘✢✴✳✵✲✘✶✵✷✹✸✺✲ , ✳✵✲✘✻ ✓  ✽✼✝✖✾✚ ✿   ✓  ❀✼✝✖✾✚ ✿ , ✸✺✲✘✻ ✓  ✽✼✝✖✾✚ ✿ ✩

A derivation in a matrix grammar is as follows:

❁ ✔ ❂ ✤ ✦ ✻ ✧ ✔ ✓ ✦  ❀    ✼✝✖✍✚ ✿ ✔ ❁ ✑✵❃❅❄✺❆ ❂ if and only if there exist ❁❈❇ ✔ ❁ ✧ ✔ ✩ ✩ ✩ ✔ ❁ ✪
★ ✔ ✩ ✩ ✩ ✔ ✦ ✪ ✫✵✻ ✙❉✔ ✦ ✲ ✢✴✳ ✲ ✶✵✷✹✸ ✲ ✔ ✰✾❊●❋❍❊❉✭✘✔ such that ❁ ✲ ■✥✧ ✑
✻ ✓  ✽✼✕✖✍✚ ✿ and
❁ ✰✬✞✲ ✩ ■✺✧ ✳ ✲ ❁ ✞✲ ✞ ■✺✧ and
for every

❁ ✲ ❁ ✞✲ ■✺✧ ✸ ✲ ❁ ✞✲ ✞ ■✥✧ ✔ for some ❁ ✞✲ ■✺✧ ✔ ❁ ✞✲ ✞ ■✺✧ ✻ ✓  ✽✼✝✖✾✚ ✿ ✔ ❏❑❊❉❋▲❊❉✭ ✶
there exist
Carlos Mart́ın-Vide
Example 4.1 The grammar
✂✁    with the following matrices:

✄✆☎✞✝✠✟ ✡☞☛✠✌✎✍✑✏✓✒✕✔ ,
✄✗✖✑✝✠✟ ✍✘☛✠✌✎✙✚✍✂✛ ✏✜☛✠✌✎✢ ✏✣✛ ✒✜☛✠✌✎✤ ✒✕✔ ,
✄✗✥✑✝✠✟ ✍✘☛✠✌✎✙✦✛ ✏✜☛✧✌✎✢ ✛ ✒★☛✧✌✎✤ ✔ ,

yield ✩✑✪
✁✓✫✭✬✘✮ ✙✚✯✰✢ ✯✰✤ ✯✣✝✚✱✳✲✵✴✚✶✚✷

A programmed grammar is:

✂✸ ✬ ✪ ✹ ✛ ✺✑✛ ✡✻✛ ✼ ✫ ✛
✫ ✫
where ✼ is a finite set of triples (✽ ✝✚✾☞☛✧✌✎✿❀✛ ❁ ✪ ✽ ✛ ❂ ✪ ✽ ), ✽              is a label, ✽    ✝❃✾☞☛✠✌✎✿❅❄ ✪ ✹❇❆ ✺ ✫ ❈
✫ ✫
and ❁ ✪ ✽ , ❂ ✪ ✽ are two sets of labels of rules.

An immediate derivation in a programmed grammar is as follows:
for every ✪    ❉ ✛ ✽ ☎ ✫ ✛ ✪ ❊ ✛ ✽ ✖ ✫ ❄ ✪ ✹❋❆ ✺ ✫ ❈✑● ✩ ✙✚✢ ✪ ✼ ✫ ✝ ✪ ❉ ✛ ✽ ☎ ✫❀✬✧❍❏■✦❑ ✪ ❊ ✛ ✽ ✖ ✫ if and only if ✝
either ❉
✬ ❉ ☎ ✾ ❉ ✖ and ❊ ✬ ❉ ☎ ✿ ❉ ✖ ✪ ❉ ☎ ✛ ❉ ✖✞❄ ✪ ✹✜❆ ✺ ✫ ❈ ✫ and ✪ ✽ ☎ ✝❃✾❅☛✠✌✎✿✭✛ ❁ ✪ ✽ ☎ ✫ ✛ ❂ ✪ ✽ ☎ ✫ ✫ ❄
(i)
✼ and ✽ ✖ ❄✳❁ ✪ ✽ ☎ ✫ ,
or ❉
✬ ❊ and ✽ ☎ ✝✦✾❏☛✠✌▲✿ (for (✽ ☎ ✝✦✾☞☛✧✌▲✿❀✛ ❁ ✪ ✽ ☎ ✫ ✛ ❂ ✪ ✽ ☎ ✫ ✫ ❄❅✼ ✫ cannot be applied to ❉
(ii)
and ✽ ✖✑❄▼❂ ✪ ✽ ☎ ✷

The language generated by a programmed grammar is:
✩✑✪   ✸✧✫✭✬✘✮ ❉ ✝ ❉ ❄◆✺ ❈ and there exist✽ ☎ ✛ ✽ ✖✞❄ ✩ ❃✙ ✢ ✪ ✼ ✫ such that ✪ ✡✻✛ ✽ ☎ ✫✭✬✠❍ ❈❖■ ❑ ✪ ❉ ✛ ✽ ✖ ✫ ✶✚✷

Example 4.2 The grammar
✸   with the following productions:

✪ ✽ ☎ ✝✦✡☞☛✠✌✎✍✑✍✂✛ ✮ ✽ ☎ ✶✚✛ ✮ ✽ ✖ ✛ ✽ ✥ ✶ ✫ ,
✪ ✽ ✖ ✝❃✍✵☛✧✌✎✡✻✛ ✮ ✽ ✖ ✶✚✛ ✮ ✽ ☎ ✶ ✫ ,
✪ ✽ ✥ ✝❃✍✵☛✧✌✙❖✛ ✮ ✽ ✥ ✶✚✛ ◗ ✫ ,
yield ✩✑✪
✂✸ ✫✭✬✘✮ ✙ ✖ ❘ ✝❃✱✳✲✵✴✚✶✚✷

A random context grammar is:
Formal Languages for Linguists: Classical and Nonclassical Models
✂✁☎✄✝✆✟✞ ✠☛✡ ☞✌✡ ✍✎✡ ✏✒✑ ✡
✏                                                         ✞ ✓✕✔✗✖✙✘✚✡ ✛✒✡ ✜✢✑ , with ✓✕✔✣✖✤✘✦✥✧✞ ✠✟★✂☞✂✑ ✩ , ✛✫✪✬✠
✜✭✪✬✠✯✮ is a finite set of rules of the form
where                                                                                                                           ,
An immediate derivation in a random context grammar is as follows:

for every ✰
✡ ✱✲✥✧✞ ✠✳★✲☞✂✑ ✩✌✴ ✰ ✆✗✵✷✶☎✸ ✹✲✱ if and only if ✰ ✆ ✰☎✺ ✓ ✰✻✺ ✺ and
✱ ✆ ✰☎✺ ✘ ✰✻✺ ✺ ✞ ✰✻✺ ✡ ☎✰ ✺ ✺ ✥✧✞ ✠✽★✲☞✾✑ ✩ ✑ and ✞ ✓✕✔✣✖✤✘✿✡ ✛✼✡ ✜✂✑❀✥✝✏ and for every ❁ ✥✝✛❂✴ ❁ ✥ ☎✰ ✺ ✰✻✺ ✺
for every ❃
✥✝✜✫✴ ❃✦✥ ❄ ✰✻✺ ✰☎✺ ✺ ✮                                    and
Example 4.3 The grammar
✁☎✄     with the following productions:

✞ ✍✧✔✣✖✤❅❆❅✢✡ ❇☎✡ ❈ ❉✼✡ ❊☛❋●✑ ,
✞ ❅✭✔✗✖✙❉✲✡ ❇☎✡ ❈●✍✎✡ ❊☛❋●✑ ,
✞ ❉❂✔✗✖✤✍✎✡ ❇☎✡ ❈ ❅✢✡ ❊☛❋●✑ ,
✞ ❅✭✔✗✖✙❊☛✡ ❇☎✡ ❈●✍✎✡ ❉✲❋●✑ ,
✞ ❊❍✔✣✖✤■☎✡ ❇☎✡ ❈●✍✎✡ ❅✢✡ ❉✼❋●✑ ,

yield ❏
✞   ✁❑✄ ✑✚✆✟❈ ■▼▲ ◆✢✴❑❖✝✭◗▼❋▼✮

A grammar with regular control is:

✢✁❑❘✻✶☛✆✫✞ ✠☛✡ ☞✌✡ ✍✎✡ ✏✌✡ ✜✢✑ ✡

where
✜     is a regular language over
✏✌✮
The language generated by an
✁❑❘✻✶         consists of the strings resulting from a derivation:

✍✦✆✗✵✕❙✶☎❚ ✸ ❯●❱✲❲❆❳ ✆✗✵✕❙✶☎❨ ✸ ❯●❱✲❲ ▲ ✗✆ ✵✷✶☎✸ ❯●❱☛✮ ✮ ✮❑✆✣✵✕❙✶✻◆ ✸ ❯●❱✼❲❀❩ ✆ ❲ ✥☛☞ ✩

such that ❬
❳ ❬ ▲ ✮ ✮ ✮ ❬ ❩ ✥✝✜✒✮

Example 4.4 The grammar
✁☎❘✻✶     consisting of:

✠ ✆✟❈●✍✎✡ ❅✂✡ ❉✲❋ ,
☞✬✆✟❈ ■☎✡ ❪ ✡ ❫ ❋ ,
✏✟✆✟❈ ❬ ❳ ✴❑✍✧✔✣✖✤❅❆❉✲✡ ❬ ▲ ▼✴ ❅✟✔✣✖✤■▼❅✾❪ ✡ ❬✻❴ ✴▼❉❂✔✗✖✤❉✢❫ ✡ ❬☎❵ ✴▼❅✟✔✣✖✤■▼❪ ✡ ❬☎❛ ✴▼❉✳✔✣✖✤❫ ❋ ,
Carlos Mart́ın-Vide
✂✁☎✄ ✆✞✝ ✟✠✄ ✆☛✡ ✆☛☞ ✟ ✌ ✄ ✆✎✍ ✆☛✏ ✟ ,
generates:

✑✓✒ ✔✖✕✘✗☛✙✛✚✜✁✂✄ ✢✠✣✥✤ ✣✠✦ ✣★✧✠✩✫✪☎✬✥✟✠✭
An additive valence grammar is:

✔✯✮✎✰✫✁✱✒ ✲✴✳ ✵✓✳ ✶✛✳ ✷✸✳ ✹✘✚ ✳
where
✹✺✧✘✷✱✻✞✼✾✽✿✒ ✽             is the set of integers).

The language generated by an
✔✖✮✘✰ is:
✑✓✒ ✔✖✮✘✰❀✚✜✁☎✄ ❁❂✧✘❁✂❃❄✵✓✌ and ✶❅✁✞❆❅❇✙☛❈ ❉ ❊ ❁ ✝ ✁✞❆❅❇✙☛❋ ❉ ❊ ❁ ✡ ✁✞❆●✙☛❉ ❊❄✭ ✭ ✭✘✁❍❆❅❇✙✎■ ❉ ❊ ❁ ✣ ✁❂❁
✹☛✒ ✆ ✝ ✚❍❏❑✹✞✒ ✆ ✡ ✚❍❏▲✭ ✭ ✭ ❏❑✹✞✒ ✆ ✣ ✚❀✁❂▼✎✟✠✭                            and
Example 4.5 The grammar
✔ ✮✎✰     consisting of:

✲ ✁☎✄✥✶✛✳ ❖✯✳ ◗✟ ,
✵❂✁☎✄ ✢✎✳ ✤ ✳ ✦ ✟ ,
✷☎✁☎✄ ✆☛✝✸✧✘✶❑✻✞✼✾❖✓◗✳ ✆✎✡✓✧✠❖☎✻✞✼✾✢✠❖✖✳ ✆✎☞✓✧✠❘✻✞✼✾✤ ★✦ ✳ ✆✘✍✿✧✠❖☎✻✞✼✾✢✎✳ ✆☛✏✸✧✘❙✻❍✼❚✤ ✦ ✟ ,
✹☛✒ ✆ ✝ ✚✜✁❂✹✞✒ ✆ ✍ ✚❀✁❂✹✞✒ ✆ ✏ ✚✜✁▲▼ , ✹☛✒ ✆ ✡ ✚✜✁☎✬ , ✹☛✒ ✆ ☞ ✚❀✁☎✻✖✬ ,
generates:

✑✓✒ ✔ ✮✎✰ ✚✜✁☎✄ ✢ ✣ ✤ ✣ ✦ ✣ ✧✘✩✫✪✂✬✠✟✠✭
Notice that the rules
✆✎✡    and
✆✎☞   must be applied the same number of times.
A multiplicative valence grammar is:

✔✖❯✿✰✫✁✱✒ ✲❄✳ ✵✸✳ ✶✛✳ ✷✸✳ ✹✎✚ ✳
where
✹✺✧✘✷✱✻✞✼✾❱✯❲ (❱              is the set of rational numbers).

The language generated by an
✔✖❯✿✰ is:
✑✓✒ ✔✯❯✯✰✛✚✜✁☎✄ ❁✂✧✠❁✂❃❄✵✿✌ and ✶❅✁✞❆ ❇✙☛❈ ❳✛❊ ❁ ✝ ✁❍❆ ❇✙✎❋ ❳❀❊ ❁ ✡ ✁❍❆●✙✎❳❀❊❄✭ ✭ ✭✘✁❍❆ ❇✙✎■ ❳❀❊ ❁ ✣ ✁▲❁
✹☛✒ ✆ ✝ ✚ ✹✞✒ ✆ ✡ ✚☛✭ ✭ ✭ ✹✞✒ ✆ ✣ ✚✜✁✂✬✠✟✠✭                               and
Formal Languages for Linguists: Classical and Nonclassical Models
Example 4.6 As
✂✁☎✄    , take
✂✆✝✄    in the last example, with the following specific valence map-
ping:

✞✠✟ ✡☞☛ ✌✎✍✏✞☞✟ ✡✝✑ ✌✒✍✏✞☞✟ ✡✔✓ ✌✎✍✖✕ ,
✞✠✟ ✡✠✗ ✌✎✍✖✘ ,
✞✠✟ ✡✠✙ ✌✎✍✚✕✜✛✜✘✝✢

It generates:

✣ ✟   ✁☎✄ ✌✎✍✖✤ ✥✧✦✜★ ✦✧✩ ✦✫✪✧✬✮✭✚✕✜✯✧✢

An ordered grammar is:

✂✰ ✍✚✟ ✱✳✲ ✴✵✲ ✶✷✲ ✸✵✲ ✹☎✌ ,

where    ✹   is a strict partial order (i.e. irreflexive, asymmetric and transitive) over ✸✵✢

An immediate derivation in an ordered grammar ✺                              ✍✼✻✾✽✔✿❁❀     holds if and only if:

(i) there exist ✺      ☛ ✲ ✺ ✗✵❂ ✟ ✱❄❃❁✴☎✌ ❅         such that ✺     ✍ ✺ ☛❆ ✺ ✗     and ❀✫✍      ✺ ☛❇✺ ✗,
❆✖❈✼❉❊❇ ❂ ✸ and there does not exist any substring ❆●❋ of ✺                                such that there exists ❇✜❋ such
that ❆ ❋ ❈☞❉❊❇ ❋ ❂ ✸ and ❆ ❋ ❈✼❉❍❇ ❋☞■ ❆✖❈✼❉❍❇✔✢
(ii)
Thus, the production that is utilized at each step is maximal in the ordered set of rules.
Example 4.7 The ordered grammar:

✰ ✍❏✟ ✤✜✶✷✲ ❑✂✲ ▲▼✲ ❑ ❋ ✲ ▲ ❋ ✲ ❑ ❋ ❋ ✲ ◆✚✯✧✲ ✤ ✥✔✲ ★ ✲ ✩ ✯✧✲ ✶✷✲ ✸✵✲ ✹☎✌ ✲
where ✸✚✍❏✤✝✟          ✕ ✌ ❑●❋ ❋☞❈✼❉❖◆✾✲ ✟ ✘✧✌ ▲❈☞❉❖★ ✩ ✲ ✟ ◗✝✌ ❑✵❋☞❈✼❉❖◆✾✲ ✟ ❘✝✌ ▲❙❋☞❈✼❉❊▲❁✲ ✟ ❚✜✌ ❑✚❈☞❉❯◆✾✲ ✟ ❱✝✌ ▲❈☞❉
★ ▲❙❋ ✩ ✲ ✟ ❲✜✌ ▲✂❋❳❈☞❉❨◆✾✲ ✟ ❩✝✌ ❑❄❈✼❉❬❑✵❋ ❋ ✲ ✟ ❭✧✌ ❑❪❈☞❉❬✥✧❑●❋ ✲ ✟ ✕ ❫✝✌ ▲❴❈☞❉❨◆✏✲ ✟ ✕✜✕✜✌ ❑✵❋ ❋❳❈☞❉❬✥✠✲ ✟ ✕ ✘✧✌ ❑✵❋❳❈☞❉
❑❙✲ ✟ ✕ ◗✝✌ ✶❵❈☞❉❊❑●▲❁✯ and the order relation is satisfied by the following pairs:
✟ ✘✜✌❳✹✚✟ ◗✧✌ , ✟ ✘✧✌✎✹✚✟ ❚✧✌ , ✟ ❘✝✌✎✹✚✟ ◗✝✌ , ✟ ❱✝✌❳✹✖✟ ✕✜✌ ✲✔✟ ❱✧✌❳✹✚✟ ❚✜✌ , ✟ ❩✧✌❳✹✚✟ ❲✜✌ , ✟ ❭✝✌✎✹✚✟ ❲✧✌ , ✟ ✕✧✕ ✌❳✹✚✟ ✕ ❫✝✌ ✲
✟ ✕ ✘✧✌✎✹✚✟ ✕ ❫✝✌ ✲

generates:

✣ ✟   ✰ ✎✌ ✍✖✤ ✥✧✦✜★ ✦✜✩ ✦▼✪✧✬✮✭✚✕✜✯✧✢
Carlos Mart́ın-Vide
Generally speaking, there exist two main types of grammar derivations:
sequential: as is the case with grammars in the Chomsky hierarchy as well as all other
ones presented in this chapter so far;
parallel: which appear in several mechanisms, particularly in:
(i) Indian parallel grammars: at each step of the derivation, every occurrence of one
letter is rewritten (by using the same production),
(ii) Lindenmayer systems: at each step of the derivation, all occurrences of all letters
are rewritten (using different productions for different occurrences of one letter is
allowed: see below for details).

An Indian parallel grammar is a construct:
✁✄✂ ☎✝✆✟✞ ✠☛✡ ☞✌✡ ✍✎✡ ✏✄✑ ✒

The immediate derivation runs as follows:
for every ✓✝✔
✞ ✠✖✕✗☞✘✑ ✙ , for every ✚✗✔ ✞ ✠✛✕✗☞✜✑ ✢✤✣ ✓ ✆✦✥★✧✪✩ ✫ ✚ if and only if:
(i)   ✓ ✆ ✓✦✬ ✭✤✓✯✮ ✭ ✒ ✒ ✒ ✓✱✰✲✭✌✓✪✰ ✙ ✬ , ✭✳✔ ✠ , ✪✓ ✴✎✔ ✞ ✞ ✠✖✕✗☞✘✑✎✵✷✶ ✭✄✸ ✑ ✢ , ✹✜✺✼✻✽✺✼✾❀✿✷✹ ,
(ii)    ✚ ✆ ✓✦✬ ❁✤✓✯✮ ❁ ✒ ✒ ✒ ✓✱✰✲❁✌✓✪✰ ✙ ✬ ,
(iii)     ✭ ✵✦❂ ❁❃✔ ✏✤✒
Example 4.8 The Indian parallel grammar:

✁✄✂ ☎✝✆✟✞ ✶✲✍ ✸ ✡ ✶ ❄ ✸ ✡ ✍✎✡ ✶✲✍❅✵✦❂❆✍❇✍✎✡ ✍❈✵✯❂❆❄ ✸ ✑

yields ❉
✞ ✁✜✂ ☎✎✑✽✆✳✶ ❄ ✮ ❊ ✣ ✾●❋✷❍✪✸ ✒

A Russian parallel grammar is a construct:
✁✜■✪☎✝✆✟✞ ✠☛✡ ☞✌✡ ✍✎✡ ✏✄✑ ,

where
✏✳✆✼✏ ✬ ☛
✕ ✏ ✮ , ✏ ✬✎❏ ✏ ✮ ✆✼❑✪✒
An immediate derivation in a Russian parallel grammar is:
✓ ✆✯✥★✧✱▲ ✫ ✚ if and only if:
(i) either ✓
✆ ✓✦✬ ✭✤✓✯✮ and ✚ ✆ ✯✓ ✬ ❁✌✓✱✮ ✞ ✓✦✬ ✡ ✓✱✮✌✔ ✞ ✠✛✕✗☞✜✑ ✢ ✑ and ✭ ✯✵ ❂ ❁❃✔ ✏ ✬ ,
(ii) or ✓
✆ ✓✯✬ ✭✌✓✱✮ ✭ ✒ ✒ ✒ ✓✪✰▼✭✤✓✱✰ ✙ ✬ and ✚ ✆ ✓✯✬ ❁✌✓✱✮ ❁ ✒ ✒ ✒ ✓✪✰▼❁✤✓✱✰ ✙ ✬ (✪✓ ✴✜✔ ✞ ✞ ✠◆✕●☞✜✑❇✵❃✶ ✭✄✸ ✑ ✢ ,
✹✜✺✼✻✽✺✼✾❀✿✷✹ ✑ and ✭ ✵✯❂ ❁❃✔ ✏ ✮ ✒
✏ ✆✷❑ , one gets an ✁ ✂ ☎ ✒ If ✏ ✮ ✆✼❑ , one gets an CF.
If ✬
Formal Languages for Linguists: Classical and Nonclassical Models
4.2 Lindenmayer Systems

The motivation behind Lindenmayer systems ( systems for short) is biological. They are
✁   ) is a context-free pure (without a nonterminal
intended to model the (parallel) growth of living beings.
An interactionless Lindenmayer system (
alphabet) grammar with parallel derivations:

✂☎✄☎✆ ✝✟✞ ✠✡✞ ☛✌☞ ✞
✝                      ✠✎✍✏✝✒✑ is an axiom and ☛ is a finite set of rules of the form ✓✕✔✗✖ ,
with ✓
✘ ✝  and ✖
where is an alphabet,
✍ ✘✝ ✑ such that for each ✓
✍✘✝ there is at least one rule ✓✙✔✚✖ in ☛ (☛ is said
to be complete).
✠✜✛ ✞ ✠✣✢✣✍✘✝✒✑ , one writes ✠✜✛✤✄✦✥✧✠✣✢ if and only if ✠✜✛★✄ ✓ ✛ ✓ ✢✪✩ ✩ ✩ ✓✬✫ and ✠✣✢★✄ ✖ ✛ ✖ ✢✦✩ ✩ ✩ ✖ ✫ ,
for ✓✮✭✦✔✧✖ ✭
Given
✍✕☛✣✞ ✯✡✰✲✱✟✰✲✳✪✩ The generated language is:
✆ ✂✒☞✤✄✵✴ ✶✕✍✘✝✡✑✣✷✸✠✲✄✹✥✏✑✤✶✦✺✬✩
There are several important variants of
systems:

✻   if for each rule    ✓✌✔✧✖ ✍✕☛      ✖✽✄✿✼ ✾ , then ✂ is propagating (nonerasing);
one has
✻ if for each ✓ ✍✘✝ there is only one rule ✓✌✔✧✖ ✍✕☛ , then ✂ is deterministic;
✻ if a subset ❀    ✝ is distinguished and   ✆ ✂✒☞ is defined as the set ✴ ✶❁✍ ❀ ✑✡✷❂✠✵✄✦✥✏✑✣✶✦✺ ,
then
✂       of
is extended.
Regarding the generative power of
systems, many results are known, among others the fol-
lowing ones:

✻                                         ✁                                                  ❃✡❄✸❅ ✞ ❆✡❇✒✂✌✞   ❄✸❅ ✞ ❈ ❃
❃✒❄✬❅
The family of deterministic       languages is incomparable with
(     is the family of finite languages).
✻ ❈ ❃ is a strict subset of the family of extended ✁   languages.
✻ All   languages are contained in ❈✌❉ .
✁   system          ✂ is that it generates its language in a se-
✆ ✂ ✒ ☞ ✤✄ ✲ ✠
✲ ✄ ✲ ✠ ✣ ❊   ✞
A remarkable feature of a deterministic
✠ ✛ ✞ ✠ ✢ ✞ ✩   ✩ ✩               ✠ ✣❊ ✣✄ ✹ ✥ ✧ ✠ ✛ ✄✹✥✧✠ ✢ ✄✹✥❋✩ ✩ ✩ Thus, one can define
the growth function of , denoted ●❂❍ ■
quence
✠✣❏ ❑❂▲✕✷✬▼✿◆ ✔ , by:
such that
●❂❍ ■ ✠✣❏ ❑ ▲ ✆ ✳✦☞✟✄❖ ✠ ✫ ❖ ✞ ✳✕◗ ✁ ✩
Carlos Mart́ın-Vide
5 Nonstandard Generative Mechanisms

5.1 Contextual Grammars

A contextual grammar is a construct:

✂✁✂✄ ☎✝✆ ✞✟✆ ✄ ✠☛✡ ✆ ☞✌✡ ✍ ✆ ✄ ✠✏✎ ✆ ☞✑✎ ✍ ✆ ✒ ✒ ✒ ✆ ✄ ✠✔✓✕✆ ☞✖✓✗✍ ✍ ✆
consisting of:

✘ ☎ an alphabet,
✘ ✞✚✙✛☎✢✜ a finite set: the base or the set of axioms,
✘ ✠✔✣✤✙✥☎✦✜ selectors,
✘ ☞ ✣ ✙✥☎✦✜✑✧★☎✦✜ contexts,
✘ ✄ ✠✔✣ ✆ ☞✖✣ ✍ productions, ✩✦✪✬✫✭✪✬✮ ✒
In a contextual grammar, one considers two main types of immediate derivation:

✯ ✆ ✰✲✱★☎✢✜✑✳ ✯ ✁☛✴✶✵ ✷✸✰                              ✰✟✁✬✹ ✯✏✺ ✆ ✯ ✱★✠✔✣ ✆ ✄ ✹☛✆ ✻✼✍✭✱✽☞✖✣ ✆ ✩✢✪✥✫✝✪✥✮ ✒
external derivation:
for every                                   if and only if
✘       internal derivation:

✯✰✿✁ ✆ ✰✲✡ ✹✱★☎✢✎ ✻ ✜✌✳ ✯ ✆ ✁✏✎ ✴ ✱★✣ ✓✢✠✔✣ ✰ ✆ ✄ if✹☛✆ and   only if ✯
✁ ✯ ✡ ✯ ✎ ✯✔✾ and
✻✼✍✭✱✽☞✖✣ ✆ ✩✦✪✬✫✭✪✬✮ ✒
✯ ✯ ✯✾ ✯
for every
The language generated by an internal contextual grammar is:

❀ ✣ ✓ ✄  ✦✍✭✁❂❁ ❃✟✱★☎ ✜ such that there exists✺ ✱✽✞ such that✺ ✁✏✴ ✣✜ ✓ ❃✕❄✗✒
Another way of defining
❀ ✣ ✓✔✄  ✿✍ is to say that it is the smallest language ❀ such that:
(i)
✞✚✙ ❀ ,
✱ ❀ ✳ ✁ ✡ ✎
(ii) for every ✯ ✄ ✹☛✆ ✻✼✍✭✱✽if☞✖✯ ✣ ✒ ✯ ✯ ✯ ✾ and ✯
✎ ✱★✠✔✣ , for some ✫ , ✩✦✪✬✫✭✪✥✮ , then ✯ ✡ ✹ ✯ ✎ ✻ ✯ ✾ ✱ ❀                    ,
for every
If one introduces several different restrictions, the following natural variants of derivation arise:
Formal Languages for Linguists: Classical and Nonclassical Models
minimal local derivation:

for every✁✄✂       ☎✝✆✟✞✡✠☞☛✌✁✎✍✄✏✒✑✔✓✕☎ if and only if ☛
(i)  ✁✖✍✗✁✙✘ ✁✙✚ ✁✙✛ ,
(ii) ☎✜✍✢✁✄✘ ✣✕✁✤✚ ✥✌✁✤✛☞✦ ✁✙✚✧✆✟★✤✩ ✂ ✦ ✣✄✂ ✥✫✪✬✆✮✭✯✩ ✂ ✰✡✱✳✲✔✱✳✴✄✪ , and
(iii) there do not exist ✁✤✵ ✘ ✂ ✁✕✵✚ ✂ ✁✕✵✛ ✆✟✞ ✠ such that ✁✎✍✗✁✕✵ ✘ ✁✤✵✚ ✁✕✵✛ and ✁✕✵✚ ✆✟★✤✩ and ✶ ✁✤✵ ✘ ✶✫✷✸✶ ✁✙✘ ✶
and ✶ ✁✕✵✛ ✶✫✷✹✶ ✁✙✛ ✶ and ✶ ✁✤✵✚ ✶✫✺✹✶ ✁✤✚✻✶ ✼

A context is adjoined to a selector provided this is minimal (i.e. the shortest one) in such
a position.
maximal local derivation:

for every✁✽✂       ☎✜✆✟✞✾✠☞☛✌✁✎✍✄✏✢✿❀✓✕☎ if and only if ☛
(i)  ✁✖✍✗✁✙✘ ✁✙✚ ✁✙✛ ,
(ii) ☎✜✍✢✁✄✘ ✣✕✁✤✚ ✥✌✁✤✛☞✦ ✁✙✚✧✆✟★✤✩ ✂ ✦ ✣✄✂ ✥✫✪✬✆✮✭✯✩ ✂ ✰✡✱✳✲✔✱✳✴✄✪ , and
(iii) there do not exist ✁✤✵ ✘ ✂ ✁✕✵✚ ✂ ✁✕✵✛ ✆✟✞ ✠ such that ✁✎✍✗✁✕✵ ✘ ✁✤✵✚ ✁✕✵✛ and ✁✕✵✚ ✆✟★✤✩ and ✶ ✁✤✵ ✘ ✶✫✱✸✶ ✁✙✘ ✶
and ✶ ✁✕✵✛ ✶✫✱✹✶ ✁ ✛ ✶ and ✶ ✁✤✵✚ ✶✫❁✹✶ ✁ ✚ ✶ ✼

A context is adjoined to a selector provided this is maximal (i.e. the longest one) in such
a position.
minimal global derivation ( ✍✄✏ ✑✽❂ ): In the definition of ✍✙✏ ✑✔✓ , one replaces ✁✕✵✚ ✆✹★✤✩
with ✁✤✵✚ ✆✟★✕❃ , for every ❄✜☛✕✰✡✱✢❄✜✱✗✴✽✼ Note that the chosen selector has to be the shortest
one among all the selectors.
maximal global derivation ( ✍✙✏ ✿✧❂ ): In the definition of ✍✄✏ ✿❀✓ , the same substitution
as above is introduced. Note that the chosen selector has to be the longest one among all
the selectors.

Given ❅❆✆❆❇   ❈✎❉ ✂ ❈✝❊✤✂ ❋✳❉ ✂ ❋✗❊✤● , the language generated by the contextual grammar is:
❍✬■
✦ ❏✾✪✬✍❑❇ ▲▼✆✟✞ ✠ such that there exist◆❖✆✮ such that◆✳✍✄✏ ■✠ ▲✫●✌✼

If all the languages in ★✤✩ belong to the same family ◗ of languages in the Chomsky hierarchy,
❏ is said to be a contextual grammar with selection of type ◗ .

Example 5.1 The contextual grammar:
❏❑✍✹✦ ❇ ❘✤✂ ❙ ●✌✂ ❇ ❘✫❙ ❘✫❙ ●✌✂ ✦ ❘✫❙ ❚✄❘✤✂ ❇✫✦ ❘✕✂ ❘✕✪ ●✻✪ ✂ ✦ ❙ ❘✫❚✙❙ ✂ ❇✫✦ ❙ ✂ ❙ ✪ ●✻✪ ✪
generates:

❍                 ❍
✩ ❯✕✦ ❏▼✪✬✍       ✑✽❂ ✦ ❏✾✪✬✍❑❇ ❘ ❯ ❙ ✑ ❘ ❯ ❙ ✑ ☛✌✴✽✂ ❈❱✷❖✰✌●✌✼
Carlos Mart́ın-Vide
Example 5.2 The language:

✂✁☎✄ ✆✞✝✠✟ ✡ ✝✞✆✠☛☞✟ ✡ ☛✍✌✏✎✒✑ ✓✕✔✗✖✠✘
is generated by:

✙✛✚ ✝ ✁✗✜ ✄ ✆✢✑ ✡ ✑ ✟ ✘✞✑ ✄ ✟ ✟ ✘✞✑ ✜ ✟ ✑ ✄✏✜ ✆✢✑ ✡ ✣ ✘✠✣ ✣ ✤
Example 5.3 The language:

✂✁✗✄ ✆✏✥✒✘☞✦✧✄ ✆✞✝✠✡ ✝★✌✏✎✧✔☎✖✞✘
is generated by:

✙✪✩✬✫ ✁✭✜ ✄ ✆✢✑ ✡ ✘✞✑ ✄ ✆✢✑ ✆✞✡ ✘✞✑ ✜ ✆✮✑ ✄✏✜ ✯✰✑ ✆✏✣ ✘✠✣ ✑ ✜ ✆ ✥ ✡ ✑ ✄✏✜ ✆✮✑ ✡ ✣ ✘✠✣ ✣ ✤

Contextual grammars allow one to produce families of languages that are eccentric with respect
to the Chomsky hierarchy, as shall be seen below. This seems to be a very relevant feature from
a linguistic viewpoint, as natural languages could possibly occupy an eccentric position with
regard to that hierarchy.
5.2 Grammar Systems

Grammar systems are complex, modular generating architectures intended for either increasing
the generative power or decreasing the complexity of the generative strategy of the mechanism.
Several types can be distinguished.

A cooperating distributed grammar system (CDGS) is a construct:

✱✧✁✭✜ ✲✳✑ ✴☞✑ ✵✒✑ ✶✸✷ ✑ ✶✺✹ ✑ ✤ ✤ ✤ ✑ ✶ ✝ ✣ ✑
where:

✻ ✲✽✼✾✴✿✁✿❀ ,
✻ ✵✂❁✧✲ ,
✻ ✶ ✷✑✶ ✹✑✤✤✤✑✶ ✝    are finite sets of rewriting rules: the components of the system.
Several modes of derivation can be considered (being                             ❂   the set of integers):

✻   in exactly   ❃   steps:
✁✰❄❆❈❅✮❉ ❇ ✜ ❃ ❁ ❂ ✣ ,
Formal Languages for Linguists: Classical and Nonclassical Models
in at most ✁ steps: ✂☎✄✝✠ ✆✟✡ ✞ ,
in at least ✁ steps: ✂☛✄✝✠ ☞✌✡ ✞ ,
arbitrary derivation: ✂☛✄✎✠ ✍ ✡ ,
terminal or maximal derivation: ✂☎✄✑✠✏ ✡ ✒

✓ ✂☎✄ ✠✏ ✡☛✔ if and only if ✓ ✂☎✄✝✠ ☞✌✡✖
✕ ✔ and there does not exist any ✗✙✘✑✚ ✛✢✜✤✣✦✥ ✍ such that
✔ ✂☎✄ ✠ ✡ ✗✟✧

✁        ✁          ✁       ✁
Given a mode of derivation ★✩✘✫✪✬✂✮✭✰✯✟✱                       ✲ ✳✴✜✖✭✶✵       ✱✂       ✱✷         ✒       ✷✮✸✶✳ , the language generated
by an CDGS is:
✺❁                 ✺❁                               ✺❁
✹✻✺
✚ ✼✽✥✴✂✾✭ ✿✮✘✩✣ ✍ ✒✟❀ ☛✂ ✄         ✡ ❂ ✿ ✕ ✂☛✄        ✡ ❃ ✿❅❄❆✂☎✄❇✧ ✧ ✧✌✂☛✄            ✡ ❈ ✿❆❉✎✂❊✿✦✱ ❋●✷✾✸✰✱ ✸✦✵❊❍ ■❏✵❊❑✽✱ ✸✦✵✎▲✙✵✝❋✫✳✶✧

Thus, five languages are associated with ✼✴✧
Example 5.4 The CDGS:
✼✫✂▼✚ ✭ ❀ ✱ ◆❖✱ ◆❅ ✱ ◗✙✱ ◗❖ ✳✶✱ ✭ ❘❙✱ ❚ ✱ ❯ ✳✶✱ ❀ ✱ ❱ ✕ ✱ ❱ ❄ ✥
consisting of:

❱ ✕ ✂✾✭ ❳ ❀ ❲☎❨❩❀ ✱ ✑
❀ ❲☎❨ ◆❬◗✙✱ ◆  ❲☎❨ ◆❖✱ ◗  ❲☛❨ ◗✤✳ ,
❱✽❄❅✂✾✭ ◆ ☛❲ ❨ ❘✟◆  ❚ ✱ ◗ ☛❲ ❨ ❯ ◗  ✱ ◆ ❲☎❨ ❘✶❚ ✱ ◗ ❲☎❨ ❯ ✳ ,

generates:

✹✴❭
❄ ✚ ✼✽✥✴✂✾✭ ❘✰❪✶❚ ❪✶❯ ❪✟✱ ❑✫✷✾✸✰✳✶✱
✹ ❭                 ✹                       ✁
✞ ✚ ✼✻✥✴✂ ☞✌✞ ✚ ✼✻✥✴✂✝❫✌✱ ❴❏❵ ❛ ❜ ✷✝❝✌✧

Example 5.5 The CDGS:
✼❞✂✾✚ ✭ ❀ ✱ ◆❖✱ ◆❅ ✳✶✱ ✭ ❘✌✱ ❚ ✳✶✱ ❀ ✱ ❱ ✕ ✱ ❱ ❄ ✱ ❱✽❡ ✥
consisting of:

❱ ✕ ✂✾✭ ❳ ❀ ❲☎❨❩❀ ✱ ✑
❀ ❲☎❨ ◆❬◆✦✱ ◆  ❲☎❨                 ◆❖✳ ,
❱✽❄❅✂✾✭ ◆ ☛❲ ❨ ❘✟◆  ✱ ◆ ❲☎❨ ❘❙✳ ,
Carlos Mart́ın-Vide
✂✁☎✄✝✆ ✞✠✟☛✡✌☞ ✞☎✍ ✎ ✞✠✟✏✡✑☞ ✒

generates:

✓✕✔✗✖ ✘ ✙✛✚✛✄✜✓✣✢✗✖ ✘ ✙✛✚✕✄✠✆ ✤✥✤✠✦✧✤✠★✩✆ ✪✫✎ ☞ ✒ ✬✛✒✧✭

✘ ✲☛✚
Let ✮✰✯✰✱        denote the family of languages generated by CDGS’s of degree (the number of
✲✗✭
components) at most ✳ (✳✠✴✶✵ ) working in the mode If the number of components is not
✭                                        ✘ ✄✠✺✗✚                         ✘
limited, one writes ✷ instead of ✳ The union of all families ✮✰✯✹✸                        (respectively, ✮✻✯✹✸ ✴
✺✼✚         ✘ ✽✠✺✗✚ ✺                                    ✘ ✄✻✚                        ✘ ✚        ✘ ✽✻✚
, ✮✻✯ ✸        ), ✴✠✵ , is denoted by ✮✰✯ ✸                (respectively, ✮✰✯ ✸ ✴ , ✮✰✯ ✸          ). If ✾ -rules
✘ ✲✏✚           ✘ ✲✏✚
are accepted, one writes ✮✻✯❀✱ ✿        , ✮✰✯❁✸ ✿       , etc. Many results on CDGS’s’ generative capacity
are known:

❂ ✻          ✘ ✲✏✚✛✄                      ✲❄★✩✆❆❅✼✎ ❇ ✎ ✄ ✎        ✒☎❈❉✆✧✽✠✺❁✦✼✺         ✒✧✭
✮ ✯✹✸              ✮✰❃ , for every                      ✵ ✴✝✵                   ✴✠✵
❂ ✮✻❃ ✄ ✻     ✮ ✯❁❊
✘ ✲✏✚☎❋
✮✰✯
✖ ✘ ✲☛✚❍●
✮✻✯❏■
✘ ✲☛✚❍●
✮✰✯ ✸
✘ ✲☛✚
, for every
✲✩★❑✆❆✄✝✺✫✎ ✺❄✦✫✺
✴▼▲ ,
◆ ✴✜❖ ✭
❂ ✮✻✯❏■ ✘ ✄✠✺✗✚✕● ✮✰✯✰■ ✘ ✄✠ ✺✗✚ , for every ✺✫✎ ◆ ✎  ✴✝✵ ✭
❂ ✮✻✯ ■ ✘ ✴ ✺✗✚✣● ✮✻✯ ■ ✘ ✴ ✺✻◗ ✵ ✚ , for every ✺✫✎ ◆ ✴✝✵ ✭
❂ ✮✻✯ ✸ ✘ ✴ ✚✣● ✮✰✯ ✸ ✘ ✄✻✚ ✭
❂ ✮✻❃ ✄ ✮✰✯ ❊ ✘ ❇ ✚✛✄ ✮✰✯ ✖ ✘ ❇ ✚✣❋ ✮✻✯ ✁ ✘ ❇ ✚✕✄ ✮✻✯✹✸ ✘ ❇ ✚ ✭
❂ All the six relations above are also true for ✮✻✯ ✿ systems.

A parallel communicating grammar system (PCGS) is a construct:

✙❉✄▼✘ ❘❀✎ ❙❉✎ ❚☎✎ ✘   ✎ ❯ ✚ ✎ ✘   ✖ ✎ ❯ ✖ ✚ ✎ ✭ ✭ ✭ ✎ ✘   ✎ ❯ ✚ ✚ ✎
❊ ❊                                 ✱ ✱
where:

❂ ❘❀✎ ❚❍✎ ❙ are pairwise disjoint alphabets,
❂ ❙✌✄❱✆ ❲ ❊ ✎ ❲✻✖ ✎ ✭ ✭ ✭ ✎ ❲ ✱ ✒ are query letters (the subindex associates the letter to the corre-
sponding component),
❂ ✫❯ ❳✂★❉❘ ,
❂   ❳  are finite sets of productions over
❘❱❈❀❙❨❈❁❚
,   ✵
✽✜❩✛✽

✄❪✘ ❘❨❈❫❙❪❈❄❚✻✚                           ✘ ❴ ✎ ❴☛✖ ✎ ✭ ✭ ✭ ✎ ❴ ✚ ❴ ❳ ★
Given ❬✼❭                         , every ✳ -uple          ❊                 ✱ ,      ✻
❬ ❭ ❵ , is a configuration of the
system.
✘ ❴ ✎ ❴ ✖ ✎ ✭ ✭ ✭ ✎ ❴ ✚ ✘ ❛ ✎ ❛ ✖ ✎ ✭ ✭ ✭ ✎ ❛ ✚ ❴✫❳ ✎ ❛ ❳✂★                ✽✜❩✕✽
Given two configurations
✘❊ ❴ ✎ ❴ ✖ ✎ ✭ ✭ ✭ ✎ ✱ ❴ , ❀
✚ ✄☛❊ ❜   ✘ ❛ ✎ ❛ ✱ ✖ ✎ ,✭ ✭ ✭ ✎ ❛ ✚ ✻
❬ ❭❵ ,✵       ✳ , one defines
the immediate derivation                ❊                   ✱         ❭ ❊                       ✱ if and only if either of the
following situations occur:
Formal Languages for Linguists: Classical and Nonclassical Models

✁✄✂   ☎✝✆✟✞                  ✁✠✂✡✆✡☛✝☞ ✌✎✍ ✂ ✏          ✁✄✂✓✒✕✔✗✖         ✁✄✂✡✆✘✍ ✂
(i) either (                                ) and ((                       or ✑               and               )), ✙✛✚✘✜✢✚✘✣ ,
✁ ✂   ☎✧★ ✞
✁✠✂✢there
(ii) or   ✪        ✂ ✭ ✩ ✮ ✬✦✜ ✂ ✯✡
✤ ✙✕
✆ ✩ ✫ ✬✗exists             ✰ ✰ ✚✥      ✬✗✚✧
✰ ✩ ✱ ✜✦  ✂ ✲ ✩ ✣✱ ✳✎✫ such that✩ ✷✦✒✹✸✦✺ ✖   ✩ ;✷✻  in    ✆✪✞ a case, for every ✜   ✁✄one
☎✟such                                         writes
✂ ❁✻  ☎✟✆✪✞
, ✴
✗ ✵
✶  ✙   ,
✍ ✂❀✆✶✩✻✫ ✁✄✂ ✭ ✩ ✮ ✁✠✂ ✯✡✰ ✰ ✰ ✩ ✱ ✁✄✂ ✲ ✩ ✱ ✳✎✫  ,                ,  ✼
✍ ✂ ❁✦✆❅❄✄✂ ❁  ✚ ✟✽ ✾ ✚ ✟ ✴ ❀ ✿ ✟ ✙ ; if             ,
✙❂✚❃✽✕✚❃✴ ,   then ✁ ✂ ❁   ☎✶✆❃   ❇ ✞                    ✍ ✂ ✆✟✁ ✂              [and                   , ✙❆✚✟✽✕✚✪✍ ✴ ];   ✂ if, for some ✽ ,
✙✛✚✘✽❆✚✟✴ ,              ✍ ✂ ✆✘✁ ✂ , then                           ; for every ✜ , ✙✛✚❃✜❈✚❃✣ , for which is not specified
above, one has                              .
(i) is a rewriting step, (ii) is a communication step: the latter has a priority over the former (i.e.
if both are possible at a certain stage of the derivation process, communication must be applied
before).

The blocking of an PCGS may happen in either of the following cases:

❉ when one component ✁✄✂ in ✑ ✎       ✁ ✫ ✰ ✰ ✰ ✁✠❊❋✏
✤ ✤          is not terminal but cannot be rewritten according
to ● , or
❉ when a circular query occurs: ● ✂ ✭ introduces ✬✗✂ ✯ , ● ✂ ✯ introduces ✬✦✂ ❍ ✤ ✰ ✰ ✰ ✤ ● ✂ ■ ❏ ✭ introduces
✬✗✂ ■         ✂■            ✬✦✂ ✭
, and ●    introduces       (communication has priority but it cannot take place, because
strings to be communicated must contain no query letters at all).
The language generated by an PCGS is:

❑         ✏✢✆✪▼ ✁✕✒✕✔✗✖❖◆ ❄ ✫ ❄ ✮ ✰ ✰ ✰ ❄ ❊ ✏✢✆✡☛✝✖ ✁ ✮ ✰ ✰ ✰ ❊ ✏ ✂ ✒◗✸✦✺ ✖
✑▲                    ✑ ✤ ✤         ✤           ✑ ✤ ✤   ✤ ✤          ✤ ❘✛✚✟✜❀✚✟✣✓❙ .
Thus, the language of the ❄✓
system
✫    is the language of the master component, which is the first
component of the system: .
✂✓❚        ✔✦✏ ✖✄❲            ✔✗✏ ✖
An PCGS is said to be centralized if and only if ●     ✑ ❯✝❱        ✑ ❯✝❱     , ❘✼✚✘✜✢✚✘✣ (i.e. only
the master is allowed to introduce query letters). Otherwise, it is said to be noncentralized.

An PCGS is called returning if and only if, after communication, each component that has
communicated goes back to its axiom and starts
❑✢❳ ✏ again.
❑ ❊ ❳ Otherwise,
✏        it is called nonreturning.
An PCGS ▲ will produce two languages, ✑ ▲ and           ✑ ▲ ✤ according to the returning or non-
returning mode of working, respectively.

By default, one understands that an PCGS works in a noncentralized, returning mode. Some
conventional notations include:

❊✻❩
●✦❨   : family of languages
❩ ❩❬generated
✒❭▼ ❪✗❫✛❴ by
❑✢❵ noncentralized,
❄ ❪✗❫ returning PCGS’s with at most
✣ components of type ,                ✤ ❯✕✤ ❨✦❛❖✤ ❨ ✤      ❙ ,
❊ ❩                 ❊ ❩
❨✦●✛❨                    : ●✦❨         ✿ centralized mode,
❊✻❩                 ❊ ❩
❯✕●✦❨                    : ●✦❨      ✿ nonreturning mode,
❊ ❩               ❊ ❩
❯✕❨✦●✛❨                     : ❨✦●✛❨      ✿ nonreturning mode,
Carlos Mart́ın-Vide
✂✁☎✄✝✆✟✞✡✠☞☛ ✌✎✍✏ ✂✁ ☛ ✆           (analogously for
✁✂ ✑✁☎✄✝✆ , ✒  ✂✁☎✄✓✆ , ✒ ✁✂ ✑✁☎✄✝✆                  ).
Example 5.6 The PCGS:

✔✕✞✗✖ ✘✚✙ ✍ ✛ ✙✢✜ ✛ ✙✢✣ ✤ ✛ ✥✦✛ ✘ ✧ ✛ ★ ✤ ✛ ✖   ✍ ✛ ✙ ✍ ✩ ✛ ✖  ✪✜ ✛ ✙✢✜ ✩ ✛ ✖  ✫✣ ✛ ✙✢✣ ✩ ✩
consisting of:

✍ ✞✬✘✚✙ ✍✮✭✰✯ ✧✏✙ ✍ ✛ ✙ ✍✮✭✢✯ ✧ ✣ ✱ ✜ ✛ ✙✢✜ ✭✰✯✲★ ✜ ✱ ✣ ✛ ✙✢✣ ✭✰✯✴✳ ✤ ,
✫✜☎✞✬✘✚✙✢✜ ✭✰✯✲★ ✙✢✜ ✤ ,
✫✣☎✞✬✘✚✙✢✣ ✭✰✯✲✳ ✙✢✣ ✤ ,

generates:

✵✪✶ ✖ ✔ ✩ ✡            ✞ ✘ ✧ ☛ ★ ☛ ✳ ☛☞✷✹✸✕✺✼✻ ✤✾✽
✞ ✵ ☛ ✶ ✖✔ ✩ ✬
Example 5.7 The PCGS:

✔✕✞✗✖ ✘✚✙ ✍ ✛ ✙ ✜ ✤ ✛ ✥✕✛ ✘ ✧ ✛ ★ ✤ ✛ ✖   ✍ ✛ ✙ ✍ ✩ ✛ ✖   ✜ ✛ ✙ ✜ ✩ ✩
consisting of:

✍ ✬✞ ✘✚✙ ✍ ✭✰✯ ✙ ✍ ✛ ✙ ✍ ✰✭ ✯ ✱ ✜ ✱ ✜ ✤ ,
✜ ✬✞ ✘✚✙ ✜ ✰✭ ✯ ✧✏✙ ✜ ✛ ✙ ✜ ✢✭ ✯✴★ ✙ ✜ ✛ ✙ ✜ ✭✢✯ ✧ ✛ ✙ ✜ ✭✢✯✴★ ✤ ,

generates:

✞ ✘ ❀✝❀ ✷ ❀✼❁❂✘ ✧ ✛ ★ ✤ ❃✫✤✾✽
✞ ✵ ☛ ✶ ✖✔ ✩ ✬
✵ ✶ ✖✔ ✩ ✿

Let ❄
✞✗✘  ✑✁ ✛ ✁✂ ✑✁ ✛ ✒  ✂✁ ✛ ✒ ✁✑ ✂✁❅✤ . The following results about PCGS’s’ generative power
are known:
❆❈❇ ☛ ✁✑✙✪❉❊✞●❋✓❍  , for every , for every            ❇ ❁ ❄ , where ✁☞✙✪❉ indicates that productions of
arbitrary type are utilized.
✸✺✼◗ ✩         ☛ ❋✂❍✑■ ✭ ✁✂❖ ✞✡◆❅✖ ✸✺✡❘ ✩
❆❈❇ ☛ ❋✓❍✑■ ✭ ✵❑❏ ✒▼✞✡
▲ ,◆   ❇ ☛ ❑✵ ❏ ✭ ✑
✒    ✁ ❖    ✞
✡ ▲   ❅
◆   ✖               ❇                ▲
❇ ❁   ❄ .
, and                               , for
every
☛        ✭           ✸✕✺✡◗                           ❁❂✘ ✒  ✑✁ ✛ ✒ ✁✂ ✑✁ ✩ .
❆❈❇ ✓❋ ❍✑■ ✁✂❖ ✞✡    ◆
▲ ,             , for every ❇
Formal Languages for Linguists: Classical and Nonclassical Models
✂✁☎✄✝✆✟✞✡✠ ☛✌☞✍☛✏✎✒✑✒✓✍✔✡✕✖✆✗☛✍☞✌☛✏✎✒✑✌✓✍✔✍✘✒✚✡✙ ✛ .
✂☛✌☞✍☛✏✜ ✑✌✓✍✔✣✢✡☛✌✤ , ☞✍☛✏✜ ✑✌✓✍✔✣✥✡☛✌✤✏✦
✂☛✌☞✍☛ ✎ ✑✒✓✍✔ contains only semilinear languages.
✂☛✌☞✍☛✏✜ ☛✍✤ contains nonsemilinear languages.
If✱ ✱✳✁✡✲ ✥★✧✍✩ , ✁✡✪✫☛✌☞✍☛✭✬✮✑✒✓✍✔ , then there exists a constant ✯ such that for every ✰ ✪✫✁ , if
❆❈✰ ❇ ✽✍✯ ❉ then      ✰                                                             ✙ ❃ , ✽✍✾✡❅✼✾✡✿ , and for every
✚✵✴✷✶ ✸✝✶ ✴ ✜ ✸ ✜✹✦ ✦ ✦ ✴✳✺✏✸ ✺☎✴✳✺✼✻✷✶ , ✽✌✾✡✿❀✾✡❁ , ✸ ❂ ✚❄
✴✹✶ ✸❋✶❊ ✴ ✜ ✸❋✜❊ ✦ ✦ ✦ ✴✳✺✏✸❋✺ ❊ ✴✳✺✼✻✷✶ ✪●✁✏✦
✂☛✌☞✍☛✭✬✮✑✌✓✍✔✣✢✵☛✍☞✌☛✭✬ ✻❍✶ ✑✒✓✍✔ , ❁ ❇ ✽ ✦
✂☞✌☛ ✬ ✑✒✓✍✔✣✢✡☞✍☛ ✬ ✻✷✶ ✑✒✓✍✔ , ❁ ❇ ✽ ✦
✂☛✌☞✍☛✭✬✮✑✌✓✍✔✣✢✵☛✍☞✌☛✭✬✝✁☎✄✝✆■✢✡☛✌☞✍☛✭✬✮☛✌✤ , ❁ ❇ ✽ ✦
✂✆✗☛✌☞✍☛✏✎✒☛✍✤❏✥■☞✌☛✏✎✒☛✍✤ (i.e. a centralized + nonreturning working mode is weaker
than a noncentralized + returning one).
✂☛✍❑ ✚✡▲ ✬ ☛✍❑ ✚✡▲ ✎ ▼☛ ❑ , ❁ ❇ ✽ , for every ▲ ✪✫◆ ☛✌☞✍☛✌❖ ✆✗☛✌☞✍☛▼ (i.e. by using centralized
CS PCGS’s, one does not go beyond the family CS).
✂☛✍❑ ✚ ☞✌☛ ✶ ☛✍❑ ✚ ☞✌☛ ✜ ☛▼❑◗✢❀☞✍☛✏❘ ☛✍❑ ✚ ☞✌☛ ✎ ☛▼❑ ✚ ✑✌✓ (noncentralized returning
PCGS’s with three CS components suffice to generate every RE).
✂☛✍❑ ✚ ✆✗☞✌☛ ✶ ☛✍❑❙✢❚✆✗☞✍☛ ✜ ☛▼❑ ✚ ✆✗☞✍☛ ✎ ☛✍❑ ✚ ✑✒✓      (noncentralized nonreturning
PCGS’s with just two CS components are enough to generate every RE).
❯ ✬ ☛✍❑✼❱ , ❁ ❇ ✽ , ❯ ✪❲❇✡◆ ☞✌❳ ☛✌❖ ☛✍☞✌☛✌❖ ✆✗☞✍☛✌❖ ✆✗☛✌☞✍☛▼ ❉ ☛▼❑ ✚ ❯ ✶ ☛▼❑✼❱✍✢ ❯ ✜ ☛✍❑✼❱ ✚
❯ ✬ ☛✍❑✼❱ ✚ ✑✒✓ , for every ❁ .
Given
5.3 Grammar Ecosystems

The postulates behind the notion of a grammar ecosystem are the following:

a) An ecosystem consists of an environment and some agents. The state of the environment
as well as the states of the agents are all described by means of strings of letters from
certain alphabets.

b) There exists one universal clock for the evolution of both the environment and the agents.

c) Both the environment and the agents have specific evolution rules, which are Linden-
mayer rules (i.e. they are applied in parallel to all the letters describing the states of the
environment and of the agents).

d) The rules for the evolution of the environment are independent from the agents and from
the state of the environment. The rules for the evolution of the agents depend on the state
of the environment in such a way that, at each step of the derivation, a specific appropriate
subset of rules is selected from the set of rules of each agent.
Carlos Mart́ın-Vide
e) The agents act on the environment through action rules, which are sequential (i.e. non-
parallel) rewriting rules. The selection of the specific action rule to be applied at each
step depends on the current state of the agent.

f) Agents’ action on the environment has a priority over the environment’s evolution. At
each step, the rules for the evolution of the environment rewrite in a parallel way only the
environment letters that are not affected by agent’s actions.
A grammar ecosystem is a construct:

✂✁☎✄ ✆✞✝ ✟✡✠ ✝ ✟☞☛ ✝ ✌ ✌ ✌ ✝ ✟✎✍✑✏
consisting of:

✒ ✆☎✁☎✄ ✓✕✔✖✝ ✗✘✔✘✏ , with:
✓✙✔ a finite alphabet,
(i)
(ii)
✗✖✔ a finite set of 0L rules over ✓✙✔ (evolution rules of ✆ ).
✒ ✟✎✚✛✁☎✄ ✓✕✚ ✝ ✗✛✚ ✝ ✜✢✚ ✝ ✣✛✚ ✝ ✤✘✚ ✏ , ✥✡✦★✧✩✦★✪ , with:
✓ ✚ a finite alphabet,
(i)
✗✘✚ a finite set of 0L rules over ✓✕✚ (evolution rules of the agent ✧ ),
(ii)
✜✢✚ a finite set of rules ✫✭✬✯✮ , with ✫✱✰ ✓✡✔ ✲ , ✮✳✰ ✓✡✔ ✴ (action rules of the agent ✧ ),
(iii)
✣✛✚✘✵✕✓✡✔✷✴ ✶ ✬✹✸ ✄ ✗✛✚ ✏ (it selects the rules for the current evolution of the agent ✧ ),
(iv)
(v)
✤ ✚ ✵✛✓ ✚ ✲ ✶ ✬✺✸ ✄ ✜ ✚ ✏ , ✥✳✦✻✧✢✦☎✪ (it selects the rules for the current action of ✟ ✚ on
the environment).
A grammar ecosystem works by modifying the strings representing the agents as well as the
environment.

A state of a grammar ecosystem is:

✼ ✁☎✄ ✽✎✔✖✝ ✽ ✠ ✝ ✽ ☛ ✝ ✌ ✌ ✌ ✝ ✽ ✍ ✏ ✝
where:

✒ ✎✽ ✔ ✰ ✓✡✔ ✴ ,
✒ ✽ ✚ ✰ ✓✡✚ ✴ , ✥✡✦✾✧✖✦✾✪ .
Given ✼
✁✿✄ ✽✎✔✖✝ ✽ ✠ ✝ ✽ ☛ ✝ ✌ ✌ ✌ ✝ ✽ ✍ ✏ , ✟ ✚ is an active agent in ✼ if and only if ✤ ✚ ✄ ✽ ✚ ✏✱✁❂                 ❀ ❁ . An
✟✢✚ in ✼ is an application of ❃✻✰ ✤✛✚ ✄ ✽❄✚ ✏ on ✽ ✔ . A simultaneous action of the
action of
✚ ❅  ✝   ✟✢✚ ❆ ✝ ✌ ✌ ✌ ✝ ✟✎✚ ❇ , ❈ ✧ ✠ ✝ ✧ ☛ ✝ ✌ ✌ ✌ ✝ ✧ ❉ ❊✡❋✻❈●✥ ✝ ❍✑✝ ✌ ✌ ✌ ✝ ✪✘❊ ✝ on the environment is a 1-step parallel
agents
derivation
✽ ✔ ✁✛■✂❏✞✽✢✔❑  such that:
Formal Languages for Linguists: Classical and Nonclassical Models
(i)       ✂✁☎✄✝✆✟✞ ✠✡✞ ✆✡☛ ✠☞☛✡✌ ✌ ✌ ✠✎✍ ✆✎✍ ✏✡✞ ,
(ii)       ✂✑✁ ✄✝✆✟✞ ✒✓✞ ✆☞☛ ✒✓☛✟✌ ✌ ✌ ✒ ✍ ✆☞✍ ✏☞✞ , and
(iii)      ✠✕✔✂✖✗✒ ✔✙✘✛✚✢✜ ✣ ✤  ✥✜ ✣ ✦ , ✧✩★✫✪✬★✮✭ , ✆✎✜✢✘✰✯✩✁ ✱ , ✧✩★✝✲✳★✝✭✙✴✝✧ ✌

A state change of a grammar ecosystem is an 0L evolution of the states of all the agents (i.e.
✜ ✄✟✵✷✶✬ ✙✜✑ , according to the productions in ✸ ✜ ✤  ✂✁✟✦ , ✧✩★✮✲✳★✮✹ ) together with an 0L evolution
of the environment in all its points (i.e.   ✁ ✄✡✵ ✶  ✂✑✁ , according to the productions in ✺ ✁ ),
except those ones that are currently affected by the agents’ actions (according to the productions
in ✚✢✜ ).

Given two states in ✻ , ✼ ✄✽✤   ✁✢✾   ✞ ✾   ☛ ✾ ✌ ✌ ✌                 ✾  ✥✿❀✦ , ✼ ❁✑ ✄❂✤  ✙✁✑ ✾  ✂✑✞ ✾  ✙☛✑ ✾ ✌ ✌ ✌ ✾  ✙✿✑ ✦ , one says that ✼
changes to ✼ ✑ (or ✼ ✑ directly derives from ✼ :                     ✼ ✄✟✵✷✶ ✼ ✑ ) if and only if:

(i)        ✁ ✄✮❃ ✞ ✆ ✞ ❃ ☛ ✆ ☛ ✌ ✌ ✌ ❃ ❄✥✆✎❄✂❃ ❄ ✏✡✞ and  ✂✑✁ ✄✮❃ ✑✞ ❅ ✞ ❃ ☛✑ ❅ ☛ ✌ ✌ ✌ ❃✓❄✑ ❅ ❄✥❃✓❄✑ ✏☞✞ and ❃ ✞ ✆ ✞ ❃ ☛ ✆ ☛ ✌ ✌ ✌ ❃ ❄✥✆✎❄✂❃ ❄ ✏✡✞ ✄✡✵ ✶
❃ ✞ ❅ ✞ ❃ ☛ ❅ ☛✟✌ ✌ ✌ ❃ ❄ ❅ ❄ ❃ ❄ ✏✡✞ is a simultaneous action of all the agents ❆ ✜ ❇ ✾ ❆ ✜ ❈ ✾ ✌ ✌ ✌ ✾ ❆ ✜ ❉ , ❊ ✲ ✞ ✾ ✲ ☛ ✾ ✌ ✌ ✌ ✾ ✲ ❄✙❋✩●
❊❀✧ ✾ ❍✕✾ ✌ ✌ ✌ ✾ ✹ ❋ , that are active in ✼ and ❃✓✑✞ ❃✓☛✑ ✌ ✌ ✌ ❃✓❄✑ ❃✓❄✑ ✏☞✞ is an evolution from ❃ ✞ ❃ ☛✟✌ ✌ ✌ ❃ ❄ ❃ ❄ ✏☞✞ ✾
(ii)         ✂✜✑ is an evolution of ❆ ✜ from  ✥✜ , ✧■★✮✲❁★✮✹ .

The sequences of states characterize the evolutionary behaviour of ✻ . Let ✼✡❏ be an initial state.
One may define:

❑   The set of sequences of states of ✻ :
▲❁▼ ◆ ✤ ✻ ✾ ✼✎❏ ✦✳✄ ❊❀❊ ✼ ✜ ❋ ✜❖  ✼✎❏ ✄✟✵✷✶ ✼ ✞✥✄✟✵✷✶ ✼ ☛✥✄✟✵✷✶❘✌ ✌ ✌ ❋ ✌
✂❏ ◗
❑   The set of sequences of states of ❙ :
▲❁▼ ◆ ✳✁ ✤ ✻ ✾ ✼✎❏ ✦✳✄ ❊❀❊  ✂✁✕❚ ❋ ✜❖  ❊ ✼ ✔ ❋ ✔❖  ✘ ▲❁▼ ◆ ✤ ✻ ✾ ✼☞❏ ✦              ✔ ✄❯✤  ✂✁ ✣ ✾  ✙✞ ✣ ✾  ✂☛ ✣ ✾ ✌ ✌ ✌ ✾   ✿ ✣ ✦ ❋ ✌
❏ ◗
✙           ❏                       and ✼

❑       The set of sequences of states of ❆                ✔ (■
✧ ★✷✪✬★✝✹ ):
▲❁▼ ◆ ✔ ✤ ✻ ✾ ✼ ✦✳✄ ❀❊ ❊  ✳✔ ❱ ❋ ❖❲  ❊ ✼ ❲ ❋ ❖❲  ✘ ▲❁▼ ◆ ✤ ✻ ✾ ✼ ✦                ❲ ✄❯✤   ✁ ❱ ✾   ✞ ❱ ✾ ✌ ✌ ✌ ✾
❏                   ❏ ◗           ❏               ❏       and ✼
✳✔ ❱ ✾ ✌ ✌ ✌ ✾  ✥✿ ❱ ✦ ❋ ✌
❑       The language of the environment:
❳ ✳✁ ✤ ✻ ✾ ✼✎❏ ✦✳✄ ❊  ✂✁✛✘✰✯✩✁ ✱ ❊ ✼ ✔ ❋ ✔❖  ✘ ▲❁▼ ◆ ✤ ✻ ✾ ✼✎❏ ✦        and ✼    ✔ ✄❨✤  ✂✁ ✾  ✙✞ ✾  ✂☛ ✾ ✌ ✌ ✌ ✾   ✿ ✦ ❋ ✌
◗           ❏
❑       The language of the agent ❆               ✜ (✩ ✧ ★✝✲✳★✝✹ ):
✘ ✯ ✜ ✱ ◗ ❊ ✼ ✔ ❋ ✔❖  ❏ ✘ ▲❁▼ ◆ ✤ ✻ ✾ ✼☞❏ ✦
❳ ✜ ✤ ✻ ✾ ☞✼ ❏ ✦✳✄ ❊   ✜ ✰                                              and ✼   ✔ ✄❯✤  ✂✁ ✾  ✙✞ ✾ ✌ ✌ ✌ ✾   ✜ ✾ ✌ ✌ ✌ ✾   ✿ ✦ ❋ ✌
Carlos Mart́ın-Vide
Example 5.8 The grammar ecosystem:

✂✁☎✄ ✆✞✝ ✟✡✠ ☛
with:

✆☎✁☎✄ ☞✍✌✎✝ ✏✑✌✑☛ , where:
☞ ✌ ✁✓✒ ✔✖✕ ,
✏ ✌ ✁✓✒ ✔✞✗✙✘✚✔✍✕ .
✟ ✠ ✁☎✄ ☞ ✠ ✝ ✏ ✠ ✝ ✛ ✠ ✝ ✜ ✠ ✝ ✢ ✠ ☛ , where:
☞✣✠✤✁✓✒ ✥ ✕ ,
✏✤✠✤✁✓✒ ✥✡✗✣✘✚✥ ✕ ,
✛ ✠ ✁✓✒ ✔✞✗✙✘✦✔★✧ ✕ ,
✜ ✠ ✄ ✩✡☛✤✁✪✏ ✠ , for every ✩✬✫✭☞✯✌ ✮ ,
✢ ✠ ✄ ✰✣☛✎✁✪✛ ✠ , for every ✰✱✫✲☞✯✠ ✳ .

produces:

✎✴ ✵ ✶ ✄  ✷✝ ✸✍✹ ☛✤✁✓✒✺✄ ✔✍✝ ✥ ☛ ✝ ✄ ✔ ✧ ✝ ✥ ☛ ✝ ✄ ✔★✻ ✝ ✥ ☛ ✝ ✼ ✼ ✼ ✝ ✄ ✔★✽ ✾ ✳ ✠ ✝ ✥ ☛ ✝ ✼ ✼ ✼ ✕ ,
✿✤✌✤✄  ✷✝ ✸ ✹ ☛✤✁✓✒ ✔ ✽ ✾ ✳ ✠ ✝ ❀✤❁❃❂✍✕ ,
✿ ✠ ✄  ✷✝ ✸✍✹ ☛✤✁✓✒ ✥ ✕ .
If
✏✤✠ above is replaced by ✏✯✠ ❄ ✁❅✒ ✥❆✗✣✘❈❇✙✕ , the agent becomes inactive after the first step and
therefore does not act on the environment anymore:

✴✎✵ ✶ ✄  ✷✝ ✸ ✹ ☛✤✁✓✒✺✄ ✔✍✝ ✥ ☛ ✝ ✄ ✔❉✧ ✝ ❇✣☛ ✕ ,
✿ ✌ ✄  ✷✝ ✸✍✹ ☛✤✁✓✒ ✔✖✝ ✔❉✧ ✕★✼

Example 5.9 The grammar ecosystem:

✂✁☎✄ ✆✞✝ ✟ ✠ ☛
with:

✆☎✁☎✄ ☞ ✌ ✝ ✏ ✌ ☛ , where:
☞✖✌❊✁✓✒ ✵ ✝ ❋✙✕ ,
Formal Languages for Linguists: Classical and Nonclassical Models
✂✁☎✄✝✆ ✞✠✟☛✡☞✞✍✌ ✎☎✟☛✡☞✎✑✏
✒✔✓ ✄✖✕ ✗ ✓ ✌   ✓ ✌ ✘ ✓ ✌ ✙ ✓ ✌ ✚ ✓ ✛
, where:
✗ ✓ ✝  ✄ ✆ ✜✢✏
✓ ✄✝✆ ✜✣✟☛✡✤✜✢✌ ✜✣✟☛✡✤✜✦✥ ✏
✙ ✓ ✕ ✞ ✛ ✄✝✆ ✜✣✟☛✡☞✜✧✥ ✏
✙ ✓ ✕ ✎ ✛ ✄✝✆ ✜✣✟☛✡✤✜✢✏
✘ ✓ ✄✝✆ ✞✠✟☛✡☞✎✢✌ ✎☎✟★✡✩✎☛✏
✚ ✓ ✕ ✜ ✛ ✄✝✆ ✞✠✟☛✡☞✎✑✏
✚ ✓ ✕ ✜✧✥ ✛ ✄✝✆✍✎☎✟★✡✩✎☛✏
produces:

✄ ✆ ✜✭✌ ✜ ✥ ✧✏ ✮
✪ ✓ ✕ ✫✬✌ ✕ ✞✍✌ ✜ ✛ ✛ ✝
5.4 Why Nonstandard Generative Mechanisms

5.4.1 Adjoining
✪✬✕ ✱ ✛ ✱✳✲✴✆ ✱               ✌ ✘✔✶✸✷✣✏
Let ✯✧✰                ✯✧✵
✱ , denote the family of languages generated by contextual
grammars with selection of type . Some major results concerning the generative capacity of
contextual grammars are the following:

✹ ✯✧✰ ✪✬✕ ✱ ✯✦✵ ✻✛ ✺
✯✦✰
✪✬✕ ✘✠✶✸✷ ✛✻✺    ✪✬✕ ✱ ✛✻✺
✯✧✰ ✰
✪✬✕ ✛✾✺
✯✦✰ ✰✽✼     ✯✧✰
✪✬✕ ✘✔✶ ✛ ✮
✹ ✘✔✶✸✷ ✺ ✯✦✰ ✬   ✪ ✕✱
✯✧✵
✛✮
✹ ✪ ✯✧✵ and ✰ ✱ are incomparable with all families ✯✦✰ ✪✬✕ ✱ ✛ ✌✦✱✿✲❀✆ ✘✔✶✸✷✣✌ ✰ ✱❁✌ ✰✽✼ ✌ ✘✔✶✣✏✧✌
✪✬✕ ✛✾✺                ✮
but ✯✦✰    ✰✽✼           ✰✸✼ (Incomparability, meaning that the respective differences are nonempty,
leads to eccentricity, which seems to be a linguistically valuable point to take into ac-
count.)
✹ ✯✧✰ ✪✬✕ ✱ ✯✦✵ ✛
is an abstract anti-family of languages, i.e. a set closed to none of the six
AFL operations: union, concatenation, Kleene star, morphisms, inverse morphisms and
intersection with regular languages.

✪✬✕ ✱         ✛
The latter result makes natural the question of finding the smallest AFL containing ✯✧✰                                            ✯✦✵       .
The result is surprising.

✪❂✲❃✘✔✶❅❄✦✪❆✄❇✪ ✓ ❈ ✪✾❉ ✪ ✓ ✲❃✘✠✶✸✷ ✪✾❉✬✲                        ✪✬✕ ✱         ✛
Theorem 5.10 For every                                                ,                    ,   ✯✦✰           ✯✧✵       .
Carlos Mart́ın-Vide
So, iterated adjoining of contexts (i.e. paste), as selected by finite sets of strings, plus a left
quotient (i.e. cut) by a regular language are able to simulate any Turing machine. What is
needed is both: context-sensing and erasing abilities.

✁✄✂ got
The same could be     ☎✝✆ by using a one-sided internal contextual grammar, all whose contexts
are of the form                   ✌☞✆ of languages generated by one-sided internal contextual
. The family
grammars is denoted by ✞ ✟✡✠☞☛       (with selection of type F).

✆✄✣✥✤✧✦                                        ✫
✌ ✆
Theorem 5.11 For every ☛✎✍✑✏✓✒✕✔✝☛✗✖                                 ☛✙✘ ✚✛☛✢✜                , ☛★✘✙✍✑✏✓✒☞✩ , ☛✢✜✙✍✪✞   ✟✡✠☞☛ ✠     .
5.4.2 Inserting

An insertion grammar is a construct:

✤✭✂ ✮✧✂ ✯✫✆
✩✬✖                        ,

where:

✰ ✤ is an alphabet,
✰ ✮     is a finite set of axioms,
✰ ✯ is a finite set of triples   ✱✄✂ ✲✳✂ ✝☎ ✆ , ✱✄✂ ✲✄✂ ☎ ✍ ✤☞✦ (insertion rules).
The immediate derivation works as follows:
✴ ✵✛✶ ✷ ✸✡✷ ✶ ✹✻✺ ✂ ✼       ✤ ✦       ✺          ✼                    ✺          ✺ ✾✱ ☎ ✺ ✂ ✼ ✺ ✱✻✲✿☎ ✺ ✂ ✺ ✂ ✺     ✤ ✦ ✂   ✱✄✂ ✲✳✂ ✝☎ ✆ ✯✙❀
✍         ✔        ✖✄✽       if and only if        ✖       ✘      ✜ ✖ ✘         ✜ ✘ ✙   ✜ ✍                     ✍

For an insertion grammar ✩ , one defines its weight :

✺   ✆      ✲✄❅✻❆ ✱✭❆   ✱✄✂ ✲✳✂ ☎✝✆ ✯ ✵✡✶   ☎✾✂ ✲✄✂ ✱✿✆ ✯✫❇✡❀
✩ ✖❂❁❄❃          ✔             ✍                   ✍

The family of languages generated by insertion grammars of weight at most ❈ , ❈✑❉❋❊ , is denoted
by ✟✝●✑❍✾■ . The union of all those families is ✟✡●✑❍✄❏ . The following results are known:

✰ ✌ ✟✝●▲❑❋✟✝●✑❍✿▼◆❑❋✟✝●✑❍ ✘ ❑ ❀ ❀ ❀ ❂
❑ ✟✡●✑❍ ❏ ❑❋✠✫❍
✰ ✏✓✒☞✩ is incomparable with all families ✟✡●✑❍ ■ , ❈✥❉✬✞ , and ✏✓✒☞✩✕❑❋✟✝●✑❍ ❏ .
✰ ✟✡●✑❍✄✘✙❑❂✠ ✌ , but ✠ ✌ is incomparable with all families ✟✝●✑❍✾■ , ❈✑❉❖ , and ✟✝●✑❍✿❏ .
✰ ☛✢✟✡● is incomparable with all families ✟✡●✑❍✿■ , ❈✑❉✬✞ , and ✟✡●✑❍✿❏ .
Formal Languages for Linguists: Classical and Nonclassical Models
All families ✁✄✂✆☎✞✝ , ✟✆✠☛✡ , are anti-AFL’s.
✁✔✂✆☎ ✝
Theorem 5.12 For every ☞✍✌✆✎✑✏✓✒✔☞✖✕☛☞✘✗ ✙✚☞✜✛ , ☞✢✗✢✌✆✎✣✏✥✤ , ☞✜✛✦✌                               , ✟✆✠★✧ .
What one does in this case is first to make use of insertion operations, and then to cut a prefix
of the string by means of a quotient with respect to a regular language. If the cutting operation
is introduced into the grammar, the so-called insertion-deletion grammars are obtained.

An insertion-deletion grammar is a construct:
✤✩✕✫✪ ✬✮✭ ✯✣✭ ✰✮✱ ✭ ✰✮✲✜✳ ,
where:

✬    is an alphabet,
✯ is a set of axioms,

✰✴✱ is a set of insertion rules (a finite subset of ✬✥✵✦✶✷✬✣✵✦✶✷✬✣✵ ),

✰✴✲ is a set of deletion rules (a finite subset of ✬✣✵✦✶✷✬✣✵✦✶✷✬✣✵ ).
The immediate derivation works as follows:
for every✸✣✭ ✹✺✌✷✬ ✵ ✒✄✸✻✕✽✼✾✹ if and only if ✒
(i) either ✸✻✕✻✸✦✗ ✿✞❀✔✸✘✛ ✭ ✹❁✕☛✸✦✗ ✿❃❂✞❀✔✸✘✛ ✭ ✪ ✿❄✭ ❂✴✭ ❀✔✳✜✌✷✰✴✱ ✭ ✸✦✗ ✭ ✸✘✛✦✌✷✬✣✵ ,

(ii) or ✸✻✕✻✸ ✗ ✿❃❂✽❀✄✸ ✛ ✭ ✹✥✕✻✸ ✗ ✿✞❀✄✸ ✛ ✭ ✪ ✿❄✭ ❂✴✭ ❀✔✳✢✌✆✰ ✲ ✭ ✸ ✗ ✭ ✸ ✛ ✌✷✬✣✵ .
✁✔✂✆☎✮❅
The family of languages generated by insertion-deletion grammars is denoted by                                       ✏✥☞ .
✁✄✂✆☎✮❅
Theorem 5.13 For every ☞✍✌✆✎✑✏ , ☞✖✕✻☞✜❆✄❇❈✬✣✵ , for some ☞✮❆✽✌                               ✏✥☞ .
If the length of the strings that are inserted/deleted is taken into consideration, one can be more
✁✔✂✆☎ ✛ ❅    ✗
precise: ☞✮❆✽✌       ✗ ✏✥☞ ✗ (i.e. strings of length at most one are inserted in contexts of weight
at most two, and strings of length at most one are deleted from contexts of weight at most one).
✁✔✂✆☎ ✗ ❅          ✁✔✂✆☎ ✛ ❅
As well, ☞✮❆ belongs to both         ✛ ✏✥☞✜❉✛ and       ✗ ✏✥☞✜✛❉ .
Carlos Mart́ın-Vide
5.4.3 Splicing

✁✄✂✆☎✞✝ ✟✠☎☛✡ ☞ ☎☛✌ ✟✠☎✎✍ , ☎✎✏✒✑ ✔  ✓ , ✄✕ ✖✘✗✙✖✘✚ ,
✟✜✛ ☞✣✑ ✢
A splicing rule over an alphabet                  is a string

The immediate derivation relation runs as follows:
for every ✤✞✛ ✥☛✛ ✦✜✑   ★✓ ✧☛✩ ✞✤ ✛ ✥✎✪✬✫☛✭✮✦   if and only if

(i) ✤✣✂✄✤ ✝ ☎ ✝ ☎ ✡ ✤ ✡ ,
(ii) ✥✠✂✯✥✰✝ ☎☛✌ ☎✎✍ ✥✱✡ ,

(iii) ✦✠✂✄✤✞✝ ☎✲✝ ☎✎✍ ✥✱✡ ,
with ✤✞✝ ✛ ✤✲✡ ✛ ✥✰✝ ✛ ✥✱✡✳✑
✴✓ .
An   ✵     scheme is a pair      ✶✣✂ ✩   ✛ ✷✔✪ , ✷✹✸  ✔✓ ✟  ✔✓ ☞  ✔✓ ✟  ✔✓ ✺
Given ✶✻✂
✩   ✛ ✷✴✪ and a language ✼✄✸  ✔✓ , one defines:
✽ ✶ ✩ ✼✮✪✬✂✹✾ ✦✜✑  ✔✓ ✧☛✩ ✤✿✛ ✥✎✪❀✫ ✭ ✦✎✛ ✤✞✛ ✥✒✑✻✼✳✛ ✁✴✑✻✷✠❁ ,
✽ ✶✲❂ ✩ ✼✮✪✬✂✯✼ ,
✽ ✶ ✏ ❃✲✝ ✩ ✼✮✪✬✂❄✶ ✏ ✩ ✼✮✪✞❅✙✶ ✩ ✶ ✏ ✩ ✼✮✪ ✪ ✛ ✗❀❆✯❇ ,
✽ ✶ ✓ ✩ ✼✮✪✬✂❉❈ ✏ ❊✎❋ ✶ ✏ ✩ ✼✮✪ .

This allows the introduction of a new generative mechanism. An extended                                 ✵   system is a
construct:

● ✂ ✩   ✛ ❍✳✛ ■✴✛ ✷✔✪ ,
where:

✽   is an alphabet,
✽ ❍❉✸   is a set of terminal letters,
✽ ■❉✸  ✔✓ is a set of axioms,
✽ ✷✹✸  ✔✓ ✟  ✴✓ ☞  ✔✓ ✟  ✴✓ .
Formal Languages for Linguists: Classical and Nonclassical Models
(    ✂✁☎✄ ✆✞✝ ✟✡✠   is the underlying H scheme of .)    ☛
The language generated by            ☛   is:

☞ ✄ ☛ ✠✌✁✍ ✏✎ ✄ ✑✒✠✏✓✕✔✖✎ ✗
Given two families of languages ✘✌✙ ✝ ✘✛✚ , ✜✣✢ ✄ ✘✌✙ ✝ ✘✞✚ ✠ denotes the family of languages ✄ ☛ ✠ ✝
☛ ✁☎✄ ✆✞✝ ✔✤✝ ✑✣✝ ✟✡✠ , with ✑✦✥ ✘✌✙ , ✟✧✥ ✘✞✚ . A surprising result is obtained again.
Theorem 5.14           ✜✣✢ ✄ ✘ ✙ ✝ ✘ ✚ ✠✞✁★✟ ✜ ✝ for every ✘ ✙ ✝ ✘ ✚✤✩ ✘✣✪✬✫✮✭★✘ ✙ ✯✝ ✟ ✣✜ ✰☎✭★✘ ✚ .
Thus, by using nonstandard resources the greatest generative power is achieved, while keeping
the complexity of the mechanism at a very low level.
6 Papers Cited
✱   Bresnan, J., R.M. Kaplan, S. Peters and A. Zaenen. 1982. ”Cross-serial dependencies in
Dutch”. Linguistic Inquiry, 13(4), 613–635.
✱   Culy, C. 1985. ”The complexity of the vocabulary of Bambara”. Linguistics and Philos-
ophy, 8, 345–351.
✱   Gazdar, G. 1981. ”Unbounded dependencies and coordinate structure”. Linguistic In-
quiry, 12(2), 155–184.
✱   Pullum, G.K. and G. Gazdar. 1982. ”Natural languages and context-free languages”.
Linguistics and Philosophy, 4, 471–504.
✱   Shieber, S.M. 1985. ”Evidence against the context-freeness of natural language”. Lin-
guistics and Philosophy, 8, 333–343.
7 Further Reading and Relevant Resources
Generally speaking, for a linguist wishing to be introduced into the field of mathematical meth-
ods in linguistics, which is a scope notably larger than the one taken in the present chapter,
Partee, ter Meulen and Wall (1990) is strongly recommended. It is a book thought for initiating
mathematically nontrained students. Brainerd (1971), Wall (1972) and Partee (1978) may be
still valid references, too. One chapter in Cole, Varile and Zampolli (1997) explains the main
trends for connecting different mathematical models with computational developments.
The most comprehensive and updated handbook of classical as well as nonclassical formal
languages is Rozenberg and Salomaa (1997).
Very cited treatises in classical formal language theory (with different levels of difficulty)
include Aho and Ullman (1971-1973), Davis, Sigal and Weyuker (1994), Harrison (1978),
Hopcroft and Ullman (1979), Révész (1991), Salomaa (1988), and Wood (1987). Other good
Carlos Mart́ın-Vide
books (not all of them having a completely general scope) are Brookshear (1989), Dassow and
P̆aun (1989), Drobot (1989), Floyd and Beigel (1994), Gurari (1989), Howie (1991), Kelley
(1995), Lewis and Papadimitriou (1981), Linz (1990), McNaughton (1982), Moll, Arbib and
Kfoury (1988), and Sudkamp (1988).
Some of the developments in nonstandard formal language theory can be found in Csuhaj-
Varj́u, Dassow, Kelemen and P̆aun (1994), P̆aun (1995), P̆aun (1997), and P̆aun, Rozenberg and
Salomaa (1998).
The present state-of-the-art of the field is well pictured in Mart́ın-Vide and Mitrana (2001a),
and Mart́ın-Vide and Mitrana (2001b).
The following references may be of help to the reader interested in knowing more about lin-
guistic applications of formal language theory: Kolb and M̈onnich (1999), Levelt (1974),
Manaster Ramer (1987), Mart́ın-Vide (1994), Mart́ın-Vide (1998), Mart́ın-Vide (1999), Mart́ın-
Vide and P̆aun (2000), P̆aun (1994), Savitch, Bach, Marsh and Safran-Naveh (1987), Savitch
and Zadrozny (1994), Sells, Shieber and Wasow (1991), and Zadrozny, Manaster Ramer and
Moshier (1993).
References

8    Books
Aho, A.V., J.E. Hopcroft and J.D. Ullman. 1974. The design and analysis of computer algo-
rithms. Reading, MA: Addison-Wesley.

Aho, A.V., R. Sethi and J.D. Ullman. 1986. Compilers: principles, techniques, and tools.
Reading, MA: Addison-Wesley.

Aho, A.V. and J.D. Ullman. 1971-1973. The theory of parsing, translation and compiling, 2
vols. Englewood Cliffs, NJ: Prentice-Hall.

Aho, A.V. and J.D. Ullman. 1977. Principles of compiler design. Reading, MA: Addison-
Wesley.

Amos, M. 2001. Theoretical and experimental DNA computation. Berlin: Springer.

Arbib, M.A. 1969. Theories of abstract automata. Englewood Cliffs, NJ: Prentice-Hall.

Atallah, M.J. (Editor). 1998. CRC handbook of algorithms and theory of computation. Boca
Raton, FL: CRC.

Bavel, Z. 1983. Introduction to the theory of automata. Reston, VA: Reston.

Berstel, J. 1979. Transductions and context-free languages. Stuttgart: Teubner.

Berstel, J. and C. Reutenauer. 1988. Rational series and their languages. Berlin: Springer.

Book, R.V. (Editor). 1980. Formal language theory: perspectives and open problems. New
York, NY: Academic Press.
Formal Languages for Linguists: Classical and Nonclassical Models
Booth, T.L. 1967. Sequential machines and automata theory. New York, NY: John Wiley.

Brainerd, B. 1971. Introduction to the mathematics of language study. New York, NY: Elsevier.

Brainerd, W.S. and L.H. Landweber. 1974. Theory of computation. New York, NY: John Wiley.

Brookshear, J.G. 1989. Theory of computation: formal languages, automata, and complexity.
Redwood City, CA: Benjamin/Cummings.

Carroll, J. and D. Long. 1989. Theory of finite automata. Englewood Cliffs, NJ: Prentice-Hall.

Cohen, D.I.A. 1986. Introduction to computer theory. New York, NY: John Wiley. (2nd ed.,
1991.)

Cole, R., G.B. Varile and A. Zampolli (Editors). 1997. Survey of the state of the art in human
language technology. Cambridge: Cambridge University Press.

Csuhaj-Varj́u, E., J. Dassow, J. Kelemen and Gh. P̆aun. 1994. Grammar systems: a grammat-
ical approach to distribution and cooperation. London: Gordon and Breach.

Dassow, J. and Gh. P̆aun. 1989. Regulated rewriting in formal language theory. Berlin:
Springer.

Davis, M.D. (Editor). 1965. The undecidable: basic papers on undecidable propositions, un-
solvable problems and computable functions. New York, NY: Raven.

Davis, M.D., R. Sigal and E.J. Weyuker. 1983. Computability, complexity, and languages: fun-
damentals of theoretical computer science. New York, NY: Academic Press. (2nd ed., 1994.)

Denning, P.J., J.B. Dennis and J.E. Qualitz. 1978. Machines, languages, and computation.
Englewood Cliffs, NJ: Prentice-Hall.

Drobot, V. 1989. Formal languages and automata theory. Rockville, MD: Computer Science
Press.

Eilenberg, S. 1974-1976. Automata, languages, and machines, 2 vols. New York, NY: Aca-
demic Press.

Engeler, E. 1968. Formal languages. Chicago, IL: Markham.

Floyd, R.W. and R. Beigel. 1994. The language of machines: an introduction to computability
and formal languages. Rockville, MD: Computer Science Press.

Gécseg, F. and I. Péak. 1972. Algebraic theory of automata. Budapest: Akadémiai Kiad́o.

Gécseg, F. and M. Steinby. 1984. Tree automata. Budapest: Akadémiai Kiad́o.

Gill, A. 1962. Introduction to the theory of finite-state machines. New York, NY: McGraw-
Hill.

Ginsburg, S. 1962. An introduction to mathematical machine theory. Reading, MA: Addison-
Wesley.

Ginsburg, S. 1966. The mathematical theory of context-free languages. New York, NY:
McGraw-Hill.
Carlos Mart́ın-Vide
Ginsburg, S. 1975. Algebraic and automata-theoretic properties of formal languages. Amster-
dam: North-Holland.

Ginsburg, S., S. Greibach and J.E. Hopcroft. 1969. Studies in abstract families of languages.
Providence, RI: American Mathematical Society.

Ginzburg, A. 1968. Algebraic theory of automata. New York, NY: Academic Press.

Gurari, E. 1989. An introduction to the theory of computation. New York, NY: Computer
Science Press.

Harrison, M.A. 1965. Introduction to switching and automata theory. New York, NY:
McGraw-Hill.

Harrison, M.A. 1969. Lectures on linear sequential machines. New York, NY: Academic Press.

Harrison, M.A. 1978. Introduction to formal language theory. Reading, MA: Addison-Wesley.

Hennie, F.C. 1968. Finite-state models for logical machines. New York, NY: John Wiley.

Herken, R. (Editor). 1988. The universal Turing machine. Oxford: Oxford University Press.

Herman, G.T. and G. Rozenberg. 1975. Developmental systems and languages. Amsterdam:
North-Holland.

Hofstadter, D.R. 1979. G̈odel, Escher, Bach: an eternal golden braid. New York, NY: Basic
Books.

Hopcroft, J.E. and J.D. Ullman. 1969. Formal languages and their relation to automata. Read-
ing, MA: Addison-Wesley.

Hopcroft, J.E. and J.D. Ullman. 1979. Introduction to automata theory, languages, and com-
putation. Reading, MA: Addison-Wesley.

Howie, J.M. 1991. Automata and languages. Oxford: Oxford University Press.

Ito, M. and H. J̈urgensen (Editors). 1994. Words, languages and combinatorics 2. Singapore:
World Scientific.

Karhum̈aki, J., H.A. Maurer, Gh. P̆aun and G. Rozenberg (Editors). 1999. Jewels are forever.
Berlin: Springer.

Karhum̈aki, J., H.A. Maurer and G. Rozenberg (Editors). 1994. Results and trends in theoret-
ical computer science. Berlin: Springer.

Kelley, D. 1995. Automata and formal languages: an introduction. Englewood Cliffs, NJ:
Prentice-Hall.

Kolb, H.-P. and U. M̈onnich (Editors). 1999. The mathematics of syntactic structure: trees and
their logics. Berlin: Mouton de Gruyter.

Kuich, W. and A. Salomaa. 1986. Formal power series and languages. Berlin: Springer.

Kuich, W. and A. Salomaa. 1986. Semirings, automata, languages. Berlin: Springer.
Formal Languages for Linguists: Classical and Nonclassical Models
Leeuwen, J. van (Editor). 1990. Handbook of theoretical computer science, 2 vols. Amster-
dam/Cambridge, MA: North-Holland/MIT Press.

Levelt, W.J.M. 1974. Formal grammars in linguistics and psycholinguistics, 3 vols. The
Hague: Mouton.

Lewis, H.R. and C.H. Papadimitriou. 1981. Elements of the theory of computation. Englewood
Cliffs, NJ: Prentice-Hall.

Linz, P. 1990. An introduction to formal languages and automata. Lexington, MA: D.C. Heath.
(2nd ed., 1996.)

Manaster Ramer, A. (Editor). 1987. Mathematics of language. Amsterdam: John Benjamins.

Marcus, S. 1967. Algebraic linguistics: analytical models. New York, NY: Academic Press.

Mart́ın-Vide, C. (Editor). 1994. Current issues in mathematical linguistics. Amsterdam:
North-Holland.

Mart́ın-Vide, C. (Editor). 1998. Mathematical and computational analysis of natural lan-
guage. Amsterdam: John Benjamins.

Mart́ın-Vide, C. (Editor). 1999. Issues in mathematical linguistics. Amsterdam: John Ben-
jamins.

Mart́ın-Vide, C. and V. Mitrana (Editors). 2001a. Grammars and automata for string pro-
cessing: from mathematics and computer science to biology, and back. London: Gordon and
Breach.

Mart́ın-Vide, C. and V. Mitrana (Editors). 2001b. Where mathematics, computer science, lin-
guistics and biology meet. Dordrecht: Kluwer.

Mart́ın-Vide, C. and Gh. P̆aun (Editors). 2000. Recent topics in mathematical and computa-
tional linguistics. Bucharest: Editura Academiei Romˆane.

McNaughton, R. 1982. Elementary computability, formal languages, and automata. Engle-
wood Cliffs, NJ: Prentice-Hall.

Minsky, M.L. 1967. Computation: finite and infinite machines. Englewood Cliffs, NJ:
Prentice-Hall.

Moll, R.N., M.A. Arbib and A.J. Kfoury. 1988. An introduction to formal language theory.
Berlin: Springer.

Moore, E.F. (Editor). 1964. Sequential machines: selected papers. Reading, MA: Addison-
Wesley.

Nelson, R.J. 1968. Introduction to automata. New York, NY: John Wiley.

Nijholt, A. 1980. Context-free grammars: covers, normal forms and parsing. Berlin: Springer.

Nijholt, A. 1988. Computers and languages: theory and practice. Amsterdam: North-Holland.

Papadimitriou, C.H. 1994. Computational complexity. Reading, MA: Addison-Wesley.
Carlos Mart́ın-Vide
Partee, B.H. 1978. Foundations of mathematics for linguistics. Harrisburg, PA: Greylock.
Partee, B.H., A.G.B. ter Meulen and R.E. Wall. 1990. Mathematical methods in linguistics.
Dordrecht: Kluwer.
P̆aun, Gh. (Editor). 1994. Mathematical aspects of natural and formal languages. Singapore:
World Scientific.
P̆aun, Gh. (Editor). 1995. Artificial life: grammatical models. Bucharest: Black Sea University
Press.
P̆aun, Gh. 1997. Marcus contextual grammars. Dordrecht: Kluwer.
P̆aun, Gh. (Editor). 1998. Computing with bio-molecules: theory and experiments. Singapore:
Springer.
P̆aun, Gh., G. Rozenberg and A. Salomaa. 1998. DNA computing: new computing paradigms.
Berlin: Springer.
P̆aun, Gh. and A. Salomaa (Editors). 1997. New trends in formal languages: control, cooper-
ation, and combinatorics. Berlin: Springer.
P̆aun, Gh. and A. Salomaa (Editors). 1999. Grammatical models of multi-agent systems. Lon-
don: Gordon and Breach.
Paz, A. 1971. Introduction to probabilistic automata. New York, NY: Academic Press.
Pin, J.-E. 1986. Varieties of formal languages. Oxford: Plenum. (Orig., 1984.)
Révész, G.E. 1983. Introduction to formal languages. New York, NY: McGraw-Hill. (2nd ed.:
New York, NY: Dover, 1991.)
Rozenberg, G. and A. Salomaa. 1980. The mathematical theory of L systems. New York, NY:
Academic Press.
Rozenberg, G. and A. Salomaa (Editors). 1986. The book of L. Berlin: Springer.
Rozenberg, G. and A. Salomaa (Editors). 1992. Lindenmayer systems: impacts on theoretical
computer science, computer graphics and developmental biology. Berlin: Springer.
Rozenberg, G. and A. Salomaa (Editors). 1997. Handbook of formal languages, 3 vols. Berlin:
Springer.
Rozenberg, G. and W. Thomas (Editors). 2000. Developments in language theory: founda-
tions, applications and perspectives. Singapore: World Scientific.
Salomaa, A. 1969. Theory of automata. Oxford: Pergamon.
Salomaa, A. 1973. Formal languages. New York, NY: Academic Press.
Salomaa, A. 1981. Jewels of formal language theory. Rockville, MD: Computer Science Press.
Salomaa, A. 1985. Computation and automata. Cambridge: Cambridge University Press.
Salomaa, A. and M. Soittola. 1978. Automata-theoretic aspects of formal power series. Berlin:
Springer.
Formal Languages for Linguists: Classical and Nonclassical Models
Savitch, W.J., E.W. Bach, W. Marsh and G. Safran-Naveh (Editors). 1987. The formal com-
plexity of natural language. Dordrecht: Reidel.

Savitch, W.J. and W. Zadrozny (Editors). 1994. Mathematics of language, Linguistics and
Philosophy, 17(6). Dordrecht: Kluwer.

Sells, P., S.M. Shieber and T. Wasow (Editors). 1991. Foundational issues in natural language
processing. Cambridge, MA: MIT Press.

Sikkel, K. 1996. Parsing schemata: a framework for specification and analysis of parsing
algorithms. Berlin: Springer.

Sippu, S. and E. Soisalon-Soininen. 1988-1990. Parsing theory, 2 vols. Berlin: Springer.

Sudkamp, T.A. 1988. Languages and machines. Reading, MA: Addison-Wesley.

Trakhtenbrot, B.A. and Y.M. Barzdin. 1973. Finite automata. Amsterdam: North-Holland.

Turing, A.M. 1992. Mechanical intelligence, ed. by D.C. Ince. Amsterdam, North-Holland.

Wall, R.E. 1972. Introduction to mathematical linguistics. Englewood Cliffs, NJ: Prentice-
Hall.

Wood, D. 1980. Grammar and L forms: an introduction. Berlin: Springer.

Wood, D. 1987. Theory of computation. New York, NY: John Wiley.

Zadrozny, W., A. Manaster Ramer and M.A. Moshier (Editors). 1993. Mathematics of lan-
guage, Annals of Mathematics and Artificial Intelligence, 8(1-2). Basel: J.C. Baltzer.
9    Journals
Acta Cybernetica

Acta Informatica

BioSystems

Bulletin of the European Association for Theoretical Computer Science

Communications of the Association for Computing Machinery

Computational Intelligence

Computational Linguistics

Computers and Artificial Intelligence

Discrete Mathematics

Fundamenta Informaticae

Grammars. A Journal of Mathematical Research on Formal and Natural Languages
Carlos Mart́ın-Vide
Information and Computation (before, Information and Control)

Information Processing Letters

International Journal of Computer Mathematics

International Journal of Foundations of Computer Science

Journal of Automata, Languages and Combinatorics

Journal of Computer and System Sciences

Journal of Logic, Language and Information

Journal of the Association for Computing Machinery

Journal of Universal Computer Science

Kybernetika

Linguistics and Philosophy

Mathematical Structures in Computer Science (before, Mathematical Systems Theory)

New Generation Computing

Revue Franaise d’Automatique, Informatique et Recherche Opérationelle (RAIRO): Informa-
tique Théorique

Revue Roumaine de Mathématiques Pures et Appliquées

Theoretical Computer Science
10 Major Conferences
ACL Annual Meeting of the Association for Computational Linguistics
AFL Conference on Automata and Formal Languages
AMiLP Algebraic Methods in Language Processing
CIAA International Conference on Implementation and Application of Automata
CLIN Computational Linguistics in the Netherlands Meeting
COLING International Conference on Computational Linguistics
DCAGRS Workshop on Descriptional Complexity of Automata, Grammars and Related
Structures
DIMACS International Meeting on DNA Based Computing
DLT International Conference Developments in Language Theory
ESSLLI European Summer School of Logic, Language and Information
Formal Languages for Linguists: Classical and Nonclassical Models
FCT Fundamentals of Computation Theory
GS International Workshop Grammar Systems
ICALP International Colloquium on Automata, Languages and Programming
ICWLC International Colloquium on Words, Languages and Combinatorics
IWPT International Workshop on Parsing Technologies
LACL International Conference on Logical Aspects of Computational Linguistics
MCU International Conference on Machines, Computations and Universality
MFCS International Symposium on Mathematical Foundations of Computer Science
MOL Meeting on Mathematics of Language
UMC Conference on Unconventional Models of Computing
11 Professional Associations
Association for Computational Linguistics, Special Interest Group on Mathematics of
Language, http://www.cis.upenn.edu/ ircs/mol/mol.html
Association for Computing Machinery, Special Interest Group on Algorithms and Com-
puting Theory, http://sigact.acm.org/
European Association for Theoretical Computer Science, http://www.eatcs.org/
12 Web Sites
American Mathematical Society Preprint Server, http://www.ams.org/preprints/
Collection of Computer Science Bibliographies, http://liinwww.ira.uka.de/bibliography/index.html
Computing Research Repository, http://xxx.lanl.gov/archive/cs/intro.html
Mathematics WWW Virtual Library, http://euclid.math.fsu.edu/Science/math.html
Networked Computer Science Technical Reference Library, http://www.ncstrl.org/
13 Research Centres
Leiden Institute of Advanced Computer Science, http://www.wi.leidenuniv.nl/CS/
Turku Centre for Computer Science, http://www.tucs.fi/
