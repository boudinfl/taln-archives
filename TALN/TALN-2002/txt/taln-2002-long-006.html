<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Construire des analyseurs avec DyALog</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2002, Nancy, 24&#8211;27 juin 2002
</p>
<p>Construire des analyseurs avec DyALog
</p>
<p>&#201;ric Villemonte de la Clergerie
ATOLL - INRIA
</p>
<p>Domaine de Voluceau
Rocquencourt, B.P. 105,78153 Le Chesnay (France)
</p>
<p>Eric.De_La_Clergerie@inria.fr
</p>
<p>Mots-clefs &#8211; Keywords
</p>
<p>Analyse Syntaxique, Tabulation, DCG, TAG, RCG, BMG, TFS
Parsing, Tabulation, DCG, TAG, RCG, BMG, TFS
</p>
<p>R&#233;sum&#233; - Abstract
</p>
<p>Cet article survole les fonctionnalit&#233;s offertes par le syst&#232;me DyALog pour construire des ana-
lyseurs syntaxiques tabulaires. Offrant la richesse d&#8217;un environnement de programmation en
logique, DyALog facilite l&#8217;&#233;criture de grammaires, couvre plusieurs formalismes et permet le
param&#233;trage de strat&#233;gies d&#8217;analyse.
</p>
<p>This paper is a survey of the functionalities provided by system DyALog to build tabular par-
sers. Providing the expressiveness of logic programming, DyALog eases the development of
grammars, covers several linguistic formalisms, and allows the parametrization of parsing stra-
tegies.
</p>
<p>1 Introduction
</p>
<p>Cet article pr&#233;sente les grandes lignes du syst&#232;me DyALog1. Issu de travaux sur les techniques
de tabulation en programmation en logique, ce syst&#232;me permet la compilation d&#8217;analyseurs
syntaxiques pour divers formalismes linguistiques &#224; base d&#8217;unification. Faute de place, nous
ne pr&#233;sentons pas les techniques de tabulation sous-jacentes ni l&#8217;architecture et le processus
de compilation qui en r&#233;sultent mais nous nous focalisons sur l&#8217;apport de DyALog pour le
d&#233;veloppement d&#8217;analyseurs syntaxiques.
</p>
<p>L&#8217;&#233;criture de grammaires avec DyALog s&#8217;appuie sur la flexibilit&#233; des notations &#224; la PROLOG,
compl&#233;t&#233;e par diverses extensions plus sp&#233;cifiquement con&#231;ues pour le champ linguistique,
telles les structures de traits (Section 2).
Les m&#233;canismes g&#233;n&#233;riques de tabulation de DyALog facilitent la mise au point d&#8217;analyseurs
</p>
<p>1Librement disponible sur le site http://atoll.inria.fr.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&#201;ric Villemonte de la Clergerie
</p>
<p>pour divers formalismes, comme les DCG, les Grammaires &#224; Mouvements Restreints [BMG],
les grammaires d&#8217;arbres adjoints [TAG] et les grammaires &#224; concat&#233;nation d&#8217;intervalles [RCG]
(Section 3). De plus, des directives de compilation sont disponibles permettant de param&#233;trer
les strat&#233;gies d&#8217;analyse. Il devient d&#232;s lors plus facile de mener des exp&#233;riences de comparaison
entre formalismes et strat&#233;gies au sein d&#8217;un unique syst&#232;me.
</p>
<p>Enfin, nous d&#233;crivons, dans la section 4, quelques fonctionnalit&#233;s qui am&#233;liorent l&#8217;efficacit&#233;
ou l&#8217;utilisation des analyseurs produits avec DyALog. Nous concluons en relatant quelques
exp&#233;riences men&#233;es avec DyALog et quelques &#233;volutions en cours.
</p>
<p>2 Faciliter l&#8217;&#233;criture de grammaires
</p>
<p>Notation Hilog Cette notation permet de d&#233;crire des termes d&#8217;ordre (pseudo) sup&#233;rieur, comme
par exemple P(X,Y) ou P (X,Y) qui d&#233;crit un terme avec une variable de pr&#233;dicat P. Ce
genre de notation est tr&#232;s utile pour repr&#233;senter des expressions s&#233;mantiques. La notation Hilog
est aussi pratique pour associer des groupes distincts d&#8217;arguments &#224; un pr&#233;dicat, par exemple
q(X1,X2)(Y1,Y2,Y3). Ainsi, nous l&#8217;utilisons pour les RCG (Section 3.5). En interne, le terme
Hilog P(X,Y) est repr&#233;sent&#233; par le terme du premier ordre apply(P,X,Y).
</p>
<p>Unification imm&#233;diate L&#8217;op&#233;rateur binaire :: force l&#8217;unification de ses deux arguments d&#232;s la
lecture des termes. Nous l&#8217;utilisons tr&#232;s souvent pour nommer des structures complexes ayant
plusieurs occurrences, comme par exemple dans p(X::g(Z,f(a)),X). L&#8217;unification imm&#233;diate est
&#233;galement utile comme op&#233;rateur de conjonction de formules, par exemple dans les HPSG.
</p>
<p>Structures cycliques &#192; la diff&#233;rence de la plupart des syst&#232;mes de programmation en logique,
DyALog admet les structures cycliques obtenues par exemple par l&#8217;unification X::f(X). Ces
structures sont rarement n&#233;cessaires, sauf potentiellement dans le cas des grammaires HPSG.
</p>
<p>Structures de traits, typ&#233;es ou non Les formalismes linguistiques font grand usage de struc-
tures de traits, typ&#233;es ou non. DyALog offre les deux variantes. Dans les deux cas, la premi&#232;re
&#233;tape consiste &#224; d&#233;finir les traits possibles pour un foncteur, comme illustr&#233; ci-dessous dans le
cas non typ&#233;.
</p>
<p>:&#8722;features ([np] , [gen,num,pers , restr ,wh]) .
lexicon (&#8217;Sabine&#8217; , np{ gen=&gt;fem, num=&gt;sing , restr=&gt;plushum, wh=&gt; (&#8722;) }).
</p>
<p>Les structures de traits typ&#233;es [TFS] &#224; la Carpenter [Carpenter, 1992] permettent l&#8217;h&#233;ritage
multiple. Un type h&#233;rite de l&#8217;ensemble de traits introduits par ses anc&#234;tres et peut en introduire
de nouveaux. Les valeurs des traits sont elles-m&#234;mes typ&#233;es. Ces informations sont exprim&#233;es
&#224; l&#8217;aide d&#8217;une hi&#233;rarchie de types. L&#8217;exemple suivant illustre les notations sur un fragment de
grammaire HPSG. La syntaxe de description des hi&#233;rarchies de type est standard, &#224; l&#8217;exception
de la ligne 2 qui permet de lier le type string &#224; un type de base de DyALog, &#224; savoir symbol.
</p>
<p>bot sub [ string , l i s t , cat ,synsem] .
string escape symbol.
cat sub [ s ,np,vp, det ,n] .
</p>
<p>s sub [ ] . np sub [ ] . vp sub [ ] .
det sub [ ] . n sub [ ] .
</p>
<p>synsem sub [ frase ,lexeme] intro [ cat : cat ] .
</p>
<p>frase sub [ root ] intro [ args : l i s t ] .
root sub [ ] intro [ cat : s ] .
</p>
<p>lexeme sub [ ] intro [ orth : string ] .
l i s t sub [ ne_list , e_list ] .
</p>
<p>ne_list sub [ ] intro [hd:bot , t l : l i s t ] .
e_list sub [ ] .</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Construire des analyseurs avec DyALog
</p>
<p>Le fragment suivant illustre l&#8217;utilisation de :: comme op&#233;rateur de conjonction, ainsi que l&#8217;ex-
ploitation des informations de la hi&#233;rarchie pour combler les informations manquantes. Ainsi,
le trait orth introduit de lui-m&#234;me le type lexeme.
</p>
<p>hpsg(root{} :: args =&gt; ne_list { hd =&gt; NP, t l =&gt; ( hd =&gt; VP :: t l =&gt; e_list {} ) })
&#8722;&#8722;&gt; hpsg( NP :: cat =&gt; np{} ) , hpsg ( VP :: cat =&gt; vp{} ).
</p>
<p>lexicon ( orth =&gt; le :: cat =&gt; det {} ) . %=&gt; lexicon ( lexeme{ orth=&gt;le , cat =&gt; det{} } ).
</p>
<p>La notation alternative par chemin A .&gt; tl .&gt; hd permet d&#8217;acc&#233;der (&#224; la LFG) &#224; la valeur associ&#233;e
au chemin tl.hd pour la structure li&#233;e &#224; A.
</p>
<p>Les structures de traits sont implant&#233;es comme des termes standards, un foncteur &#233;tant associ&#233;
&#224; chaque type et un rang fixe &#233;tant associ&#233; &#224; chaque trait pour un type donn&#233;. Pour les types
non maximaux (i.e. acceptant des sous-types), un argument suppl&#233;mentaire (non visible &#224; l&#8217;af-
fichage) permet de g&#233;rer de mani&#232;re transparente les cas d&#8217;instantiation vers un sous-type (lors
de l&#8217;unification par exemple).
L&#8217;unification de structures typ&#233;es est souvent consid&#233;r&#233;e comme co&#251;teuse car n&#233;cessitant (a)
d&#8217;identifier les types unifiables ; (b) de trouver les traits devant &#234;tre unifi&#233;s pour deux types
distincts ; (c) de construire un nouveau terme quand deux types unifiables &#964;1 et &#964;2 s&#8217;instancient
en un sous-type distinct &#964;3, nouveau terme qui est perdu en cas d&#8217;&#233;chec ult&#233;rieur de l&#8217;unification.
Dans le cas de DyALog, les hi&#233;rarchies de types sont compil&#233;es avec l&#8217;utilitaire tfs2lib (&#233;crit
en DyALog) pour construire une biblioth&#232;que qui &#233;tend la syntaxe et l&#8217;affichage de DyALog
ainsi que les op&#233;rations d&#8217;unification et de subsomption [Sanches, 1998]. Les points (a) et (b)
sont g&#233;r&#233;s en associant &#224; chaque paire de types distincts et unifiables une fonction sp&#233;cialis&#233;e
d&#8217;unification (idem pour la subsomption). Le point (3) se g&#232;re gr&#226;ce au m&#233;canisme de partage
de structures utilis&#233; par DyALog [Villemonte de la Clergerie, 1993]. Il n&#8217;y a pas construction
d&#8217;un nouveau sous-terme mais r&#233;utilisation par partage d&#8217;un squelette calcul&#233; statiquement. Ces
caract&#233;ristiques font que l&#8217;unification des structures de traits typ&#233;es n&#8217;est gu&#232;re plus co&#251;teuse
que celle des autres termes2.
</p>
<p>Domaines finis Ils permettent de manipuler des disjonctions de valeurs prises dans un en-
semble fini qui est d&#233;clar&#233; &#224; l&#8217;aide des directives finite_set ou subset. Ils sont implant&#233;s dans
DyALog &#224; l&#8217;aide de vecteurs de bits, rendant leur utilisation tr&#232;s efficace. Ces domaines finis
sont d&#8217;un usage tr&#232;s fr&#233;quent et tr&#232;s pratique pour des grammaires linguistiques, comme illustr&#233;
par les deux exemples suivants.
</p>
<p>Le premier, issu d&#8217;une grammaire TAG, d&#233;finit les valeurs possibles pour les modes du verbe et
sp&#233;cifie les valeurs possibles pour la forme aime.
</p>
<p>:&#8722;finite_set (mode, [ ind , subj , inf ] ) .
tag_lexicon (aime , &#8217;&#8727;AIMER&#8727;&#8217; , v , v{ mode =&gt; mode[ind , subj ] , num =&gt; sing }) .
</p>
<p>Le second exemple, issu d&#8217;un analyseur morphologique jouet pour l&#8217;akkadien, d&#233;velopp&#233; par
Fran&#231;ois Barth&#233;lemy, d&#233;finit un alphabet comme un domaine fini et caract&#233;rise la sous-classe
des voyelles.
</p>
<p>:&#8722;finite_set ( letter , [ a , i ,u,e ,aleph ,b,g,d,w,z ,h, &#8217; t . &#8217; , j ,k, l ,m,n, s ,p, &#8217; s . &#8217; ,q, r ,sh , t ] ) .
:&#8722;subset(voyelle , letter [a , i ,u,e ] ) .
add_lattice (P1, P2, [K, letter [ j , aleph ] , voyelle [ ] ] ) .
</p>
<p>2Cependant d&#8217;autres probl&#232;mes ne sont pas compl&#232;tement r&#233;gl&#233;s, en particulier les probl&#232;mes d&#8217;indexation
efficace des TFS.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&#201;ric Villemonte de la Clergerie
</p>
<p>3 Proposer une palette de formalismes
</p>
<p>Nous pr&#233;sentons plusieurs formalismes, linguistiques ou non, couverts par DyALog. Cette di-
versit&#233; permet la comparaison d&#8217;analyseurs pour divers formalismes au sein d&#8217;un m&#234;me sys-
t&#232;me. Du point de vue du d&#233;veloppement de DyALog, cette diversit&#233; permet &#233;galement de tes-
ter plus largement nos techniques tabulaires et de g&#233;n&#233;raliser certaines optimisations propos&#233;es
dans la litt&#233;rature.
</p>
<p>3.1 Programmation en logique
</p>
<p>Historiquement, DyALog est issu de la volont&#233; d&#8217;exploiter les techniques de tabulation en pro-
grammation en logique. En cons&#233;quence, DyALog offre actuellement la puissance d&#8217;un envi-
ronnement de programmation en logique, permettant, en particulier, d&#8217;auto-amorcer (bootstrap)
son compilateur qui est &#233;crit en DyALog.
</p>
<p>Le fait de pouvoir utiliser la puissance de la programmation en logique pr&#233;sente au moins deux
avantages. Premi&#232;rement, il est imm&#233;diat de r&#233;aliser des &#233;chappements vers des pr&#233;dicats lo-
giques dans les grammaires linguistiques. Cela permet de g&#233;rer plus facilement certains d&#233;tails
d&#8217;un formalisme, comme par exemple la gestion des contraintes de co-ancrage dans les gram-
maires XTAG [Doran et al., 1994]. Deuxi&#232;mement, que le compilateur DyALog soit &#233;crit en
DyALog illustre une caract&#233;ristique bien connue de la programmation en logique, &#224; savoir la
facilit&#233; d&#8217;&#233;criture de m&#233;ta-interpr&#232;tes. En pratique, cela signifie qu&#8217;il est facile d&#8217;&#233;tendre le com-
pilateur de DyALog pour int&#233;grer de nouveaux formalismes ou alternativement de construire
rapidement un m&#233;ta-analyseur.
</p>
<p>Par d&#233;faut, les pr&#233;dicats logiques sont tabul&#233;s. Ce comportement peut &#234;tre modifi&#233; par des direc-
tives de compilation, permettant de ne pas tabuler certains pr&#233;dicats et d&#8217;optimiser leur traite-
ment. Nous avons ainsi des optimisations sp&#233;cialis&#233;es pour les pr&#233;dicats uniquement d&#233;finis par
des faits ou les pr&#233;dicats dont tous les descendants ne sont pas tabul&#233;s. Cette classification des
pr&#233;dicats s&#8217;&#233;tend dans une certaine mesure aux non-terminaux des formalismes grammaticaux.
</p>
<p>La plupart des pr&#233;dicats standard de PROLOG sont disponibles sous DyALog et l&#8217;appel de
fonctions C est possible avec $interface. Dans le cadre d&#8217;une interface vers les bases de
donn&#233;es, nous d&#233;finissons ainsi le pr&#233;dicat pg_tuple qui retourne, de mani&#232;re non-d&#233;terministe,
les valeurs d&#8217;une requ&#234;te SQL.
</p>
<p>pg_tuple(Res,Val) :&#8722; &#8217;$interface &#8217; ( &#8217;DyALog_PQtuple&#8217; (Res: ptr ,Val:term ) , choice_size (1)] ) .
</p>
<p>3.2 DCG
</p>
<p>Comme la plupart des syst&#232;mes de programmation en logique, les Grammaires de Clauses D&#233;fi-
nies [DCG] [Pereira and Warren, 1980] sont disponibles sous DyALog. Cependant, l&#8217;int&#233;gration
de la tabulation rend plus imm&#233;diate l&#8217;utilisation des DCG en &#233;vitant les probl&#232;mes de bouclage
et en offrant une trace des analyses au travers des for&#234;ts partag&#233;es d&#8217;analyse3. Nous avons &#233;ga-
lement &#233;tendu les DCG. Ainsi, l&#8217;op&#233;rateur &amp; d&#8217;intersection permet, par exemple, de d&#233;finir tr&#232;s
facilement le langage anbncn avec la clause DCG &#171;s &#8722;&#8722;&gt; &#8217;AnBnC&#8727;&#8217; &amp; &#8217;A&#8727;BnCn&#8217;&#187;.
L&#8217;analyse peut se faire sur le contenu d&#8217;une liste PROLOG de terminaux, comme cela est stan-
dard pour les DCG, mais aussi, alternativement, sur un treilli de mots ou m&#234;me sur un automate
</p>
<p>3ou plus pr&#233;cisement de for&#234;ts de d&#233;rivation isomorphes aux for&#234;ts d&#8217;analyse.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Construire des analyseurs avec DyALog
</p>
<p>&#224; &#233;tats finis [FSA]. Le passage aux FSA rend l&#8217;analyse plus efficace et offre une grande flexibi-
lit&#233; pour traiter des phrases incompl&#232;tes ou &#224; mots ambigus ou inconnus, comme illustr&#233; par la
phrase &#171;[mot inconnu] regarde [mots inconnus] avec un t&#233;lescope.&#187; cod&#233;e en FSA par la base
suivante de faits &#8217;C&#8217;(Left,Token,Right) 4 :
</p>
<p>&#8217;C&#8217; (0,_,1) . &#8217;C&#8217; (1,regarde ,2) . &#8217;C&#8217; (2,_,2) . &#8217;C&#8217; (2,avec ,3) . &#8217;C&#8217; (3,un,4) . &#8217;C&#8217; (4, t&#233;lescope ,5).
</p>
<p>Annoter les clauses avec les op&#233;rateurs +&gt; et &lt;+ permet de d&#233;finir des strat&#233;gies d&#8217;analyse bi-
directionnelle, g&#233;n&#233;ralement dirig&#233;es par les t&#234;tes. Ainsi, la clause &#171; a &#8722;&#8722;&gt; b &lt;+ c +&gt; d +&gt;e. &#187;
donne l&#8217;ordre de reconnaissance c, d, e, b. Cette notation &#233;tant plus op&#233;rationnelle que d&#233;clara-
tive, il est pr&#233;f&#233;rable de convertir une grammaire avec des indications de t&#234;te en une grammaire
avec des annotations de direction, comme r&#233;alis&#233; pour une grammaire DCG du portugais [Rocio
et al., 2001]5 :
</p>
<p>s&#8722;&#8722;&gt;np,vp . head(s ,vp ) . %==&gt;s&#8722;&#8722;&gt;np &lt;+ vp
vp&#8722;&#8722;&gt;v(Type) , v_args(Type) . head(vp,v ) . %==&gt;vp&#8722;&#8722;&gt;v(Type) +&gt; v_args(Type)
</p>
<p>Parall&#232;lement &#224; l&#8217;&#233;criture des grammaires, DyALog offre la possibilit&#233; de sp&#233;cifier la strat&#233;gie
d&#8217;analyse &#224; utiliser au niveau des non-terminaux en utilisant des directives de modulation [Bar-
th&#233;lemy and Villemonte de la Clergerie, 1998]. Ainsi la directive dcg_mode(np/2,+(&#8722;,&#8722;),+,&#8722;)
exprime le fait que, pour reconna&#238;tre un non-terminal np(sing,fem) entre les positions gauche
L et droite R de la cha&#238;ne d&#8217;entr&#233;e, seuls np et L sont utilis&#233;s pour la pr&#233;diction (phase des-
cendante d&#8217;appel), les autres informations &#233;tant v&#233;rifi&#233;es lors de la propagation des r&#233;ponses
(phase ascendante de retour). Il est ainsi imm&#233;diat de basculer d&#8217;une strat&#233;gie totalement des-
cendante gauche-droite avec la directive de modulation &#171;:&#8722;dcg_mode(_,+,+,&#8722;)&#187; &#224; une strat&#233;gie
totalement ascendante avec la directive &#171;:&#8722;dcg_mode(_,&#8722;,&#8722;,&#8722;)&#187;.
</p>
<p>3.3 BMG
</p>
<p>Les grammaires &#224; mouvements restreints [BMG] sont une variante de grammaires d&#8217;extrapo-
sition qui se codent comme des extensions des DCG. Elles ont &#233;t&#233; ajout&#233;es &#224; DyALog dans
le cadre du d&#233;veloppement d&#8217;une grammaire du portugais [Rocio et al., 2001] et h&#233;ritent des
propri&#233;t&#233;s des DCG, en terme de modulation, de bidirectionalit&#233; et de lecture des terminaux.
Le principe de ces grammaires est que des constituants peuvent &#234;tre empil&#233;s temporairement et
&#234;tre d&#233;charg&#233;s ult&#233;rieurement pour combler des trous dans la phrase. Des barri&#232;res (island) per-
mettent de bloquer le d&#233;placement de constituants, si n&#233;cessaire. Comme illustr&#233; par le fragment
suivant (pour le portugais), les directives bmg_stacks, bmg_pushable et bmg_island d&#233;finissent
les piles (ici pour les relatives, les interrogatives et les topicalisations), les constituants autoris&#233;s
sur chaque pile et les op&#233;rateurs de barri&#232;res (en plus des op&#233;rateurs automatiquement d&#233;finis
pour chaque pile). La clause ligne 8 permet ainsi d&#8217;empiler sur slash un groupe pr&#233;positionnel
pp topicalis&#233;, celui-ci pouvant &#234;tre d&#233;charg&#233; dans le groupe verbal (ligne 9) mais pas dans le
groupe nominal sujet (ligne 6) &#224; cause de la barri&#232;re isl_slash.
:&#8722;bmg_stacks([slash , rel ,quest] ) .
</p>
<p>2 :&#8722;bmg_pushable(np, [quest , rel ] ) .
:&#8722;bmg_pushable([v,pp] , [ slash ] ) .
</p>
<p>4 :&#8722;bmg_island( isl_relquest , [ rel ,quest] ) .
</p>
<p>6 s&#8722;&#8722;&gt; isl_slash np, vp.
s&#8722;&#8722;&gt;comp, s .
</p>
<p>8 comp slash pp&#8722;&#8722;&gt; is l pp.
vp&#8722;&#8722;&gt;v,np,pp.
</p>
<p>4Il est possible de sp&#233;cifier un pr&#233;dicat de lecture autre que C/3 &#224; l&#8217;aide de la directive scanner.
5Ce m&#233;canisme sera syst&#233;matis&#233; &#224; terme dans le compilateur de DyALog.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&#201;ric Villemonte de la Clergerie
</p>
<p>3.4 TAG
</p>
<p>DyALog permet le traitement des grammaires d&#8217;arbres adjoints [TAG] [Joshi, 1987], avec d&#233;-
coration possible des non-terminaux par des arguments top et bottom (Feature TAG). De
plus, il est possible (mais non obligatoire) d&#8217;organiser les grammaires selon une architecture &#224;
la XTAG [Doran et al., 1994] o&#249; (a) les arbres &#233;l&#233;mentaires sont ancrables (par des terminaux)
et regroup&#233;s par familles et (b) le lexique est hi&#233;rarchis&#233; en formes fl&#233;chies r&#233;f&#233;ren&#231;ant des
lemmes qui indiquent quels arbres ils ancrent.
</p>
<p>Ainsi l&#8217;exemple suivant, issu d&#8217;une TAG jouet pour le fran&#231;ais, montre l&#8217;arbre auxiliaire vvp
de la famille &#233;ponyme vvp ancrant les verbes de modalit&#233; comme pouvoir ainsi que les entr&#233;es
associ&#233;es &#224; la forme peut et au lemme pouvoir.
</p>
<p>tag_tree{ name =&gt; vvp, family =&gt; vvp,
tree=&gt; auxtree bot=VP: :vp{}
</p>
<p>at vp( &lt;&gt; v, id=vp_ and bot=VP at &#8727;vp) } .
tag_lemma(&#8217;&#8727;POUVOIR&#8727;&#8217; ,v,
</p>
<p>tag_anchor{ name=&gt;vvp, equations=&gt;[bot = vp{ mode=&gt;inf } at vp_]}).
tag_lexicon (peut , &#8217;&#8727;POUVOIR&#8727;&#8217; , v , v{ mode =&gt; ind , num =&gt; sing }) .
</p>
<p>VP
vvp
</p>
<p>&lt;&gt;V VP&#2;
</p>
<p>Les TAG peuvent &#234;tre &#233;crites directement en DyALog, mais il existe &#233;galement un format de
repr&#233;sentation XML pour ces grammaires et des outils de conversion vers le format d&#8217;entr&#233;e de
DyALog [Barth&#233;lemy et al., 2001]. Comme pour les DCG et les BMG, les strat&#233;gies d&#8217;analyse
pour les TAG sont modulables. En interne, l&#8217;analyse tabulaire des TAG s&#8217;appuie sur l&#8217;utilisation
d&#8217;automates &#224; 2 piles [Villemonte de la Clergerie, 2001]. Notons qu&#8217;en sus de l&#8217;extension du
compilateur, nous nous sommes aussi amus&#233;s &#224; r&#233;aliser un m&#233;ta-interpr&#232;te pour les TAGs.
</p>
<p>3.5 RCG
</p>
<p>Les grammaires &#224; concat&#233;nation d&#8217;intervalles [RCG] [Boullier, 2000] forment une classe tr&#232;s
puissante de grammaires pouvant n&#233;anmoins s&#8217;analyser en temps polynomial. De nombreux
formalismes, comme les TAG, peuvent &#234;tre encod&#233;s &#224; l&#8217;aide des RCG. Les clauses RCG res-
semblent &#224; des clauses DCG, &#224; la diff&#233;rence que les arguments sp&#233;cifient les intervalles de la
cha&#238;ne d&#8217;entr&#233;e couverts par les non-terminaux. Ces arguments sont des terminaux ou des va-
riables (X , Y , . . . ) s&#233;par&#233;s par l&#8217;op&#233;rateur de concat&#233;nation @. En plus de ces arguments,
l&#8217;implantation DyALog des RCG permet d&#8217;associer un second jeu d&#8217;arguments logiques aux
non-terminaux (XRCG). Ainsi, la grammaire suivante reconnait le langage anbncn, utilisant un
argument logique attach&#233; aux non-terminaux s et a pour retourner n.
</p>
<p>s(N) (X@Y@Z)&#8722;&#8722;&gt; a(N) (X,Y,Z) . a(0) (&quot;&quot; ,&quot;&quot; ,&quot;&quot;)&#8722;&#8722;&gt; true .
a(M) (&quot;a&quot; @X,&quot;b&quot; @Y,&quot;c&quot; @ Z)&#8722;&#8722;&gt; a(N) (X,Y,Z), {M is N+1}. axiom(s(N)) .
</p>
<p>L&#8217;int&#233;gration des RCG dans le compilateur DyALog reste pr&#233;liminaire mais s&#8217;est effectu&#233;e
en moins de 2 jours, en commen&#231;ant par r&#233;aliser un m&#233;ta-analyseur, puis une extension du
compilateur. Nous avons test&#233; des RCG r&#233;sultant de la conversion (automatique) de TAG (50 et
420 arbres) et obtenu de bon r&#233;sultats 6.
</p>
<p>6Sans rivaliser n&#233;anmoins avec l&#8217;implantation tr&#232;s performante de Pierre Boullier.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Construire des analyseurs avec DyALog
</p>
<p>3.6 Autres formalismes logiques
</p>
<p>Pour l&#8217;instant, DyALog n&#8217;int&#232;gre pas les formalismes LFG et HPSG mais propose d&#233;j&#224; certaines
fonctionnalit&#233;s (programmation en logique et structures de traits typ&#233;es) qui doivent faciliter
cette int&#233;gration.
</p>
<p>4 Am&#233;liorer les parseurs
</p>
<p>For&#234;ts partag&#233;es Les analyseurs construits avec DyALog admettent l&#8217;option -forest per-
mettant de visualiser l&#8217;ensemble des arbres de d&#233;rivation produits par une analyse. Cet ensemble
d&#8217;arbres est &#233;mis sous une forme partag&#233;e, refl&#233;tant le partage de calcul qui r&#233;sulte de l&#8217;emploi
des techniques de tabulation. Dans le cas des DCG, la for&#234;t de d&#233;rivation est isomorphe &#224; la
for&#234;t d&#8217;analyse mais ce n&#8217;est plus le cas pour les TAG. Le format de repr&#233;sentation utilis&#233; pour
les for&#234;ts correspond &#224; une vue &#171;grammaire&#187; et illustre le fait que ces for&#234;ts ont formellement la
structure de grammaires hors-contexte avec comme non-terminaux les constituants de la phrase
et comme productions les r&#232;gles de d&#233;rivation des constituants. Dans le cas des TAG, les non-
terminaux dans le corps des productions sont &#233;ventuellement pr&#233;c&#233;d&#233;s par un label indiquant le
nom du noeud sur lequel s&#8217;attache le constituant (par substitution ou adjonction).
Ainsi, l&#8217;exemple suivant provient de l&#8217;analyse de la phrase &#171;Yves aime Sabine&#187; par une TAG,
avec l&#8217;indice 1 repr&#233;sentant le constituant s{inv=&gt; &#8722;, mode=&gt; mode[ind, subj]}(0,3) construit
avec l&#8217;arbre tn1 par ancrage de la forme aime sur le noeud &lt;&gt; et de substitutions sur les
noeuds np_0 et np_1 des constituants associ&#233;s aux indices 2 et 4.
</p>
<p>s{inv=&gt; &#8722;, mode=&gt; mode[ind , subj ]}(0,3) 1 &lt;&#8722;&#8722; [np_0]2 [&lt;&gt;]3 [np_1]4
np{gen=&gt; masc , num=&gt; sing } ( 0 , 1 ) 2 &lt;&#8722;&#8722; [&lt;&gt;]5
tag_anchor (aime,1,2,tn1 ) 3 &lt;&#8722;&#8722;
np{gen=&gt; fem, num=&gt; sing } ( 2 , 3 ) 4 &lt;&#8722;&#8722; [&lt;&gt;]6
tag_anchor (Yves,0,1,np ) 5 &lt;&#8722;&#8722;
tag_anchor (Sabine,2,3,np ) 6 &lt;&#8722;&#8722;
</p>
<p>Un constituant peut avoir plusieurs d&#233;rivations possibles, chacune &#233;tant associ&#233;e &#224; une produc-
tions, comme par exemple dans le cas de &#171;Yves cherche les fleurs sur la table&#187;, avec ambigu&#239;t&#233;
de l&#8217;attachement pr&#233;positionnel :
</p>
<p>s {}(0 ,7) 1 &lt;&#8722;&#8722; ( [np_0]2 [&lt;&gt;]3 [np_1]4 [vp]5 | [np_0]2 [&lt;&gt;]3 [np_1]6 )
Dans le cas des TAG, des outils de conversion existent pour transformer la vue grammaire en
une repr&#233;sentation XML, qui sert ensuite de pivot pour des repr&#233;sentations graphiques sous
forme d&#8217;arborescences ou de graphes de d&#233;pendance [Barth&#233;lemy et al., 2001]7.
Le fait de pouvoir annoter un non-terminal par un label (tel np_0) dans le corps des productions
aide &#224; la lecture des for&#234;ts. Le principe s&#8217;&#233;tend &#224; d&#8217;autres formalismes que les TAG en d&#233;fi-
nissant un op&#233;rateur d&#8217;&#233;tiquetage permettant de nommer les non-terminaux dans les clauses,
comme dans le cas de la clause DCG suivante :
</p>
<p>:&#8722;tagop(&#8217; : &#8217; ) . s&#8722;&#8722;&gt; sujet :np , verbe :v , objet :np.
</p>
<p>L&#8217;extraction des for&#234;ts s&#8217;effectue gr&#226;ce aux pointeurs arri&#232;res vers les parents qui sont pr&#233;sents
dans les objets tabul&#233;s lors de l&#8217;analyse. Des pr&#233;dicats permettent l&#8217;examen des objets tabul&#233;s
</p>
<p>7Le serveur de parseurs accessible &#224; http://medoc.inria.fr/pub-cgi-bin/parser.cgi permet
de comparer les diff&#233;rentes vues des for&#234;ts.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&#201;ric Villemonte de la Clergerie
</p>
<p>et de leurs pointeurs arri&#232;res, rendant possible le d&#233;veloppement d&#8217;algorithmes de traitement de
for&#234;ts (recherche des points d&#8217;ambigu&#239;t&#233;, calculs de formes s&#233;mantiques).
</p>
<p>Lexicalisation DyALog ne fait aucune hypoth&#232;se sur le statut lexicalis&#233; ou non des gram-
maires. Cependant, des extensions r&#233;centes am&#233;liorent le traitement des structures (clauses ou
arbres) lexicalis&#233;es (ou lexicalisables) en pouvant leur associer une condition d&#8217;activation qui
est v&#233;rifi&#233;e au d&#233;but de l&#8217;analyse. Ainsi, l&#8217;exemple suivant permet de bloquer l&#8217;activation de la
clause si le lexical &#171;qui&#187; n&#8217;est pas pr&#233;sent dans la cha&#238;ne d&#8217;entr&#233;e.
</p>
<p>&#8217;$loader&#8217; ( phrase ([qui ] ,_,_ ) , ( np&#8722;&#8722;&gt;np, [ qui ] , s_rel ) ) . %%&#8217;$loader &#8217;(Cond,Clause) .
</p>
<p>Bien qu&#8217;il soit pr&#233;f&#233;rable que le compilateur d&#233;duise de lui-m&#234;me ces conditions d&#8217;activation
(comme c&#8217;est d&#233;j&#224; le cas pour les TAG), ce m&#233;chanisme permet &#224; un utilisateur de tester ou
d&#8217;affiner ses propres conditions d&#8217;activations.
</p>
<p>Robustesse Convertir un analyseur complet en un analyseur partiel robuste revient simple-
ment &#224; changer la requ&#234;te initiale :
</p>
<p>?&#8722;recorded (&#8217;N&#8217; (N) ) , A=0, tag_phrase (top=S: : s{} at s ,A,N) . % analyse compl&#232;te
?&#8722;tag_phrase (top=U1: : s{} at s ,A,N) ; tag_phrase (top=U2: :np{} at np,A,N) . % analyse partielle
</p>
<p>Nous avons d&#233;j&#224; mentionn&#233; la possibilit&#233; de d&#233;finir des strat&#233;gies d&#8217;analyse bidirectionnelle,
lesquelles sont bien adapt&#233;es dans le cas d&#8217;analyseurs partiels.
</p>
<p>L&#8217;utilisation d&#8217;automates finis comme entr&#233;e pour l&#8217;analyse donne &#233;galement une robustesse ac-
crue en permettant le traitement de phrases avec mots ambigu&#235;s, mots inconnus, voire portions
inconnues de phrases.
</p>
<p>Enfin, les techniques de tabulation coupl&#233;es aux propri&#233;t&#233;s d&#8217;examen de la table &#224; l&#8217;aide de
pr&#233;dicats logiques permettent la mise au point d&#8217;algorithmes de correction des erreurs. Cette
possibilit&#233; est en cours d&#8217;&#233;tude dans le cadre d&#8217;un analyseur robuste du portugais.
</p>
<p>5 Exp&#233;riences et &#233;valuations
</p>
<p>Nous utilisons DyALog en interne pour diverses grammaires DCG et surtout TAG. En particu-
lier, nous menons des exp&#233;riences sur une TAG jouet pour le fran&#231;ais de 50 arbres et une de
l&#8217;anglais de 400 arbres et pr&#233;voyons de passer tr&#232;s prochainement aux grammaires du fran&#231;ais
et de l&#8217;anglais &#224; large couverture (plusieurs milliers d&#8217;arbres). Nous avons test&#233; la robustesse
(analyse partielle et traitement de mots inconnus) ainsi que l&#8217;int&#233;r&#234;t des techniques de filtrage
r&#233;sultant de la lexicalisation (Tables 1 et 2)8.
Par ailleurs, DyALog est utilis&#233; pour traiter les niveaux 2 des 3 niveaux d&#8217;un analyseur robuste
multi-niveaux du portugais[Rocio et al., 2001], &#224; savoir (a) l&#8217;identification de syntagmes non-
r&#233;cursifs avec une grammaire DCG et une strat&#233;gie bidirectionnelle dirig&#233;e par les t&#234;tes ; et (b)
le rattachement des syntagmes avec une grammaire BMG. Les r&#233;sultats obtenus par rapport
&#224; un analyseur &#224; charte standard sont parlants, &#224; savoir 254 mots par seconde pour DyALog
contre 1,66 pour l&#8217;analyseur standard sur un PC 200MHz. Enfin, tr&#232;s r&#233;cemment, l&#8217;ensemble
des niveaux plus une phase compl&#233;mentaire de correction d&#8217;erreurs a &#233;t&#233; r&#233;&#233;crit avec DyALog.
</p>
<p>8La plupart des analyseurs r&#233;sultants de ces exp&#233;rimentations sont accessibles en ligne sur http://medoc.
inria.fr/pub-cgi-bin/parser.cgi.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Construire des analyseurs avec DyALog
</p>
<p>Phrase Filtrage faible Filtrage fort Robuste
&#8709; 169 89 86
Jean aime Marie 230 90 98
Yves montre des fleurs &#224; Sharon 260 130 129
Kathy regarde un livre avec St&#233;phane 250 129 115
un ami am&#233;ricain de Yves qui visite la France boit du bon vin 522 213 215
la jolie fille pense que Andrew est le grand ami de son chien 336 179 180
Marie comprend que Kathy dort bien chez Andrew 306 122 127
Anne voit les fleurs que Yves cherche sur la table 362 164 173
Jean pense que B&#233;atrice perd les p&#233;dales 297 133 133
le petit chat de Sabine court vite 270 135 137
la fille de Marie aime bien les fleurs 279 127 122
qui dit que Yves a un chien 322 128 127
un enfant intelligent de Marie comprend lentement que sa m&#232;re est b&#234;te 378 225 225
</p>
<p>TAB. 1: Temps d&#8217;analyse avec une petite TAG du fran&#231;ais (en ms sur un PC 450MHz)
Phrase Filtrage faible Filtrage Fort Robuste
&#8709; 506 119 110
John loves Mary 13190 442 378
John eats 8031 391 344
John thinks that he is eating 43340 3173 2875
John is not advising her not to eat the apple 64750 5010 5311
John advises Mary that she should eat an apple 70500 5025 4214
the book belongs to John 11730 459 551
the apple falls apart 11450 382 479
John gives Mary an apple 13690 754 708
John eats while giving Mary an apple 15300 1697 1394
perhaps John is eating an apple 20280 903 930
nevertheless John is not eating an apple 22880 1164 1235
John was also eating an apple 19620 1445 1569
</p>
<p>TAB. 2: Temps d&#8217;analyse avec une petite TAG de l&#8217;anglais (en ms sur un PC 450MHz)
</p>
<p>6 &#201;volutions
Le syst&#232;me DyALog nous sert de plate-forme pour tester de nouvelles id&#233;es en mati&#232;re d&#8217;ana-
lyse syntaxique, et notre catalogue d&#8217;&#233;volutions possibles reste fourni. Ainsi, nous comptons
enrichir la palette des strat&#233;gies d&#8217;analyse possibles en implantant efficacement des strat&#233;gies
comme celles par coin gauche (left corner) qui reposent sur des tables de d&#233;cision statiquement
calcul&#233;es. Nous pr&#233;voyons &#233;galement de modifier (profond&#233;ment) le mod&#232;le de compilation des
grammaires pour permettre la factorisation des pr&#233;fixes communs dans les parcours des clauses
ou des arbres TAG. Pour les TAG, nous souhaitons optimiser le traitement des cas d&#8217;adjonctions
non enveloppantes.
</p>
<p>Enfin, de r&#233;cents r&#233;sultats th&#233;oriques sur la tabulation vont permettre d&#8217;uniformiser le traite-
ment des formalismes actuels (en particulier les RCG) et de traiter de nouveaux formalismes
comme les Multi-Component TAG[Villemonte de la Clergerie, 2002]. Nous allons &#233;galement
poursuivre l&#8217;int&#233;gration des formalismes &#224; base de structures de traits tels HPSG ou LFG.
</p>
<p>7 Conclusion
</p>
<p>Nous avons pr&#233;sent&#233; les grandes lignes du syst&#232;me DyALog qui syst&#233;matise l&#8217;emploi de tech-
niques de tabulation, se veut multi-formalismes, multi-strat&#233;gies, et est orient&#233; vers l&#8217;&#233;criture
de grammaires. Nous pensons que DyALog peut jouer un r&#244;le &#224; plusieurs titres. Dans un cadre
p&#233;dagogique, l&#8217;int&#233;gration de base des techniques de tabulation permet de d&#233;velopper et tester</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&#201;ric Villemonte de la Clergerie
</p>
<p>rapidement des grammaires jouets pour divers formalismes. Pour les concepteurs de nouveaux
formalismes, la facilit&#233; d&#8217;extension du compilateur ou d&#8217;&#233;criture de m&#233;ta-analyseurs permet
de tester ceux-ci au sein d&#8217;une architecture uniforme. Pour les concepteurs d&#8217;analyseurs syn-
taxiques, DyALog sert de plate-forme d&#8217;int&#233;gration pour tester de nouvelles optimisations et les
g&#233;n&#233;raliser &#224; un ensemble de formalismes. Enfin, les analyseurs produits avec DyALog &#233;tant
relativement efficaces, on peut envisager leur utilisation dans le cadre d&#8217;applications r&#233;elles.
</p>
<p>R&#233;f&#233;rences
Fran&#231;ois Barth&#233;lemy, Pierre Boullier, Philippe Deschamp, Linda Kaouane, and &#201;ric Villemonte
</p>
<p>de la Clergerie. Atelier ATOLL pour les grammaires d&#8217;arbres adjoints. In Proceedings of
TALN&#8217;01, pages 63&#8211;72, Tours, France, July 2001.
</p>
<p>Fran&#231;ois Barth&#233;lemy and &#201;ric Villemonte de la Clergerie. Information flow in tabular interpre-
tations for generalized push-down automata. Theoretical Computer Science, 199 :167&#8211;198,
1998.
</p>
<p>Pierre Boullier. Range concatenation grammars. In Proceedings of the Sixth International
Workshop on Parsing Technologies (IWPT2000), pages 53&#8211;64, Trento, Italy, February 2000.
</p>
<p>Bob Carpenter. The Logic of Typed Feature Structures with Applications to Unification Gram-
mars, Logic Programs and Constraint Resolution. Number ISBN 0-521-41932. Cambridge
University Press, 1992.
</p>
<p>Christy Doran, Dania Egedi, Beth Ann Hockey, B. Srinivas, and Martin Zaidel. XTAG system
&#8212; a wide coverage grammar for English. In Proc. of the 15th International Conference on
Computational Linguistics (COLING&#8217;94), pages 922&#8211;928, Kyoto, Japan, August 1994.
</p>
<p>Aravind K. Joshi. An introduction to tree adjoining grammars. In Alexis Manaster-Ramer,
editor, Mathematics of Language, pages 87&#8211;115. John Benjamins Publishing Co., Amster-
dam/Philadelphia, 1987.
</p>
<p>Fernando C. N. Pereira and David H. D. Warren. Definite clause grammars for language analysis
- a survey of the formalism and a comparison with augmented transition networks. Artificial
Intelligence, 13 :231&#8211;278, 1980.
</p>
<p>Vitor Jorge Rocio, Gabriel Pereira Lopes, and &#201;ric Villemonte de la Clergerie. Tabulation for
multi-purpose parsing. Grammars, 4(1) :41&#8211;65, 2001.
</p>
<p>Fernand Sanches. &#201;tude et implantation modulaire d&#8217;algorithmes d&#8217;analyse syntaxique pour
des grammaires utilis&#233;es en langue naturelle (grammaires d&#8217;arbres adjoints ou grammaires
lexicales fonctionnelles). M&#233;moire d&#8217;Ing&#233;nieur CNAM, 1998.
</p>
<p>&#201;ric Villemonte de la Clergerie. Layer sharing : an improved structure&#8211;sharing framework. In
Proc. of POPL&#8217;93, pages 345&#8211;356, 1993.
</p>
<p>&#201;ric Villemonte de la Clergerie. Refining tabular parsers for TAGs. In Proceedings of NAA-
CL&#8217;01, pages 167&#8211;174, CMU, Pittsburgh, PA, USA, June 2001.
</p>
<p>&#201;ric Villemonte de la Clergerie. Parsing MCS languages with thread automata. In Proc. of
TAG+6, May 2002.</p>

</div></div>
</body></html>