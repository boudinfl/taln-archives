'1ALN zuuz, Nancy, 24-27 _]l11I1 zuuz

Construire des analyseurs avec DyALog

Eric Villemonte de la Clergerie
ATOLL - INRIA
Domaine de Voluceau

Rocquencourt, B.P. 105,78153 Le Chesnay (France)
Eric.De_La_Clergerie@inria.fr

Mots-clefs — Keywords

Analyse Syntaxique, Tabulation, DCG, TAG, RCG, BMG, TFS
Parsing, Tabulation, DCG, TAG, RCG, BMG, T FS

Résumé - Abstract

Cet article survole les fonctionnalités offertes par le systeme DyALog pour construire des ana-
lyseurs syntaxiques tabulaires. Offrant la richesse d’un environnement de programmation en
logique, DyALog facilite l’écriture de grammaires, couvre plusieurs formalismes et permet le
paramétrage de stratégies d’analyse.

This paper is a survey of the functionalities provided by system DyALog to build tabular par-
sers. Providing the expressiveness of logic programming, DyALog eases the development of
grammars, covers several linguistic formalisms, and allows the parametrization of parsing stra-
tegies.

1 Introduction

Cet article présente les grandes lignes du systeme DyALog1. Issu de travaux sur les techniques
de tabulation en programmation en logique, ce systeme permet la compilation d’analyseurs
syntaxiques pour divers formalismes linguistiques a base d’uniﬁcation. Faute de place, nous
ne présentons pas les techniques de tabulation sous-jacentes ni l’architecture et le processus
de compilation qui en résultent mais nous nous focalisons sur l’apport de DyALog pour le
développement d’analyseurs syntaxiques.

L’ écriture de grammaires avec DyALog s’appuie sur la ﬂexibilité des notations a la PROLOG,
complétée par diverses extensions plus spéciﬁquement congues pour le champ linguistique,
telles les structures de traits (Section 2).

Les mécanismes génériques de tabulation de DyALog facilitent la Inise au point d’analyseurs

1Librement disponible sur le site http : //atoll . inria . fr.

Lillb V111Ul11Ul1LU UU 1a \./IULEULIU

pour divers formalismes, comme les DCG, les Grammaires a Mouvements Restreints [BMG],
les grammaires d’arbres adjoints [TAG] et les grammaires a concaténation d’intervalles [RCG]
(Section 3). De plus, des directives de compilation sont disponibles permettant de paramétrer
les stratégies d’analyse. Il devient des lors plus facile de mener des expériences de comparaison
entre formalismes et stratégies au sein d’un unique systeme.

Enﬁn, nous décrivons, dans la section 4, quelques fonctionnalités qui améliorent l’efﬁcacité
ou l’utilisation des analyseurs produits avec DyALog. Nous concluons en relatant quelques
expériences menées avec DyALog et quelques évolutions en cours.

2 Faciliter l’écriture de grammaires

Notation Hilog Cette notation permet de décrire des termes d’ordre (pseudo) supérieur, comme
par exemple P(X,Y) ou P__,(X,Y) qui décrit un terme avec une variable de prédicat P. Ce
genre de notation est tres utile pour représenter des expressions sémantiques. La notation Hilog
est aussi pratique pour associer des groupes distincts d’arguments a un prédicat, par exemple
q(X1,X2)(Y1,Y2,Y3). Ainsi, nous l’utilisons pour les RCG (Section 3.5). En interne, le terme
Hilog P(X,Y) est représenté par le terme du premier ordre apply(P,X,Y).

Uniﬁcation immédiate L’ opérateur binaire :: force l’uniﬁcation de ses deux arguments des la
lecture des termes. Nous l’utilisons tres souvent pour nommer des structures complexes ayant
plusieurs occurrences, comme par exemple dans p(X::g(Z,f(a)),X). L’ uniﬁcation immédiate est
également utile comme opérateur de conjonction de formules, par exemple dans les HPSG.

Structures cycliques A la différence de la plupart des systemes de programmation en logique,
DyALog admet les structures cycliques obtenues par exemple par l’uniﬁcation X::f(X). Ces
structures sont rarement nécessaires, sauf potentiellement dans le cas des grammaires HPSG.

Structures de traits, typées on non Les formalismes linguistiques font grand usage de struc-
tures de traits, typées ou non. DyALog offre les deux variantes. Dans les deux cas, la premiere
étape consiste a déﬁnir les traits possibles pour un foncteur, comme illustré ci-dessous dans le
cas non typé.

:—features ([np] , [gen,num, pers , re str ,wh] ).

lexicon (’ Sabine’ , np{ gen=>fem, rum=>sing , re str=>plushum, wh=> (—) }).

Les structures de traits typées [TFS] a la Carpenter [Carpenter, 1992] permettent l’héritage
multiple. Un type hérite de l’ensemble de traits introduits par ses ancétres et peut en introduire
de nouveaux. Les valeurs des traits sont elles-mémes typées. Ces informations sont exprimées
a l’aide d’une hiérarchie de types. L’ exemple suivant illustre les notations sur un fragment de
grammaire HPSG. La syntaxe de description des hiérarchies de type est standard, a l’exception
de la ligne 2 qui permet de lier le type st ring a un type de base de DyALog, a savoir symbol.

bot sub [string,list,cat,synsem]. frase sub [root] intro [argszlist] .
string escape symbol. root sub [] intro [catzs].
cat sub [s,np,Vp,det,n]. lexeme sub [] intro [orthzstring] .
s sub []. np sub []. Vp sub []. list sub [ne_1ist,e_1ist].
det sub []. 11 sub []. ne_1ist sub [] intro [hd:bot,t1:1ist].

synsem sub [frase,lexeme] intro [catzcat] . e_1ist sub [].

\/UIIDLLLILLU \al\/D u.uu.1_y Dk/BILL) (l.V\/U 

Le fragment suivant illustre l’utilisation de :: comme opérateur de conjonction, ainsi que l’ex-
ploitation des informations de la hiérarchie pour combler les informations manquantes. Ainsi,
le trait orth introduit de lui-méme le type lexeme.

hpsg(root{} :: args => ne_list{ hd =>NP, tl => ( hd =>VP :: tl => e_list{} ) })
——> hpsg( NP :: cat => np{} ), hpsg( VP :: cat => Vp{} ).
lexicon( orth => le :: cat => det{ }). %=> lexicon( lexeme{ orth=>le, cat => det{} } ).

La notation alternative par cheIr1in A .> tl .> hd permet d’accéder (a la LFG) a la valeur associée
au cheIr1in tl.hd pour la structure liée a A.

Les structures de traits sont implantées comme des termes standards, un foncteur étant associé
a chaque type et un rang ﬁxe étant associé a chaque trait pour un type donné. Pour les types
non maximaux (i.e. acceptant des sous-types), un argument supplémentaire (non visible a l’af-
ﬁchage) permet de gérer de maniere transparente les cas d’instantiation vers un sous-type (lors
de l’uniﬁcation par exemple).

L’uniﬁcation de structures typées est souvent considérée comme coﬁteuse car nécessitant (a)
d’identiﬁer les types uniﬁables; (b) de trouver les traits devant étre uniﬁés pour deux types
distincts; (c) de construire un nouveau terme quand deux types uniﬁables 71 et 72 s’instancient
en un sous-type distinct 7'3, nouveau terme qui est perdu en cas d’échec ultérieur de l’uniﬁcation.
Dans le cas de DyALog, les hiérarchies de types sont compilées avec l’utilitaire t f s 2 l ib (écrit
en DyALog) pour construire une bibliotheque qui étend la syntaxe et l’afﬁchage de DyALog
ainsi que les opérations d’uniﬁcation et de subsomption [Sanches, 1998]. Les points (a) et (b)
sont gérés en associant a chaque paire de types distincts et uniﬁables une fonction spécialisée
d’uniﬁcation (idem pour la subsomption). Le point (3) se gere grace au mécanisme de partage
de structures utilisé par DyALog [Villemonte de la Clergerie, 1993]. I1 n’y a pas construction
d’un nouveau sous-terme mais réutilisation par partage d’un squelette calculé statiquement. Ces
caractéristiques font que l’uniﬁcation des structures de traits typées n’est guere plus coﬁteuse
que celle des autres termesz.

Domaines ﬁnis Ils permettent de manipuler des disjonctions de valeurs prises dans un en-
semble ﬁni qui est declare a l’aide des directives ﬁnite_set ou subset. Ils sont implantés dans
DyALog a l’aide de vecteurs de bits, rendant leur utilisation tres efﬁcace. Ces domaines ﬁnis
sont d’un usage tres fréquent et tres pratique pour des grammaires linguistiques, comme illustré
par les deux exemples suivants.

Le premier, issu d’une grammaire TAG, déﬁnit les valeurs possibles pour les modes du verbe et
spéciﬁe les valeurs possibles pour la forme aime.

:—finite_set (mode, [ind , subj , inf ] ).
tag_1exicon (aime, ’ >«sAIlVIER>«<’ , V, V{ mode => mode[ind,subj ] , hum => sing }).

Le second exemple, issu d’un analyseur morphologique jouet pour l’akkadien, développé par
Francois Barthélemy, déﬁnit un alphabet comme un domaine ﬁni et caractérise la sous-classe
des voyelles.

:—finite_set(letter, [a,i,u,e,aleph,b,g,d,w,z,h,’t.’,j,k,l,m,n,s,p,’s.’,q,r,sh,t]).
:—subset(Voyel1e , letter [a, i ,u,e] ).
add_lattice (P1, P2, [K,letter[j,aleph], Voyelle[] ]).

2Cependant d’autres problémes ne sont pas complétement réglés, en particulier les problémes d’indexation
efﬁcace des TFS.

Lillb V111Ul11Ul1LU UU 1a \./IULEULIU

3 Proposer une palette de formalismes

Nous présentons plusieurs formalismes, linguistiques ou non, couverts par DyALog. Cette di-
versité permet la comparaison d’analyseurs pour divers formalismes au sein d’un méme sys-
teme. Du point de vue du développement de DyALog, cette diversité permet également de tes-
ter plus largement nos techniques tabulaires et de généraliser certaines optimisations proposées
dans la littérature.

3.1 Programmation en logique

Historiquement, DyALog est issu de la volonté d’exploiter les techniques de tabulation en pro-
grammation en logique. En conséquence, DyALog offre actuellement la puissance d’un envi-
ronnement de programmation en logique, permettant, en particulier, d’auto-amorcer (bootstrap)
son compilateur qui est écrit en DyALog.

Le fait de pouvoir utiliser la puissance de la programmation en logique présente au moins deux
avantages. Premierement, il est immédiat de réaliser des échappements vers des prédicats lo-
giques dans les grammaires linguistiques. Cela permet de gérer plus facilement certains détails
d’un formalisme, comme par exemple la gestion des contraintes de co-ancrage dans les gram-
maires XTAG [Doran et al., 1994]. Deuxiemement, que le compilateur DyALog soit écrit en
DyALog illustre une caractéristique bien connue de la programmation en logique, a savoir la
facilité d’écriture de méta-interpretes. En pratique, cela signiﬁe qu’il est facile d’étendre le com-
pilateur de DyALog pour intégrer de nouveaux formalismes ou alternativement de construire
rapidement un méta-analyseur.

Par défaut, les prédicats logiques sont tabulés. Ce comportement peut étre modiﬁé par des direc-
tives de compilation, permettant de ne pas tabuler certains prédicats et d’optiIniser leur traite-
ment. Nous avons ainsi des optimisations spécialisées pour les prédicats uniquement déﬁnis par
des faits ou les prédicats dont tous les descendants ne sont pas tabulés. Cette classiﬁcation des
prédicats s’étend dans une certaine mesure aux non-terminaux des formalismes grammaticaux.

La plupart des prédicats standard de PROLOG sont disponibles sous DyALog et l’appel de
fonctions C est possible avec $interf ace. Dans le cadre d’une interface vers les bases de
données, nous déﬁnissons ainsi le prédicat pg_tuple qui retourne, de maniere non-déterministe,
les valeurs d’une requéte SQL.

| pg_tup1e (Res,Val) :— ’ $interface ’ ( ’DyALog_PQtup1e’ (Res: ptr ,Val:term) , choice_size ( 1)] ).

3.2 DCG

Comme la plupart des systemes de programmation en logique, les Grammaires de Clauses De’ﬁ-
nies [DCG] [Pereira and Warren, 1980] sont disponibles sous DyALog. Cependant, l’intégration
de la tabulation rend plus immédiate l’utilisation des DCG en évitant les problemes de bouclage
et en offrant une trace des analyses au travers des foréts partagées d’analyse3. Nous avons ega-
lement étendu les DCG. Ainsi, l’opérateur & d’intersection permet, par exemple, de déﬁnir tres
facilement le langage a”b”c“ avec la clause DCG «s ——> ’AnBnC>:<’ & ’A>:<BnCn’».

L’ analyse peut se faire sur le contenu d’une liste PROLOG de terminaux, comme cela est stan-
dard pour les DCG, mais aussi, altemativement, sur un treilli de mots ou méme sur un automate

3ou plus précisement de foréts de dérivation isomorphes aux foréts d’ana1yse.

4

\/UIIDLLLILLU \al\/D u.uu.1_y Dk/BILL) (l.V\/U 

a états ﬁnis [FSA]. Le passage aux FSA rend l’analyse plus efﬁcace et offre une grande ﬂexibi-
lité pour traiter des phrases incompletes ou a mots ambigus ou inconnus, comme illustré par la
phrase «[m0t inconnu] regarde [ mots inconnus] avec un télescope.» codée en FSA par la base
suivante de faits ’C’(Left,Token,Right) 4 :

’C’ (0,_,1). ’C’(1,regarde,2). ’C’(2,_,2). ’C’(2,avec,3). ’C’(3,un,4). ’C’(4,télescope,5).

Annoter les clauses avec les opérateurs +> et <+ permet de déﬁnir des stratégies d’analyse bi-
directionnelle, généralement dirigées par les tétes. Ainsi, la clause « a ——> b <+ c +> d +>e. »
donne l’ordre de reconnaissance c, d, e, b. Cette notation étant plus opérationnelle que declara-
tive, il est préférable de convertir une grammaire avec des indications de téte en une grammaire
avec des annotations de direction, comme réalisé pour une grammaire DCG du portugais [Rocio
et al., 2001]5 :

S ——>Ilp,Vp .
Vp——>V(Type), v_args(Type).

head(s,vp).
head(vp,v).

%=>s ——>np <+ vp
%=>vp ——>v(Type) +> v_args (Type)

Parallelement a l’écriture des grammaires, DyALog offre la possibilité de spéciﬁer la stratégie
d’analyse a utiliser au niveau des non-terminaux en utilisant des directives de modulation [Bar-
thélemy and Villemonte de la Clergerie, 1998]. Ainsi la directive dcg_mode(np/2,+(—,—),+,—)
exprime le fait que, pour reconnaitre un non-terminal np(sing,fem) entre les positions gauche
L et droite R de la chaine d’entrée, seuls np et L sont utilisés pour la prédiction (phase des-
cendante d’appel), les autres informations étant vériﬁées lors de la propagation des réponses
(phase ascendante de retour). Il est ainsi immédiat de basculer d’une stratégie totalement des-
cendante gauche-droite avec la directive de modulation «: —dcg_mode(_,+,+,—)» a une stratégie
totalement ascendante avec la directive «:—dcg_mode(_,—,—,—)».

3.3 BMG

Les grammaires a mouvements restreints [BMG] sont une variante de grammaires d’eXtrapo-
sition qui se codent comme des extensions des DCG. Elles ont été ajoutées a DyALog dans
le cadre du développement d’une grammaire du portugais [Rocio et al., 2001] et héritent des
propriétés des DCG, en terme de modulation, de bidirectionalité et de lecture des terminaux.
Le principe de ces grammaires est que des constituants peuvent étre empilés temporairement et
étre déchargés ultérieurement pour combler des trous dans la phrase. Des barrieres (island) per-
mettent de bloquer le déplacement de constituants, si nécessaire. Comme illustré par le fragment
suivant (pour le portugais), les directives bmg_stacks, bmg_pushable et bmg_island déﬁnissent
les piles (ici pour les relatives, les interrogatives et les topicalisations), les constituants autorisés
sur chaque pile et les opérateurs de barrieres (en plus des opérateurs automatiquement déﬁnis
pour chaque pile). La clause ligne 8 permet ainsi d’empiler sur slash un groupe prépositionnel
pp topicalisé, celui-ci pouvant étre déchargé dans le groupe verbal (ligne 9) mais pas dans le
groupe nominal sujet (ligne 6) a cause de la barriere isl_slash.

:—bmg_stacks([slash , re] ,quest] ). e s ——> isl_slash np, vp.
:—bmg_pushable (np, [quest, rel] ) . s ——>oomp, s.
:—bmg_pushab1e([v,pp] , [slash] ). s oomp slash pp ——> is] pp.
:—bmg_island(isl_relquest , [re] ,quest] ). vp——>v,np,pp.

411 est possible de speciﬁer un prédicat de lecture autre que C/3 a l’aide de la directive scanner.
5Ce mécanisme sera systématisé a terme dans le compilateur de DyALog.

Lillb V111Ul11Ul1LU UU 1a \./IULEULIU

3.4 TAG

DyALog permet le traitement des grammaires d’arbres adjoints [TAG] [J oshi, 1987], avec de-
coration possible des non-terminaux par des arguments top et bottom (Feature TAG). De
plus, il est possible (mais non obligatoire) d’organiser les grammaires selon une architecture a
la XTAG [Doran et al., 1994] ou (a) les arbres elementaires sont ancrables (par des terminaux)
et regroupes par faInilles et (b) le lexique est hierarchise en formes ﬂechies referencant des
lemmes qui indiquent quels arbres ils ancrent.

Ainsi l’exemple suivant, issu d’une TAG jouet pour le francais, montre l’arbre auxiliaire vvp
de la faInille eponyme vvp ancrant les verbes de modalite comme pouvoir ainsi que les entrees
associees a la forme peut et au lemme pouvoir.

vvp
tag_tree{ name => vvp, family => vvp, VP
tree=> auxtree bot=VP::Vp{} / \
at Vp( <> V, id=vp_ and bot=VP at >l<Vp) }. <>V VP*

tag_lemma(’>I<PCIJVOIR>1<’ ,V,
tag_anchor{ name=>VVp, equations=>[bot = Vp{ mo@>inf } at Vp_]}).
tag_lexicon (peut, ’>«<P(IJVO1R>«<’ , V, V{ mode => ind, num=> sing }).

Les TAG peuvent etre ecrites directement en DyALog, mais il existe egalement un format de
representation XML pour ces grammaires et des outils de conversion vers le format d’entree de
DyALog [Barthelemy et al., 2001]. Come pour les DCG et les BMG, les strategies d’analyse
pour les TAG sont modulables. En interne, l’analyse tabulaire des TAG s’appuie sur l’utilisation
d’automates a 2 piles [Villemonte de la Clergerie, 2001]. Notons qu’en sus de l’extension du
compilateur, nous nous sommes aussi amuses a realiser un meta-interprete pour les TAGs.

3.5 RCG

Les grammaires a concatenation d’intervalles [RCG] [Boullier, 2000] forment une classe tres
puissante de grammaires pouvant neanmoins s’analyser en temps polynomial. De nombreux
formalismes, comme les TAG, peuvent etre encodes a l’aide des RCG. Les clauses RCG res-
semblent a des clauses DCG, a la difference que les arguments speciﬁent les intervalles de la
chaine d’entree couverts par les non-terminaux. Ces arguments sont des terminaux ou des va-
riables (X , Y,  ) separes par l’operateur de concatenation @. En plus de ces arguments,
l’implantation DyALog des RCG permet d’associer un second jeu d’arguments logiques aux
non-terminaux (XRCG). Ainsi, la grammaire suivante reconnait le langage a”b”c”, utilisant un
argument logique attache aux non-terminaux 3 et a pour retoumer n.

s(N) (X@Y@Z)——>a(N) (X,Y,Z). a(0) ("","","") ——>true.
a(M) ("a" @X,"b" @Y,"c" @Z)——>a(N) (X,Y,Z), ﬁvl is N+l}. axiom(s(N)).

L’integration des RCG dans le compilateur DyALog reste preliminaire mais s’est effectuee
en moins de 2 jours, en commencant par realiser un meta-analyseur, puis une extension du
compilateur. Nous avons teste des RCG resultant de la conversion (automatique) de TAG (50 et
420 arbres) et obtenu de bon resultats 6.

5Sans rivaliser neanmoins avec l’i1nplantation trés perfonnante de Pierre Boullier.

\/UIIDLLLILLU \al\/D u.uu.1_y Dk/BILL) (l.V\/U 

3.6 Autres formalismes logiques

Pour l’instant, DyALog n’integre pas les formalismes LFG et HPSG mais propose déja certaines
fonctionnalités (programmation en logique et structures de traits typées) qui doivent faciliter
cette integration.

4 Améliorer les parseurs

Foréts partagées Les analyseurs construits avec DyALog admettent l’option —fore st per-
mettant de visua1iserl’ensemble des arbres de dérivation produits par une analyse. Cet ensemble
d’arbres est émis sous une forme partagée, reﬂétant le partage de calcul qui résulte de l’emploi
des techniques de tabulation. Dans le cas des DCG, la forét de dérivation est isomorphe a la
forét d’analyse mais ce n’est plus le cas pour les TAG. Le format de représentation utilisé pour
les foréts correspond a une vue «grammaire» et illustre le fait que ces foréts ont formellement la
structure de grammaires hors-contexte avec comme non-terminaux les constituants de la phrase
et comme productions les regles de dérivation des constituants. Dans le cas des TAG, les non-
terminaux dans le corps des productions sont éventuellement précédés par un label indiquant le
nom du noeud sur lequel s’attache le constituant (par substitution ou adjonction).

Ainsi, l’exemple suivant provient de l’analyse de la phrase «Yves aime Sabine» par une TAG,
avec l’indice 1 représentant le constituant s{inv=> —, mode=> mode[ind, subj]}(0,3) constr11it
avec l’arbre tnl par ancrage de la forme aime sur le noeud <> et de substitutions sur les
noeuds np_0 et np_1 des constituants associés aux indices 2 et 4.

s{inv=> —,mode=>mode[ind, subj]}(0,3) 1 <——[np_0]2 [<>]3 [np_1]4

np{gen=> masc, num=> sing }(0,1) 2 <—— [<>]5
tag_anchor(aime,1,2,tn1 ) 3 <—
np{gen=> fem, IlJ1’1’l=> sing } (2, 3) 4 <—— [<>]6
tag_anchor (Yves, 0 , 1 ,np) 5 <—
tag_anchor (Sabine , 2 , 3 ,np) 6 <—

Un constituant peut avoir plusieurs dérivations possibles, chacune étant associée a une produc-
tions, comme par exemple dans le cas de «Yves cherche les ﬂeurs sur la table», avec ambigu'1'té
de l’attachement prépositionnel :

|S{}(0,7) 1 <—-([I1P_0]2 [<>]3 [I1P_1]4 [VP]5 | [I1P_0]2 [<>]3 [I1P_1]6)

Dans le cas des TAG, des outils de conversion existent pour transformer la vue grammaire en
une représentation XML, qui sert ensuite de pivot pour des représentations graphiques sous
forme d’arborescences ou de graphes de dépendance [Barthélemy et al., 2001]7.

Le fait de pouvoir annoter un non-terminal par un label (tel np_0) dans le corps des productions
aide a la lecture des foréts. Le principe s’étend a d’autres formalismes que les TAG en deﬁ-
nissant un opérateur d’étiquetage permettant de nommer les non-terminaux dans les clauses,
comme dans le cas de la clause DCG suivante :

I I-tag0p(’:’). s——>&1j2t=np,Lr1><%:v, o,bj2t=np-

L’ extraction des foréts s’effectue grace aux pointeurs arrieres vers les parents qui sont présents
dans les objets tabulés lors de l’analyse. Des prédicats permettent l’examen des objets tabulés

7Le serveur de parseurs accessible at http : //medoc . inria . fr/pub-cgi-bin/parser . cgi permet
de comparer les djfférentes vues des foréts.

Lillb V111Ul11Ul1LU UU 1a \./IULEULIU

et de leurs pointeurs arrieres, rendant possible le développement d’algorithmes de traitement de
foréts (recherche des points d’ambigui'té, calculs de formes sémantiques).

Lexicalisation DyALog ne fait aucune hypothese sur le statut lexicalisé ou non des gram-
maires. Cependant, des extensions récentes améliorent le traitement des structures (clauses ou
arbres) lexicalisées (ou lexicalisables) en pouvant leur associer une condition d’activation qui
est vériﬁée au début de l’analyse. Ainsi, l’exemple suivant permet de bloquer l’activation de la
clause si le lexical «qui» n’est pas présent dans la chaine d’entrée.

’$loader’( phrase([qui],_,_), ( np——>np, [qui], s_rel )). %%’$loader’(Oond,Clause).

Bien qu’il soit préférable que le compilateur déduise de lui-méme ces conditions d’activation
(comme c’est déja le cas pour les TAG), ce méchanisme permet a un utilisateur de tester ou
d’afﬁner ses propres conditions d’activations.

Robustesse Convertir un analyseur complet en un analyseur partiel robuste revient simple-
ment a changer la requéte initiale :

?—recorded(’N’ (N) ) , A=0, tag_phrase (top=S: 2 s{ } at s ,A,N) . % analyse complete
?—tag_phrase (top=U1: 2 s{} at s ,A,N) ; tag_phrase (top=U2: :np{} at np ,A,N). % analyse partielle

Nous avons déja mentionné la possibilité de déﬁnir des stratégies d’analyse bidirectionnelle,
lesquelles sont bien adaptées dans le cas d’analyseurs partiels.

L’ utilisation d’automates ﬁnis comme entrée pour l’analyse donne également une robustesse ac-
crue en permettant le traitement de phrases avec mots ambigues, mots inconnus, voire portions
inconnues de phrases.

Enﬁn, les techniques de tabulation couplées aux propriétés d’examen de la table a l’aide de
prédicats logiques permettent la Inise au point d’algorithmes de correction des erreurs. Cette
possibilité est en cours d’étude dans le cadre d’un analyseur robuste du portugais.

5 Expériences et évaluations

Nous utilisons DyALog en inteme pour diverses grammaires DCG et surtout TAG. En particu-
lier, nous menons des expériences sur une TAG jouet pour le francais de 50 arbres et une de
l’anglais de 400 arbres et prévoyons de passer tres prochainement aux grammaires du francais
et de l’anglais a large couverture (plusieurs milliers d’arbres). Nous avons testé la robustesse
(analyse partielle et traitement de mots inconnus) ainsi que l’intérét des techniques de ﬁltrage
résultant de la lexicalisation (Tables 1 et 2)8.

Par ailleurs, DyALog est utilisé pour traiter les niveaux 2 des 3 niveaux d’un analyseur robuste
multi-niveaux du portugais[Rocio et al., 2001], a savoir (a) l’identiﬁcation de syntagmes non-
récursifs avec une grammaire DCG et une stratégie bidirectionnelle dirigée par les tétes; et (b)
le rattachement des syntagmes avec une grammaire BMG. Les résultats obtenus par rapport
a un analyseur a charte standard sont parlants, a savoir 254 mots par seconde pour DyALog
contre 1,66 pour l’analyseur standard sur un PC 200MHz. Enﬁn, tres récemment, l’ensemble
des niveaux plus une phase complémentaire de correction d’erreurs a été réécrit avec DyALog.

8La plupart des analyseurs résultants de ces expérimentations sont accessibles en ligne sur http : / /medoc .
inria . fr/pub—cgi—bin/parser . cgi.

\/UIIDLLLILLU \al\/D u.uu.1_y Dk/BILL) (l.V\/U 

Jean
Yves montre

un France
est son
dort bien chez Andrew
Yves sur

C01]It

Yves a un

 

TAB. 1: Temps d’analyse avec une petite TAG du frangais (en ms sur un PC 450MHz)

not

the book

 

TAB. 2: Temps d’analyse avec une petite TAG de l’anglais (en ms sur un PC 450MHz)

6 Evolutions

Le systéme DyALog nous sert de plate-forme pour tester de nouvelles idées en matiére d’ana-
lyse syntaxique, et notre catalogue d’évolutions possibles reste fourni. Ainsi, nous comptons
enrichir la palette des stratégies d’analyse possibles en implantant efﬁcacement des stratégies
comme celles par coin gauche (leﬁ comer) qui reposent sur des tables de décision statiquement
calculées. Nous prévoyons également de modiﬁer (profondément) le modéle de compilation des
grammaires pour permettre la factorisation des préﬁxes communs dans les parcours des clauses
ou des arbres TAG. Pour les TAG, nous souhaitons optimiser le traitement des cas d’adj onctions
non enveloppantes.

Enﬁn, de récents résultats théoriques sur la tabulation vont permettre d’uniforIniser le traite-
ment des formalismes actuels (en particulier les RCG) et de traiter de nouveaux formalismes
comme les Multi-Component TAG[Villemonte de la Clergerie, 2002]. Nous allons également
poursuivre l’intégration des formalismes a base de structures de traits tels HPSG ou LFG.

7 Conclusion

Nous avons présenté les grandes lignes du systéme DyALog qui systématise l’emploi de tech-
niques de tabulation, se veut multi-formalismes, multi-stratégies, et est orienté vers l’écriture
de grammaires. Nous pensons que DyALog peut jouer un role a plusieurs titres. Dans un cadre
pédagogique, l’intégration de base des techniques de tabulation permet de développer et tester

Lillb V111Ul11Ul1LU UU 1a \./IULEULIU

rapidement des grammaires jouets pour divers formalismes. Pour les concepteurs de nouveaux
formalismes, la facilité d’extension du compilateur ou d’écriture de méta-analyseurs permet
de tester ceux-ci au sein d’une architecture uniforme. Pour les concepteurs d’analyseurs syn-
taxiques, DyALog sert de plate-forme d’intégration pour tester de nouvelles optimisations et les
généraliser a un ensemble de formalismes. Enﬁn, les analyseurs produits avec DyALog étant
relativement efﬁcaces, on peut envisager leur utilisation dans le cadre d’applications réelles.

Références

Francois Barthélemy, Pierre Boullier, Philippe Deschamp, Linda Kaouane, and Bric Villemonte
de la Clergerie. Atelier ATOLL pour les grammaires d’arbres adjoints. In Proceedings of
TALN’0I, pages 63-72, Tours, France, July 2001.

Francois Barthélemy and Eric Villemonte de la Clergerie. Information ﬂow in tabular interpre-
tations for generalized push-down automata. Theoretical Computer Science, 199 :167-198,
1998.

Pierre Boullier. Range concatenation grammars. In Proceedings of the Sixth International
Workshop on Parsing Technologies (IWPT2000), pages 53-64, Trento, Italy, February 2000.

Bob Carpenter. The Logic of Typed Feature Structures with Applications to Uniﬁcation Gram-
mars, Logic Programs and Constraint Resolution. Number ISBN 0-521-41932. Cambridge
University Press, 1992.

Christy Doran, Dania Egedi, Beth Ann Hockey, B. Srinivas, and Martin Zaidel. XTAG system
— a wide coverage grammar for English. In Proc. of the I5th International Conference on
Computational Linguistics (COLING’94), pages 922-928, Kyoto, Japan, August 1994.

Aravind K. J oshi. An introduction to tree adjoining grammars. In Alexis Manaster-Ramer,
editor, Mathematics of Language, pages 87-115. John Benjamins Publishing Co., Amster-
dam/Philadelphia, 1987.

Fernando C. N. Pereira and David H. D. Warren. Deﬁnite clause grammars for language analysis
- a survey of the formalism and a comparison with augmented transition networks. Artiﬁcial
Intelligence, 13 :231-278, 1980.

Vitor Jorge Rocio, Gabriel Pereira Lopes, and Bric Villemonte de la Clergerie. Tabulation for
multi-purpose parsing. Grammars, 4(1) :41-65, 2001.

Fernand Sanches. Btude et implantation modulaire d’algorithmes d’analyse syntaxique pour
des grammaires utilisées en langue naturelle (grammaires d’arbres adjoints ou grammaires
lexicales fonctionnelles). Mémoire d’Ingénieur CNAM, 1998.

Eric Villemonte de la Clergerie. Layer sharing : an improved structure-sharing framework. In
Proc. of POPL’93, pages 345-356, 1993.

Eric Villemonte de la Clergerie. Reﬁning tabular parsers for TAGs. In Proceedings of NAA-
CL’0I, pages 167-174, CMU, Pittsburgh, PA, USA, June 2001.

Eric Villemonte de la Clergerie. Parsing MCS languages with thread automata. In Proc. of
TAG+6, May 2002.

