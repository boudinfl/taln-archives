<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>François Barthélemy</author>
<author>Pierre Boullier</author>
<author>Philippe Deschamp</author>
</authors>
<title>Linda Kaouane, and Éric Villemonte de la Clergerie. Atelier ATOLL pour les grammaires d’arbres adjoints.</title>
<date>2001</date>
<booktitle>In Proceedings of TALN’01,</booktitle>
<pages>63--72</pages>
<location>Tours, France,</location>
<contexts>
<context position="16762" citStr="Barthélemy et al., 2001" startWordPosition="2666" endWordPosition="2669">vp ancrant les verbes de modalité comme pouvoir ainsi que les entrées associées à la forme peut et au lemme pouvoir. vvp tag_tree{ name =&gt; vvp, family =&gt; vvp, VP tree=&gt; auxtree bot=VP: :vp{} at vp( &lt;&gt; v, id=vp_ and bot=VP at ∗vp) } . &lt;&gt;V VP tag_lemma(’∗POUVOIR∗’ ,v, tag_anchor{ name=&gt;vvp, equations=&gt;[bot = vp{ mode=&gt;inf } at vp_]}). tag_lexicon (peut , ’∗POUVOIR∗’ , v , v{ mode =&gt; ind , num =&gt; sing }) . Les TAG peuvent être écrites directement en DyALog, mais il existe également un format de représentation XML pour ces grammaires et des outils de conversion vers le format d’entrée de DyALog [Barthélemy et al., 2001]. Comme pour les DCG et les BMG, les stratégies d’analyse pour les TAG sont modulables. En interne, l’analyse tabulaire des TAG s’appuie sur l’utilisation d’automates à 2 piles [Villemonte de la Clergerie, 2001]. Notons qu’en sus de l’extension du compilateur, nous nous sommes aussi amusés à réaliser un méta-interprète pour les TAGs. 3.5 RCG Les grammaires à concaténation d’intervalles [RCG] [Boullier, 2000] forment une classe très puissante de grammaires pouvant néanmoins s’analyser en temps polynomial. De nombreux formalismes, comme les TAG, peuvent être encodés à l’aide des RCG. Les clause</context>
<context position="20824" citStr="Barthélemy et al., 2001" startWordPosition="3313" endWordPosition="3316">&lt;&gt;]6 tag_anchor (Yves,0,1,np ) 5 &lt;−− tag_anchor (Sabine,2,3,np ) 6 &lt;−− Un constituant peut avoir plusieurs dérivations possibles, chacune étant associée à une productions, comme par exemple dans le cas de «Yves cherche les fleurs sur la table», avec ambiguïté de l’attachement prépositionnel : s {}(0 ,7) 1 &lt;−− ( [np_0]2 [&lt;&gt;]3 [np_1]4 [vp]5 |[np_0]2 [&lt;&gt;]3 [np_1]6 ) Dans le cas des TAG, des outils de conversion existent pour transformer la vue grammaire en une représentation XML, qui sert ensuite de pivot pour des représentations graphiques sous forme d’arborescences ou de graphes de dépendance [Barthélemy et al., 2001]7. Le fait de pouvoir annoter un non-terminal par un label (tel np_0) dans le corps des productions aide à la lecture des forêts. Le principe s’étend à d’autres formalismes que les TAG en définissant un opérateur d’étiquetage permettant de nommer les non-terminaux dans les clauses, comme dans le cas de la clause DCG suivante : :−tagop(’ : ’ ) . s−−&gt; sujet :np , verbe :v , objet :np. L’extraction des forêts s’effectue grâce aux pointeurs arrières vers les parents qui sont présents dans les objets tabulés lors de l’analyse. Des prédicats permettent l’examen des objets tabulés 7Le serveur de par</context>
</contexts>
<marker>Barthélemy, Boullier, Deschamp, 2001</marker>
<rawString>François Barthélemy, Pierre Boullier, Philippe Deschamp, Linda Kaouane, and Éric Villemonte de la Clergerie. Atelier ATOLL pour les grammaires d’arbres adjoints. In Proceedings of TALN’01, pages 63–72, Tours, France, July 2001.</rawString>
</citation>
<citation valid="true">
<title>François Barthélemy and Éric Villemonte de la Clergerie. Information flow in tabular interpretations for generalized push-down automata.</title>
<date>1998</date>
<journal>Theoretical Computer Science,</journal>
<volume>199</volume>
<pages>167--198</pages>
<marker>1998</marker>
<rawString>François Barthélemy and Éric Villemonte de la Clergerie. Information flow in tabular interpretations for generalized push-down automata. Theoretical Computer Science, 199 :167–198, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Range concatenation grammars.</title>
<date>2000</date>
<booktitle>In Proceedings of the Sixth International Workshop on Parsing Technologies (IWPT2000),</booktitle>
<pages>53--64</pages>
<location>Trento, Italy,</location>
<contexts>
<context position="17173" citStr="Boullier, 2000" startWordPosition="2730" endWordPosition="2731">ent être écrites directement en DyALog, mais il existe également un format de représentation XML pour ces grammaires et des outils de conversion vers le format d’entrée de DyALog [Barthélemy et al., 2001]. Comme pour les DCG et les BMG, les stratégies d’analyse pour les TAG sont modulables. En interne, l’analyse tabulaire des TAG s’appuie sur l’utilisation d’automates à 2 piles [Villemonte de la Clergerie, 2001]. Notons qu’en sus de l’extension du compilateur, nous nous sommes aussi amusés à réaliser un méta-interprète pour les TAGs. 3.5 RCG Les grammaires à concaténation d’intervalles [RCG] [Boullier, 2000] forment une classe très puissante de grammaires pouvant néanmoins s’analyser en temps polynomial. De nombreux formalismes, comme les TAG, peuvent être encodés à l’aide des RCG. Les clauses RCG ressemblent à des clauses DCG, à la différence que les arguments spécifient les intervalles de la chaîne d’entrée couverts par les non-terminaux. Ces arguments sont des terminaux ou des variables (X , Y , . . . ) séparés par l’opérateur de concaténation @. En plus de ces arguments, l’implantation DyALog des RCG permet d’associer un second jeu d’arguments logiques aux non-terminaux (XRCG). Ainsi, la gra</context>
</contexts>
<marker>Boullier, 2000</marker>
<rawString>Pierre Boullier. Range concatenation grammars. In Proceedings of the Sixth International Workshop on Parsing Technologies (IWPT2000), pages 53–64, Trento, Italy, February 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures with Applications to Unification Grammars, Logic Programs and Constraint Resolution.</title>
<date>1992</date>
<journal>Number ISBN</journal>
<pages>0--521</pages>
<publisher>Cambridge University Press,</publisher>
<contexts>
<context position="4266" citStr="Carpenter, 1992" startWordPosition="605" endWordPosition="606">par l’unification X::f(X). Ces structures sont rarement nécessaires, sauf potentiellement dans le cas des grammaires HPSG. Structures de traits, typées ou non Les formalismes linguistiques font grand usage de structures de traits, typées ou non. DyALog offre les deux variantes. Dans les deux cas, la première étape consiste à définir les traits possibles pour un foncteur, comme illustré ci-dessous dans le cas non typé. :−features ([np] , [gen,num,pers , restr ,wh]) . lexicon (’Sabine’ , np{ gen=&gt;fem, num=&gt;sing , restr=&gt;plushum, wh=&gt; (−) }). Les structures de traits typées [TFS] à la Carpenter [Carpenter, 1992] permettent l’héritage multiple. Un type hérite de l’ensemble de traits introduits par ses ancêtres et peut en introduire de nouveaux. Les valeurs des traits sont elles-mêmes typées. Ces informations sont exprimées à l’aide d’une hiérarchie de types. L’exemple suivant illustre les notations sur un fragment de grammaire HPSG. La syntaxe de description des hiérarchies de type est standard, à l’exception de la ligne 2 qui permet de lier le type string à un type de base de DyALog, à savoir symbol. bot sub [ string , l i s t , cat ,synsem] . frase sub [ root ] intro [ args : l i s t ] . string esc</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Bob Carpenter. The Logic of Typed Feature Structures with Applications to Unification Grammars, Logic Programs and Constraint Resolution. Number ISBN 0-521-41932. Cambridge University Press, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christy Doran</author>
<author>Dania Egedi</author>
<author>Beth Ann Hockey</author>
<author>B Srinivas</author>
<author>Martin Zaidel</author>
</authors>
<title>XTAG system — a wide coverage grammar for English.</title>
<date>1994</date>
<booktitle>In Proc. of the 15th International Conference on Computational Linguistics (COLING’94),</booktitle>
<pages>922--928</pages>
<location>Kyoto, Japan,</location>
<contexts>
<context position="9881" citStr="Doran et al., 1994" startWordPosition="1588" endWordPosition="1591">tion en logique. En conséquence, DyALog offre actuellement la puissance d’un environnement de programmation en logique, permettant, en particulier, d’auto-amorcer (bootstrap) son compilateur qui est écrit en DyALog. Le fait de pouvoir utiliser la puissance de la programmation en logique présente au moins deux avantages. Premièrement, il est immédiat de réaliser des échappements vers des prédicats logiques dans les grammaires linguistiques. Cela permet de gérer plus facilement certains détails d’un formalisme, comme par exemple la gestion des contraintes de co-ancrage dans les grammaires XTAG [Doran et al., 1994]. Deuxièmement, que le compilateur DyALog soit écrit en DyALog illustre une caractéristique bien connue de la programmation en logique, à savoir la facilité d’écriture de méta-interprètes. En pratique, cela signifie qu’il est facile d’étendre le compilateur de DyALog pour intégrer de nouveaux formalismes ou alternativement de construire rapidement un méta-analyseur. Par défaut, les prédicats logiques sont tabulés. Ce comportement peut être modifié par des directives de compilation, permettant de ne pas tabuler certains prédicats et d’optimiser leur traitement. Nous avons ainsi des optimisatio</context>
<context position="15812" citStr="Doran et al., 1994" startWordPosition="2506" endWordPosition="2509"> [ slash ] ) . 8 comp slash pp−−&gt; is l pp. 4 :−bmg_island( isl_relquest , [ rel ,quest] ) . vp−−&gt;v,np,pp. 4Il est possible de spécifier un prédicat de lecture autre que C/3 à l’aide de la directive scanner. 5Ce mécanisme sera systématisé à terme dans le compilateur de DyALog. Éric Villemonte de la Clergerie 3.4 TAG DyALog permet le traitement des grammaires d’arbres adjoints [TAG] [Joshi, 1987], avec dé- coration possible des non-terminaux par des arguments top et bottom (Feature TAG). De plus, il est possible (mais non obligatoire) d’organiser les grammaires selon une architecture à la XTAG [Doran et al., 1994] où (a) les arbres élémentaires sont ancrables (par des terminaux) et regroupés par familles et (b) le lexique est hiérarchisé en formes fléchies référençant des lemmes qui indiquent quels arbres ils ancrent. Ainsi l’exemple suivant, issu d’une TAG jouet pour le français, montre l’arbre auxiliaire vvp de la famille éponyme vvp ancrant les verbes de modalité comme pouvoir ainsi que les entrées associées à la forme peut et au lemme pouvoir. vvp tag_tree{ name =&gt; vvp, family =&gt; vvp, VP tree=&gt; auxtree bot=VP: :vp{} at vp( &lt;&gt; v, id=vp_ and bot=VP at ∗vp) } . &lt;&gt;V VP tag_lemma(’∗POUVOIR∗’ ,v, tag_a</context>
</contexts>
<marker>Doran, Egedi, Hockey, Srinivas, Zaidel, 1994</marker>
<rawString>Christy Doran, Dania Egedi, Beth Ann Hockey, B. Srinivas, and Martin Zaidel. XTAG system — a wide coverage grammar for English. In Proc. of the 15th International Conference on Computational Linguistics (COLING’94), pages 922–928, Kyoto, Japan, August 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>An introduction to tree adjoining grammars.</title>
<date>1987</date>
<booktitle>Mathematics of Language,</booktitle>
<pages>87--115</pages>
<editor>In Alexis Manaster-Ramer, editor,</editor>
<publisher>John Benjamins Publishing Co.,</publisher>
<location>Amsterdam/Philadelphia,</location>
<contexts>
<context position="15590" citStr="Joshi, 1987" startWordPosition="2473" endWordPosition="2474">s dans le groupe nominal sujet (ligne 6) à cause de la barrière isl_slash. :−bmg_stacks([slash , rel ,quest] ) . 6 s−−&gt; isl_slash np, vp. 2 :−bmg_pushable(np, [quest , rel ] ) . s−−&gt;comp, s . :−bmg_pushable([v,pp] , [ slash ] ) . 8 comp slash pp−−&gt; is l pp. 4 :−bmg_island( isl_relquest , [ rel ,quest] ) . vp−−&gt;v,np,pp. 4Il est possible de spécifier un prédicat de lecture autre que C/3 à l’aide de la directive scanner. 5Ce mécanisme sera systématisé à terme dans le compilateur de DyALog. Éric Villemonte de la Clergerie 3.4 TAG DyALog permet le traitement des grammaires d’arbres adjoints [TAG] [Joshi, 1987], avec dé- coration possible des non-terminaux par des arguments top et bottom (Feature TAG). De plus, il est possible (mais non obligatoire) d’organiser les grammaires selon une architecture à la XTAG [Doran et al., 1994] où (a) les arbres élémentaires sont ancrables (par des terminaux) et regroupés par familles et (b) le lexique est hiérarchisé en formes fléchies référençant des lemmes qui indiquent quels arbres ils ancrent. Ainsi l’exemple suivant, issu d’une TAG jouet pour le français, montre l’arbre auxiliaire vvp de la famille éponyme vvp ancrant les verbes de modalité comme pouvoir ain</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>Aravind K. Joshi. An introduction to tree adjoining grammars. In Alexis Manaster-Ramer, editor, Mathematics of Language, pages 87–115. John Benjamins Publishing Co., Amsterdam/Philadelphia, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>David H D Warren</author>
</authors>
<title>Definite clause grammars for language analysis - a survey of the formalism and a comparison with augmented transition networks.</title>
<date>1980</date>
<journal>Artificial Intelligence,</journal>
<volume>13</volume>
<pages>231--278</pages>
<contexts>
<context position="11265" citStr="Pereira and Warren, 1980" startWordPosition="1791" endWordPosition="1794">dicats s’étend dans une certaine mesure aux non-terminaux des formalismes grammaticaux. La plupart des prédicats standard de PROLOG sont disponibles sous DyALog et l’appel de fonctions C est possible avec $interface. Dans le cadre d’une interface vers les bases de données, nous définissons ainsi le prédicat pg_tuple qui retourne, de manière non-déterministe, les valeurs d’une requête SQL. pg_tuple(Res,Val) :− ’$interface ’ ( ’DyALog_PQtuple’ (Res: ptr ,Val:term ) , choice_size (1)] ) . 3.2 DCG Comme la plupart des systèmes de programmation en logique, les Grammaires de Clauses Définies [DCG] [Pereira and Warren, 1980] sont disponibles sous DyALog. Cependant, l’intégration de la tabulation rend plus immédiate l’utilisation des DCG en évitant les problèmes de bouclage et en offrant une trace des analyses au travers des forêts partagées d’analyse3. Nous avons également étendu les DCG. Ainsi, l’opérateur &amp; d’intersection permet, par exemple, de définir très facilement le langage anbncn avec la clause DCG «s −−&gt; ’AnBnC∗’ &amp; ’A∗BnCn’». L’analyse peut se faire sur le contenu d’une liste PROLOG de terminaux, comme cela est standard pour les DCG, mais aussi, alternativement, sur un treilli de mots ou même sur un au</context>
</contexts>
<marker>Pereira, Warren, 1980</marker>
<rawString>Fernando C. N. Pereira and David H. D. Warren. Definite clause grammars for language analysis - a survey of the formalism and a comparison with augmented transition networks. Artificial Intelligence, 13 :231–278, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Vitor Jorge Rocio</author>
</authors>
<title>Gabriel Pereira Lopes, and Éric Villemonte de la Clergerie. Tabulation for multi-purpose parsing.</title>
<date>2001</date>
<journal>Grammars,</journal>
<volume>4</volume>
<issue>1</issue>
<pages>41--65</pages>
<marker>Rocio, 2001</marker>
<rawString>Vitor Jorge Rocio, Gabriel Pereira Lopes, and Éric Villemonte de la Clergerie. Tabulation for multi-purpose parsing. Grammars, 4(1) :41–65, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernand Sanches</author>
</authors>
<title>Étude et implantation modulaire d’algorithmes d’analyse syntaxique pour des grammaires utilisées en langue naturelle (grammaires d’arbres adjoints ou grammaires lexicales fonctionnelles). Mémoire d’Ingénieur CNAM,</title>
<date>1998</date>
<contexts>
<context position="6913" citStr="Sanches, 1998" startWordPosition="1111" endWordPosition="1112">s est souvent considérée comme coûteuse car nécessitant (a) d’identifier les types unifiables ; (b) de trouver les traits devant être unifiés pour deux types distincts ; (c) de construire un nouveau terme quand deux types unifiables τ1 et τ2 s’instancient en un sous-type distinct τ3, nouveau terme qui est perdu en cas d’échec ultérieur de l’unification. Dans le cas de DyALog, les hiérarchies de types sont compilées avec l’utilitaire tfs2lib (écrit en DyALog) pour construire une bibliothèque qui étend la syntaxe et l’affichage de DyALog ainsi que les opérations d’unification et de subsomption [Sanches, 1998]. Les points (a) et (b) sont gérés en associant à chaque paire de types distincts et unifiables une fonction spécialisée d’unification (idem pour la subsomption). Le point (3) se gère grâce au mécanisme de partage de structures utilisé par DyALog [Villemonte de la Clergerie, 1993]. Il n’y a pas construction d’un nouveau sous-terme mais réutilisation par partage d’un squelette calculé statiquement. Ces caractéristiques font que l’unification des structures de traits typées n’est guère plus coûteuse que celle des autres termes2. Domaines finis Ils permettent de manipuler des disjonctions de val</context>
</contexts>
<marker>Sanches, 1998</marker>
<rawString>Fernand Sanches. Étude et implantation modulaire d’algorithmes d’analyse syntaxique pour des grammaires utilisées en langue naturelle (grammaires d’arbres adjoints ou grammaires lexicales fonctionnelles). Mémoire d’Ingénieur CNAM, 1998.</rawString>
</citation>
<citation valid="true">
<title>Éric Villemonte de la Clergerie. Layer sharing : an improved structure–sharing framework.</title>
<date>1993</date>
<booktitle>In Proc. of POPL’93,</booktitle>
<pages>345--356</pages>
<marker>1993</marker>
<rawString>Éric Villemonte de la Clergerie. Layer sharing : an improved structure–sharing framework. In Proc. of POPL’93, pages 345–356, 1993.</rawString>
</citation>
<citation valid="true">
<title>Éric Villemonte de la Clergerie. Refining tabular parsers for TAGs.</title>
<date>2001</date>
<booktitle>In Proceedings of NAACL’01,</booktitle>
<pages>167--174</pages>
<location>CMU, Pittsburgh, PA, USA,</location>
<marker>2001</marker>
<rawString>Éric Villemonte de la Clergerie. Refining tabular parsers for TAGs. In Proceedings of NAACL’01, pages 167–174, CMU, Pittsburgh, PA, USA, June 2001.</rawString>
</citation>
<citation valid="true">
<title>Éric Villemonte de la Clergerie. Parsing MCS languages with thread automata.</title>
<date>2002</date>
<booktitle>In Proc. of TAG+6,</booktitle>
<marker>2002</marker>
<rawString>Éric Villemonte de la Clergerie. Parsing MCS languages with thread automata. In Proc. of TAG+6, May 2002.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>