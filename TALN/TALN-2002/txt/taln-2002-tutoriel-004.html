<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Tutoriel : Open Agent Architecture D&#233;veloppement d&#8217;applications de TALN distribu&#233;es, multiagents et multiplates-formes</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2002, Nancy, 24-27 juin 2002 
</p>
<p>Tutoriel : Open Agent Architecture 
D&#233;veloppement d&#8217;applications de TALN  
</p>
<p>distribu&#233;es, multiagents et multiplates-formes 
</p>
<p>Antonio BALVET (1), Olivier GRISVARD (2) et Pascal BISSON (2) 
</p>
<p>(1) UMR MoDyCo, Universit&#233; Paris X Nanterre 
200, av. de le R&#233;publique 92001 Nanterre 
</p>
<p>antonio.balvet@u-paris10.fr  
(2) Thales RT, DAS-HIT  
</p>
<p>Domaine de Corbeville, 91404 Orsay 
olivier.grisvard@thalesgroup.com  
pascal.bisson@thalesgroup.com  
</p>
<p>R&#233;sum&#233; - Abstract 
</p>
<p>Nous pr&#233;senterons tout d&#8217;abord la philosophie &#171; Agents &#187; en g&#233;n&#233;ral, afin d&#8217;en montrer les 
avantages pour le domaine du TALN, qui se caract&#233;rise par une h&#233;t&#233;rog&#233;n&#233;it&#233; av&#233;r&#233;e des 
syst&#232;mes existants (multiplicit&#233; des langages de programmation), ainsi qu&#8217;une forte demande 
en ressources (m&#233;moire notamment). Nous ferons ensuite une pr&#233;sentation des principales 
plate-formes orient&#233;es agents, puis nous examinerons de plus pr&#232;s la plate-forme d&#233;velopp&#233;e 
au Standford Research Institute (SRI) : OAA (licence libre). Nous cl&#244;turerons le tutoriel sur 
des exemples comment&#233;s d&#8217;applications industrielles utilisant OAA, permettant de donner 
toutes les cl&#233;s n&#233;cessaires au d&#233;veloppement d&#8217;applications distribu&#233;es (intra/internet), 
multiagents et multiplates-formes (plusieurs langages de programmation/syst&#232;mes 
d&#8217;exploitation). 
</p>
<p>We will first present the &#8220;Agent&#8221; philosophy in general, in order to put forward its usefulness 
for resources-intensive (memory) NLP systems, in a heterogeneous context. We will also 
present an overview of the main agent-oriented platforms, with a focus on the OAA platform, 
developed at the Stanford Research Institute. Finally, we will present a detailed example of a 
real-scale multiagent NLP system based on OAA, with an emphasis on development details 
which will provide the audience with all the required information to develop distributed 
(intra/internet), multiagent and multiplaforms systems (different programming 
languages/operating systems). 
</p>
<p>89 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>Introduction 
</p>
<p>La tendance actuelle, dans le domaine du Traitement Automatique du Langage Naturel, est &#224; 
la standardisation, la modularit&#233; et la r&#233;utilisabilit&#233;, apr&#232;s une p&#233;riode de foisonnement dans 
les approches, les langages de programmation utilis&#233;s ainsi que les plates-formes vis&#233;es. Cette 
tendance semble suivre le mod&#232;le du domaine du d&#233;veloppement logiciel professionnel, elle 
se traduit &#233;galement depuis une dizaine d&#8217;ann&#233;es par des campagnes d&#8217;&#233;valuation 
internationales portant sur des domaines traditionnels du TALN : &#233;tiquetage, lev&#233;e 
d&#8217;ambigu&#239;t&#233;s, calcul s&#233;mantique etc&#8230; (les conf&#233;rences MUC, TREC, mais &#233;galement 
AMARYLLIS, Senseval ou Parseval), ainsi que la constitution de corpus de r&#233;f&#233;rence. 
</p>
<p>La n&#233;cessit&#233; de disposer d&#8217;environnements de d&#233;veloppement, de bo&#238;tes &#224; outils et autres 
plate-formes normalis&#233;es pour le TALN se fait d&#8217;autant plus sentir qu&#8217;un certain nombre de 
techniques sont devenues, de fait, des standard dans le domaine (ex : l&#8217;analyse locale, les 
cascades de transducteurs) et que, par ailleurs, un certain nombre de ressources lexicales sont 
disponibles pour les langues autres que l&#8217;anglais (ex : EuroWordnet, Memodata). Toutefois, 
force est de constater l&#8217;h&#233;t&#233;rog&#233;n&#233;it&#233; r&#233;siduelle du domaine, au niveau logiciel, notamment en 
ce qui concerne les langages de programmation utilis&#233;s (de Lisp &#224; Perl en passant par C++, 
Java et Prolog), le mode de d&#233;veloppement (programmation structur&#233;e/orient&#233;e-
objet/orient&#233;e-composants/multiagents) que le cadre de d&#233;ploiement (ex : sur poste local / sur 
un r&#233;seau via une architecture client-server, sous Windows/Linux/Unix). 
</p>
<p>Certaines initiatives, telles la plate-forme GATE (General Architecture for Text Engineering), 
d&#233;velopp&#233;e &#224; l&#8217;universit&#233; de Sheffield, ont tent&#233; de r&#233;pondre &#224; cette demande (voir 
Cunningham H. et alii., 1997) en proposant une architecture modulaire visant &#224; lib&#233;rer les 
linguistes-informaticiens de t&#226;ches de d&#233;veloppement inutiles, r&#233;p&#233;t&#233;es pour chaque 
impl&#233;mentation, telles que la gestion des documents, la visualisation des donn&#233;es, les liaisons 
entre modules logiciels existants. Toutefois, malgr&#233; la popularit&#233; de GATE1 pour des t&#226;ches 
li&#233;es au traitement de l&#8217;&#233;crit (extraction d&#8217;information notamment), la plate-forme d&#233;velopp&#233;e 
par l&#8217;universit&#233; de Sheffield n&#8217;offre pas de fonctionnalit&#233;s telles que : le fonctionnement 
distribu&#233; (sur un r&#233;seau intra/internet) permettant de r&#233;partir la charge des traitements sur des 
serveurs sp&#233;cialis&#233;s en laissant l&#8217;affichage au(x) poste(s) client(s), ou encore le 
fonctionnement par agents autonomes communiquant par requ&#234;tes via un superviseur 
(architecture de type &#171; tableau noir &#187;). Par ailleurs, GATE ne s&#8217;aventure pas hors du domaine 
fix&#233; par ses concepteurs (i.e. l&#8217;&#233;crit), alors que l&#8217;int&#233;gration des diff&#233;rentes modalit&#233;s du 
langage naturel (voix, &#233;crit, ou encore geste) appara&#238;t comme l&#8217;&#233;tape suivante dans les 
d&#233;veloppements pour le domaine du TALN. 
</p>
<p>Nous pr&#233;senterons au cours de ce tutoriel une architecture en libre acc&#232;s, d&#233;velopp&#233;e au SRI 
pour le d&#233;veloppement de syst&#232;mes &#224; dimension industrielle, h&#233;t&#233;rog&#232;nes, distribu&#233;s, multi-
agents et multi-plateformes : OAA (Open Agent Architecture). Cette architecture permet 
d&#8217;envisager le d&#233;veloppement d&#8217;applications de TALN comme l&#8217;assemblage de briques de 
base, favorisant l&#8217;&#233;mergence de v&#233;ritables &#171; syst&#232;mes &#187; dont l&#8217;int&#233;gration, le d&#233;ploiement et 
</p>
<p>                                                 
1  Voir Maynard D. et alii., 2000 : plus de 12 projets de dimension europ&#233;enne et industrielle reposant sur 
</p>
<p>GATE ont &#233;t&#233; recens&#233;s. 
</p>
<p>90 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p>le fonctionnement reposent sur des bases solides, ainsi que la r&#233;utilisation et la capitalisation 
de modules logiciels existants2. 
</p>
<p>Nous assoirons le pr&#233;sent tutoriel sur l&#8217;exp&#233;rience acquise par le laboratoire Thales-RT 
France dans le domaine du d&#233;veloppement d&#8217;applications int&#233;grant la commande vocale, le 
traitement du texte et la r&#233;alit&#233; augment&#233;e reposant sur OAA. Dans un premier temps, nous 
pr&#233;senterons, de fa&#231;on synth&#233;tique, la philosophie &#171; Agents &#187;, en mettant l&#8217;accent sur les 
b&#233;n&#233;fices que le domaine du TALN peut en tirer. Dans un deuxi&#232;me temps, nous pr&#233;senterons 
les sp&#233;cificit&#233;s de la plate-forme OAA par rapport aux principales plates-formes 
agents/distribu&#233;es disponibles. Dans un troisi&#232;me temps, nous aborderons des exemples 
comment&#233;s de syst&#232;mes industriels de TALN, d&#233;velopp&#233;s &#224; Thales-RT France,  reposant sur 
OAA ainsi que sur des composants aussi divers que Nuance (reconnaissance vocale) ou le 
Dictionnaire Int&#233;gral (Memodata). 
</p>
<p>Le pr&#233;sent tutoriel s&#8217;appuie principalement sur les r&#233;f&#233;rences consultables sur le site du SRI, 
consacr&#233; &#224; la plate-forme OAA, version 2.1 et &#224; ses applications : http://www.ai.sri.com/~oaa. 
Sont notamment disponibles : 
</p>
<p>&#8226; Le guide du d&#233;veloppeur (OAA 2.1 Developer&#8217;s Guide) ; 
&#8226; La documentation du syst&#232;me (OAA 2.1 Documentation) ; 
&#8226; Un tutoriel sur OAA (OAA 2.1 Tutorial) ; 
&#8226; La r&#233;f&#233;rence du langage ICL (OAA Interagent Communication Language, API 
</p>
<p>Reference Manual) ; 
</p>
<p>&#8226; La Foire Aux Questions OAA 2.x (OAA V2.x FAQ) ; 
&#8226; Le manuel de r&#233;f&#233;rence de la libraire Agent, fournissant l&#8217;acc&#232;s aux fonctionnalit&#233;s 
</p>
<p>OAA pour l&#8217;int&#233;gration (OAA, Agent Library Reference Manual Version 2.1) ; 
</p>
<p>&#8226; L&#8217;API OAA pour les langages C et Java ; 
&#8226; Des d&#233;monstrations vid&#233;o d&#8217;applications OAA. 
</p>
<p>Par ailleurs, des exemples d&#8217;applications centr&#233;es sur l&#8217;interaction multimodale avec 
l&#8217;utilisateur sont pr&#233;sent&#233;es, ainsi que des exemples de code source pour l&#8217;ensemble des 
langages de programmation support&#233;s : C, Java,, Prolog et WebL. L&#8217;int&#233;gralit&#233; du code 
source OAA est &#233;galement disponible. 
</p>
<p> 
</p>
<p>                                                 
2  OAA a &#233;t&#233; adopt&#233;e par de nombreux laboratoires &#224; travers le monde, tant priv&#233;s que publics. 
</p>
<p>91 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>1 La philosophie &#171; Agents &#187; 
</p>
<p>1.1 Aper&#231;u de diff&#233;rents paradigmes de d&#233;veloppement logiciel 
</p>
<p>La figure ci-dessous pr&#233;sente de fa&#231;on synth&#233;tique les principaux mod&#232;les de d&#233;veloppement 
de logiciels. 
</p>
<p> 
</p>
<p> 
</p>
<p>Applications  
</p>
<p>Monolithiques 
</p>
<p>Applications  
</p>
<p>Orient&#233;es-Objet 
</p>
<p>Applications 
</p>
<p>Objets distribu&#233;s 
</p>
<p>Ajout &#8220;&#224; chaud&#8221; 
</p>
<p>Applications  
</p>
<p>OAA 
</p>
<p>Figure 1 : principaux mod&#232;les de d&#233;veloppement de logiciels 
</p>
<p>Dans cette figure, nous cherchons &#224; souligner le passage d&#8217;applications &#171; monolithiques &#187;, 
constituant un tout indivisible, dont les diff&#233;rentes fonctionnalit&#233;s ne pouvaient &#234;tre 
dissoci&#233;es, aux applications &#171; orient&#233;es-objets &#187;, puis &#171; objets distribu&#233;s &#187;. Le passage aux 
applications orient&#233;es-objets ont essentiellement apport&#233; au monde du d&#233;veloppement la 
modularisation, ainsi que la possibilit&#233; de faire h&#233;riter des fonctionnalit&#233;s int&#233;ressantes &#224; de 
nouveaux composants. Cette &#233;tape a surtout permis &#224; la communaut&#233; des d&#233;veloppeurs de 
pouvoir envisager la r&#233;utilisabilit&#233; des composants logiciels autrement que par le code source. 
Le paradigme distribu&#233; a, lui, permis le d&#233;veloppement d&#8217;applications non centralis&#233;es sur un 
poste unique : le fonctionnement en client/serveur. L&#8217;adoption de ce mod&#232;le a &#233;galement 
permis d&#8217;envisager le d&#233;veloppement d&#8217;architectures &#171; n-tier &#187; (&#224; n &#233;tages), permettant, par 
</p>
<p>92 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p>exemple, de limiter la charge des postes clients &#224; l&#8217;affichage (interface-utilisateur), en 
d&#233;l&#233;guant les processus gourmands en ressources &#224; des postes sp&#233;cialis&#233;s (serveurs). 
</p>
<p>OAA est pr&#233;sent&#233; par ses concepteurs comme l&#8217;&#233;tape suivante dans les mod&#232;les de 
d&#233;veloppement : les composants logiciels modularis&#233;s forment une communaut&#233;, dont les 
interactions sont r&#233;gl&#233;es par un composant central, le facilitateur. Dans cette optique, les 
composants peuvent &#234;tre ajout&#233;s ou retir&#233;s de la communaut&#233; en fonction des besoins, c'est-&#224;-
dire en fonction de la t&#226;che, des ressources disponibles etc&#8230; Cet ajout ou retrait se font &#171; &#224; 
chaud &#187; : chaque nouvel agent annonce au facilitateur les services qu&#8217;il est capable de fournir. 
</p>
<p>1.2 Les bases des plates-formes multiagents 
</p>
<p>1.2.1 Modularit&#233; 
</p>
<p>La modularit&#233; semble &#234;tre une des caract&#233;ristiques principales des architectures agents. Cette 
modularit&#233; permet d&#8217;envisager des &#171; syst&#232;mes &#187; logiciels, dans lesquels des briques de base 
sont assembl&#233;es de fa&#231;on &#224; fournir un service global. Cette approche du d&#233;veloppement 
logiciel permet &#233;galement d&#8217;envisager des syst&#232;mes o&#249; les composants sont interchangeables. 
</p>
<p>La modularit&#233;, en termes logiciels, pr&#233;suppose d&#8217;adopter des mod&#232;les ou principes 
d&#8217;architecture o&#249; les services sont distingu&#233;s en fonction de leur type. Ainsi, par exemple, le 
principe &#171; mod&#232;le/vue/contr&#244;leur &#187; oblige &#224; distinguer les diff&#233;rents objets logiciels selon 
qu&#8217;ils offrent des services d&#8217;affichage (interface-utilisateur), de contr&#244;le de l&#8217;application 
(prise en charge mat&#233;rielle, suivi du d&#233;roulement des programmes) ou de repr&#233;sentation 
abstraite (ex : pour un document XML, la DTD permettant d&#8217;interpr&#233;ter le balisage employ&#233;). 
</p>
<p>1.2.2 Autonomie 
</p>
<p>Au-del&#224; des caract&#233;ristiques &#233;voqu&#233;es plus haut, la philosophie agents repose sur la notion 
d&#8217;autonomie. En d&#8217;autres termes, les agents logiciels sont vus comme des extensions des 
utilisateurs : ils sont pens&#233;s pour accomplir des t&#226;ches &#224; la place des utilisateurs. Ceci suppose 
que lesdits utilisateurs sp&#233;cifient de fa&#231;on formelle les t&#226;ches &#224; accomplir, ainsi que les 
modalit&#233;s de l&#8217;ex&#233;cution de ces t&#226;ches : synchronisation temporelle, environnement, 
conditions d&#8217;ex&#233;cution &#8230; En d&#8217;autres termes, l&#8217;autonomie accord&#233;e aux agents logiciels 
pr&#233;suppose une caract&#233;risation explicite formelle des buts poursuivis par les utilisateurs, que 
les agents vont tenter de mener &#224; bien en fonction des conditions du monde ext&#233;rieur 
(environnement logiciel). Cette autonomie implique &#233;galement une repr&#233;sentation logique de 
l&#8217;agent, de son environnement et des relations qu&#8217;il entretient avec cet environnement. C&#8217;est 
pourquoi les formalismes d&#8217;inspiration logique et la programmation d&#233;clarative, tels que 
fournis par le langage Prolog, par exemple, servent souvent de base aux architectures agents.  
</p>
<p>1.2.3 Fonctionnement dynamique 
</p>
<p>Dans le cas de OAA, l&#8217;essentiel du comportement des agents regroup&#233;s en communaut&#233; 
autour d&#8217;un facilitateur est g&#233;r&#233; par une couche de repr&#233;sentation logique des individus 
composant la communaut&#233;, de leurs buts, des services qu&#8217;ils peuvent rendre. Cette couche 
</p>
<p>93 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>logique repose sur un moteur Prolog, qui permet, par le biais du principe d&#8217;unification, de 
mener &#224; bien des buts de fa&#231;on non proc&#233;durale, en optimisant l&#8217;accomplissement d&#8217;une t&#226;che 
par rapport aux agents et services disponibles. 
</p>
<p>Le fonctionnement dynamique permet l&#8217;ajout ou le retrait d&#8217;agents de la communaut&#233; sans 
arr&#234;t du syst&#232;me, ni recompilation. Le facilitateur enregistre simplement un changement dans 
la communaut&#233; qu&#8217;il r&#233;gule. 
</p>
<p>1.3 Exemple : l&#8217;assistant bureautique 
</p>
<p>La figure ci-dessous donne un aper&#231;u du prototype &#171; office assistant &#187; d&#233;velopp&#233; par le SRI.  
</p>
<p>Figure 2 : communaut&#233; d&#8217;agents formant le &#171; office assistant &#187; 
</p>
<p>Ce prototype int&#232;gre un ensemble d&#8217;agents logiciels bureautiques, en interaction constante 
avec les utilisateurs (reconnaissance vocale, reconnaissance de locuteur, prise en compte des 
pr&#233;f&#233;rences-utilisateurs, prise en charge des p&#233;riph&#233;riques : fax, e-mail &#8230;). L&#8217;ensemble de 
ces agents forme une &#171; communaut&#233; &#187;, dont les interactions sont r&#233;gies par le facilitateur. A 
tout moment, de nouveaux agents, prenant en charge d&#8217;autres p&#233;riph&#233;riques, peuvent &#234;tre 
ajout&#233;s. 
</p>
<p>2 OAA et autres plates-formes multiagents 
</p>
<p>Dans cette partie, nous pr&#233;sentons synth&#233;tiquement les sp&#233;cificit&#233;s de quelques plates-formes 
multiagents reconnues. 
</p>
<p>94 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p>2.1 Quelques plates-formes multiagents 
</p>
<p>2.1.1 Principes communs 
</p>
<p>D&#8217;apr&#232;s les concepteurs d&#8217;OAA, la plupart des plates-formes multiagents visent &#224; assurer un 
fonctionnement modulaire, autonome et distribu&#233; de leurs agents. Ceci passe par la mise en 
&#339;uvre d&#8217;au moins quatre composants : 
</p>
<p>&#8226; un protocole de communication assurant l&#8217;acheminement asynchrone des messages ; 
&#8226; un protocole d&#8217;interaction d&#233;finissant diff&#233;rentes modalit&#233;s de communication ainsi 
</p>
<p>que leurs implications &#171; sociales &#187; (ex : une requ&#234;te appelle une r&#233;ponse) ; 
</p>
<p>&#8226; un langage de contenu (une s&#233;mantique) permettant l&#8217;expression et la compr&#233;hension 
d&#8217;&#233;nonc&#233;s ; 
</p>
<p>&#8226; une ontologie, ou ensemble partag&#233; d&#8217;associations entre concepts et interpr&#233;tation, 
ainsi qu&#8217;un vocabulaire commun. 
</p>
<p>2.1.2 Quelques plates-formes agents 
</p>
<p>Historiquement, l&#8217;une des plates-formes les plus reconnues et les plus diffus&#233;es semble &#234;tre 
KQML (Knowledge Query and Manipulation Language)3. KQML, qui g&#232;re les aspects li&#233;s au 
protocole d&#8217;interaction, est souvent associ&#233;e &#224; KIF (Knowledge Interchange Format)4, pour la 
gestion du contenu et la mise en place d&#8217;ontologies g&#233;n&#233;riques aussi bien que sp&#233;cialis&#233;es. 
KQML inaugura l&#8217;utilisation de &#171; performatifs symboliques &#187; afin de g&#233;rer la notion de but 
dans les interactions. Cette plate-forme, plut&#244;t orient&#233;e vers le traitement automatis&#233; des 
interactions vocales, appara&#238;t limit&#233;e par l&#8217;utilisation d&#8217;un ensemble fini de performatifs 
atomiques, limitant le pouvoir expressif du formalisme. 
</p>
<p>BDI (Belief, Desire and Intention), une autre approche reconnue, fait des hypoth&#232;ses plus 
fortes quant aux connaissances et aux processus mis en &#339;uvre par les diff&#233;rents agents. Cette 
approche repose sur la structuration des activit&#233;s de ses agents autour des concepts de 
croyances, de d&#233;sir et d&#8217;intentionnalit&#233; (Rao &amp; Georgeff, 1995). Bien que BDI ait contribu&#233; &#224; 
int&#233;grer un fort niveau d&#8217;abstraction dans les plates-formes multiagents, les applications sont 
apparues limit&#233;es par les pr&#233;suppos&#233;s structuraux li&#233;s &#224; chaque agent, mais &#233;galement par 
dans le cadre de la p&#233;rennisation d&#8217;applications (legacy code). 
</p>
<p>2.2 La philosphie OAA 
</p>
<p>Les concepteurs de la plate-forme revendiquent une parent&#233; forte avec les approches 
mentionn&#233;es plus haut. Toutefois, ils mettent en avant la p&#233;rennisation d&#8217;applications, 
                                                 
3  Voir (Labrou &amp; Finin, 1997) et (Finin et al., 1997). 
</p>
<p>4  Voir (Geneserth &amp; Fikes, 1992). 
</p>
<p>95 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>l&#8217;int&#233;gration de composants h&#233;t&#233;rog&#232;nes, un fonctionnement dynamique et extensible proche 
des approches dites &#171; tableau noir &#187; (blackboard), ainsi que l&#8217;efficacit&#233; des agents dits 
mobiles et les interactions de haut niveau des agents communicationnels. Par ailleurs, les 
concepteurs inscrivent d&#8217;embl&#233;e leur plate-forme dans le cadre des interactions multimodales 
intelligentes avec les utilisateurs, ainsi que dans celui des syst&#232;mes robustes &#224; vocation 
industrielle. 
</p>
<p>2.2.1 Des communications de haut niveau : ICL 
</p>
<p>Le protocole de communication inter-agents, Interagent Communication Language, est la 
lingua franca de la communaut&#233; d&#8217;agents g&#233;r&#233;e par un facilitateur. Elle repose sur le 
formalisme Prolog (programmation d&#233;clarative par expression de buts &#224; atteindre et de 
conditions pour r&#233;aliser ces buts). Elle permet une abstraction par rapport &#224; l&#8217;ensemble des 
d&#233;tails propres &#224; chaque plate-forme.  
</p>
<p>ICL int&#232;gre une couche de protocole de communication similaire &#224; celle fournie par KQML, 
ainsi qu&#8217;une couche de contenu, semblable &#224; celle de KIF. La couche de communication 
d&#8217;ICL est d&#233;finie par les types d&#8217;&#233;v&#233;nements, ainsi que les listes de param&#232;tres associ&#233;s &#224; 
certains de ces &#233;v&#233;nements. La couche d&#8217;&#233;v&#233;nements, elle,  regroupe les buts sp&#233;cifiques, les 
triggers (d&#233;clencheurs d&#8217;&#233;v&#233;nements) et les donn&#233;es pouvant &#234;tre accessibles par les 
diff&#233;rents &#233;v&#233;nements. 
</p>
<p>Les concepteurs d&#8217;OAA recommandent, dans la mesure du possible, d&#8217;avoir recours &#224; ICL, 
bien qu&#8217;il soit possible de g&#233;rer des &#233;v&#233;nements, des donn&#233;es etc&#8230; de fa&#231;on classique pour 
chaque composant (d&#233;pendante du langage de programmation). Les concepteurs mettent en 
avant les avantages &#224; passer par ICL : les diff&#233;rents buts et sous-buts sont rendus accessibles 
au facilitateur, qui peut ainsi r&#233;partir la charge sur les diff&#233;rents agents. Un meilleur contr&#244;le 
des requ&#234;tes peut ainsi &#234;tre assur&#233; par le facilitateur. 
</p>
<p>2.2.2 Notion de &#171; d&#233;l&#233;gation &#187; 
</p>
<p>Cette notion est centrale dans l&#8217;approche OAA : de fa&#231;on g&#233;n&#233;rale, les requ&#234;tes, quel que soit 
leur type, ne sont pas adress&#233;es directement par le demandeur au fournisseur de services : 
plusieurs &#233;tapes interm&#233;diaires de n&#233;gociation sont pr&#233;vues, assur&#233;es par le facilitateur, afin 
d&#8217;acheminer chaque requ&#234;te &#224; l&#8217;agent le mieux &#224; m&#234;me de la traiter. De m&#234;me, de fa&#231;on 
g&#233;n&#233;rale, les r&#233;ponses ne sont pas adress&#233;es directement &#224; l&#8217;auteur de la requ&#234;te, mais 
amen&#233;es &#224; la connaissance du facilitateur qui se charge de les acheminer au bon destinataire. 
Ce fonctionnement indirect est qualifi&#233; de &#171; d&#233;l&#233;gation &#187; par les concepteurs de la plate-
forme. Le principe de d&#233;l&#233;gation implique que les agents, et par extension le d&#233;veloppeur 
humain, n&#8217;ont pas &#224; conna&#238;tre pr&#233;cis&#233;ment quel agent offre quel service, sur quelle machine. 
Le facilitateur prend en charge les interactions entre agents et la satisfaction des requ&#234;tes 
exprim&#233;es. 
</p>
<p>La d&#233;l&#233;gation repose sur une sp&#233;cification formelle, abstraite, tant des services pouvant &#234;tre 
assur&#233;s par chaque membre de la communaut&#233;, que sur celle des requ&#234;tes. Les &#233;changes sont 
ainsi r&#233;gul&#233;s par le facilitateur par confrontation (unification) entre des requ&#234;tes et des 
services enregistr&#233;s aupr&#232;s de celui-ci. 
</p>
<p>96 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p>2.3 D&#233;claration d&#8217;un agent 
</p>
<p>2.3.1 Principaux types d&#8217;agents 
</p>
<p>OAA distingue les types d&#8217;agents suivants : 
</p>
<p>&#8226; Facilitator, centralise les requ&#234;tes et coordonne l&#8217;ex&#233;cution des agents ; 
&#8226; Interface, d&#233;di&#233;es  &#224; la gestion des entr&#233;es multimodales (&#233;criture manuscrite, voix, 
</p>
<p>vid&#233;o etc&#8230;) et &#224; l&#8217;affichage ; 
</p>
<p>&#8226; Application ; 
&#8226; M&#233;ta-agents, qui int&#232;grent des connaissances afin de guider les autres agents (ex : 
</p>
<p>algorithmes d&#8217;apprentissage, r&#233;seaux de neurones, syst&#232;mes-experts etc&#8230;) ; 
</p>
<p>&#8226; Langage naturel, &#224; l&#8217;interface entre les requ&#234;tes en langage naturel et les requ&#234;tes ICL. 
La figure ci-dessous donne une repr&#233;sentation sch&#233;matique d&#8217;une communaut&#233; d&#8217;agents 
id&#233;ale. 
</p>
<p> 
</p>
<p>Figure 3 : communaut&#233; d&#8217;agents OAA id&#233;ale 
</p>
<p>Agent Facilitator 
Registr
</p>
<p>Interagent Communication Language 
</p>
<p>M&#233;ta 
</p>
<p>Agent 
</p>
<p>Agent  
</p>
<p>Application
</p>
<p>Agent  
</p>
<p>Interface  
</p>
<p>Agent  
</p>
<p>LN&#217;ICL 
API
</p>
<p>Application
Agents Modalit&#233; 
</p>
<p>2.3.2 Principales &#233;tapes 
</p>
<p>La cr&#233;ation d&#8217;un agent OAA passe par les &#233;tapes suivantes, dont les d&#233;tails sont fournis plus 
bas lorsque n&#233;cessaire : 
</p>
<p>97 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>1. d&#233;terminer quels services, ou solvables doivent &#234;tre fournis par l&#8217;agent. Ceux-ci seront 
d&#233;clar&#233;s &#224; la connexion avec le facilitateur et l&#8217;impl&#233;mentation de l&#8217;agent sera 
structur&#233;e autour des solvables ; 
</p>
<p>2. inclure une copie de la biblioth&#232;que Agent, en suivant les conventions propres &#224; 
chaque langage. La librairie Agent est une API fournissant l&#8217;acc&#232;s aux fonctionnalit&#233;s 
de la plate-forme OAA, en vue du d&#233;veloppement de syst&#232;mes multiagents ; 
</p>
<p>3. de fa&#231;on optionnelle, surcharger (red&#233;finir) les comportements par d&#233;faut &#224; l&#8217;aide 
d&#8217;appels sp&#233;cifiques ; 
</p>
<p>4. la d&#233;finition de triggers (voir plus bas) de type data, task ou procedure est effectu&#233;e 
gr&#226;ce &#224; oaa_AddTrigger ; 
</p>
<p>5. une proc&#233;dure de callback doit &#234;tre d&#233;finie par chacun de ses solvables procedure. Le 
code, d&#233;fini pour chacun de ces callback, est susceptible d&#8217;installer des triggers 
locaux ou distants, de lire ou d&#8217;&#233;crire &#224; partir du facilitateur, d&#8217;envoyer des 
&#233;v&#233;nements ou des requ&#234;tes au facilitateur ou &#224; un agent particulier, ou encore de 
s&#8217;interfacer avec des routines associ&#233;es &#224; l&#8217;agent ; 
</p>
<p>6. une communication avec le facilitateur doit &#234;tre ouverte, par le biais de 
com_Connect(parent, [], address) ; 
</p>
<p>7. l&#8217;agent doit s&#8217;enregistrer aupr&#232;s d&#8217;un facilitateur, via oaa_Register(parent, 
AgentName , Solvable, Params) ; 
</p>
<p>8. enfin, l&#8217;agent doit initialiser une boucle d&#8217;&#233;v&#233;nement, via oaa_MainLoop.  
</p>
<p>2.3.3 D&#233;claration des services, ou &#171; solvables &#187; 
</p>
<p>Chaque agent membre d&#8217;une communaut&#233; OAA d&#233;finit et rend publiques un ensemble de 
services qu&#8217;il est capable de rendre, exprim&#233;es en ICL : les solvables. Ces services mettent en 
place une interface de haut niveau entre l&#8217;agent et le facilitateur. Ce dernier peut ainsi 
d&#233;l&#233;guer les requ&#234;tes de service &#224; l&#8217;agent.  
</p>
<p>Notons que les solvables sont typ&#233;s : 
</p>
<p>&#8226; Proc&#233;dures (procedure) ; 
&#8226; Donn&#233;es (data) ; 
&#8226; Triggers. 
</p>
<p>Les solvables procedure et data d&#233;clarent les services pouvant &#234;tre appel&#233;s directement par 
d&#8217;autres agents (par l&#8217;appel de la proc&#233;dure de la librairie Agent : oaa_Solve). 
Fondamentalement, un solvable procedure accomplit une action, alors qu&#8217;un solvable data 
enregistre un ensemble de faits. Ainsi, par exemple, un agent de courrier &#233;lectronique 
d&#233;finirait des solvables proc&#233;dure afin d&#8217;envoyer un message au destinataire. De son c&#244;t&#233; un 
agent encapsulant une base de donn&#233;es d&#233;finirait un solvable donn&#233;es correspondant &#224; chaque 
</p>
<p>98 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p>relation pr&#233;sente dans la base. Les solvables data sont le plus souvent utilis&#233;es pour fournir 
des enregistrement de donn&#233;es partag&#233;s, pouvant faire l&#8217;objet d&#8217;une requ&#234;te mais pouvant 
&#233;galement &#234;tre mis &#224; jour par les agents autoris&#233;s &#224; le faire. 
</p>
<p>Les solvables triggers ne sont pas directement accessibles par les autres agents, qui ne 
peuvent y avoir acc&#232;s qu&#8217;indirectement, en assignant des triggers de t&#226;ches aux agents 
concern&#233;s. Un solvable trigger n&#8217;existe que pour d&#233;clarer des conditions ou &#233;v&#233;nements 
sp&#233;cifiques &#224; une t&#226;che donn&#233;e. Pour reprendre l&#8217;exemple de l&#8217;agent de courrier &#233;lectronique, 
celui-ci peut d&#233;clarer un solvable trigger surveillant l&#8217;arriv&#233;e de nouveaux messages, en 
fonction du profil des utilisateurs. Cette d&#233;claration signifie aux autres agents (y compris le 
facilitateur et l&#8217;agent source) que des triggers peuvent &#234;tre assign&#233;s &#224; cet agent. Le type task 
est le seul trigger pour lequel une d&#233;claration de solvable trigger est n&#233;cessaire, via l&#8217;appel 
aux proc&#233;dures de la librairie Agent telles que :  oaa_Declare et oaa_Undeclare.  
</p>
<p>2.3.4 Ev&#233;nements 
</p>
<p>L&#8217;ensemble des communications entre agents ont lieu sous la forme d&#8217;&#233;v&#233;nements. De plus, la 
plupart des traitements et des structures internes d&#8217;un agent sont normalement centr&#233;s autour 
de ces &#233;v&#233;nements. On peut penser ces &#233;v&#233;nements en termes de messages, qui ne doivent pas 
&#234;tre directement construits par le d&#233;veloppeur : la construction et la transmission de ces 
&#233;v&#233;nements est le r&#233;sultat des appels aux fonction OAA telles que oaa_Solve et 
oaa_AddTrigger. 
</p>
<p>Ainsi, un appel &#224; 
</p>
<p>Oaa_Solve(Goal, Params) 
</p>
<p>au sein d&#8217;un agent A a pour r&#233;sultat un &#233;v&#233;nement de la forme 
</p>
<p>ev_solve(GoalID, Goal, Params) 
</p>
<p>de A vers le facilitateur, ainsi qu&#8217;un message de retour de la forme 
</p>
<p>ev_solved(GoalID, Requestees, Solvers, Goal, Params, 
Solutions). 
</p>
<p>2.3.5 Appels de services et traitement des requ&#234;tes 
</p>
<p>Un agent fait appel &#224; des services par l&#8217;envoi de buts au facilitateur. Chaque but contient des 
appels &#224; un ou plusieurs solvable. L&#8217;appel &#224; un solvable n&#8217;implique pas la sp&#233;cification d&#8217;un 
agent particulier pour le traitement de la requ&#234;te. Bien qu&#8217;il soit possible de d&#233;signer un agent 
particulier pour le traitement d&#8217;une requ&#234;te, il est g&#233;n&#233;ralement pr&#233;f&#233;rable de faire appel au 
facilitateur. Les fonctions de la biblioth&#232;qe Agent d&#8217;OAA mettent un place un point d&#8217;entr&#233;e 
unique pour l&#8217;appel aux services d&#8217;autres agents : la proc&#233;dure oaa_Solve. Cette proc&#233;dure 
peut aussi bien servir &#224; extraire des donn&#233;es qu&#8217;&#224; d&#233;clencher des actions. Par ailleurs, elle 
fournit un certain nombre de param&#232;tres diff&#233;rents permettant de contr&#244;ler le comportement 
du facilitateur et des autres agents. En particulier, le param&#232;tre address permet la 
</p>
<p>99 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>d&#233;l&#233;gation explicite envers un ou plusieurs agents. Ce param&#232;tre permet &#233;galement l&#8217;appel 
aux solvables de l&#8217;agent &#233;metteur lui-m&#234;me. 
</p>
<p>Les donn&#233;es qui sont retourn&#233;es en r&#233;ponse &#224; une requ&#234;te, ou solvable data, ainsi que celles 
utilis&#233;es pour les op&#233;rations de mise &#224; jour sont directement exprimables en ICL. Ces donn&#233;es 
peuvent &#234;tre compl&#232;tement ou partiellement instanti&#233;es. 
</p>
<p>2.4 Exemples 
</p>
<p>Ci-dessous, deux exemples en Java et en C, adapt&#233;s du manuel de r&#233;f&#233;rence de la plate-forme 
OAA. Ces exemples illustrent les &#233;tapes donn&#233;es plus haut de cr&#233;ation d&#8217;un agent. 
</p>
<p>2.4.1 Un agent fax en Java 
</p>
<p>import oaa.agents.bean.agentBean.*;  
AgentBean oaa = new AgentBean();     
</p>
<p>1. Importation des librairies 
</p>
<p>oaa.setOaaName(&quot;fax&quot;); 
oaa.setOaaSolvables(&quot;[fax(Destination,Document)]&quot;); 
</p>
<p>2. D&#233;claration des services 
</p>
<p> 
String oaa_doEvent(DoEvent e) { 
   if (e.func.compareTo(&quot;fax&quot;) == 0) { 
       String person = oaa.lib.nthElt(e.args, 1);  // Person 
       String doc = oaa.lib.nthElt(e.args, 2); // Document 
       String res = oaa.lib.solve(&quot;fax_num(&quot; + person + &quot;,N)&quot;, 
&quot;[]&quot;); 
       if (res.compareTo(&quot;[]&quot;) != 0) { ... 
      } 
} 
</p>
<p>3. D&#233;finition des services 
</p>
<p>oaa.connect(); 
</p>
<p>4. Initialisation 
</p>
<p>100 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p> 
</p>
<p>2.4.2 Un agent Text-To-Speech en C 
</p>
<p>#include &lt;libcom_tcp.h&gt; 
#include &lt;liboaa.h&gt; 
</p>
<p>1. Importation des librairies 
</p>
<p>ICLTerm capabilities = icl_TermFromStr(&#8220;[play(tts, Msg)]&#8221;); 
</p>
<p>2. D&#233;claration des services 
</p>
<p>ICLTerm oaa_AppDoEvent(ICLTerm Event, ICLTerm Params) { 
      if (strcmp(icl_Str(Event), &#8220;play&#8221;) == 0) { 
          return playTTS(icl_ArgumentAsStr(Event, 2)); 
      } 
      else return NULL; 
} 
</p>
<p>3. D&#233;finition des services 
</p>
<p>main() { 
      com_Connect(&#8220;parent&#8221;, connectionInfo); 
      oaa_Register(&#8220;parent&#8221;, &#8220;tts&#8221;, capabilities); 
      oaa_MainLoop(True); 
} 
</p>
<p>4. Initialisation 
</p>
<p>3 D&#233;velopper une application de TALN avec OAA : exemples 
d&#233;taill&#233;s 
</p>
<p>Dans cette partie, nous examinons la mise en &#339;uvre d&#8217;applications d&#233;di&#233;es au TALN. La 
premi&#232;re est une plate-forme de commande vocale d&#8217;interfaces (ex : simulateur tactique). Les 
applications pr&#233;sent&#233;es sont des syst&#232;mes industriels en vraie grandeur, dont nous d&#233;taillerons 
le cadre, les contraintes et les composantes retenus au cours de la pr&#233;sentation du tutoriel. Les 
applications pr&#233;sent&#233;es int&#232;grent des composants de reconnaissance vocale, de cartographie, 
des grammaires destin&#233;es &#224; analyser le langage naturel (grammaires g&#233;n&#233;riques, sp&#233;cifiques, 
r&#232;gles d&#8217;interpr&#233;tation contextuelle, r&#233;solution des anaphores etc&#8230;). 
</p>
<p>101 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>3.1 Thomspeaker, commande vocale d&#8217;interfaces 
</p>
<p>3.1.1 Architecture 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p>Module  
</p>
<p>G&#233;n&#233;ration LN 
Gemini Module 
</p>
<p>d&#8217;interaction 
</p>
<p>Nuance Communications 
</p>
<p>application 
</p>
<p>BDD appli 
</p>
<p> 
</p>
<p>R&#233;f&#233;rence 
</p>
<p> objets et actions 
</p>
<p>Enonc&#233; 
</p>
<p>Appli.
</p>
<p>Elan 
</p>
<p>Signal 
</p>
<p>Figure 4 : architecture d&#8217;un syst&#232;me multiagents industriel, Thomspeaker 
</p>
<p> 
</p>
<p>3.1.2 Fonctionnalit&#233;s 
</p>
<p>&#8226; Grammaire g&#233;n&#233;rique de l&#8217;anglais pour la commande 
&#8226; Grammaire g&#233;n&#233;rique du fran&#231;ais pour la commande 
&#8226; Grammaire de l&#8217;anglais pour les requ&#234;tes 
&#8226; Module de n&#233;gociation avec sous-dialogues 
&#8226; G&#233;n&#233;ration de r&#233;ponses 
&#8226; Synth&#232;se de parole 
&#8226; Interpr&#233;tation contextuelle (th&#233;orie des RMs) 
</p>
<p>102 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p>&#8226; Rattrapage des erreurs de reconnaissance au niveau interpr&#233;tation 
&#8226; Modification/restriction en dynamique de la phras&#233;ologie 
&#8226; Multi-utilisateurs 
&#8226; Outils de saisie des ressources 
</p>
<p>3.2 MARA, assistance &#224; la maintenance 
</p>
<p>3.2.1 Architecture du syst&#232;me 
</p>
<p> 
</p>
<p> 
</p>
<p>Bus vid&#233;o
Protocole UDP
</p>
<p>Recalage 
</p>
<p>magn&#233;tique 
</p>
<p>Affichage
</p>
<p>RA
</p>
<p>Acquisition 
</p>
<p>Vid&#233;o 
</p>
<p>Client  
</p>
<p>Interface 
</p>
<p>Superviseur 
</p>
<p>de sc&#232;ne 
</p>
<p>Bus logiciel 
</p>
<p>CORBA
</p>
<p>Open Agent Architecture (Superviseur) 
</p>
<p>Parole 
</p>
<p>Communication
</p>
<p>G&#233;n&#233;ration
</p>
<p>Interaction
</p>
<p>Dialogu
</p>
<p>Browser 
</p>
<p>En
vi
</p>
<p>ro
nn
</p>
<p>em
en
</p>
<p>t d
e 
</p>
<p>R
A
</p>
<p> 
In
</p>
<p>te
rf
</p>
<p>ac
e 
</p>
<p>Vo
ca
</p>
<p>le
 
</p>
<p>O
bj
</p>
<p>et
s 
</p>
<p>D
is
</p>
<p>tr
ib
</p>
<p>u&#233;
s 
</p>
<p>M
ul
</p>
<p>ti-
A
</p>
<p>ge
nt
</p>
<p>s 
</p>
<p>Start-It 
</p>
<p>Configurateur 
</p>
<p>TextToSpeech
</p>
<p>Analyseur
</p>
<p>Figure 5 : architecture fonctionnelle d&#8217;un syst&#232;me d&#8217;aide &#224; la maintenance 
</p>
<p> 
</p>
<p> 
</p>
<p> 
</p>
<p>103 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p> 
</p>
<p>RECONNAISSANCE Signal Enonc&#233;Phras&#233;ologie Mod&#232;les 
i
</p>
<p>Phon&#233;tiques Langage 
</p>
<p>COMPREHENSION Trame Enonc&#233; Historique 
&#233; &#233;
</p>
<p>Grammaire 
d&#8217; l
</p>
<p>Analyse Statique Analyse en contexte
</p>
<p>Message Trame DIALOGUE
Mod&#232;le du 
di l Gestion interactions
</p>
<p>Trame 
compl&#232;te Action PLUG-IN APPLICATION 
</p>
<p>API application 
</p>
<p>Mise au format  
</p>
<p>Figure 6 : sources de connaissances et traitements du syst&#232;me MARA 
</p>
<p>Figure 7 : architecture d&#8217;acquisition de ressources pour les syst&#232;mes industriels multiagents 
</p>
<p>Information conceptuelle + 
Lexique OAA facilitatorInformation conceptuelle + Lexique 
</p>
<p>Enonc&#233;s Interface 
d&#8217;acquisition 
</p>
<p>(LCMDI GUI) 
G&#233;n&#233;rateur de 
</p>
<p>Grammaires 
</p>
<p>Enonc&#233;s 
DCG Analyseur
</p>
<p> 
</p>
<p>Lexique 
</p>
<p>G&#233;n&#233;riqueDCG 
</p>
<p>Gramm
</p>
<p>Concepts 
+ 
</p>
<p>Lexique 
</p>
<p>Domaine 
Grammaire 
</p>
<p>Reconnaissance
</p>
<p>Dialogue Analyseur Generation 
ASR 
</p>
<p>Cette architecture est celle mise en  &#339;uvre pour un syst&#232;me destin&#233; au d&#233;veloppement de 
ressources linguistiques destin&#233;es &#224; &#234;tre utilis&#233;es par des syst&#232;mes multiagents utilisant la 
reconnaissance vocale, tels que pr&#233;sent&#233;s plus haut. Cette architecture est elle-m&#234;me 
</p>
<p>104 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p>multiagents et repose sur OAA. Les ressources sont g&#233;n&#233;r&#233;es &#224; partir de ressources 
g&#233;n&#233;riques, telles qu&#8217;une grammaire g&#233;n&#233;rique d&#233;crivant les principaux types de phrases, par 
exemple. La sortie du syst&#232;me est un ensemble de r&#232;gles d&#8217;interpr&#233;tation sp&#233;cifiques &#224; un 
domaine, produites &#224; partir des ressources g&#233;n&#233;riques et de ressources telles qu&#8217;un lexique-
m&#233;tier (ex : lexique de la maintenance), ou des mod&#232;les acoustiques en milieu bruit&#233;. Ces 
r&#232;gles d&#8217;interpr&#233;tation propres &#224; un domaine de sp&#233;cialit&#233; permettent de guider les modules de 
reconnaissance de la parole et d&#8217;interpr&#233;tation, en &#233;liminant les candidats improbables, &#233;tant 
donn&#233;e l&#8217;application. 
</p>
<p>3.3 D&#233;monstrateur MARA 
</p>
<p> 
</p>
<p>Figure 8 : interface de r&#233;alit&#233; augment&#233;e du syst&#232;me MARA 
</p>
<p>La figure ci-dessus donne la vision augment&#233;e fournie au technicien utilisant le syst&#232;me 
MARA de maintenance &#224; distance, int&#233;grant des fonctionnalit&#233;s de reconnaissance  vocale, de 
r&#233;alit&#233; augment&#233;e (superposition d&#8217;informations graphiques), de gestion des documents (i.e. la 
documentation technique) : textes, vid&#233;os, graphiques etc&#8230; Le syst&#232;me r&#233;pond ici &#224; une 
requ&#234;te vocale de l&#8217;utilisateur : &#171; afficher le bloc d&#8217;alimentation &#187;, en mettant en &#233;vidence le 
bloc d&#8217;alimentation. 
</p>
<p>105 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>L&#8217;ensemble des requ&#234;tes vocales sont trait&#233;es par un agent de reconnaissance vocale reposant 
sur Nuance (SRI), ainsi que sur une grammaire du domaine, exprim&#233;e de fa&#231;on traditionnelle 
sous la forme de clauses Prolog (DCG). 
</p>
<p> 
</p>
<p>Figure 9 : interface homme-machine pour le syst&#232;me MARA, extraction de la carte graphique 
</p>
<p>La figure ci-dessus pr&#233;sente une autre phase de l&#8217;interaction : l&#8217;utilisateur demande &#171; quelle 
est la proc&#233;dure d&#8217;extraction de la carte graphique &#187;, qui suscite l&#8217;affichage d&#8217;un extrait de 
documentation technique multim&#233;dia illustrant la proc&#233;dure demand&#233;e. 
</p>
<p>106 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Tutoriel : Open Agent Architecture 
</p>
<p> 
</p>
<p>Figure 10 : interface du syst&#232;me MARA, r&#233;solution d&#8217;anaphores 
</p>
<p>La figure ci-dessus pr&#233;sente le sch&#233;ma de c&#226;blage demand&#233; par l&#8217;utilisateur via la question 
&#171; quel est son sch&#233;ma de c&#226;blage &#187;. Le syst&#232;me fait appel &#224; un agent de r&#233;solution des 
anaphores pour traiter la requ&#234;te et affiche le sch&#233;ma de la carte graphique. 
</p>
<p>107 </p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Antonio BALVET, Olivier GRISVARD et Pascal BISSON 
</p>
<p>108 
</p>
<p>R&#233;f&#233;rences 
</p>
<p>Cunningham H. et alii., 1997. Software infrastructure for Natural Language Processing. In 
Proceedings of the Fifth Conference on Applied Natural Language Processing (ANLP-97), 
March 1997. 
</p>
<p>Cunningham H. et alii., 2001. Developing language components with GATE, University of 
Sheffield. 
</p>
<p>Finin T., Labrou Y, Mayfield J., 1997, KQML as an agent communication language, in Jeff  
Bradshaw, editor, Software Agents, MIT Press, Cambridge. 
</p>
<p>FIPA, 1997, Foundation for intelligent physical agents, (FIPA) 1997 specification 
(http://drogo.cselt.stet.it/fipa/spec/fipa97.html). 
</p>
<p>Genesereth, M. R., Fikes R.E., 1992, Knowledge interchange format version 3.0, Reference 
Manual, Technical Report Logic-92-1, Stanford University 
(http://logic.stanford.edu/kif/kif.html). 
</p>
<p>Labrou Y., Finin T., 1997, A proposal for a new KQML specification, Technical Report CS-
97-03, Computer Science and Electrical Engineering Department, University of Maryland 
Baltimore County, (http://www.cs.umbc.edu/kqml). 
</p>
<p>Martin D., Cheyer A.J., Moran D.B., (1999), The Open Agent Architecture: a framework for 
building distributed software systems, Applied Artificial Intelligence, vol. 13, p 91-128. 
</p>
<p>Martin D., Cheyer A.J., Moran D.B.. The Open Agent Architecture: a framework for building 
distributed software systems, Artificial Intelligence Center, SRI International. 
</p>
<p>Maynard D. et alii., 2000. A survey of uses of GATE, Research Memo CS-00-06, Institute for 
Language Speech and Hearing (ILASH) and Department of Computer Science, University of 
Sheffield. 
</p>
<p>Open Agent Architecture (OAA) developer&#8217;s guide, V2.0, SRI International. 
</p>
<p> 
</p>
<p> 
</p>
<p>   
</p>
<p> 
</p>
<p>  </p>

</div></div>
</body></html>