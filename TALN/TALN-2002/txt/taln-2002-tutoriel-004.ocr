TALN 2002, Nancy, 24-27 juin 2002

Tutoriel : Open Agent Architecture
Développement d’applications de TALN
distribuées, multiagents et multiplates-formes

Antonio BALVET (1), Olivier GRISVARD (2) et Pascal BISSON (2)

(l) Ul\/[R MoDyCo, Université Paris X Nanterre
200, av. de le République 92001 Nanterre
antonio.balvet@u-parisl0.fr
(2) Thales RT, DAS-HIT
Domaine de Corbeville, 91404 Orsay
olivier. grisvard(aDthales group . com
pascal.bisson@thalesgroup.com

Résumé - Abstract

Nous présenterons tout d’abord la philosophie << Agents >> en général, af1n d’en montrer les
avantages pour le domaine du TALN, qui se caractérise par une hétérogénéité avérée des
systemes existants (multiplicité des langages de programmation), ainsi qu’une forte demande
en ressources (mémoire notamment). Nous ferons ensuite une présentation des principales
plate-formes orientées agents, puis nous examinerons de plus pres la plate-forme développée
au Standford Research Institute (SR1) : OAA (licence libre). Nous cloturerons le tutoriel sur
des exemples commentés d’applications industrielles utilisant OAA, permettant de donner
toutes les clés nécessaires au développement d’applications distribuées (intra/internet),
multiagents et multiplates-formes (plusieurs langages de programmation/systemes
d’exploitation).

We will first present the “Agent” philosophy in general, in order to put forward its usefulness
for resources-intensive (memory) NLP systems, in a heterogeneous context. We will also
present an overview of the main agent-oriented platforms, with a focus on the OAA platform,
developed at the Stanford Research Institute. Finally, we will present a detailed example of a
real-scale multiagent NLP system based on OAA, with an emphasis on development details
which will provide the audience with all the required information to develop distributed
(intra/internet), multiagent and multiplaforms systems (different programming
languages/operating systems).

89

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

Introduction

La tendance actuelle, dans le domaine du Traitement Automatique du Langage Naturel, est a
la standardisation, la modularité et la réutilisabilité, apres une période de foisonnement dans
les approches, les langages de programmation utilisés ainsi que les plates-formes visées. Cette
tendance semble suivre le modele du domaine du développement logiciel professionnel, elle
se traduit également depuis une dizaine d’années par des campagnes d’éValuation
intemationales portant sur des domaines traditionnels du TALN : étiquetage, levée
d’ambigu'1'tés, calcul sémantique etc... (les conférences MUC, TREC, mais également
AMARYLLIS, Senseval ou Parseval), ainsi que la constitution de corpus de référence.

La nécessité de disposer d’enVironnements de développement, de boites a outils et autres
plate-formes normalisées pour le TALN se fait d’autant plus sentir qu’un certain nombre de
techniques sont devenues, de fait, des standard dans le domaine (ex: l’analyse locale, les
cascades de transducteurs) et que, par ailleurs, un certain nombre de ressources lexicales sont
disponibles pour les langues autres que l’anglais (ex : EuroWordnet, Memodata). Toutefois,
force est de constater l’hétérogénéité résiduelle du domaine, au niveau logiciel, notamment en
ce qui conceme les langages de programmation utilisés (de Lisp a Perl en passant par C++,
Java et Prolog), le mode de développement (programmation structurée/orientée-
obj et/orientée-composants/multiagents) que le cadre de déploiement (ex : sur poste local / sur
un réseau Via une architecture client-server, sous Windows/Linux/U nix).

Certaines initiatives, telles la plate-forme GATE (General Architecture for Text Engineering),
développée a l’uniVersité de Sheffield, ont tenté de répondre a cette demande (Voir
Cunningham H. et alii., 1997) en proposant une architecture modulaire Visant a libérer les
linguistes-informaticiens de taches de développement inutiles, répétées pour chaque
implementation, telles que la gestion des documents, la Visualisation des données, les liaisons
entre modules logiciels existants. Toutefois, malgré la popularité de GATEI pour des taches
liées au traitement de l’écrit (extraction d’information notamment), la plate-forme développée
par l’uniVersité de Sheffield n’offre pas de fonctionnalités telles que: le fonctionnement
distribué (sur un réseau intra/internet) permettant de répartir la charge des traitements sur des
serveurs spécialisés en laissant l’affichage au(x) poste(s) client(s), ou encore le
fonctionnement par agents autonomes communiquant par requétes Via un superviseur
(architecture de type << tableau noir >>). Par ailleurs, GATE ne s’aVenture pas hors du domaine
fixé par ses concepteurs (i.e. l’écrit), alors que l’intégration des différentes modalités du
langage naturel (voix, écrit, ou encore geste) apparait comme l’étape suivante dans les
développements pour le domaine du TALN.

Nous présenterons au cours de ce tutoriel une architecture en libre acces, développée au SR1
pour le développement de systemes a dimension industrielle, hétérogenes, distribués, multi-
agents et multi-plateformes: OAA (Open Agent Architecture). Cette architecture permet
d’enVisager le développement d’applications de TALN comme l’assemblage de briques de
base, favorisant l’émergence de véritables << systemes >> dont l’intégration, le déploiement et

Voir Maynard D. et alii., 2000 : plus de 12 projets de dimension europe'enne et industrielle reposant sur
GATE ont été recense's.

90

T utoriel .' Open Agent Architecture

le fonctionnement reposent sur des bases solides, ainsi que la réutilisation et la capitalisation
de modules logiciels existants2.

Nous assoirons le présent tutoriel sur l’expérience acquise par le laboratoire Thales-RT
France dans le domaine du développement d’applications intégrant la commande vocale, le
traitement du texte et la réalité augmentée reposant sur OAA. Dans un premier temps, nous
présenterons, de facon synthétique, la philosophie << Agents >>, en mettant l’accent sur les
bénéfices que le domaine du TALN peut en tirer. Dans un deuxieme temps, nous présenterons
les spécificités de la plate-forrne OAA par rapport aux principales plates-formes
agents/distribuées disponibles. Dans un troisieme temps, nous aborderons des exemples
commentés de systemes industriels de TALN, développés a Thales-RT France, reposant sur
OAA ainsi que sur des composants aussi divers que Nuance (reconnaissance Vocale) ou le
Dictionnaire Intégral (Memodata).

Le présent tutoriel s’appuie principalement sur les références consultables sur le site du SR1,
consacré a la plate-forme OAA, Version 2.1 et a ses applications : http://www.ai.sri.com/~oaa.
Sont notamment disponibles :

0 Le guide du développeur (OAA 2.1 Developer’s Guide) ;
0 La documentation du systeme (OAA 2.1 Documentation) ;
0 Un tutoriel sur OAA (OAA 2.1 Tutorial) ;

0 La référence du langage ICL (OAA Interagent Communication Language, API
Reference Manual) ;

0 La Foire Aux Questions OAA 2.x (OAA V2.x FAQ) ;

0 Le manuel de référence de la libraire Agent, foumissant l’acces aux fonctionnalités
OAA pour l’intégration (OAA, Agent Library Reference Manual Version 2.1) ;

0 L’API OAA pour les langages C et Java ;
0 Des démonstrations Vidéo d’applications OAA.

Par ailleurs, des exemples d’applications centrées sur l’interaction multimodale avec
l’utilisateur sont présentées, ainsi que des exemples de code source pour l’ensemble des
langages de programmation supportés: C, JaVa,, Prolog et WebL. L’intégralité du code
source OAA est également disponible.

2 OAA a été adopte'e par de nombreux laboratoires a travers le monde, tant prive's que publics.

91

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

1 La philosophic « Agents »

1.1 Apercu de différents paradigmes de développement logiciel

La ﬁgure ci-dessous présente de facon synthétique les principaux modeles de développement
de logiciels.

|:> ‘ E>

Applications Applications Applications

Monolithiques Orientées—Objet Objets distribués

   

1I©

Ajout “a chaud”

Applications

OAA

Figure 1 : principaux modeles de développement de logiciels

Dans cette ﬁgure, nous cherchons a souligner le passage d’app1ications << monolithiques »,
constituant un tout indivisible, dont les différentes fonctionnalités ne pouvaient étre
dissociées, aux applications << orientées-objets », puis << objets distribués >>. Le passage aux
applications orientées-objets ont essentiellement apporté au monde du développement la
modularisation, ainsi que la possibilité de faire hériter des fonctionnalités intéressantes a de
nouveaux composants. Cette étape a surtout permis a la communauté des développeurs de
pouvoir envisager la réutilisabilité des composants logiciels autrement que par le code source.
Le paradigme distribué a, lui, permis le développement d’app1ications non centralisées sur un
poste unique: le fonctionnement en client/serveur. L’adoption de ce modele a également
permis d’enVisager le développement d’architectures << n-tier >> (a n étages), permettant, par

92

T utoriel .' Open Agent Architecture

exemple, de limiter la charge des postes clients a l’affichage (interface-utilisateur), en
déléguant les processus gourmands en ressources a des postes spécialisés (serveurs).

OAA est présenté par ses concepteurs comme l’étape suivante dans les modeles de
développement: les composants logiciels modularisés forment une communauté, dont les
interactions sont réglées par un composant central, le facilitateur. Dans cette optique, les
composants peuvent étre ajoutés ou retirés de la communauté en fonction des besoins, c'est-a-
dire en fonction de la tache, des ressources disponibles etc... Cet aj out ou retrait se font << a
chaud >> : chaque nouvel agent annonce au facilitateur les services qu’il est capable de fournir.

1.2 Les bases des plates-formes multiagents

1.2. 1 Modularité

La modularité semble étre une des caractéristiques principales des architectures agents. Cette
modularité permet d’envisager des << systemes >> logiciels, dans lesquels des briques de base
sont assemblées de facon a fournir un service global. Cette approche du développement
logiciel permet également d’envisager des systemes ou les composants sont interchangeables.

La modularité, en termes logiciels, présuppose d’adopter des modeles ou principes
d’architecture ou les services sont distingués en fonction de leur type. Ainsi, par exemple, le
principe << modele/vue/contr6leur» oblige a distinguer les différents objets logiciels selon
qu’ils offrent des services d’afﬁchage (interface-utilisateur), de controle de l’application
(prise en charge matérielle, suivi du déroulement des programmes) ou de représentation
abstraite (ex : pour un document XML, la DTD permettant d’interpréter le balisage employé).

1. 2. 2 Autonomie

Au-dela des caractéristiques évoquées plus haut, la philosophie agents repose sur la notion
d’autonomie. En d’autres termes, les agents logiciels sont vus comme des extensions des
utilisateurs : ils sont pensés pour accomplir des taches a la place des utilisateurs. Ceci suppose
que lesdits utilisateurs spéciﬁent de facon formelle les taches a accomplir, ainsi que les
modalités de l’exécution de ces taches : synchronisation temporelle, environnement,
conditions d’exécution  En d’autres termes, l’autonomie accordée aux agents logiciels
présuppose une caractérisation explicite formelle des buts poursuivis par les utilisateurs, que
les agents vont tenter de mener a bien en fonction des conditions du monde extérieur
(environnement logiciel). Cette autonomie implique également une représentation logique de
l’agent, de son environnement et des relations qu’il entretient avec cet environnement. C’est
pourquoi les forrnalismes d’inspiration logique et la programmation déclarative, tels que
fournis par le langage Prolog, par exemple, servent souvent de base aux architectures agents.

1.2.3 F onctionnement dynamique

Dans le cas de OAA, l’essentiel du comportement des agents regroupés en communauté
autour d’un facilitateur est géré par une couche de représentation logique des individus
composant la communauté, de leurs buts, des services qu’ils peuvent rendre. Cette couche

93

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

logique repose sur un moteur Prolog, qui permet, par le biais du principe d’unification, de
mener a bien des buts de facon non procédurale, en optimisant1’accomp1issement d’une tache
par rapport aux agents et services disponibles.

Le fonctionnement dynamique perrnet 1’ajout ou le retrait d’agents de la communauté sans
arrét du systeme, ni recompilation. Le facilitateur enregistre simplement un changement dans
la communauté qu’i1 régule.

1.3 Exemple : l’assistant bureautique

La ﬁgure ci-dessous donne un apercu du prototype << office assistant >> développé par le SR1.

 
   

   

, E
H _______ c. 
.. %
Speech . N Fa"
User Hecugnitiﬂn Speaker |[) Eleetrenle Agent
Interfaee Agent ﬂggnt Hall J5!-QED‘ Web
Agents ggem
Natural Language 
Parser Agent   Telephone
* h 55:57:; :5: Agent
Uaieemail ﬂgtify Agent
 r I §
Calendar 
:_ Agent 13,“ 1., Primer
5 Speech -H-HEM
3 Agent
GEWNL Preltlgreernees
Agent

Figure 2 : communauté d’agents formant 1e << office assistant >>

Ce prototype integre un ensemble d’agents logiciels bureautiques, en interaction constante
avec les utilisateurs (reconnaissance Vocale, reconnaissance de locuteur, prise en compte des
préférences-utilisateurs, prise en charge des périphériques: fax, e-mail ...). L’ensemb1e de
ces agents forme une << communauté », dont les interactions sont régies par le facilitateur. A
tout moment, de nouveaux agents, prenant en charge d’autres périphériques, peuvent étre
ajoutés.

2 OAA et autres plates-formes multiagents

Dans cette partie, nous présentons synthétiquement les spécificités de quelques plates-formes
multiagents reconnues.

94

T utoriel .' Open Agent Architecture

2.1 Quelques plates-formes multiagents

2. 1. 1 Principes communs

D’apres les concepteurs d’OAA, la plupart des plates-formes multiagents Visent a assurer un
fonctionnement modulaire, autonome et distribue de leurs agents. Ceci passe par la mise en
oeuvre d’au moins quatre composants :

un protocole de communication assurant l’acheminement asynchrone des messages ;

0 un protocole d’interaction definissant differentes modalites de communication ainsi
que leurs implications << sociales >> (ex : une requéte appelle une reponse) ;

0 un langage de contenu (une semantique) permettant l’expression et la comprehension
d’enonces ;

0 une ontologie, ou ensemble partage d’associations entre concepts et interpretation,
ainsi qu’un Vocabulaire commun.

2.1.2 Quelques plates-formes agents

Historiquement, l’une des plates-formes les plus reconnues et les plus diffusees semble étre
KQML (Knowledge Query and Manipulation Language)3. KQML, qui gere les aspects lies au
protocole d’interaction, est souvent associee a KIF (Knowledge Interchange Format)4, pour la
gestion du contenu et la mise en place d’ontologies generiques aussi bien que specialisees.
KQML inaugura l’utilisation de << performatifs symboliques >> afin de gerer la notion de but
dans les interactions. Cette plate-forme, plut6t orientee Vers le traitement automatise des
interactions Vocales, apparait limitee par l’utilisation d’un ensemble fini de performatifs
atomiques, limitant le pouvoir expressif du formalisme.

BDI (Belief, Desire and Intention), une autre approche reconnue, fait des hypotheses plus
fortes quant aux connaissances et aux processus mis en oeuvre par les differents agents. Cette
approche repose sur la structuration des activites de ses agents autour des concepts de
croyances, de desir et d’intentionnalite (Rao & Georgeff, 1995). Bien que BDI ait contribue a
integrer un fort niveau d’abstraction dans les plates-formes multiagents, les applications sont
apparues limitees par les presupposes structuraux lies a chaque agent, mais egalement par
dans le cadre de la perennisation d’applications (legacy code).

2.2 La philosphie OAA

Les concepteurs de la plate-forme revendiquent une parente forte avec les approches
mentionnees plus haut. Toutefois, ils mettent en avant la perennisation d’applications,

3 Voir (Labrou & Finin, 1997) et (Finin et al., 1997).

4 Voir (Geneserth & Fikes, 1992).

95

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

l’intégration de composants hétérogenes, un fonctionnement dynamique et extensible proche
des approches dites «tableau noir>> (blackboard), ainsi que l’efﬁcacité des agents dits
mobiles et les interactions de haut niveau des agents communicationnels. Par ailleurs, les
concepteurs inscrivent d’emblée leur plate-forrne dans le cadre des interactions multimodales
intelligentes avec les utilisateurs, ainsi que dans celui des systemes robustes a vocation
industrielle.

2.2.1 Des communications de haut niveau .' ICL

Le protocole de communication inter-agents, Interagent Communication Language, est la
lingua ﬂanca de la communauté d’agents gérée par un facilitateur. Elle repose sur le
formalisme Prolog (programmation déclarative par expression de buts a atteindre et de
conditions pour réaliser ces buts). Elle permet une abstraction par rapport a l’ensemble des
détails propres a chaque plate-forme.

ICL integre une couche de protocole de communication similaire a celle fournie par KQML,
ainsi qu’une couche de contenu, semblable a celle de KIF. La couche de communication
d’ICL est déﬁnie par les types d’événements, ainsi que les listes de parametres associés a
certains de ces événements. La couche d’événements, elle, regroupe les buts spéciﬁques, les
triggers (déclencheurs d’événements) et les données pouvant étre accessibles par les
différents événements.

Les concepteurs d’OAA recommandent, dans la mesure du possible, d’avoir recours a ICL,
bien qu’il soit possible de gérer des événements, des données etc... de facon classique pour
chaque composant (dépendante du langage de programmation). Les concepteurs mettent en
avant les avantages a passer par ICL : les différents buts et sous-buts sont rendus accessibles
au facilitateur, qui peut ainsi répartir la charge sur les différents agents. Un meilleur contr6le
des requétes peut ainsi étre assuré par le facilitateur.

2.2.2 Notion de « délégation »

Cette notion est centrale dans l’approche OAA : de facon générale, les requétes, quel que soit
leur type, ne sont pas adressées directement par le demandeur au foumisseur de services :
plusieurs étapes intermédiaires de négociation sont prévues, assurées par le facilitateur, afin
d’acheminer chaque requéte a l’agent le mieux a meme de la traiter. De méme, de facon
générale, les réponses ne sont pas adressées directement a l’auteur de la requéte, mais
amenées a la connaissance du facilitateur qui se charge de les acheminer au bon destinataire.
Ce fonctionnement indirect est qualifié de << délégation>> par les concepteurs de la plate-
forme. Le principe de délégation implique que les agents, et par extension le développeur
humain, n’ont pas a connaitre précisément quel agent offre quel service, sur quelle machine.
Le facilitateur prend en charge les interactions entre agents et la satisfaction des requétes
exprimées.

La délégation repose sur une speciﬁcation formelle, abstraite, tant des services pouvant étre
assurés par chaque membre de la communauté, que sur celle des requétes. Les échanges sont
ainsi régulés par le facilitateur par confrontation (uniﬁcation) entre des requétes et des
services enregistrés aupres de celui-ci.

96

T utoriel .' Open Agent Architecture

2.3 Déclaration d’un agent
2.3.1 Principaux types d’agents
OAA distingue les types d’agents suivants :
0 Facilitator, centralise les requétes et coordonne l’exécution des agents ;

0 Interface, dédiées a la gestion des entrées multimodales (écriture manuscrite, Voix,
video etc...) et a l’affichage ;

0 Application ;

0 Méta-agents, qui integrent des connaissances afin de guider les autres agents (ex:
algorithmes d’apprentissage, réseaux de neurones, systemes-experts etc...) ;

0 Langage naturel, a l’interface entre les requétes en langage naturel et les requétes ICL.

La ﬁgure ci-dessous donne une représentation schématique d’une communauté d’agents
idéale.

Agent Facilitator ::

........... .. AA 4...; 

I  .................... _.| u I y I ......  ........................... .-

Agent Agent Agent Méta

Interface LN<:>|CL Application Agent

® API
C) C) Application

Agents Modalité

Figure 3 : communauté d’agents OAA idéale
2.3.2 Principales étapes

La création d’un agent OAA passe par les étapes suivantes, dont les détails sont fournis plus
bas lorsque nécessaire :

97

2.3.3

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

déterminer quels services, ou solvables doivent étre foumis par l’agent. Ceux-ci seront
declares a la connexion avec le facilitateur et l’implémentation de l’agent sera
structurée autour des solvables ;

inclure une copie de la bibliotheque Agent, en suivant les conventions propres a
chaque langage. La librairie Agent est une API fournissant l’acces aux fonctionnalités
de la plate-forrne OAA, en vue du développement de systemes multiagents ;

de facon optionnelle, surcharger (redéﬁnir) les comportements par défaut a l’aide
d’appels spéciﬁques ;

la définition de triggers (voir plus bas) de type data, task ou procedure est effectuée
grace a oaa_AddTrigger '

5

une procédure de callback doit étre définie par chacun de ses solvables procedure. Le
code, déﬁni pour chacun de ces callback, est susceptible d’installer des triggers
locaux ou distants, de lire ou d’écrire a partir du facilitateur, d’envoyer des
événements ou des requétes au facilitateur ou a un agent particulier, ou encore de
s’interfacer avec des routines associées a l’agent ;

une communication avec le facilitateur doit étre ouverte, par le biais de
com_Co1'11'1ect(pare1'1t, [], address)‘

5

l’agent doit s’enregistrer aupres d’un facilitateur, via oaa_Register (parent,
Ager1tName , Solvable, Params)

5

enfin, l’agent doit initialiser une boucle d’événement, via oaa_MainLoop.

Déclaration des services, ou « solvables »

Chaque agent membre d’une communauté OAA définit et rend publiques un ensemble de
services qu’il est capable de rendre, exprimées en ICL : les solvables. Ces services mettent en
place une interface de haut niveau entre l’agent et le facilitateur. Ce demier peut ainsi
déléguer les requétes de service a l’agent.

Notons que les solvables sont typés :

Procédures (procedure) ;
Données (data) ;

Triggers.

Les solvables procedure et data déclarent les services pouvant étre appelés directement par
d’autres agents (par l’appel de la procédure de la librairie Agent : oaa_Solve).
Fondamentalement, un solvable procedure accomplit une action, alors qu’un solvable data
enregistre un ensemble de faits. Ainsi, par exemple, un agent de courrier électronique
définirait des solvables procédure afin d’envoyer un message au destinataire. De son cote un
agent encapsulant une base de données définirait un solvable données correspondant a chaque

98

T utoriel .' Open Agent Architecture

relation présente dans la base. Les solvables data sont le plus souvent utilisées pour foumir
des enregistrement de données partagés, pouvant faire l’objet d’une requéte mais pouvant
également étre mis a jour par les agents autorisés ale faire.

Les solvables triggers ne sont pas directement accessibles par les autres agents, qui ne
peuvent y avoir acces qu’indirectement, en assignant des triggers de taches aux agents
concernés. Un solvable trigger n’existe que pour déclarer des conditions ou événements
spéciﬁques a une tache donnée. Pour reprendre l’exemple de l’agent de courrier électronique,
celui-ci peut déclarer un solvable trigger surveillant l’arrivée de nouveaux messages, en
fonction du proﬁl des utilisateurs. Cette déclaration signiﬁe aux autres agents (y compris le
facilitateur et l’agent source) que des triggers peuvent étre assignés a cet agent. Le type task
est le seul trigger pour lequel une déclaration de solvable trigger est nécessaire, via l’appel
aux procédures de la librairie Agent telles que : oaa_Declare et oaa_Ur1declare.

2.3. 4 Evénements

L’ensemble des communications entre agents ont lieu sous la forme d’événements. De plus, la
plupart des traitements et des structures intemes d’un agent sont normalement centrés autour
de ces événements. On peut penser ces événements en termes de messages, qui ne doivent pas
étre directement construits par le développeur : la construction et la transmission de ces
événements est le résultat des appels aux fonction OAA telles que oaa_Solve et
oaa_AddTrigger.

Ainsi, un appel a
Oaa_Solve(Goal, Params)

au sein d’un agent A a pour résultat un événement de la forme

ev_solve(GoalID, Goal, Params)

de A vers le facilitateur, ainsi qu’un message de retour de la forme

ev_solved(GoalID, Requestees, Solvers, Goal, Params,
Solutions).

2. 3. 5 Appels de services et traitement des requétes

Un agent fait appel a des services par l’envoi de buts au facilitateur. Chaque but contient des
appels a un ou plusieurs solvable. L’appel a un solvable n’implique pas la spéciﬁcation d’un
agent particulier pour le traitement de la requéte. Bien qu’il soit possible de désigner un agent
particulier pour le traitement d’une requéte, il est généralement préférable de faire appel au
facilitateur. Les fonctions de la bibliotheqe Agent d’OAA mettent un place un point d’entrée
unique pour l’appel aux services d’autres agents : la procédure oaa_Solve. Cette procédure
peut aussi bien servir a extraire des données qu’a déclencher des actions. Par ailleurs, elle
fournit un certain nombre de parametres différents permettant de contr6ler le comportement
du facilitateur et des autres agents. En particulier, le parametre address permet la

99

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

délégation explicite envers un ou plusieurs agents. Ce parametre perrnet également 1’appe1
aux solvables de 1’agent émetteur lui-méme.

Les données qui sont retournées en réponse a une requéte, ou solvable data, ainsi que celles
utilisées pour les opérations de mise a jour sont directement exprimables en ICL. Ces données
peuvent étre completement ou partiellement instantiées.

2.4 Exemples

Ci-dessous, deux exemples en Java et en C, adaptés du manuel de référence de la plate-forrne
OAA. Ces exemples illustrent les étapes données plus haut de création d’un agent.
2.4.1 Un agent fax en Java
import oaa.agents.bean.agentBean.*;
AgentBean oaa = new AgentBean () ;
1. Importation des librairies
oaa.setOaaName("fax");
oaa.setOaaSolvables("[fax(Destination,Document)]");

2. Declaration des services

String oaa_doEvent(DoEvent e) {
if (e.func.compareTo("fax") == 0) {
String person = oaa.lib.nthElt(e.args, 1); // Person
String doc = oaa.lib.nthElt(e.args, 2); // Document

String res = oaa.lib.solve("fax_num(" + person + ",N)",

H|::|H),.

if (res.compareTo("[]") != O) {

3. Definition des services

oaa.connect();

4. Initialisation

100

T utoriel .' Open Agent Architecture

2.4.2 Un agent T ext—T 0-Speech en C
#include <libcom_tcp.h>
#include <liboaa.h>
1. Importation des librairies
ICLTerm capabilities = icl_TermFromStr(“[play(tts, Msg)]”);
2. Declaration des services
ICLTerm oaa_AppDoEvent(ICLTerm Event, ICLTerm Params) {
if (strcmp(icl_Str(Event), “play”) == ) {
return playTTS(icl_ArgumentAsStr(Event, 2));
}

else return NULL;

3. Definition des services
main() {
com_Connect(“parent”, connectionlnfo);
oaa_Register(“parent”, “tts”, capabilities);

oaa_MainLoop(True);

4. Initialisation

3 Développer une application de TALN avec OAA : exemples
détaillés

Dans cette partie, nous examinons la mise en oeuvre d’applications dédiées au TALN. La
premiere est une plate-forrne de commande Vocale d’interfaces (ex : simulateur tactique). Les
applications présentées sont des systemes industriels en Vraie grandeur, dont nous détaillerons
le cadre, les contraintes et les composantes retenus au cours de la présentation du tutoriel. Les
applications présentées integrent des composants de reconnaissance Vocale, de cartographie,
des grammaires destinées a analyser le langage naturel (grammaires génériques, spécifiques,
regles d’interprétation contextuelle, résolution des anaphores etc. . .).

101

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

3.1 Thomspeaker, commande vocale d’interfaces

3. 1. 1 Architecture

  
     
 

    
  

“WWW” IWWWWII
, .

.eutNLUi AgJC&&§m Agjnuxgn
:\g,€11tK.DI’ I I“ 2 is-:11tw111

Enoncé

Signal Appli-

  
  

obiets et actions

.~.<;:;:t.;1i:'i~;c:u;ir~.1 As *:‘11t BUD

Figure 4 : architecture d’un systeme multiagents industriel, Thomspeaker

3.1.2 F onctionnalités

0 Grammaire generique de 1’ang1ais pour la commande
0 Grammaire generique du franoais pour la commande
0 Grammaire de 1’ang1ais pour les requétes

0 Module de negociation avec sous-dialogues

0 Generation de reponses

0 Synthese de parole

0 Interpretation contextuelle (theorie des RMs)

102

T utoriel .' Open Agent Architecture

0 Rattrapage des erreurs de reconnaissance au niveau interprétation
0 Modiﬁcation/restriction en dynamique de la phraséologie
0 Multi-utilisateurs

0 Outils de saisie des ressources

3.2 MARA, assistance in la maintenance

3.2.1 Architecture (In systéme

Bus vidéo

 
 
 

 

 

 

Environnement de RA

   

Start-It

u:
3 Bus logiciel
L
§ CORBA
.0
 | |
O Recalage Superviseur Client Affichage Acquisition
maqnétique de scéne Interface RA Vidéo
"3 . .
5 Open Aqent Architecture (Superviseur)
ii’ I I
E l Interaction | | Communication configurateur
I

  

Dialogul l Génération l -I-ext-I-ospeech

 

Figure 5 : architecture fonctionnelle d’un systeme d’aide a la maintenance

103

Interface Vocale

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

   
 
     

T rame
compléte

RE CONNAISSAN CE .
Enonce

T PL UG-INAPPLICA TION Action
API application
—

Figure 6 : sources de connaissances et traitements du systeme MARA

   

 

,/- rmation conceptuelle +
 Lexique

 
 
  

Information conceptuelle
Lexique

Interface
d’acquisition

    
     
   

 

(LCMDI GUI)

Figure 7 : architecture d’acquisition de ressources pour les systemes industriels multiagents

Cette architecture est celle mise en oeuvre pour un systeme destiné au développement de
ressources linguistiques destinées a étre utilisées par des systemes multiagents utilisant la
reconnaissance Vocale, tels que présentés plus haut. Cette architecture est elle-méme

104

T utoriel .' Open Agent Architecture

multiagents et repose sur OAA. Les ressources sont générées a partir de ressources
génériques, telles qu’une grammaire générique décrivant les principaux types de phrases, par
exemple. La sortie du systeme est un ensemble de regles d’interprétation spécifiques a un
domaine, produites a partir des ressources génériques et de ressources telles qu’un lexique-
métier (ex : lexique de la maintenance), ou des modeles acoustiques en milieu bruité. Ces
regles d’interprétation propres a un domaine de spécialité perrnettent de guider les modules de
reconnaissance de la parole et d’interprétation, en éliminant les candidats improbables, étant
donnée l’application.

3.3 Démonstrateur MARA

use” laﬂiche le hloc d"aIimenI.aIion

Push To Talk System: lie mon1.rel"aIim.

Slams = Listening...

Figure 8 : interface de réalité augmentée du systeme MARA

La ﬁgure ci-dessus donne la Vision augmentée fournie au technicien utilisant le systeme
MARA de maintenance a distance, intégrant des fonctionnalités de reconnaissance Vocale, de
réalité augmentée (superposition d’informations graphiques), de gestion des documents (i. e. la
documentation technique): textes, Vidéos, graphiques etc... Le systeme répond ici a une
requéte Vocale de l’utilisateur : << afﬁcher le bloc d’alimentation », en mettant en évidence le
bloc d’alimentation.

105

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

L’ensemble des requétes Vocales sont traitées par un agent de reconnaissance Vocale reposant
sur Nuance (SR1), ainsi que sur une grammaire du domaine, exprimée de facon traditionnelle
sous la forme de clauses Prolog (DCG).

Ploiel MAHA : Console Video HEI g '7 Netscape
Graphic IC Board removal:

' before removing the board from its expansion slot
touch both the board and the computer chassis to
establish grounrljng. This is panriculary important in
dry ur low-humidity climates to equalize any static
charge and to avoid electzrustam: discharges

' unplug the external connector J155 HE1ﬂ and be
careful not to rlamage the mrgets
ﬁrmly extmct the bottom connector Rum its
expansion slot. CAUTION : Never install or remove
the graphic IC hoard while the computer is powered
on.

3- Push To Talk Agent

Use” lquelle es! la procédure d"e)d.rac1.ion ale Ia carle graphique

Push To Talk System : lie munlre Ia pmcédure d"ext.raction de la carte graphique.

Status : Listening...

ejoémaneulj -Nu. -Nu. §DA. ‘Star. gqne. gm. gs-.1... gm gum" ﬂees. ﬂow. gem. gm. ‘IH E-Plot. £1:\ie.[§M,,, H|@2(Jeﬁﬂ€)g® Mus

Figure 9 : interface homme-machine pour le systeme MARA, extraction de la carte graphique
La ﬁgure ci-dessus présente une autre phase de l’interaction : l’utilisateur demande << quelle

est la procedure d’extraction de la carte graphique », qui suscite l’afﬁchage d’un extrait de
documentation technique multimédia illustrant la procédure demandée.

106

T utoriel .' Open Agent Architecture

FIuietMAHA:lInnsa|eVIden QEIIS A’ Netscape mill:

The TEK M1 circuit is a graphic hnard haserl nn type
74LS mmponents. The ﬁgure presents typical wiring
cnnﬁgumﬁnns ufthe buard fur analug input analog uutput
and digital inputfuuqlut connections. Analug inputs/nutputs
are attzicherl tn cunnectur J2 digital I/O and cuunterfﬁrner
fum:u'uns are attached tu cunnectur J1.

-’- Push Tn Talk gant

Use“ lquel est son schéma .12 céhlage

Push To Talk System : lie montre I2 schéma tie céhlage wle la carte graphique.

5‘-9‘-IIS I Listening...

?l*3l°émw=' liﬁlﬁlﬂlﬁlﬁlﬂlﬁﬂlﬂlﬂlﬁﬂlﬁﬂﬂlﬂlﬁlﬁl

H] Qﬂsfﬁﬁgﬁp 14 22

Figure 10 : interface du systeme MARA, resolution d’anaphores

La ﬁgure ci-dessus presente le schema de cablage demande par 1’uti1isateur via la question
<<que1 est son schema de cablage». Le systeme fait appel a un agent de resolution des
anaphores pour traiter la requéte et afﬁche le schema de la carte graphique.

107

Antonio BALI/E7} Olivier GRISVARD et Pascal BISSON

Références

Cunningham H. et alii., 1997. Software infrastructure for Natural Language Processing. In
Proceedings of the Fifth Conference on Applied Natural Language Processing (ANLP-97),
March 1997.

Cunningham H. et alii., 2001. Developing language components with GATE, University of
Sheffield.

Finin T., Labrou Y, Mayfield J., 1997, KQML as an agent communication language, in Jeff
Bradshaw, editor, Soﬁware Agents, MIT Press, Cambridge.

FIPA, 1997, Foundation for intelligent physical agents, (FIPA) 1997 specification
(http://drogo.cselt.stet.it/fipa/spec/fipa97.html).

Genesereth, M. R., Fikes R.E., 1992, Knowledge interchange format version 3.0, Reference
Manual, Technical Report Logic-92- 1, Stanford University
(http://logic.stanford.edu/kif/kif.html).

Labrou Y., Finin T., 1997, A proposal for a new KQML specification, Technical Report CS-
97-03, Computer Science and Electrical Engineering Department, University of Maryland
Baltimore County, (http://www.cs.umbc.edu/kqml).

Martin D., Cheyer A.J., Moran D.B., (1999), The Open Agent Architecture: a framework for
building distributed software systems, Applied Artiﬁcial Intelligence, vol. 13, p 91-128.

Martin D., Cheyer A.J., Moran D.B.. The Open Agent Architecture: a framework for building
distributed software systems, Artificial Intelligence Center, SRI International.

Maynard D. et alii., 2000. A survey of uses of GATE, Research Memo CS-00-06, Institute for
Language Speech and Hearing (ILASH) and Department of Computer Science, University of
Sheffield.

Open Agent Architecture (OAA) developer’s guide, V2.0, SRI International.

108

