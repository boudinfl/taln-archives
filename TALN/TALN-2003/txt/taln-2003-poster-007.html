<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Structuration automatique de preuves math&#233;matiques : de la logique &#224; la rh&#233;torique</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2003, Batz-sur-Mer, 11&#8211;14 juin 2003
</p>
<p>Structuration automatique de preuves math&#233;matiques : de la
logique &#224; la rh&#233;torique
</p>
<p>Adil El Ghali Laurent Roussarie
LATTICE &#8211; PPS LATTICE &#8211; CNRS
</p>
<p>Universit&#233; Paris 7 &#8211; Case 7003
2, place jussieu
</p>
<p>75251 Paris Cedex 05
{adil,laurent}@linguist.jussieu.fr
</p>
<p>Mots-clefs &#8211; Keywords
</p>
<p>G&#233;n&#233;ration automatique de textes, d&#233;termination de contenu, logiques de description, struc-
turation de document, SDRT
</p>
<p>NLG, content determination, description logics, document structuring, SDRT
</p>
<p>R&#233;sum&#233;
</p>
<p>Nous pr&#233;sentons dans ses grandes lignes un mod&#232;le de structuration de documents pour la
g&#233;n&#233;ration automatique de preuves math&#233;matiques. Le mod&#232;le prend en entr&#233;e des sorties d&#8217;un
prouveur automatique et vise &#224; produire des textes dont le style s&#8217;approche le plus possible des
d&#233;monstrations r&#233;dig&#233;es par des humains. Cela implique la mise au point d&#8217;une strat&#233;gie de
planification de document capable de s&#8217;&#233;carter de la structure purement logique de la preuve.
La solution que nous proposons consiste &#224; int&#233;grer de mani&#232;re simple des informations de type
intentionnel afin d&#8217;enrichir la structure rh&#233;torique finale du texte.
</p>
<p>1 Introduction
</p>
<p>En g&#233;n&#233;ration automatique, les strat&#233;gies de structuration de document1 ont non seulement un
impact durable sur l&#8217;ensemble du processus de production, mais aussi une efficacit&#233; double :
elles constituent une premi&#232;re &#233;tape de mise en forme (les choix des structures de discours se
r&#233;percutent sur l&#8217;agencement final du texte), et elles incluent une phase de raisonnement qui
n&#8217;est pas compl&#232;tement ind&#233;pendante de la d&#233;termination de contenu : il s&#8217;agit, par exemple,
</p>
<p>1Pour des d&#233;tails sur l&#8217;architecture et les composants des syst&#232;mes de g&#233;n&#233;ration, voir (Reiter &amp; Dale, 2000).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali, Laurent Roussarie
</p>
<p>de construire une argumentation, ce qui implique de choisir, en sus de certaines connexions
rh&#233;toriques, des arguments &#8211; i.e. du contenu &#8211; convaincants. L&#8217;objectif principal de cette com-
munication est d&#8217;aborder ce probl&#232;me de la double efficacit&#233; de la structuration de document
&#224; la lumi&#232;re d&#8217;une application particuli&#232;re : la g&#233;n&#233;ration automatique de textes de preuves
math&#233;matiques. La g&#233;n&#233;ration de preuves en langue naturelle fournit une illustration claire de
l&#8217;acuit&#233; du probl&#232;me en question. En effet, un objet preuve poss&#232;de une structure formelle assez
stable et bien d&#233;finie, que l&#8217;on appelle l&#8217;arbre de preuve. D&#8217;un point de vue s&#233;mantique, une
telle structure peut souvent se ramener &#224; une s&#233;rie d&#8217;inf&#233;rences (&#233;ventuellement imbriqu&#233;es).
On peut alors s&#8217;accorder l&#8217;intuition que l&#8217;information fournie par un arbre de preuve non seule-
ment refl&#232;te le contenu s&#233;mantique du texte-preuve, mais donne aussi certaines indications sur
sa structure rh&#233;torique. C&#8217;est d&#8217;ailleurs ce sur quoi s&#8217;appuient un certain nombre de travaux
en g&#233;n&#233;ration automatique de preuves (e.g. (Huang &amp; Fiedler, 1997; Fiedler, 2001)) qui &#233;la-
borent des strat&#233;gies plus ou moins sophistiqu&#233;es d&#8217;exploitation ou de parcours de l&#8217;arbre pour
produire, par appariements et regroupements, un plan de texte. De telles strat&#233;gies permet-
tent de g&#233;n&#233;rer des textes corrects et conformes &#224; la preuve formelle; cependant beaucoup sont
st&#233;r&#233;otyp&#233;s, peu naturels, r&#233;p&#233;titifs, fastidieux, et parfois m&#234;me abscons. Nous pensons que
ces imperfections peuvent s&#8217;expliquer par le fait qu&#8217;&#224; partir d&#8217;une preuve formelle, il n&#8217;est pas
forc&#233;ment trivial de distinguer ce qui devrait relever de la d&#233;termination de contenu vs. de la
structuration de document. De plus m&#234;me si la structure de l&#8217;arbre de preuve contraint forte-
ment la structure rh&#233;torique du texte, elle ne la d&#233;termine pas compl&#232;tement. Empiriquement
on constate que, souvent, l&#8217;organisation apparente d&#8217;un texte-preuve r&#233;el rend compte de la
structure de l&#8217;arbre mais aussi des m&#233;canismes de raisonnement utilis&#233;s dans la d&#233;monstration.
</p>
<p>Dans cette communication nous allons proposer une strat&#233;gie originale de planification de textes
de preuve, visant &#224; obtenir des discours plus naturels et plus proches des preuves r&#233;dig&#233;es en
langue naturelle. Les grandes lignes de cette strat&#233;gie seront expos&#233;es &#224; travers la pr&#233;sentation
du syst&#232;me GEPHOX qui est un g&#233;n&#233;rateur de textes de preuves math&#233;matiques obtenues avec
le syst&#232;me d&#8217;aide &#224; la preuve PHOX (Raffalli &amp; Roziere, 2002). Nous nous interessons ici au
module Quoi-dire? du g&#233;n&#233;rateur dont l&#8217;organisation respecte une architecture standard en deux
sous-modules : ContDet qui calcule le contenu &#224; exprimer &#224; partir de sorties de PHOX et en
fonction de connaissances de l&#8217;utilisateur, et DocStruct qui calcule les plans du discours. Les
plans de discours produits sont repr&#233;sent&#233;s dans le formalisme de la SDRT (Asher &amp; Lascarides,
2003). Ce choix est motiv&#233; par deux raisons : d&#8217;abord nous nous fondons en grande partie
sur le mod&#232;le de structuration de document de (Danlos et al., 2001) qui montre l&#8217;efficacit&#233; de la
SDRT pour la g&#233;n&#233;ration profonde ; ensuite nous adoptons les conclusions de (Zinn, 1999) selon
lesquelles la DRT (et implicitement la SDRT) propose un formalisme particuli&#232;rement appropri&#233;
pour l&#8217;analyse et la repr&#233;sentation des textes math&#233;matiques.
</p>
<p>2 D&#233;termination du contenu : le module ContDet
</p>
<p>Le syst&#232;me d&#8217;aide &#224; la preuve PHOX permet de r&#233;aliser sur ordinateur des preuves math&#233;ma-
tiques, en en garantissant la validit&#233;. M&#234;me si le logiciel dispose d&#8217;un algorithme de preuve au-
tomatique, son utilisation principale &#8211; e.g. pour l&#8217;enseignement des math&#233;matiques &#8211; est la v&#233;ri-
fication des &#233;tapes de raisonnement. L&#8217;utilisateur guide PHOX pour d&#233;montrer des th&#233;or&#232;mes
math&#233;matiques, en laissant le soin au logiciel de r&#233;aliser les v&#233;rifications et les op&#233;rations fasti-
dieuses de la preuve.
</p>
<p>GEPHOX prend en entr&#233;e des informations de deux types: le script de preuve qui repr&#233;sente
la trace de la d&#233;monstration (i.e. les commandes entr&#233;es par l&#8217;utilisateur) et la sortie de PhoX</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Structuration automatique de preuves math&#233;matiques
</p>
<p>proprement dite, qui est constitu&#233;e de fragments de l&#8217;arbre de preuve et que l&#8217;on peut donc voir
comme le contenu de la preuve. Le module ContDet doit calculer &#224; partir de cette entr&#233;e, et en
tenant compte des connaissances de l&#8217;utilisateur, le message qui sera exprim&#233; par le g&#233;n&#233;rateur.
Dans GEPHOX les informations sont d&#233;crites dans les concepts et les r&#244;les d&#8217;une logique de
description (DL, cf. (Baader et al., 2003)). Les connaissances sur le domaine et les connais-
sances propres de l&#8217;utilisateur sont respectivement repr&#233;sent&#233;es dans deux bases : DKB et UKB
(UKB est en fait un sous-ensemble de DKB). Les bases de connaissances sont structur&#233;es en
deux parties. D&#8217;une part, la T-Box (pour connaissances terminologiques) encode les connais-
sances intensionnelles, i.e. les concepts et les relations du domaine. Par exemple, le concept
Entier d&#233;signe l&#8217;ensemble des entiers naturels. D&#8217;autre part, la A-Box (pour connaissances
assertionnelles) encode les connaissances extensionnelles, i.e. les individus de notre univers.
Par exemple n &#8712; Entier introduit un individu appartenant au concept Entier.
Le principe g&#233;n&#233;ral du calcul de contenu est le suivant. Il s&#8217;agit, dans un premier temps, de
construire les expressions conceptuelles (T-Box) correspondant &#224; l&#8217;entr&#233;e, en se rappelant des
individus I qui leurs correspondent. C&#8217;est sur cette T-Box qu&#8217;op&#232;re la d&#233;termination de contenu
proprement dite. Enfin, les expressions conceptuelles sont instanci&#233;es en utilisant les individus
I pour produire la A-Box qui repr&#233;sente, sous formes de faits, le message &#224; g&#233;n&#233;rer. Le module
ContDet commence donc par traduire l&#8217;entr&#233;e du g&#233;n&#233;rateur en DL, en utilisant les concepts et
r&#244;les de la DKB. Si des d&#233;finitions et des th&#233;or&#232;mes issus de PHOX n&#8217;existent pas dans la base
de connaissance, la proc&#233;dure de traduction cr&#233;e de nouveaux concepts en fonction de ceux
d&#233;j&#224; pr&#233;sents. Une fois construit l&#8217;ensemble des expressions conceptuelles (ECD) repr&#233;sentant
l&#8217;entr&#233;e, ContDet doit s&#233;lectionner dans cet ensemble ce qui doit &#234;tre dit. Sont alors mis en jeu
des op&#233;rations de filtrage et de regroupement. Une premi&#232;re consiste &#224; d&#233;tecter des strat&#233;gies
de raisonnement et leurs param&#232;tres: par exemple, reconna&#238;tre l&#8217;annonce d&#8217;un raisonnement par
cas; et ensuite calculer les diff&#233;rents cas et les associer &#224; cette annonce. La deuxi&#232;me op&#233;ra-
tion est la mise en &#233;vidence des similitudes entre portions de preuve. On utilise &#224; cet effet
l&#8217;unification de concepts (Baader &amp; K&#252;sters, 2001). Enfin, ContDet cherche &#224; apparier des
d&#233;finitions de concepts complexes de la DKB avec des expressions de ECD. Cela permet de syn-
th&#233;tiser des groupes d&#8217;informations plus ou moins simples sous le chef d&#8217;un concept pr&#233;d&#233;fini
(une telle op&#233;ration est g&#233;n&#233;ralement d&#233;nomm&#233;e agr&#233;gation en g&#233;n&#233;ration automatique). Les
axiomes (i.e. les d&#233;finitions de DKB) utilis&#233;s &#224; cet effet sont gard&#233;s en m&#233;moire pour &#233;tablir
ensuite des relations de second ordre sur les &#233;l&#233;ments de ECD. La T-Box ainsi obtenue donne
une repr&#233;sentation de la preuve qui fait usage de tous les concepts du domaine2. La derni&#232;re
&#233;tape de la d&#233;termination du contenu est l&#8217;instanciation de ECU par les individus de I et la
v&#233;rification de consistance du fragment de A-Box obtenu.
</p>
<p>3 Structuration de document
</p>
<p>La figure 1 donne un exemple de sortie de ContDet. Ce type de structure peut &#234;tre vu comme
un ensemble ordonn&#233;3 de formes logiques qui marquent les pas significatifs de la d&#233;monstration.
En regard de certaines formules figurent les axiomes qui ont permis de construire la formule.
</p>
<p>2Pour produire un message coop&#233;ratif et personnalis&#233;, il est n&#233;cessaire de confronter cette repr&#233;sentation avec
les connaissances de l&#8217;utilisateur (UKB), afin de v&#233;rifier s&#8217;il comprend tout ce que comporte EC D. Cela revient en
fait &#224; expliquer (i.e. d&#233;composer) les concepts de ECD qui ne figurent pas dans UKB. On obtient ainsi un nouvel
ensemble d&#8217;expressions conceptuelles ECU , qui est calcul&#233; par projectionde ECD dans UKB.
</p>
<p>3L&#8217;ordre provient de la s&#233;mantique du conjoncteur dynamique &#8743; qui n&#8217;est pas sym&#233;trique. Dans la figure 1,
l&#8217;&#233;num&#233;ration des formules n&#8217;est donn&#233;e (pour l&#8217;instant) que pour la lisibilit&#233; du tableau.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali, Laurent Roussarie
</p>
<p>De plus, la structure est plus riche qu&#8217;un simple arbre de preuve, puisque ContDet fait en sorte
qu&#8217;elle contienne &#233;galement des &#233;lements d&#8217;information provenant du script de preuve. Un des
points centraux de notre strat&#233;gie de g&#233;n&#233;ration profonde va consister &#224; exploiter cette richesse,
notamment en postulant que les &#233;tapes du script traduites en formes logiques s&#8217;assimilent &#224; des
intentions communicatives. Ces intentions vont permettre en particulier de g&#233;n&#233;rer des actes de
langage qui &#171; humanisent &#187; le texte de preuve en ajoutant des &#233;l&#233;ments de rh&#233;torique autres que
les habituelles relations logiques.
</p>
<p>Formes logiques Axiomes
A sous-ensemble(Q,&#1;&#8727;) &#8743; define(Q,&#8220;&#8707;n &#8712; &#1; (m2 = 2 &#8727; n2)&#8221; ) Q .= Ensemble &#8743; &#8707;sous-ensemble.{&#1;&#8727;}
</p>
<p>&#8743; &#8707;eq-def.{&#8707;n &#8712; &#1; (m2 = 2 &#8727; n2)
B Entier(m) &#8743; neg-Q(m) neg-Q .= &#172; Q
C t1 = not-in(sqrt&#8722; 2,&#2;) &#8743; Theoreme(t1) &#8743; annonce(t1)
</p>
<p>1. Entier(m) &#8743; Entier(n) &#8743; choose(m) &#8743; choose(n)
2. p1 = Prop(&#8220;m2 = 2 &#8727; n2&#8221;) &#8743; suppose(p1)
3. l1 = lemme(&#8220;lemme1&#8221;)
4. neg-Q(m) &#8743; implies(e3,e4)
</p>
<p>D 5. CaseReason(current)
6. is-case(current,e6) &#8743; Nul(m)
7. Nul(n) &#8743; implies(e6,e7)
8. is-case(current,e8) &#8743; Entier-non-nul(m)
. . . . . .
</p>
<p>Figure 1: Fragment du message pour &#171;
&#8730;
2 n&#8217;est pas rationnel &#187; (sortie de ContDet)
</p>
<p>Le calcul du plan du texte est pris en charge par le module DocStruct, qui s&#8217;inspire de (Danlos
et al., 2001). Partant, DocStruct a deux t&#226;ches principales &#224; mener pour produire une structure
de document : 1) choisir les unit&#233;s minimales de la structure, 2) choisir les relations rh&#233;toriques
qui lient les unit&#233;s entre elles pour garantir la coh&#233;sion et la coh&#233;rence du discours.
</p>
<p>La structure de la A-Box calcul&#233;e par ContDet est celle d&#8217;un graphe connexe4 (les sommets
correspondant aux individus et les arcs &#224; des r&#244;les ou relations conceptuels). Dans ce graphe,
certains sous-graphes sont fortement connexes (pseudo-cliques). Notre strat&#233;gie est de consid-
&#233;rer que ce sont ces sous-graphes qui donneront lieu &#224; des unit&#233;s de discours, i.e. des segments
minimaux de contenu. Par ailleurs, nos sous-graphes sont reli&#233;s entre eux par des d&#233;pendances
que nous assimilerons &#224; des relations d&#8217;ordre sup&#233;rieur portant sur les unit&#233;s de discours. Une
telle relation correspond en fait soit &#224; une commande du script, soit au r&#233;sultat d&#8217;un axiome
(e.g. d&#233;duction, conclusion...). Un r&#233;sultat de segmentation appara&#238;t dans la disposition de la
figure 1 (colonne de gauche), o&#249; chaque ligne correspond &#224; un segment de discours. Comme
annonc&#233; supra, notre futur plan de discours sera formalis&#233; dans le cadre de la SDRT, i.e. sous
forme d&#8217;une SDRS (Asher &amp; Lascarides, 2003). Une SDRS est une structure dans laquelle des
constituants de discours sont connect&#233;s par des relations rh&#233;toriques. Les constituants sont des
repr&#233;sentations s&#233;mantiques dynamiques h&#233;rit&#233;es de la DRT, &#224; savoir des DRS. Les segments
de la figure 1 sont donc destin&#233;s &#224; &#234;tre traduits en DRS, et en accord avec (Danlos et al., 2001),
cette op&#233;ration se fait conjointement &#224; la s&#233;lection des relations rh&#233;toriques.
Le mod&#232;le propos&#233; par (Danlos et al., 2001) est d&#233;claratif. L&#8217;id&#233;e est que les relations rh&#233;-
toriques sont associ&#233;es &#224; des postulats de sens et que ceux-ci sont consid&#233;r&#233;s comme des con-
ditions (des d&#233;clencheurs) de s&#233;lection d&#8217;une relation valide. Les conditions sont formul&#233;es
dans le m&#234;me langage que celui des formes logiques d&#8217;entr&#233;e pour permettre des appariements
</p>
<p>4Nous n&#8217;allons nous int&#233;resser ici qu&#8217;au cas d&#8217;un seul graphe connexe; si nous avons un graphe compos&#233; de
plusieurs parties non connexes, le module DocStruct les traitera s&#233;parement. Dans notre message (Fig. 1) les
parties A, B, C et D sont les repr&#233;sentants de sous graphes non connexes de notre entr&#233;e.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Structuration automatique de preuves math&#233;matiques
</p>
<p>directs. La figure 2(a) illustre un tel appariement avec une r&#232;gle pour la relation Resultat,
qui en SDRT permet d&#8217;exprimer la causalit&#233; entre deux phrases. La r&#232;gle a la forme suivante:
conditions &#8594; SDRS. La SDRS de la partie droite est une portion de discours dans laquelle est
instanci&#233;e la relation rh&#233;torique d&#233;clench&#233;e5. La SDRS obtenue en Fig. 2(a) pourra &#234;tre g&#233;n&#233;r&#233;e
en &#171; Phrase1. Donc Phrase2. &#187;6.
</p>
<p>R&#232;gles pour les relations de discours
Resultat:
implies(e1, e2)&#8594; &#960;1 &#960;2
</p>
<p>&#960;1 : Calculer_SDRS(e1)
&#960;2 : Calculer_SDRS(e2)
Resultat(&#960;1, &#960;2)
</p>
<p>(a)
</p>
<p>Sch&#233;ma du raisonnement par cas
</p>
<p>1 2
</p>
<p>1 :
</p>
<p>3 4 5 6
</p>
<p>Consequence( 3 , 4 )
Consequence( 5 , 6 )
</p>
<p>2 : Conclude
</p>
<p>Consequence( 1 , 2 )
(b)
</p>
<p>Figure 2: R&#232;gles et Sch&#233;mas de Structuration Rh&#233;torique
</p>
<p>Cependant notre strat&#233;gie se distingue de (Danlos et al., 2001) sur plusieurs points. D&#8217;abord
les formes logiques de notre entr&#233;e comportent des informations qui peuvent refl&#233;ter des in-
tentions communicatives. Cela permet de s&#233;lectionner dans un plus large &#233;ventail de rela-
tions rh&#233;toriques, notamment en faisant varier les forces illocutoires. Nous reprenons en ef-
fet l&#8217;hypoth&#232;se de (Asher &amp; Lascarides, 2003) selon laquelle les arguments des relations rh&#233;-
toriques sont des actes de langage et que les relations induisent des typages illocutoires. Il
s&#8217;agit ici pour nous de traduire des &#171; actes de d&#233;monstration &#187; (les commandes saisies dans
PHOX) en actes de langage. Les r&#232;gles sont similaires &#224; celles de Fig. 2(a) mais les relations
d&#233;clench&#233;es pourront sp&#233;cifier une force illocutoire particuli&#232;re. Par exemple, une condition
comme choose(n) pourra ainsi donner lieu &#224; une assertion (&#171; on choisit n... &#187;) ou un imp&#233;ratif
(&#171; soit n... &#187;). Nous postulons aussi qu&#8217;un imp&#233;ratif d&#233;clenche une relation qui a port&#233;e sur
tout le reste du discours7; en l&#8217;occurence, pour les textes de preuve, nous posons la relation
Backgroundi pour &#171; imp&#233;ratif d&#8217;arri&#232;re-plan &#187;.
</p>
<p>Une seconde particularit&#233; de notre approche tient au traitement des annonces de strat&#233;gies de
raisonnement mentionn&#233;es dans la forme logique et issues du script de preuve. Une telle an-
nonce ne d&#233;clenche pas directement une relation rh&#233;torique, mais un sch&#233;ma rh&#233;torique propre
au raisonnement en question. Un sch&#233;ma est en fait une structure contenant plusieurs relations.
Par exemple, le sch&#233;ma du raisonnement par cas est illustr&#233; en Fig. 2(b). Ce type de traitement
s&#8217;explique par le fait que ces strat&#233;gies de raisonnement s&#8217;appuient sur des th&#233;or&#232;mes fonda-
mentaux (e.g. le tiers exclu pour le raisonnement par cas) qui en soi ne sont jamais explicit&#233;s
dans la d&#233;monstration, mais qui en revanche impliquent des agencements discursifs bien pr&#233;cis
(e.g. une suite de &#171; si..., alors... &#187; dans le raisonnement par cas). Un sch&#233;ma ainsi enclench&#233;
ne contient qu&#8217;un squelette rh&#233;torique, qui sera param&#233;tr&#233; ensuite en fonction du contenu de la
forme logique.
</p>
<p>5La fonction Calculer_SDRS fait partie de la proc&#233;dure de structuration et permet de construire le discours
r&#233;cursivement.
</p>
<p>6Notons que comme dans (Danlos et al., 2001), une condition comme implies(e 1, e2) peut donner lieu &#224; autre
chose qu&#8217;une relation rh&#233;torique, par exemple un pr&#233;dicat (&#171; verbal &#187;) qui fonde une DRS (&#171; X 1 implique X2. &#187;,
&#171; de X1 on obtient X2. &#187; ou &#171; X2 se d&#233;duit de X1 &#187;).
</p>
<p>7Ce que nous ne d&#233;montrerons pas ici pour des raisons de place.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali, Laurent Roussarie
</p>
<p>4 Conclusion
</p>
<p>Le mod&#232;le de g&#233;n&#233;ration profonde en cours d&#8217;impl&#233;mentation de GEPHOX8 propose une
strat&#233;gie de planification originale sur au moins deux aspects. D&#8217;abord, par rapport aux g&#233;n&#233;ra-
teurs automatiques de textes de preuves d&#233;j&#224; existants, les (plans de) discours ici produits
s&#8217;annoncent plus naturels et plus proches des preuves r&#233;dig&#233;es manuellement. Cela est d&#251; &#224;
la sp&#233;cificit&#233; du module ContDet qui exploite avantageusement les sorties du prouveur pour
engendrer dynamiquement9 une structure linguistique sp&#233;cifique et distincte, notamment en d&#233;-
gageant des informations de nature intentionnelle (e.g. les commandes du script). Par ailleurs, si
l&#8217;utilisation d&#8217;intentions n&#8217;est pas neuve en g&#233;n&#233;ration (e.g. cf. (Moore &amp; Paris, 1993)), la mise
en &#339;uvre que nous pr&#233;sentons se distingue par la simplicit&#233; du traitement. En effet l&#8217;approche
est hybride en ce sens que les conditions intentionnelles et les conditions informationnelles (s&#233;-
mantiques) de l&#8217;entr&#233;e donnent toutes des structures de discours de m&#234;me type: des (portions
de) SDRS. Celles-ci peuvent ensuite s&#8217;assembler selon un proc&#233;d&#233; unique (qui d&#233;pend seule-
ment des contraintes de bonne formation stipul&#233;es en SDRT). Cela permet, entre autres, de
s&#8217;affranchir de la complexit&#233;, souvent mentionn&#233;e, d&#8217;une gestion s&#233;par&#233;e des buts communicat-
ifs et de leurs interactions parfois discordantes avec les structures rh&#233;toriques.
</p>
<p>R&#233;f&#233;rences
ASHER N. &amp; LASCARIDES A. (2003). Logics of Conversation. Cambridge: CUP. (&#224; para&#238;tre).
BAADER F. &amp; K&#220;STERS R. (2001). Unification in a Description Logic with Transitive Closure of
Roles. In R. NIEUWENHUIS &amp; A. VORONKOV, Eds., Proceedings of LPAR 2001, volume 2250 of
Lecture Notes in Artificial Intelligence, Vienna: Springer&#8211;Verlag.
F. BAADER, D. L. MCGUINNESS, D. NARDI &amp; P. F. PATEL-SCHNEIDER, Eds. (2003). Description
Logics Handbook: Theory, Implementation and Applications. Cambridge University Press.
DANLOS L., GAIFFE B. &amp; ROUSSARIE L. (2001). Document structuring &#224; la SDRT. In Proceedings of
the 8th European Workshop on Natural Language Generation (EWNLG&#8217;2001), p. 11&#8211;20, Toulouse.
FIEDLER A. (2001). User-adaptive proof explanation. PhD thesis, Naturwissenschaftlich-Technische
Fakult&#228;t I, Universit&#228;t des Saarlandes, Saarbr&#252;cken, Germany.
HALLGREN T. &amp; RANTA A. (2000). An extensible proof text editor. In M. PARIGOT &amp; A. VORONKOV,
Eds., Proceedings of LPAR&#8217;2000, LNCS/LNAI 1955, p. 70&#8211;84, Heidelberg: Springer Verlag.
HUANG X. &amp; FIEDLER A. (1997). Proof verbalization as an application of NLG. In IJCAI&#8217;97 Proceed-
ing (2), p. 965&#8211;972.
MOORE J. D. &amp; PARIS C. L. (1993). Planning text for advisory dialogues: Capturing intentional and
rhetorical information. Computational Linguistics, 19(4), 651&#8211;694.
RAFFALLI C. &amp; ROZIERE P. (2002). The PhoX Proof checker documentation. LAMA, Universit&#233; de
Savoie / Universit&#233; Paris 7.
REITER E. &amp; DALE R. (2000). Building Natural Language Generation Systems. Studies in Natural
Language Processing. CUP.
ZINN C. (1999). Understanding mathematical discourse. In Proceedings of Amstelogue&#8217;99, 3rd Work-
shop on the Semantics and Pragmatics of Dialogue, Amsterdam.
</p>
<p>8Pour des raisons de place, nous n&#8217;avons pas d&#233;taill&#233; ici l&#8217;algorithme complet de planification de GEPHOX,
pr&#233;f&#233;rant concentrer notre propos sur les principes qui sous-tendent la structuration de document.
</p>
<p>9Et en cela, nous nous distinguons de l&#8217;approche par traduction (mapping) de (Hallgren &amp; Ranta, 2000).</p>

</div></div>
</body></html>