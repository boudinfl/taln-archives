TALN 2004, Fès, 19–21 avril 2004
Vers un statut de l’arbre de dérivation : exemples de
construction de representations sémantiques pour les
Grammaires d’Arbres Adjoints
Sylvain Pogodalla
LORIA – Campus Scientifique
BP239
F-54602 Vandoeuvre-lès-Nancy
sylvain.pogodalla@loria.fr
Résumé – Abstract
Cet article propose une définition des arbres de dérivation pour les Grammaires d’Arbres Ad-
joints, étendant la notion habituelle. Elle est construite sur l’utilisation des Grammaires Caté-
gorielles Abstraites et permet de manière symétrique le calcul de la représentation syntaxique
(arbre dérivé) et le calcul de la représentation sémantique.
This paper suggests a definition for Tree Adjoining Grammar derivation trees, extending the
usual notion. It results from using Abstract Categorial Grammars and enables, in a symmet-
ric way, the computation of both the syntactic representation (derived tree) and the semantic
representation.
Mots-clefs – Keywords
Sémantique, grammaires d’arbre adjoints, grammaires catégorielles, λ-calcul
Semantics, tree adjoining grammars, categorial grammars, λ-calculus
1 Introduction
Dans le processus de construction de la représentation sémantique d’une expression de la langue
naturelle, une approche importante consiste à associer les règles de combinaison syntaxique
et celles de combinaison sémantique. Si dans (Montague, 1974) la définition du calcul syn-
taxique se prête mal à l’implantation, les principes sous-jacents sont à la base de nombreux
autres travaux menés sur des formalismes syntaxiques plus élaborés. Nous mentionnerons en
premier lieu les grammaires catégorielles (Lambek, 1958; Moortgat, 1996), par le lien basé
sur l’homomorphisme de Curry-Howard qu’elles établissent entre un calcul syntaxique logique
et un calcul sémantique basé sur le λ-calcul. Puis, les grammaires HPSG, avec les travaux
de (Copestake et al., 1999), ou LFG (Dalrymple, 1999).
Sylvain Pogodalla
Nous nous intéressons ici plus particulièrement aux travaux réalisés dans ce cadre pour les
grammaires d’arbres adjoint (TAG) (Joshi et al., 1975; Abeillé, 1993). Le principe de ces
grammaires est de proposer un calcul d’arbres présentant deux opérations : l’adjonction et
la substitution. Ainsi, lors de l’analyse syntaxique d’une phrase, se construit l’arbre dérivé,
résultat du calcul de toutes ces opérations sur des arbres issus du lexique, les arbres initiaux
et les arbres auxiliaires. Cet arbre s’accompagne d’un autre arbre, l’arbre de dérivation qui
indique les opérations entre les arbres du lexiques par des flèches orientées vers le bas s’il s’agit
de substitution et vers le haut s’il s’agit d’adjonction (exemple de la figure 1).
Ce dernier arbre, en ce qu’il décrit les opérations de com-
binaison entre les arbres, a généralement été pris comme
c
base dans les propositions de calcul de représentation sé- aboie
mantique pour les TAG (Schabes & Shieber, 1994; Can-
c
dito & Kahane, 1998; Kallmeyer, 2002; Joshi et al., 2003). chien
Néanmoins, pour répondre à diverses contraintes, telle
celle de la représentation en Français des quantificateurs ctout
par des arbres auxiliaires, ces structures nécessitent d’être
enrichie, sans que cela ne règle tous les problèmes. Figure 1: Arbre de dérivation
(Gardent & Kallmeyer, 2003) propose de résoudre ces problèmes en construisant directement
sur l’arbre dérivé les représentations sémantiques, sans plus tenir compte de l’arbre de dériva-
tion. Néanmoins se pose alors le problème de l’attachement et de la réutilisation des représen-
tations ainsi construites.
Dans cet article nous nous proposons de revenir sur la notion d’arbre de dérivation. S’inspirant
d’autres formalismes grammaticaux qui n’ont pas non plus de règles syntagmatiques, la notion
que nous définissons permet de considérer de manière équivalente la représentation syntaxique
et la représentation sémantique en tant que résultat d’un processus spécifié par l’arbre de déri-
vation. La différence reflète alors simplement le choix de langages formels différents pour la
partie syntaxique (arbres) et la partie sémantique (langage de représentation sous-spécifié), ainsi
que les définitions lexicales.
Pour ce faire, nous faisons appel au formalisme, introduit par (de Groote, 2001), des gram-
maires catégorielles abstraites (ACG). Puis nous montrons comment y modéliser les TAG, puis
la sémantique LU (Bos, 1995). Enfin nous explorons sur quelques exemples les résultats de cette
approche.
2 Grammaires catégorielles abstraites
Les ACG, formalisme grammatical basé sur la logique linéaire (Girard, 1987), correspondent
plus à un cadre grammatical dans lequel modéliser d’autres formalismes grammaticaux et leur
apporter ses outils que comme un nouveau formalisme grammatical. Ceci en raison des carac-
téristiques suivantes :
• chaque ACG engendre deux langages : un langage abstrait, qui peut être vu comme
un ensemble abstrait de structures grammaticales, et un langage objet représentant les
formes réalisées des structures abstraites. Ici, le langage abstrait correspond à la structure
grammaticale que l’on veut manipuler : l’arbre de dérivation. Il sera associé, par deux
Vers un statut de l’arbre de dérivation : exemples de construction de
representations sémantiques pour les Grammaires d’Arbres Adjoints
ACG différentes, d’une part à la réalisation syntaxique sous forme d’arbres de TAG et
d’autre part à la réalisation sémantique sous forme de formules de LU ;
• les ACG reposent sur un ensemble réduit de primitives mathématiques, en particulier le
connecteur implicatif de la logique linéaire . Ce connecteur permet de représenter
l’implication comme consommateur de ressources : lorsqu’une formule A est utilisée
avec une formule A  B pour produire une formule B, les deux premières formules
ne sont plus utilisables par la suite dans la preuve, contrairement à la logique classique.
La conséquence de ce comportement est que les λ-termes associés via l’isomorphisme de
Curry-Howard (Howard, 1980) sont dits linéaires, c’est-à-dire que toute λ-abstraction lie
une et une seule variable.
Dans (de Groote, 2001), les langages engendrés par les ACG sont des ensembles de λ-termes
linéaires. Ces derniers généralisent aussi bien les langages de chaînes de caractères que ceux
d’arbres. Cela suffit pour modéliser les TAG, c’est en revanche insuffisant pour la partie séman-
tique (par exemple la variable x est utilisée deux fois pour dire que l’individu qu’elle dénote
est un chien chien(x) et qu’il est noir noir(x) dans l’expression chien noir). La motivation
principale pour se limiter au λ-calcul linéaire tient dans le principe sous-jacent d’analyse dans
ce cadre : il consiste en la résolution de problèmes de filtrage de λ-termes d’ordre supérieur. Or
ce problème pris dans toute sa généralité est difficile. Suivant les cas, il est indécidable (Loader,
2003), de complexité encore inconnue (Dowek, 2001), ou décidable. Pour le filtrage de λ-
termes linéaires, le problème est NP-complet (de Groote, 2000), ce qui en fait un bon candidat
pour les langages des ACG.
Toutefois, si l’on considère pour le langage objet des termes du λ-calcul simplement typé, avec
certaines conditions sur le lexique, la propriété de décidabilité est conservée (le problème est
ramené à un problème de recherche de preuve dans le fragment multiplicatif de la logique
linéaire, qui est décidable). Nous n’approfondirons pas ce point, mais c’est le cas pour les
ACG que nous considérons ici. Par ailleurs, le problème ne se poserait que pour passer de la
représentation sémantique à la représentation syntaxique (génération), l’analyse sémantique ne
posant pas ces problàmes de décidabilité.
Pour les définitions précises des ACG, nous renvoyons le lecteur à (de Groote, 2001). Toutefois,
certaines notions sont un peu différentes et nous les redéfinissons ici.
Definition 1 (Types). Soit A un ensemble de types atomiques. L’ensemble T (A) des types
construits sur A est défini par : T (A) ::= A|A → T (A)|T (A) T (A)
L’ensemble des types t ∈ T (A) tels que le symbole → n’apparaît pas dans t est l’ensemble
des types linéaires implicatifs, noté TL(A). Les autres renvoie au λ-calcul simplement typé
habituel.
Definition 2 (Signature d’ordre supérieur). Une signature d’ordre supérieure est un triplet
Σ = 〈A,C, τ〉 où :
• A est un ensemble de types atomiques ;
• C est un ensemble fini de constantes ;
• τ : C → T (A) qui assigne à chaque constante de C un type.
Si τ : C → TL(A), la signature est dite linéaire.
Sylvain Pogodalla
L’ensemble des termes typés Λ(Σ) est défini de manière habituelle, avec l’aide de la logique
linéaire pour manipuler aussi bien des termes linéaires que non linéaires. Nous utilisons ici les
deux implications linéaire et intuitionniste →. Ceci est permis par le codage de la logique
intuitionniste en logique linéaire par la traduction A → B ≡ (!A) B (Girard, 1987; Danos
& Cosmo, 1992). Cela signifie qu’une variable de type α dans un terme de type α → β pourra
être abstraite plusieurs fois (mais, ici, au moins une), alors qu’elles ne l’est qu’une et une seule
fois dans un terme de type α β.
Definition 3 (Lexique). Étant donnés une signature linéaire d’ordre supérieur Σ1 = 〈A1, C1, τ1〉
et une signature d’ordre supérieur Σ2 = 〈A2, C2, τ2〉, un lexique L de Σ1 vers Σ2 est une paire
L = 〈F,G〉 telle que :
• F : A1 → T (A2) est une fonction d’interprétation des types atomiques de Σ1 comme
des types implicatifs construits à partir de A2. On appellera F également l’extension
homomorphique de F à tous les types de T (A1) ;
• G : C1 → Λ(Σ2) est une fonction d’interprétation des constantes de Σ1 comme des
λ-termes construits à partir de Σ2. On appellera G son extension homomorphique ;
• les fonctions d’interprétation sont compatibles avec la relation de typage, c’est-à-dire
que pour tout c ∈ C1,G(c) : F (τ1(c)) (le type de l’image de c est l’image du type de c).
Dans la suite, on utilisera L(a) pour F (a) ou G(a) suivant le contexte.
Definition 4 (Grammaire catégorielle abstraite). Une grammaire catégorielle abstraite est un
quadruplet G = 〈Σ1,Σ2,L, s〉 où :
• Σ1 est une signature linéaire d’ordre supérieure, et Σ2 une signature d’ordre supérieure.
Ils sont appelés vocabulaire abstrait et vocabulaire objet ;
• L : Σ1 → Σ2 est un lexique ;
• s est un type atomique du vocabulaire abstrait, appelé le type distingué de la grammaire.
Definition 5 (Langages abstrait et objet). Soit G = 〈Σ1,Σ2,L, s〉 une grammaire catégorielle
abstraite.
1. Le langage abstrait A(G) engendré par G est défini par A(G) = {t ∈ Λ(Σ1)|t : s}
2. Le langage objet O(G) engendré par G est défini par
O(G) = {t ∈ Λ(Σ2)|∃u ∈ A(G) avec t = L(u)}
3 Les grammaires d’arbres adjoints comme une ACG
Dans cette section, nous allons montrer comment une grammaire TAG peut être modélisée avec
une ACG. Nous reprenons cette modélisation de (de Groote, 2002).
Soit G = 〈Σ, N, I, A, S〉 une TAG. Σ, N , I , A et S sont respectivement l’ensemble des sym-
boles terminaux, des symboles non terminaux, l’ensemble des arbres initiaux et auxiliaires et
le symbole non terminal distingué de la grammaire. GG = 〈ΣGDT,ΣGTAG,LG, sG〉 la grammaire
catégorielle abstraite associée est construite de la manière suivante :
ΣGDT : à partir de G, on définit :
Vers un statut de l’arbre de dérivation : exemples de construction de
representations sémantiques pour les Grammaires d’Arbres Adjoints
• AGDT = {αS, αA|α ∈ N}
• CGDT = {cT |T ∈ I} ∪ {cT |T ∈ A} ∪ {Iα|α ∈ N} avec
– si T ∈ I alors cT : γ1A · · · γmA β1S  · · · βnS  αS où α est la racine
de T , les γi ses nœuds intérieurs et les βi ses nœuds où les substitutions ont lieu
– si T ∈ A alors cT : γ1A  · · · γmA  β1S  · · · βnS  αA  αA où α est
la racine de T , les γi ses nœuds intérieurs et les βi ses nœuds où les substitutions
ont lieu
– Iα est de type αA
ΣGTAG : à partir de G, on définit :
• AGTAG = {τ} où τ représentera le type arbre
• CGTAG est constitué de
– pour chaque terminal u de Σ, une constante u de type τ
– pour chaque non terminal α, des constantes αi : τ  · · · τ  τ pour
} {{ }
i fois
1 ≤ i ≤ kα, avec kα le nombre maximum de fils que peut avoir un nœud
étiqueté α dans G
Il reste maintenant à définir le lexique. Plutôt que de le définir dans sa généralité, nous don-
nerons les principes de construction à partir des arbres du tableau 1. On a alors :
• aux types αS sont associés le type τ , c’est-à-dire qu’ils correspondent à des arbres ;
• aux types αA sont associés le type τ  τ , c’est-à-dire qu’ils correspondent à des fonc-
tions transformant un arbre en arbre ;
• aux constantes Iα correspondent à l’identité λx.x.
S S
N N N VP N N N VP VP
chat tout N∗ chasse N chien un N∗ aboie VP∗ habituellement
Table 1: Exemple de lexique TAG
Un arbre tel que celui de aboie est appelé à être défini de la manière suivante : S2N(VP1 aboie)
c’est-à-dire que S2 a deux fils : N et un deuxième qui est lui-même un arbre de racine VP1 qui
a un seul fils aboie. Compte tenu de la substitution possible en N , mais aussi des adjonctions,
en particulier en VP, le lexique lui associe la forme λV λN.S2N(V (VP1 aboie)). En effet, si
un arbre T , de habituellement, est adjoint en VP1, T prend l’arbre de racine VP1 et l’ajoute à
lui-même, au niveau de son fils gauche, pour former un nouvel arbre. Autrement dit, T est de
la forme λx.VP2x habituellement , un terme d’ordre supérieur qui transforme un arbre en un
autre arbre.
Cela nous conduit par exemple au lexique d’ACG du tableau 21. On laissera le lecteur vérifier
que le typage des termes est correct.
1Pour des raisons de concision, on omet les nœuds habituels Det, V, etc. Pour les mêmes raisons, on supprime
comme paramètres les nœuds sur lesquels il n’y aura pas d’adjonction dans les exemple (on pourrait sinon les
neutraliser en leur appliquant Iα).
Sylvain Pogodalla
Constante c son type
cchien : NA NS
cchat : NA NS
ctout : NA
cun : NA
caboie : VPA NS  SS
cchasse : VPA NS  NS  SS
chabituellement : VPA VPA
c′ = L(c) ∈ Λ(ΣTAG)
c′chien = λN.N(N1 chien) : (τ  τ) τ
c′chat = λN.N(N1 chat) : (τ  τ) τ
c′tout = λx.N2 tout x : τ  τ
c′un = λx.N2 un x : τ  τ
c′aboie = λV.λx.S2x(V (VP1aboie)) : (τ  τ) τ  τ
c′chasse = λV.λx.λy.S2x(V (VP2chasse y)) : (τ  τ) τ  τ  τ
c′habituellement = λV.λx.V (VP2x habituellement ) : (τ  τ) (τ  τ)
Table 2: Lexique de GG
En neutralisant les nœuds sur lesquels aucune adjonction n’est faite par la constante Iα corre-
spondante, on a alors par exemple la correspondance entre les termes du langage abstrait de
Λ(ΣDT) et les termes du langage objet de Λ(ΣTAG) du tableau 3.
Λ(ΣDT) : caboieIVP(cchienctout) cchasseIVP(cchienctout)(cchatcun)
S
S N VP
tout N
N VP chasse N
chien
tout N aboie un N
Λ(ΣTAG) : chien chat
Table 3: Exemple de termes abstraits et des arbres dérivés correspondants dans G
Remarquons que le terme caboieIVP(cchienctout) peut s’écrire sous forme d’arbre foncteurs-arguments.
Sur cet arbre, si l’on supprime les liens vers les arguments Iα qui indiquent simplement que cer-
tains nœuds n’ont fait l’objet d’aucune adjonction, et si l’on indique le typage de l’argument
par l’orientation de la flèche, avec une flèche orientée vers le bas si l’argument est de type αS
et vers le haut si l’argument est de type αA, on obtient bien l’arbre de dérivation traditionnel de
la figure 1.
Avec une telle traduction, on a le théorème suivant (de Groote, 2002) : soit G une TAG. Le
langage d’arbre engendré par G est isomorphe aux langages objet de l’ACG GG.
Alors que l’arbre de dérivation n’est généralement utilisé que dans le cadre sémantique, nous
voyons ici que l’on peut lui donner un statut utile au calcul de l’arbre dérivé, c’est-à-dire
au cadre syntaxique. Dans la section suivante, nous allons montrer comment, en utilisant
Vers un statut de l’arbre de dérivation : exemples de construction de
representations sémantiques pour les Grammaires d’Arbres Adjoints
comme notion d’arbre de dérivation les termes du langage abstrait Λ(ΣDT), peut se constru-
ire la représentation sémantique associée aux arbres dérivés. En particulier, nous reprenons
le principe d’élévation de type utilisé pour les arbres adjoints, qui leur donne un type d’ordre
supérieur.
4 La sémantique LU comme une ACG
Le choix de la représentation sémantique pour notre expérimentation se rapproche de celui fait
dans différents articles sur la représentation sémantique en TAG, en particulier (Kallmeyer,
2002; Gardent & Kallmeyer, 2003). Il s’agit de la sémantique sous-spécifiée LU dite « à
trou » (Bos, 1995; Blackburn & Bos, 2003). Nous renvoyons le lecteur à ces deux références
pour les détails.
Le principe de LU est de spécifier entre différentes formules les relations de sous-formule. Ainsi,
la formule de LU associée à l’expression tout chien chasse un chat :
λhl.∃h1l1l2l3v1(h ≥ l2 ∧ l2 : All(v1, l3) ∧ l3 : Imp(l1, h1) ∧ h1 ≥ l ∧ h ≥ l1 ∧ l1 : chien(v1)
∧∃h′1l′1l′2l′3v′1(h ≥ l′2 ∧ l′2 : Ex(v′1, l′3) ∧ l′3 : And(l′1, h′1) ∧ h′1 ≥ l ∧ h ≥ l′1 ∧ l′1 : chat(v′1)
∧h ≥ l ∧ l : chasse(v1, v′1)))
spécifie que la formule étiquetée par l (l : chasse(v1, v′1)) soit sous-formule de celle étiquetée
par l2 (car h1 ≥ l, et h1 sous-formule de Imp(l1, h1) étiquetée par l3, elle-même sous-formule
de All(v1, l3) d’étiquette l2). De la même manière, elle doit être sous-formule de Ex(v′1, l
′
3)
étiquetée par l′2 (via h
′
1 ≥ l et l′3).
Cela donne deux formules de la logique de prédicats possibles qui vérifient cette spécification :
All(x, Imp(man(x), Ex(y, And(woman(y), love(x, y)))))
Ex(y, And(woman(y), All(x, Imp(man(x), love(x, y)))))
ou, exprimées dans la logique des prédicats usuelle :
∀x(man(x) ⇒ ∃y(woman(y) ∧ love(x, y)))
∃y(woman(y) ∧ ∀x(man(x) ⇒ love(x, y)))
Ici, nous ne nous intéressons pas à trouver les formules de la logiques des prédicats qui sat-
isfont les formule de LU. Nous ne faisons que construire des formules de LU. Pour ce faire,
nous utiliserons une signature d’ordre supérieure ΣLU = 〈ALU , CLU , τLU〉 définie de la manière
suivante2 :
• ALU = {h, l, t, p, e} sont les types représentant respectivement les trous, les étiquettes, les
descriptions d’arbre, les prédicats et les entités (t et e sont choisis pour l’analogie avec la
sémantique de Montague, en particulier pour l’élévation de type) ;
• CLU et τLU sont définis par les tableau 4 et trois quantificateurs existentiels ∃l : (l →
t)  t, ∃h : (h → t)  t et ∃e : (e → t)  t, tous notés par abus de langage ∃, et
dont l’interprétation intuitive est que ∃P est une description d’arbre satisfiable s’il existe
x respectivement étiquette, trou ou individu, P x est satisfiable. Par abus de notation
toujours, on notera ∃xP pour ∃(λx.P ) où x est une variable libre de P .
Sylvain Pogodalla
≥ : h → l → t pour spécifier les relations de dominance large entre trous
et étiquettes
: : l → p t permet d’étiqueter des prédicats
∧ : t t t permet la conjonction de descriptions
All, Ex : e → l → t destiné à être interprété comme les quantifications uni-
verselle et existentielle
And, Imp : l → h → p destiné à être interprété comme la conjonction et
l’implication
chien, chat, : e → p Prédicats habituels
aboie
chasse : e → e → p
habituellement : h → p
Table 4: Définition de la signature pour le langage de sous-spécification
Pour utiliser ΣLU , il reste à définir une ACG 〈ΣDT,ΣLU ,L〉, avec L un lexique qui lie les termes
abstraits des arbres de dérivation aux termes des descriptions d’arbre. On aura bien entendu
pour tout c, L(c) = c′′ dans le tableau 5, avec pour la transformation des types atomiques :
L(NS) = (e → h → l → t) (h → l → t) L(V PA) = (h → l → t) (h → l → t)
L(SS) = h → l → t L(NA) = (e → h → l → t) (e → h → l → t) (h → l → t)
c′′chien = λq.q(λxhl.h ≥ l ∧ l : chien(x))
c′′chat = λq.q(λxhl.h ≥ l ∧ l : chat(x))
c′′aboie = λadvλs.s(λx.adv(λhl.h ≥ l ∧ l : aboie(x)))
c′′chasse = λadvλsλo.s(λx.adv(o(λyh
′l′.h′ ≥ l′ ∧ l′ : chasse(x, y))))
c′′tout = λrp.λhl.∃h1l1l2l3v1(h ≥ l2 ∧ l2 : All(v1, l3) ∧ l3 : Imp(l1, h1)
∧h1 ≥ l ∧ r v1 h l1 ∧ p v1 h l)
c′′un = λrp.λh′l′.∃h′1l′1l′2l′3v′1(h′ ≥ l′2 ∧ l′2 : Ex(v′1, l′3) ∧ l′3 : And(l′1, h′1)
∧h′1 ≥ l′ ∧ r v′1 h′ l′1 ∧ p v′1 h′ l′)
c′′habituellement = λadv.λr.λhl.∃h1l1(r h l ∧ h ≥ l1 ∧ l1 : habituellement(h1)
∧h1 ≥ l ∧ adv(λh′l′.h′ ≥ l′)h l1)
Table 5: Quelques représentations sémantiques
Nous ne pouvons pas détailler ici les calculs, mais ce lexique rend compte de l’ambiguïté de
portée des quantificateurs, en calculant par exemple
c′′chienc
′′
tout = λphl.∃h1l1l2l3v1(h ≥ l2 ∧ l2 : All(v1, l3) ∧ l3 : Imp(l1, h1)
∧h1 ≥ l ∧ h ≥ l1 ∧ l1 : chien(v1) ∧ p v1 h l)
c′′chatc
′′
un = λph
′l′.∃h′1l′1l′2l′3v′1(h′ ≥ l′2 ∧ l′2 : Ex(v′1, l′3) ∧ l′3 : And(l′1, h′1)
∧h′1 ≥ l′ ∧ h′ ≥ l′1 ∧ l′1 : chat(v′1) ∧ p v′1 h′ l′)
L(cchasseIV P (cchienctout)(cchatcun)) = c′′chasseIV P (c′′chienc′′tout)(c′′chatc′′un)
= λhl.∃h1l1l2l3v1(h ≥ l2 ∧ l2 : All(v1, l3) ∧ l3 : Imp(l1, h1)
∧h1 ≥ l ∧ h ≥ l1 ∧ l1 : chien(v1) ∧ ∃h′1l′1l′2l′3v′1(h ≥ l′2
∧l′2 : Ex(v′1, l′3) ∧ l′3 : And(l′1, h′1) ∧ h′1 ≥ l ∧ h ≥ l′1
∧l′1 : chat(v′1) ∧ h ≥ l ∧ l : chasse(v1, v′1)))
où le prédicat chasse(v1, v′1), étiqueté par l, est dominé à la fois par l2 et l
′
2, ces deux quantifi-
2Nous remarquons que cette fois nous utilisons des termes non linéaires : si λx.P : α → β alors x est une
variable libre de P qui y apparaît une ou plusieurs fois.
Vers un statut de l’arbre de dérivation : exemples de construction de
representations sémantiques pour les Grammaires d’Arbres Adjoints
cateurs n’étant pas ordonnés l’un par rapport à l’autre.
On peut de la même manière tenir compte de l’ambiguïté introduite par les adverbes. Ainsi,
on remarquera que le terme associé à c′′habituellement agit comme un adverbe opaque : si un autre
adverbe lui est adjoint (le paramètre adv), son champ dominera l1 : habituellement(h1). Cela
rend compte de ce que si un autre adverbe est ajouté, habituellement restera toujours dans son
champs. Pour lever cette opacité, il suffirait que l’adverbe adv ne domine que le label du verbe,
soit l.
5 Conclusion
Revenant sur les diverses approches pour construire une représentation sémantique en TAG,
nous avons proposé de donner un rôle central à l’arbre de dérivation. Ce dernier est pris au
sens de terme du langage abstrait de l’ACG associée à la grammaire TAG, plus large que le
sens traditionnel. Dès lors, la représentation syntaxique (arbre dérivé) comme la représentation
sémantique s’obtiennent au bout d’un processus de calcul décrit par l’arbre de dérivation.
Si la partie syntaxique a été montrée comme complète vis-à-vis du langage d’arbre engen-
dré (de Groote, 2002), nous n’avons donné ici que quelques exemples de la pertinence de notre
approche pour le calcul sémantique en TAG. Il s’agit de poursuivre cet effort et de vérifier com-
ment modéliser les différents phénomènes identifiés comme problématiques dans (Kallmeyer,
2002; Frank & van Genabith, 2001; Gardent & Kallmeyer, 2003), en particulier pour les verbes
à contrôle. Néanmoins nous avons montré que les arbres de dérivation suffisent pour rendre
compte du rôle sémantique des quantificateurs, même en les représentant par des arbres ad-
joints.
Enfin, nous n’avons pas tenu compte des contrôles induits sur la dérivation par la présence
des traits. Pour ce faire, il sera sans doute nécessaire d’élargir encore le langage de λ-termes
en faisant intervenir les types additifs de la logique linéaire, de la même manière qu’ils sont
utilisés pour modéliser les traits dans les grammaires de types logique (Morrill, 1994).
Références
ABEILLÉ A. (1993), Les nouvelles syntaxes, Paris, Armand Colin Éditeur.
BLACKBURN P., BOS J. (2003), Computational semantics for natural language, http://www.
iccs.informatics.ed.ac.uk/~jbos/comsem/book1.html, Course Notes for NASSLLI
2003.
BOS J. (1995), Predicate logic unplugged, Proceedings of the Tenth Amsterdam Colloquium.
CANDITO M.-H., KAHANE S. (1998), Can the tag derivation tree represent a semantic graph? an
answer in the light of meaning-text theory, Proceedings of the Fourth International Workshop on Tree
Adjoining Grammars and Related Framework (TAG+4), volume 98-12 of IRCS Technical Report Series.
COPESTAKE A., FLICKINGER D., SAG I., POLLARD C. (1999), Minimal recursion semantics: An
introduction, http://www-csli.stanford.edu/~aac/papers/newmrs.pdf.
M. DALRYMPLE, Ed. (1999), Semantics and Syntax in Lexical Functional Grammar: The Resource
Logic Approach, MIT Press.
Sylvain Pogodalla
DANOS V., COSMO R. D. (1992), The linear logic primer, http://www.pps.jussieu.fr/
~dicosmo/CourseNotes/LinLog/, An introductory course on Linear Logic.
DE GROOTE P. (2000), Linear higher-order matching is np-complete, dans L. BACHMAIR, Ed., Rewrit-
ing Techniques and Applications, RTA’00, volume 1833 of LNCS, p. 127–140, Springer.
DE GROOTE P. (2001), Towards abstract categorial grammars, Association for Computational Linguis-
tics, 39th Annual Meeting and 10th Conference of the European Chapter, Proceedings of the Conference,
p. 148–155.
DE GROOTE P. (2002), Tree-adjoining grammars as abstract categorial grammars, TAG+6, Proceedings
of the sixth International Workshop on Tree Adjoining Grammars and Related Frameworks, p. 145–150,
Università di Venezia.
DOWEK G. (2001), Higher-order unification and matching, dans A. ROBINSON & A. VORONKOV,
Eds., Handbook of Automated Reasoning, volume 2, chapter 16, Elsevier Science.
FRANK A., VAN GENABITH J. (2001), Glue tag: Linear logic based semantics construction for
ltag - and what it teaches us about the relation between lfg and ltag, dans M. BUTT & T. H.
KING, Eds., Proceedings of the LFG ’01 Conference, Online Proceedings, CSLI Publications, http:
//cslipublications.stanford.edu/LFG/6/lfg01.html.
GARDENT C., KALLMEYER L. (2003), Semantic construction in feature-based tag, Proceedings of the
10th Meeting of the European Chapter of the Association for Computational Linguistics (EACL).
GIRARD J.-Y. (1987), Linear logic, Theoretical Computer Science, Vol. 50, 1–102.
J. R. HINDLEY & J. P. SELDIN, Eds. (1980), To H. B. Curry: Essays on combinatory logic, Lambda
Calculus and Formalism, Academic Press.
HOWARD W. A. (1980), The Formulæ-as-Types Notion of Construction, p. 479–490, dans (Hindley &
Seldin, 1980).
JOSHI A. K., KALLMEYER L., ROMERO M. (2003), Flexible composition in ltag: Quantifier scope
and inverse linking, dans H. BUNT, I. VAN DER SLUIS & R. MORANTE, Eds., Proceedings of the Fifth
International Workshop on Computational Semantics IWCS-5.
JOSHI A. K., LEVY L. S., TAKAHASHI M. (1975), Tree adjunct grammars, Journal of Computer and
System Sciences, Vol. 10(1), 136–163.
KALLMEYER L. (2002), Using an enriched tag derivation structure as basis for semantics, Proceedings
of the Sixth International Workshop on Tree Adjoining Grammar and Related Frameworks (TAG+6).
LAMBEK J. (1958), The mathematics of sentence structure, American Mathematical Monthly,
Vol. 65(3), 154–170.
LOADER R. (2003), Higher order β matching is undecidable, Logic Journal of the IGPL, Vol. 11(1),
51–68.
MONTAGUE R. (1974), The proper treatment of quantification in ordinary english, dans P. PORTNER &
B. H. PARTEE, Eds., Formal Semantics: The Essential Readings, chapter 1, Blackwell Publishers, 2002
edition.
MOORTGAT M. (1996), Categorial type logics, dans J. VAN BENTHEM & A. TER MEULEN, Eds.,
Handbook of Logic and Language, p. 93–177, Amsterdam, Elsevier Science Publishers.
MORRILL G. V. (1994), Type Logical Grammar Categorial Logic of Signs, Kluwer Academin Publish-
ers.
SCHABES Y., SHIEBER S. M. (1994), An alternative conception of tree-adjoining derivation, Compu-
tational Linguistics, Vol. 20(1), 91–124.
