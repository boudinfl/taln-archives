<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Application des programmes de contraintes orient&#233;s objet &#224; l&#8217;analyse du langage naturel</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2004, F&#232;s, 19&#8211;21 avril 2004
</p>
<p>Application des programmes de contraintes orient&#233;s objet &#224;
l&#8217;analyse du langage naturel
</p>
<p>Mathieu Estratat (1), Laurent Henocque (2)
LSIS
</p>
<p>Universit&#233; d&#8217;Aix-Marseille III
Avenue Escadrille Normandie-Niemen
</p>
<p>13397 Marseille cedex 20
(1) mathieu.estratat@lsis.org
</p>
<p>(2) henocque@esil.univ-mrs.fr
</p>
<p>R&#233;sum&#233; - Abstract
</p>
<p>Les &#233;volutions r&#233;centes des formalismes et th&#233;ories linguistiques font largement appel au con-
cept de contrainte. De plus, les caract&#233;ristiques g&#233;n&#233;rales des grammaires de traits ont conduit
plusieurs auteurs &#224; pointer la ressemblance existant entre ces notions et les objets ou frames.
Une &#233;volution r&#233;cente de la programmation par contraintes vers les programmes de contraintes
orient&#233;s objet (OOCP) poss&#232;de une application possible au traitement des langages naturels.
Nous proposons une traduction syst&#233;matique des concepts et contraintes d&#233;crits par les gram-
maires de propri&#233;t&#233;s sous forme d&#8217;un OOCP. Nous d&#233;taillons l&#8217;application de cette traduction
au langage &quot;context free&quot; arch&#233;typal anbn, en montrant que cette approche permet aussi bien
l&#8217;analyse que la g&#233;n&#233;ration de phrases, de prendre en compte la s&#233;mantique au sein du m&#234;me
mod&#232;le et ne requiert pas l&#8217;utilisation d&#8217;algorithmes ad hoc pour le parsage.
</p>
<p>Recent evolutions of linguistic theories heavily rely upon the concept of constraint. Also, sev-
eral authors have pointed the similitude existing between the categories of feature based theories
and the notions of objects or frames. A recent evolution of constraint programming to object
oriented constraint programs (OOCP) can be applied to natural language parsing. We propose
here a systematic translation of the concepts and constraints introduced by property grammars
to an OOCP. We apply this translation to the archetypal context free language anbn, and show
that this approach allows to both parse and generate, to account for the semantics in the same
formalism, and also that it does not require the use of ad hoc algorithms.
</p>
<p>Mots-clefs &#8211; Keywords
</p>
<p>Grammaires de propri&#233;t&#233;s, traitement du langage naturel, contraintes, configuration
Property grammars, natural language processing, constraints, configuration</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Mathieu Estratat, Laurent Henocque
</p>
<p>Introduction
</p>
<p>Les &#233;volutions r&#233;centes des formalismes et th&#233;ories linguistiques font largement appel au con-
cept de contrainte (Pollard &amp; Sag, 1994; Blache, 2000; Blache, 2001). Selon ces formalismes,
la validit&#233; d&#8217;une construction syntaxique est d&#233;finie par le respect de contraintes portant sur les
traits. De plus, les caract&#233;ristiques g&#233;n&#233;rales des grammaires de traits (Gazdar et al., 1985)
ont conduit plusieurs auteurs &#224; pointer la ressemblance existant entre ces notions et les objets
ou frames et l&#8217;h&#233;ritage m&#234;me multiple (Pollard &amp; Sag, 1994). Dans le m&#234;me temps, une &#233;vo-
lution de la programmation par contraintes vers les programmes de contraintes orient&#233;s objet
(OOCP) apporte une solution technique &#224; un probl&#232;me d&#8217;un grand int&#233;r&#234;t industriel : la config-
uration1 (voir par exemple (Fargier &amp; Henocque, 2002) pour une pr&#233;sentation g&#233;n&#233;rale et une
large bibliographie). Au del&#224; de la configuration, les OOCPs sont des CSP quantifi&#233;s ayant des
applications g&#233;n&#233;rales &#224; l&#8217;IA. Nous en pr&#233;sentons ici une application au traitement de langage
context free, travail qui a d&#233;but&#233; avec (Estratat, 2003) et qui a pour objectif le traitement de
langages naturels.
</p>
<p>programmes de contraintes orient&#233;s objet
</p>
<p>Un OOCP est un CSP quantifi&#233;, dans lequel peuvent appara&#238;tre arbitrairement quantifications
existentielles et universelles qui s&#8217;apparente &#224; un probl&#232;me de la logique des pr&#233;dicats, ind&#233;-
cidable dans le cas g&#233;n&#233;ral. C&#8217;est donc un probl&#232;me consid&#233;rablement plus g&#233;n&#233;ral que les
CSP, formul&#233; explicitement comme un probl&#232;me de recherche de mod&#232;les finis au premier or-
dre2. Un tel programme est d&#233;crit par un mod&#232;le orient&#233; objet (comme illustr&#233; par la figure 3),
assorti de contraintes de bonne formation. Une pr&#233;sentation formelle des OOCP figure dans
(Henocque, 2003). R&#233;soudre techniquement le probl&#232;me d&#8217;&#233;num&#233;ration associ&#233; &#224; une requ&#234;te
peut &#234;tre fait en utilisant divers formalismes et approches techniques: extensions des CSP (Mit-
tal &amp; Falkenhainer, 1990; Fleischanderl et al., 1998; Sabin &amp; Freuder, 1996), approches bas&#233;es
sur la connaissance (Stumptner, 1997) ou sur les logiques terminologiques (Nebel, 1990), pro-
grammation logique &#233;tendue (cha&#238;nage avant et arri&#232;re, s&#233;mantiques non standard) (Colmerauer,
1990; Fromherz et al., 1997; Soininen et al., 2000; Gelfond &amp; Lifschitz, 1988), approches &quot;pur
objet&quot;. Nos exp&#233;rimentations sont conduites avec un outil d&#8217;&#233;num&#233;ration de ce dernier type:
Ilog Jconfigurator (Mailharro, 1998). Nous avons choisis cet outil pour deux raisons majeures
: tout d&#8217;abord c&#8217;est un produit industriel ais&#233;ment acquierable (bonne diffusion), installable
facilement et proposant un large support technique. D&#8217;un autre c&#244;t&#233;, ce configurateur pro-
pose une &#233;num&#233;ration orient&#233;e objet des solutions. Son comportement lors de la recherche de
solutions est ais&#233; &#224; comprendre et facilite l&#8217;impl&#233;mentation d&#8217;heuristiques. En effet, son com-
portement est celui d&#8217;un CSP &#233;tendu dans le paradigme orient&#233; objet. De plus, la g&#233;n&#233;ration
de mod&#232;le est intuitive. Lors de la recherche de solution, la complexit&#233; d&#8217;un tel syst&#232;me est
li&#233;e d&#8217;un c&#244;t&#233; au nombre de points de choix emprunt&#233;s par le solveur et de l&#8217;autre au temps de
calcul d&#233;pendant du co&#251;t de propagation des contraintes dans le syst&#232;me.
</p>
<p>1Configurer consiste &#224; simuler la r&#233;alisation d&#8217;un produit complexe &#224; partir de composants choisis dans un
catalogue de types. Les composants sont soumis &#224; des relations (cette information est appel&#233;e &quot;partonomique&quot;),
et leurs types sont soumis &#224; des relations d&#8217;h&#233;ritage (information &quot;taxonomique&quot;). Des contraintes d&#233;finissent
les produits r&#233;alisables. Un outil de configuration prend en entr&#233;e un fragment du produit final, et compl&#232;te ces
donn&#233;es de fa&#231;on &#224; satisfaire &#224; la fois les contraintes g&#233;n&#233;rales et les contraintes et objectifs particuliers &#224; une
requ&#234;te.
</p>
<p>2Il est impossible de conna&#238;tre au d&#233;part le nombre et le type des composants qui interviendront dans une
solution d&#8217;un OOCP.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Application des OOCP &#224; l&#8217;analyse du langage naturel
</p>
<p>grammaires de propri&#233;t&#233;s
</p>
<p>Les grammaires de propri&#233;t&#233;s (GP) (Blache, 2001) constituent une th&#233;orie bas&#233;e exclusivement
sur les contraintes qui propose d&#8217;une part une classification des contraintes de traits (appel&#233;es
propri&#233;t&#233;s) et d&#8217;autre part un algorithme de parsage sp&#233;cialis&#233; exploitant la propagation de ces
contraintes. Ind&#233;pendamment des algorithmes, les grammaires de propri&#233;t&#233;s s&#8217;articulent autour
de deux notions : les cat&#233;gories qui repr&#233;sentent toute unit&#233; syntaxique du texte, associ&#233;e &#224;
un mot isol&#233; ou &#224; un groupe de mots (voir figure 1), et les propri&#233;t&#233;s (ou contraintes) portant
sur ces cat&#233;gories, qui sp&#233;cifient les r&#232;gles de bonne formation des syntagmes et les r&#232;gles de
coh&#233;sion de la phrase.
</p>
<p>cat&#233;gories et programmation par contraintes
</p>
<p>Les cat&#233;gories sont des structures de traits : des fonctions partielles d&#233;finies sur l&#8217;ensemble des
expressions linguistiques et &#224; valeur dans un certain ensemble de valeurs de traits. Cette d&#233;fi-
nition est r&#233;cursive : la valeur d&#8217;un trait peut &#234;tre un trait, ou une liste de traits. Une structure
de traits est un ensemble de couples (attribut,valeur), permettant d&#8217;&#233;tiqueter toute unit&#233; linguis-
tique, comme illustr&#233; figure 1, qui d&#233;crit Livre comme un nom commun masculin, employ&#233; &#224; la
troisi&#232;me personne du singulier. D&#8217;un point de vue fonctionnel, un trait est assimilable &#224; une
</p>
<p>&#9121;
&#9122;&#9122;&#9122;&#9122;&#9122;&#9122;&#9123;
</p>
<p>Cat: N
Phon: Livre
</p>
<p>Accord:
</p>
<p>&#9121;
&#9123;
</p>
<p>Genre: masc
Nombre: sing
Pers: 3
</p>
<p>&#9124;
&#9126;
</p>
<p>Type : commun
</p>
<p>&#9124;
&#9125;&#9125;&#9125;&#9125;&#9125;&#9125;&#9126;
</p>
<p>Figure 1: La cat&#233;gorie N
</p>
<p>variable de CSP et une structure de traits peut &#234;tre vue comme une affectation de variables &#224; des
valeurs prises dans le domaine ad&#233;quat (par exemple une &#233;num&#233;ration comme {Sing, P lur},
ou un entier comme {1, 2, 3}). En pratique, la valeur d&#8217;un trait pouvant &#234;tre un autre trait, ou
un ensemble (ordonn&#233;) de traits, les variables des CSP classiques (&#224; domaines finis) ne permet-
tent pas d&#8217;en rendre compte facilement. Il est n&#233;cessaire de disposer de variables ensemblistes,
comme celles introduites par (Mailharro, 1998).
</p>
<p>propri&#233;t&#233;s et programmation par contraintes
</p>
<p>Les propri&#233;t&#233;s sont des contraintes qui portent sur les cat&#233;gories, et sp&#233;cifient les r&#232;gles de
bonne formation des syntagmes et de coh&#233;sion de la phrase. Il y a sept sortes de propri&#233;t&#233;s
: constitution (d&#233;crit les composants possibles d&#8217;un syntagme), noyau (d&#233;crit les constituants
noyaux), unicit&#233; (contraint un constituant &#224; n&#8217;appara&#238;tre qu&#8217;une fois au plus), exigence (contraint
la cooccurence de groupes de cat&#233;gories), exclusion (idem pour la non cooccurence), lin&#233;arit&#233;
(ordre de pr&#233;c&#233;dence entre cat&#233;gories), et d&#233;pendance (contraintes entre cat&#233;gories distantes).
Par exemple Const(SN) = {Det,N, Pro, ...} est une propri&#233;t&#233; du fran&#231;ais. Ces propri&#233;t&#233;s
correspondent directement &#224; des contraintes pos&#233;es, soit sur le mod&#232;le objet sous forme de con-
traintes de cardinalit&#233;, soit en compl&#233;ment de ce dernier en sp&#233;cifiant quelles relations doivent
entretenir les instances de classes entre elles. La section 1 propose une traduction automatique
de ces propri&#233;t&#233;s.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Mathieu Estratat, Laurent Henocque
</p>
<p>plan
</p>
<p>La section 1 pr&#233;sente une traduction syst&#233;matique des grammaires de propri&#233;t&#233;s sous forme de
programmes de contraintes orient&#233;s objet. La section 2 d&#233;crit une application de cette approche
&#224; la grammaire du langage context free anbn. La section 3 d&#233;crit l&#8217;utilisation du programme de
contraintes pour le parsage ou la g&#233;n&#233;ration, et illustre la prise en charge de la s&#233;mantique. La
section 4 pr&#233;sente les r&#233;sultats obtenus. La section 5 fournit une conclusion et des perspectives.
</p>
<p>1 Traduire les GP en OOCP
</p>
<p>1.1 Un mod&#232;le objet de la syntaxe
</p>
<p>Les &#233;l&#233;ments structurels des formalismes linguistiques modernes correspondent naturellement
&#224; des concepts de programmation par contraintes orient&#233;e objet. Un trait est un attribut dont
le domaine de d&#233;finition est fini, qui correspond &#224; une variable de CSP, ensembliste ou non,
de m&#234;me domaine. Ce domaine est d&#233;fini comme l&#8217;ensemble des valeurs possibles du trait
associ&#233;. Une structure de traits est un agr&#233;gat de traits, dont les affectations sont des ensembles
de couples (attribut,valeur). De tels agr&#233;gats sont bien mod&#233;lis&#233;s par des classes d&#8217;un mod&#232;le
objet. Une cat&#233;gorie est une structure de traits nomm&#233;e, qui correspond &#233;galement &#224; une classe
dans un mod&#232;le objet, ins&#233;r&#233;e dans une hi&#233;rarchie de classes utilisant l&#8217;h&#233;ritage.
</p>
<p>De nombreux traits ont pour valeur des structures de traits, ou des ensembles de telles structures.
Cette situation est ad&#233;quatement traduite par des relations entre les classes du mod&#232;le objet
correspondant. Notamment, un syntagme est un ensemble de mots en relation avec un &#233;l&#233;ment
central appel&#233; noyau. Par exemple, un syntagme nominal est un ensemble de mots dont le noyau
est un nom (ou un pronom). Cette relation entre un syntagme et sa cat&#233;gorie noyau peut &#234;tre
formul&#233;e explicitement par une relation d&#8217;un mod&#232;le objet.
</p>
<p>La figure 1, d&#233;crit une cat&#233;gorie de GP repr&#233;sentant un Nom. Le mod&#232;le objet associ&#233;, illustr&#233;
par la figure 2 comporte trois classes. La classe catTerminale est une abstraction int&#233;grant
les traits communs &#224; toutes les cat&#233;gories terminales, par des attributs propres mais &#233;galement
par des relations de compostions avec notament la classe Accord qui impl&#233;mente les traits
de genre, nombre et personne pour toute cat&#233;gorie terminale. Ainsi, la classe N h&#233;rite des
attributs de catTerminale, l&#8217;attribut type lui &#233;tant sp&#233;cifique. Disposer d&#8217;un mod&#232;le objet permet
d&#8217;introduire des classes qui r&#233;alisent des abstractions utiles pour la simplification du mod&#232;le.
La figure 2 illustre cette possibilit&#233; par l&#8217;insertion de l&#8217;abstraction catTerminale. L&#8217;exemple
anbn d&#233;velopp&#233; en section 2 illustrera plus en d&#233;tail cette possibilit&#233;.
</p>
<p>CatTerminale
</p>
<p>&#8722;phon:string
</p>
<p>N
</p>
<p>&#8722;type:string
</p>
<p>Accord
</p>
<p>&#8722;Genre:String
</p>
<p>&#8722;Nombre:String
</p>
<p>&#8722;Pers:int 1
</p>
<p>1
</p>
<p>Figure 2: Un mod&#232;le orient&#233; objet simplifi&#233; de la cat&#233;gorie N
</p>
<p>1.2 Traduction des propri&#233;t&#233;s en contraintes du mod&#232;le objet
</p>
<p>Les propri&#233;t&#233;s peuvent &#234;tre vues comme des contraintes et des relations adjointes du mod&#232;le ob-
jet associ&#233; aux traits d&#8217;une grammaire de propri&#233;t&#233;s. Les symboles d&#233;notant des cat&#233;gories sont
des lettres majuscules (e.g. S,A,B,C . . .). Lorsqu&#8217;il existe une relation entre deux cat&#233;gories</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Application des OOCP &#224; l&#8217;analyse du langage naturel
</p>
<p>S et A, on note s.A l&#8217;ensemble des A li&#233;s &#224; une instance s de S donn&#233;e et |s.A| sa cardinal-
it&#233;. Lorsque cela est possible, &#224; des fins de simplicit&#233;, on utilise la notation &#8704;S F plut&#244;t que
&#8704;s &#8712; S F . La notation point&#233;e habituelle est utilis&#233;e pour d&#233;signer les attributs d&#8217;une classe
(ex : a.begin d&#233;signe l&#8217;attribut begin de l&#8217;objet a). Chaque cat&#233;gorie peut &#234;tre discrimin&#233;e par
des attributs de ses &#233;l&#233;ments: par exemple Det[art] d&#233;note l&#8217;ensemble des &#233;l&#233;ments appartenant
&#224; la classe Det et de type art. Pour des raisons de place mais sans perte de g&#233;n&#233;ralit&#233;, nous ne
d&#233;crivons pas ce cas g&#233;n&#233;ral dans la suite. Enfin, S d&#233;note un syntagme quelconque.
</p>
<p>Sur la base de ces d&#233;finitions, nous proposons pour chaque type de propri&#233;t&#233; les traductions qui
suivent :
</p>
<p>&#8226; Constituants (Const) :
La propri&#233;t&#233; Const(S) = {Am}m&#8712;IA sp&#233;cifie qu&#8217;un S ne peut contenir que des &#233;l&#233;ments
appartenant &#224; {Am}m&#8712;IA . Cette propri&#233;t&#233; est ad&#233;quatement d&#233;crite dans un mod&#232;le objet
par des relations de cardinalit&#233; [0, n] entre la cat&#233;gorie S et chacune des cat&#233;gories de
{Am}m&#8712;IA , comme illustr&#233; dans le mod&#232;le objet sur la figue 3.
</p>
<p>&#8226; Noyaux (Noyaux) :
La propri&#233;t&#233; Noyaux(S) = {Am}m&#8712;IA sp&#233;cifie que tout S doit avoir pour noyau (un
repr&#233;sentant d&#8217;) une des cat&#233;gories de l&#8217;ensemble {Am}m&#8712;IA . Le noyau est unique et
obligatoire dans tout syntagme. La relation Noyaux est un sous-ensemble de la rela-
tion Const. Une telle propri&#233;t&#233; est traduite en utilisant des relations comme pour les
Constituants et des contraintes de cardinalit&#233; ad&#233;quates.
</p>
<p>&#8226; Unicit&#233; (Unic) :
La propri&#233;t&#233; Unic(S) = {Am}m&#8712;IA sp&#233;cifie que la cat&#233;gorie S ne peut contenir qu&#8217;au
plus une instance de chaque Am. Les cardinalit&#233;s des relations codant la propri&#233;t&#233; de
constitution permettent l&#8217;expression de ces contraintes. Traduire l&#8217;unicit&#233; revient &#224; con-
traindre chaque relation S.Am &#224; avoir une cardinalit&#233; inf&#233;rieure ou &#233;gale &#224; 1 (ce que dans
toute la suite en l&#8217;absence d&#8217;ambigu&#239;t&#233; nous noterons |S.Am| &#8804; 1) :
</p>
<p>|{x : S.Const | x &#8712; Am}| &#8804; 1
</p>
<p>&#8226; Exigence (&#8658;) :
La propri&#233;t&#233; {Am}m&#8712;IA &#8658;S {{Bn}n&#8712;IB , {Co}o&#8712;IC} signifie que toute occurence de la
totalit&#233; des Am dans un S implique n&#233;cessairement au moins une occurence d&#8217;un des
ensembles : {Bn} ou {Co}. Cette propri&#233;t&#233; correspond &#224; la contrainte :
</p>
<p>&#8704;S(&#8704;m &#8712; IA |S.Am| &#8805; 1) &#8658; ((&#8704;n &#8712; IB |S.Bn| &#8805; 1) &#8744; (&#8704;o &#8712; IC |S.Co| &#8805; 1))
</p>
<p>&#8226; Exclusion (&#1;) :
La propri&#233;t&#233; {Am}m&#8712;IA &#1;S {Bn}n&#8712;IB sp&#233;cifie que deux ensembles de cat&#233;gories s&#8217;ex-
cluent mutuellement (&#8658; d&#233;signe ici l&#8217;implication logique et non la propri&#233;t&#233; d&#8217;exigence):
</p>
<p>&#8704;S,
{
</p>
<p>(&#8704;m &#8712; IA |S.Am| &#8805; 1) &#8658; (&#8704;n &#8712; IB |S.Bn| = 0) &#8743;
(&#8704;n &#8712; IB |S.Bn| &#8805; 1) &#8658; (&#8704;m &#8712; IA |S.Am| = 0)
</p>
<p>&#8226; Lin&#233;arit&#233; (&#8826;) :
La propri&#233;t&#233; {Am}m&#8712;IA &#8826;S {Bn}n&#8712;IB signifie que si des cat&#233;gories de {Am}m&#8712;IA coex-
istent avec des cat&#233;gories de {Bn}n&#8712;IB alors elles les pr&#233;c&#232;dent dans le syntagme. A cette</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Mathieu Estratat, Laurent Henocque
</p>
<p>fin, la repr&#233;sentation des cat&#233;gories dans le mod&#232;le objet comporte deux attributs debut
et fin (des entiers). Cette propri&#233;t&#233; est traduite par la contrainte 3 :
</p>
<p>&#8704;S &#8704;m &#8712; IA &#8704;n &#8712; IB, max({i &#8712; S.Am &#8226; i.fin}) &#8804; min({i &#8712; S.Bn &#8226; i.debut})
&#8226; D&#233;pendance (&#1;) :
</p>
<p>Cette propri&#233;t&#233; permet d&#8217;&#233;tablir des relations sp&#233;cifiques entre des cat&#233;gories distantes, en
rapport avec la s&#233;mantique (pour traduire par exemple le lien existant entre un pronom et
son r&#233;f&#233;rent dans une phrase pr&#233;c&#233;dente). Chaque cas &#233;tant sp&#233;cifique, la prise en compte
des d&#233;pendances ne peut &#234;tre pr&#233;sent&#233;e de fa&#231;on g&#233;n&#233;rique.
</p>
<p>Les sept propri&#233;t&#233;s ci-dessus sont transcrites sous forme de contraintes ind&#233;pendantes. Il est
cependant possible de d&#233;crire par une seule contrainte plusieurs propri&#233;t&#233;s (existence et unic-
it&#233; par exemple), notamment gr&#226;ce au contr&#244;le fin des cardinalit&#233;s. L&#8217;exemple d&#233;taill&#233; suivant
(figure 3) illustrera cette possibilit&#233;. Les expressions logiques codant les propri&#233;t&#233;s pr&#233;sent&#233;es
ci-dessus se traduisent imm&#233;diatement en terme de contrainte. Par exemple, la formule logique
|S.Am| &#8804; 1 pour la propri&#233;t&#233; d&#8217;unicit&#233; se traduit par : forAll(S, leq(S.getCardinality(&#8221;Am&#8221;), 1)
de mani&#232;re tr&#232;s intuitive, en effet, l&#8217;op&#233;rateur d&#8217;ingalit&#233; est postfixe dans la taduction et infixe
dans la formule logique, de m&#234;me l&#8217;op&#233;rateur de calcul de cardinalit&#233; est remplac&#233; par la m&#233;th-
ode getCardinality de la classe S.
</p>
<p>2 Application au langage anbn
</p>
<p>Nous pr&#233;sentons maintenant une application &#224; la repr&#233;sentation et au parsage du langage anbn,
arch&#233;type des grammaires context free. Cet exemple illustre de fa&#231;on simple l&#8217;ad&#233;quation des
OOCP au probl&#232;me du parsage de grammaires arbitrairement complexes et r&#233;cursives4, ce qui
est requis pour l&#8217;analyse du langage naturel et permet de r&#233;aliser concr&#232;tement un couplage
syntaxe/s&#233;mantique5. (Blache, 2001) d&#233;crit le langage anbn par les propri&#233;t&#233;s suivantes :
</p>
<p>&#9127;
&#9130;&#9130;&#9130;&#9130;&#9128;
&#9130;&#9130;&#9130;&#9130;&#9129;
</p>
<p>Constituants : Const(S) = {S, a, b};
Noyaux : Noyaux(S) = {a};
Unicite&#769; : Unic(S) = {S, a, b};
</p>
<p>Exigence : a &#8658;S b;
Linarite&#769; : a &#8826;S b; a &#8826;S S;S &#8826;S b;
</p>
<p>Cet exemple introduit trois cat&#233;gories : S(non terminal), a et b (terminales). Cette grammaire
est r&#233;cursive. S est un syntagme dont le noyau est un a. Un S contient exactement un a et un b et
optionnellement un autre S tels que a pr&#233;c&#232;de b ou a pr&#233;c&#232;de S et S pr&#233;c&#232;de b selon le cas. Nous
proposons le mod&#232;le objet illustr&#233; par la figure 3 et les contraintes de configuration associ&#233;es
pour d&#233;crire et parser ce langage. Les classes S, A, et B correspondent aux trois cat&#233;gories
pr&#233;c&#233;dentes. La classe Cat est une abstraction pour toutes les cat&#233;gories. Elle d&#233;crit notamment
les deux attributs debut et fin requis pour l&#8217;expression des propri&#233;t&#233;s de lin&#233;arit&#233;, cel&#224; simplifie
le mod&#232;le, l&#8217;h&#233;ritage permettant de ne pas r&#233;p&#233;ter ces attributs dans les sous-classes. La classe
Mot est une abstraction pour les cat&#233;gories terminales A et B qui h&#233;ritent au passage de la
relation suivant. La cat&#233;gorie Cat factorise des attributs et la classe Mot factorise des relations.
</p>
<p>3{i &#8712; S.Am &#8226; i.fin} d&#233;note l&#8217;ensemble des valeurs de l&#8217;attribut i.fin pour i variant dans l&#8217;ensemble S.Am
4La r&#233;cursivit&#233; est tr&#232;s pr&#233;sente dans le langage naturel. Notament la syntaxe du syntagme nominal (SN ) est
</p>
<p>r&#233;cursive, par exemple : &quot;[la selle [du v&#233;lo [de ma grand-m&#232;re]]]&quot;.
5Dans l&#8217;exemple trait&#233; la s&#233;mantique est simple, mais l&#8217;efficacit&#233; du couplage syntaxe/s&#233;mantique laisse
</p>
<p>pr&#233;sager de bonnes dispositions de la part des OOCP &#224; effectuer cette t&#226;che sur des grammaires plus complexes.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Application des OOCP &#224; l&#8217;analyse du langage naturel
</p>
<p>Phrase S&#233;mantique
</p>
<p>+n:int
</p>
<p>Cat
</p>
<p>+d&#233;but:int
</p>
<p>+fin:int
</p>
<p>Mot S
</p>
<p>A B
</p>
<p>1..*
</p>
<p>{ordered}
</p>
<p>sub S
0..1
</p>
<p>+
</p>
<p>0..1
suivant0..1
</p>
<p>0..1
</p>
<p>premier+
</p>
<p>Figure 3: Mod&#232;le objet pour le langage anbn
</p>
<p>La classe Phrase permet de d&#233;crire une liste de mots. Elle est &#233;galement en relation avec le
premier mot de cette liste. Chaque Mot hors le dernier poss&#232;de un mot suivant. Chaque S est
en relation avec un A, un B et optionnellement un autre S. La classe Se&#769;mantique mod&#233;lise la
s&#233;mantique d&#8217;une entr&#233;e (ici le nombre n de r&#233;p&#233;titions de A). Les classes S et Phrase sont
en relation entre elles (cela associe une phrase &#224; sa repr&#233;sentation syntaxique), et avec la classe
Se&#769;mantique : chaque unit&#233; syntaxique a une s&#233;mantique associ&#233;e.
</p>
<p>Dans cet exemple, les propri&#233;t&#233;s de constitution, de noyau, d&#8217;unicit&#233; et d&#8217;exigence sont im-
plicitement d&#233;crites par les relations du mod&#232;le et leurs multiplicit&#233;s, ce qui illustre la remarque
finale de la section pr&#233;c&#233;dente.
</p>
<p>&#9127;
&#9128;
&#9129;
</p>
<p>|S.A| = 1; (tout S contient un A)
|S.B| = 1; (tout S contient un B)
|S.S| = {0, 1}; (tout S contient &#233;ventuellement un autre S)
</p>
<p>Les propri&#233;t&#233;s de lin&#233;arit&#233;, sont d&#233;crites par des contraintes compl&#233;mentaires &#224; ce mod&#232;le :
&#9127;
&#9128;
&#9129;
</p>
<p>&#8704;S , S.A.debut &lt; S.B.debut;
&#8704;S , (|S.S| == 1) &#8658; (S.A.fin &#8804; S.S.debut);
&#8704;S , (|S.S| == 1) &#8658; (S.B.debut &#8805; S.S.fin);
</p>
<p>2.1 S&#233;mantique
</p>
<p>Dans ce cas particuli&#232;rement simple, la s&#233;mantique associ&#233;e &#224; une phrase de anbn est naturelle-
ment le nombre n. La classe Se&#769;mantique du mod&#232;le comprend donc un attribut de type entier
: n. Le nombre S.Se&#769;mantique.n repr&#233;sente le nombre total de A dans un S. Les contraintes
qui lient la s&#233;mantique &#224; la syntaxe sont les suivantes :
</p>
<p>&#9127;
&#9128;
&#9129;
</p>
<p>&#8704;S (|S.S| == 1) &#8658; S.Se&#769;mantique.n = 1 + S.S.Se&#769;mantique.n
&#8704;S (|S.S| == 0) &#8658; S.Se&#769;mantique.n = 1
&#8704;Phrase Phrase.Se&#769;mantique = Phrase.S.Se&#769;mantique;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Mathieu Estratat, Laurent Henocque
</p>
<p>Ces contraintes d&#233;finissent r&#233;cursivement la s&#233;mantique associ&#233;e &#224; un S comme le nombre de
A qu&#8217;il contient, et la s&#233;mantique d&#8217;une phrase comme la s&#233;mantique associ&#233;e &#224; son syntagme
de plus haut niveau.
</p>
<p>3 Parsage
</p>
<p>Un programme de contraintes orient&#233; objet est utilis&#233; de la mani&#232;re suivante : il re&#231;oit en
entr&#233;e un groupe d&#8217;objets partiellement connus et partiellement inter connect&#233;s (par exemple des
instances de Mot li&#233;s par la relation suivant). Les &#233;l&#233;ments ainsi fournis forment une partie de
la solution (s&#8217;il en existe). Un programme sp&#233;cialis&#233; (nous avons utilis&#233; le configurateur orient&#233;
objet d&#8217;Ilog (Mailharro, 1998)) peut alors compl&#233;ter les donn&#233;es entr&#233;es par de nouveaux objets,
par l&#8217;&#233;tablissement des relations manquantes et par la d&#233;termination exacte des types et des
attributs. Dans notre cas, ce mode de fonctionnement permet d&#8217;utiliser la grammaire traduite
sous forme d&#8217;un programme de contraintes orient&#233; objet soit en mode analyse, soit en mode
g&#233;n&#233;ration, voire de mani&#232;re hybride, tout en prenant en compte la s&#233;mantique. Si une suite
de mots est fournie en entr&#233;e, le programme produit l&#8217;arbre syntaxique et la s&#233;mantique. Si un
fragment de l&#8217;arbre syntaxique, ou la s&#233;mantique, ou une suite de mots incompl&#232;te, est donn&#233;e,
le programme g&#233;n&#232;re si elle existe la suite de mots valide correspondante, tout en compl&#233;tant
ce qui doit l&#8217;&#234;tre. La figure 4 illustre ce comportement. Les &#233;tats du syst&#232;me y sont d&#233;crits par
des tuples &#12296;mots, syntaxe, se&#769;mantique&#12297; (le caract&#232;re ? d&#233;note un objet inconnu et le caract&#232;re
&#11; un mot inconnu) et son comportement par des r&#232;gles e&#769;tat entre&#769;e &#12;&#8594; e&#769;tat sortie. Les deux
&#9127;
&#9130;&#9130;&#9128;
&#9130;&#9130;&#9129;
</p>
<p>&#12296;aaabbb, ?, ?&#12297; &#12;&#8594; &#12296;aaabbb, S(A, S(A, S(A, null, B), B), B), 3&#12297;
&#12296;abbb, ?, ?&#12297; &#12;&#8594; false
&#12296;&#11; a &#11; b, ?, ?&#12297; &#12;&#8594; &#12296;aabb, S(A, S(A, null, B), B), 2&#12297;
&#12296;?, ?, 2&#12297; &#12;&#8594; &#12296;aabb, S(A, S(A, null, B), B), 2&#12297;
</p>
<p>Figure 4: Exemples de parsage
</p>
<p>premiers cas sont des exemples de parsage pur. Dans le deuxi&#232;me cas, la phrase fournie en
entr&#233;e n&#8217;appartient pas au langage. Les autres exemples illustrent le fonctionnement g&#233;n&#233;ratif
ou hybride du programme.
</p>
<p>4 R&#233;sultats
</p>
<p>La figure 5 pr&#233;sente les r&#233;sultats obtenus6 pour des entr&#233;es (consistantes et inconsistantes) de
diff&#233;rentes tailles. Les r&#233;sultats (nombre de backtracks, nombre de points de choix, temps
en secondes) sont donn&#233;s d&#8217;une part pour la production de la premi&#232;re solution si elle existe,
d&#8217;autre part pour le parcours de l&#8217;espace de recherche complet. Une entr&#233;e est d&#233;finie par
une suite de Mot li&#233;s entre eux par la relation suivant (c.f. figure 3) et n&#8217;incorpore aucune
autre information susceptible de guider le parsage. La totalit&#233; du travail d&#8217;analyse reste donc &#224;
faire par le configurateur. Les temps de calcul qui peuvent para&#238;tre &#233;lev&#233;s pour des &quot;phrases&quot;
de 100 mots sont fortement influenc&#233;s par l&#8217;utilisation du langage Java et par la complexit&#233;
de la propagation des contraintes ensemblistes (qui est corr&#233;lee polynomialement au nombre
d&#8217;objets). De fa&#231;on plus remarquable, on observe que ce probl&#232;me n&#8217;est pas combinatoire.
On montrerait ais&#233;ment que la profondeur de l&#8217;espace de recherche est en O(5n), n &#233;tant le
nombre de mots. On observe que le nombre de points de choix (appel&#233;s ici &quot;noeuds&quot;) comme
le nombre de backtracks (ou &quot;fails&quot;) sont born&#233;s par cette valeur. L&#8217;espace de recherche est
</p>
<p>6Pentium4 2,4GHz - 512 Mo DDR - Windows XP Professional SP1 - Java 2 V.1.4.2 - Ilog Jconfigurator 2.08</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Application des OOCP &#224; l&#8217;analyse du langage naturel
</p>
<p>mot Nb Cont Nb V ar 1e&#768;resolution terminaison
Fails Noeuds Tps Fails Noeuds Tps
</p>
<p>aaabbb 105 74 0 20 0,38 s 20 20 0,41 s
&#11; a &#11; b 145 104 0 29 0,5 s 29 29 0,53 s
</p>
<p>a(10) b(10) 383 300 0 92 0,8 s 92 92 0,84 s
a(20) b(20) 723 580 0 182 1,44 s 182 182 1,66 s
a(50) b(50) 1743 1420 0 452 5,53 s 452 452 5,69 s
a(51) b(49) 1743 1420 - - - 1 0 4,62 s
&#11; a(50) b(49) 1740 1419 - - - 1 0 4,61 s
</p>
<p>Figure 5: R&#233;sultats exp&#233;rimentaux
</p>
<p>de taille lin&#233;aire, donc le probl&#232;me est polynomial si l&#8217;on tient compte des contraintes. De
plus, le fait que lorsque l&#8217;entr&#233;e est inconsistante (a(51) b(49) et &#11; a(50) b(49)) le programme
termine sans point de choix montre que la propagation des contraintes suffit &#224; d&#233;tecter cette
inconsistance. Notons que notre mod&#232;le impl&#233;mente une contrainte redondante tr&#232;s g&#233;n&#233;rale
pour briser les sym&#233;tries existant entre les instances des cat&#233;gories non-terminales (les valeurs
des attributs begin de toutes les instances de S sont ordonn&#233;es) et la s&#233;mantique.
</p>
<p>5 Conclusion
</p>
<p>Nous avons d&#233;crit une traduction des grammaires de propri&#233;t&#233;s sous forme d&#8217;un programme de
contraintes orient&#233; objet, et montr&#233; que ce programme peut &#234;tre utilis&#233; aussi bien de mani&#232;re
analytique (construire l&#8217;arbre syntaxique d&#8217;une phrase bien form&#233;e) que de mani&#232;re g&#233;n&#233;rative
(produire une phrase bien form&#233;e sous contraintes). Cela place cette approche au niveau des
grammaires de clauses d&#233;finies (Definite Clause Grammars en Prolog (Colmerauer, 1978)) et au
dessus des formalismes reposant sur l&#8217;utilisation de r&#232;gles exploit&#233;es en cha&#238;nage avant comme
les constraint grammars (Karlsson, 1990). La compl&#233;tion d&#8217;entr&#233;e incompl&#232;te, ou la g&#233;n&#233;ration
de phrases, a beaucoup d&#8217;applications pratiques.
</p>
<p>(Blache, 2001) pr&#233;sente un formalisme reposant exclusivement sur des contraintes, mais em-
ploie un algorithme ad hoc pour la propagation et le parsage. De plus, la coop&#233;ration de la s&#233;-
mantique avec la syntaxe lors de l&#8217;analyse n&#8217;est pas abord&#233;e. Mod&#233;liser la syntaxe sous forme
d&#8217;un programme de contraintes orient&#233; objet donne acc&#232;s &#224; la grande gamme de contraintes
disponibles dans ce cadre, et permet l&#8217;utilisation d&#8217;algorithmes g&#233;n&#233;raux.
</p>
<p>La s&#233;mantique v&#233;hicul&#233;e par des textes descriptifs simples peut &#234;tre d&#233;crite comme un OOCP
(de nombreux articles sur la configuration utilisent un exemple de configuration de PC (Soini-
nen et al., 2000)). Dans une telle situation nos exp&#233;rimentations montrent que le mod&#232;le s&#233;-
mantique peut &#234;tre combin&#233; avec le mod&#232;le syntaxique. Ainsi, syntaxe et s&#233;mantique coop&#232;rent
&#233;troitement lors de l&#8217;analyse ou de la g&#233;n&#233;ration. Nos recherches s&#8217;orientent actuellement vers
l&#8217;impl&#233;mentation d&#8217;un parseur du langage naturel pour un sous-ensemble du fran&#231;ais, dans le
cadre de la description de sc&#232;nes 3D (La Greca &amp; Daniel, 2002).
</p>
<p>Remerciements
</p>
<p>Ces travaux de recherche ont pu &#234;tre r&#233;alis&#233;s gr&#226;ce &#224; un financement JemSTIC du CNRS.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Mathieu Estratat, Laurent Henocque
</p>
<p>R&#233;f&#233;rences
</p>
<p>BLACHE P. (2000). Property grammars and the problem of constraint satisfaction. In ESSLLI-2000
workshop on Linguistic Theory and Grammar Implementation.
</p>
<p>BLACHE P. (2001). Les Grammaires de Propri&#233;t&#233;s : des contraintes pour le traitement automatique des
langues naturelles. Herm&#232;s Sciences.
</p>
<p>COLMERAUER A. (1978). Metamorphosis grammars. Lecture Notes on Computer Science, 63, 133&#8211;
189.
</p>
<p>COLMERAUER A. (1990). An introduction to prolog 3. communication of the ACM, 33(7), 69&#8211;90.
</p>
<p>ESTRATAT M. (2003). Application de la configuration &#224; l&#8217;analyse syntaxico s&#233;mantique de descriptions.
Master&#8217;s thesis, Facult&#233; des Sciences et Techniques de Saint J&#233;r&#244;me, LSIS &#233;quipe InCA, Marseille,
France, submitted for the obtention of the DEA degree.
</p>
<p>FARGIER H. &amp; HENOCQUE H. (2002). Configuration &#224; base de contraintes. Information Interaction
Intelligence, Actes des 2i&#232;mes Assises nationales du GdR I3, p. 141&#8211;159.
</p>
<p>FLEISCHANDERL G., FRIEDRICH G., HASELB&#214;CK A., SCHREINER H. &amp; STUMPTNER M. (1998).
Configuring large-scale systems with generative constraint satisfaction. IEEE Intelligent Systems - Spe-
cial issue on Configuration, 13(7).
</p>
<p>FROMHERZ M., GUPTA V. &amp; SARASWAT V. (1997). cc - a generic framework for dommain specific
languages. POPL Workshop on Domain Specific Languages, p. 89&#8211;96.
</p>
<p>GAZDAR G., KLEIN E., PULLUM G. &amp; SAG I. (1985). Generalized Phrase Structure Grammar. Ox-
ford: Blackwell.
</p>
<p>GELFOND M. &amp; LIFSCHITZ V. (1988). The stable modem semantics for logic programming. In 5th In-
ternational Conf&#233;rence and Symposium on Logic Programming, p. 1070&#8211;1080, Cambridge: MIT Press.
</p>
<p>HENOCQUE L. (2003). Modeling Object Oriented Constraint Programs in Z. Rapport interne, LSIS
Research Report, available at http://arXiv.org/abs/cs/0312020.
</p>
<p>KARLSSON J. (1990). Constraint grammar as a framework for parsing running text. In COLING-90,
13th International Conference on Computational Linguistics, volume 3, p. 168&#8211;173: H. Karlgren.
</p>
<p>LA GRECA R. &amp; DANIEL M. (2002). Mod&#233;lisation d&#233;clarative : De la description vers les mod&#232;les. In
Proceedings of Journ&#233;es Des Doctorants du LSIS, p. 3&#8211;12.
</p>
<p>MAILHARRO D. (1998). A classification and constraint based framework for configuration. AI-EDAM :
Special issue on Configuration, 12(4), 383 &#8211; 397.
</p>
<p>MITTAL S. &amp; FALKENHAINER B. (1990). Dynamic constraint satisfaction problems. In Proceedings
of AAAI-90, p. 25&#8211;32.
</p>
<p>NEBEL B. (1990). Reasoning and revision in hybrid representation systems. Lecture Notes in Artificial
Intelligence, 422.
</p>
<p>POLLARD C. &amp; SAG I. (1994). Head-Driven Phrase Structure Grammar. Chicago: The University of
Chicago Press.
</p>
<p>SABIN S. &amp; FREUDER E. (1996). Configuration as composite constraint satisfaction. Artificial Intelli-
gence and Manufacturing Research Planning Workshop, p. 153&#8211;161.
</p>
<p>SOININEN T., NIEMEL&#213; I., TIIHONEN J. &amp; SULONEN R. (2000). Unified configuration knowledge
representation using weight constraint rules. In ECAI 2000 Configuration Workshop.
</p>
<p>STUMPTNER M. (1997). An overview of knowledge-based configuration. AI Communications, 10(2),
111&#8211;125.</p>

</div></div>
</body></html>