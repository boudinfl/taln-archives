TALN 2004, Fés, 19-21 avril 2004

Application des programmes de contraintes orientes objet a
l’analyse du langage naturel

Mathieu Estratat (1), Laurent Henocque (2)
LSIS
Universite d’Aix—Marseille III
Avenue Escadrille Normandie—Niemen
13397 Marseille cedex 20
(1) mathieu.estratat@lsis.org
(2) henocque@esil.univ—mrs.fr

Resume - Abstract

Les evolutions recentes des formalismes et theories linguistiques font largement appel au con-
cept de conlrainte. De plus, les caracteristiques generales des grammaires de traits ont conduit
plusieurs auteurs a pointer la ressemblance existant entre ces notions et les objets ou frames.
Une evolution recente de la programmation par contraintes vers les programmes de contraintes
orientes objet (OOCP) possede une application possible au traitement des langages naturels.
Nous proposons une traduction systematique des concepts et contraintes decrits par les gram-
maires de proprietes sous forme d’un OOCP. Nous detaillons l’application de cette traduction
au langage "context free" archetypal a"b", en montrant que cette approche permet aussi bien
l’analyse que la generation de phrases, de prendre en compte la semantique au sein du meme
modele et ne requiert pas l’utilisation d’algorithmes ad hoc pour le parsage.

Recent evolutions of linguistic theories heavily rely upon the concept of constraint. Also, sev-
eral authors have pointed the similitude existing between the categories of feature based theories
and the notions of objects or frames. A recent evolution of constraint programming to object
oriented constraint programs (OOCP) can be applied to natural language parsing. We propose
here a systematic translation of the concepts and constraints introduced by property grammars
to an OOCP. We apply this translation to the archetypal context free language a"b", and show
that this approach allows to both parse and generate, to account for the semantics in the same
formalism, and also that it does not require the use of ad hoc algorithms.

Mots-clefs — Keywords

Grammaires de proprietes, traitement du langage naturel, contraintes, conﬁguration
Property grammars, natural language processing, constraints, conﬁguration

Mathieu Eslratat, Laurent Henocque

Introduction

Les e’volutions récentes des formalismes et théories linguistiques font largement appel au con-
cept de conlrainte (Pollard & Sag, 1994; Blache, 2000; Blache, 2001). Selon ces formalismes,
la validité d’une construction syntaxique est déﬁnie par le respect de contraintes portant sur les
traits. De plus, les caractéristiques générales des grammaires de traits (Gazdar et al., 1985)
ont conduit plusieurs auteurs a pointer la ressemblance existant entre ces notions et les objets
ou frames et l’héritage meme multiple (Pollard & Sag, 1994). Dans le meme temps, une evo-
lution de la programmation par contraintes vers les programmes de contraintes oriente’s objet
(OOCP) apporte une solution technique a un probleme d’un grand inte’rét industriel : la conﬁg-
urationl (voir par exemple (Fargier & Henocque, 2002) pour une pre’sentation générale et une
large bibliographie). Au dela de la conﬁguration, les OOCPs sont des CSP quantiﬁe’s ayant des
applications ge’nérales a l’IA. Nous en présentons ici une application au traitement de langage
context free, travail qui a de’bute’ avec (Estratat, 2003) et qui a pour objectif le traitement de
langages naturels.

programmes de contraintes orientés objet

Un OOCP est un CSP quantiﬁe’, dans lequel peuvent apparaitre arbitrairement quantiﬁcations
existentielles et universelles qui s’apparente a un probleme de la logique des prédicats, inde-
cidable dans le cas géne’ral. C’est donc un probleme conside’rablement plus géne’ral que les
CSP, formule’ explicitement comme un probleme de recherche de modeles ﬁnis au premier or-
dre2. Un tel programme est décrit par un modele orienté objet (comme illustré par la ﬁgure 3),
assorti de contraintes de bonne formation. Une pre’sentation formelle des OOCP ﬁgure dans
(Henocque, 2003). Résoudre techniquement le probleme d’énumération associe’ a une requéte
peut étre fait en utilisant divers formalismes et approches techniques: extensions des CSP (Mit-
tal & Falkenhainer, 1990; Fleischanderl et al., 1998; Sabin & Freuder, 1996), approches basées
sur la connaissance (Stumptner, 1997) ou sur les logiques terminologiques (Nebel, 1990), pro-
grammation logique étendue (chainage avant et arriere, se’mantiques non standard) (Colmerauer,
1990; Fromherz et al., 1997; Soininen et al., 2000; Gelfond & Lifschitz, 1988), approches "pur
objet". Nos expérimentations sont conduites avec un outil d’e’numération de ce dernier type:
Ilog Jconﬁgurator (Mailharro, 1998). Nous avons choisis cet outil pour deux raisons majeures
: tout d’abord c’est un produit industriel aisément acquierable (bonne diffusion), installable
facilement et proposant un large support technique. D’un autre cote, ce conﬁgurateur pro-
pose une énumération orientée objet des solutions. Son comportement lors de la recherche de
solutions est aise’ a comprendre et facilite l’implémentation d’heuristiques. En effet, son com-
portement est celui d’un CSP étendu dans le paradigme orienté objet. De plus, la ge’nération
de modele est intuitive. Lors de la recherche de solution, la complexite’ d’un tel systeme est
lie’e d’un cote’ au nombre de points de choix emprunte’s par le solveur et de l’autre au temps de
calcul dependant du coﬁt de propagation des contraintes dans le systeme.

1Conﬁgurer consiste a simuler la réalisation d’un produit complexe a partir de composants choisis dans un
catalogue de types. Les composants sont soumis a des relations (cette information est appelée "partonomique"),
et leurs types sont soumis a des relations d’héritage (information "taxonomique"). Des contraintes déﬁnissent
les produits réalisables. Un outil de conﬁguration prend en entrée un fragment du produit ﬁnal, et complete ces
données de facon a satisfaire a la fois les contraintes générales et les contraintes et objectifs particuliers a une
requéte.

211 est impossible de connaitre au départ le nombre et le type des composants qui interviendront dans une
solution d’un OOCP.

Application des OOCP ii l’analyse du langage naturel

grammaires de propriétés

Les grammaires de proprie’tés (GP) (Blache, 2001) constituent une théorie base’e exclusivement
sur les contraintes qui propose d’une part une classiﬁcation des contraintes de traits (appele’es
proprie’te’s) et d’autre part un algorithme de parsage specialise’ exploitant la propagation de ces
contraintes. Indépendamment des algorithmes, les grammaires de proprie’tés s’articulent autour
de deux notions : les categories qui représentent toute unite’ syntaxique du texte, associe’e a
un mot isole’ ou a un groupe de mots (Voir ﬁgure 1), et les proprie’te’s (ou contraintes) portant
sur ces catégories, qui spe’ciﬁent les regles de bonne formation des syntagmes et les regles de
cohésion de la phrase.

catégories et programmation par contraintes

Les catégories sont des structures de traits : des fonctions partielles de’ﬁnies sur l’ensemble des
expressions linguistiques et a Valeur dans un certain ensemble de Valeurs de traits. Cette deﬁ-
nition est récursive : la Valeur d’un trait peut étre un trait, ou une liste de traits. Une structure
de traits est un ensemble de couples (attribut,Valeur), permettant d’étiqueter toute unite’ linguis-
tique, comme illustré ﬁgure 1, qui décrit Livre comme un nom commun masculin, employé a la
troisieme personne du singulier. D’un point de Vue fonctionnel, un trait est assimilable a une

Cat: N
Phon: Livre

Genre: masc
Accord: Nombre: sing

Pers.' 3
Type .' commun

Figure 1: La catégorie N

Variable de CSP et une structure de traits peut étre Vue comme une affectation de Variables a des
Valeurs prises dans le domaine adéquat (par exemple une énumération comme {S'ing, Plur},
ou un entier comme «[1, 2, 3}). En pratique, la Valeur d’un trait pouvant étre un autre trait, ou
un ensemble (ordonne’) de traits, les Variables des CSP classiques (a domaines ﬁnis) ne permet-
tent pas d’en rendre compte facilement. Il est nécessaire de disposer de Variables ensemblistes,
comme celles introduites par (Mailharro, 1998).

propriétés et programmation par contraintes

Les proprie’te’s sont des contraintes qui portent sur les catégories, et spéciﬁent les regles de
bonne formation des syntagmes et de cohésion de la phrase. 11 y a sept sortes de proprie’tés
: constitution (décrit les composants possibles d’un syntagme), noyau (décrit les constituants
noyaux), unicite’ (contraint un constituant a n’apparaitre qu’une fois au plus), exigence (contraint
la cooccurence de groupes de catégories), exclusion (idem pour la non cooccurence), line’arite’
(ordre de précédence entre catégories), et dependance (contraintes entre catégories distantes).
Par exemple C'onst(S'N) = {Det, N, Pro,  est une propriéte’ du frangais. Ces proprie’tés
correspondent directement a des contraintes pose’es, soit sur le modele objet sous forme de con-
traintes de cardinalite’, soit en complement de ce dernier en spe’ciﬁant quelles relations doivent
entretenir les instances de classes entre elles. La section 1 propose une traduction automatique
de ces propriéte’s.

Mathieu Estratat, Laurent Henocque

plan

La section 1 présente une traduction systématique des grammaires de proprie’tés sous forme de
programmes de contraintes oriente’s objet. La section 2 décrit une application de cette approche
51 la grammaire du langage context free a"b". La section 3 décrit l’utilisation du programme de
contraintes pour le parsage ou la generation, et illustre la prise en charge de la sémantique. La
section 4 présente les résultats obtenus. La section 5 fournit une conclusion et des perspectives.

1 Traduire les GP en OOCP

1.1 Un modéle objet de la syntaxe

Les éléments structurels des formalismes linguistiques modernes correspondent naturellement
51 des concepts de programmation par contraintes oriente’e objet. Un trait est un attribut dont
le domaine de deﬁnition est ﬁni, qui correspond 51 une Variable de CSP, ensembliste ou non,
de meme domaine. Ce domaine est déﬁni comme l’ensemble des Valeurs possibles du trait
associe’. Une structure de traits est un agre’gat de traits, dont les affectations sont des ensembles
de couples (attribut,Valeur). De tels agrégats sont bien modélisés par des classes d’un modele
objet. Une catégorie est une structure de traits nommée, qui correspond également 51 une classe
dans un modele objet, inse’re’e dans une hiérarchie de classes utilisant l’héritage.

De nombreux traits ont pour Valeur des structures de traits, ou des ensembles de telles structures.
Cette situation est ade’quatement traduite par des relations entre les classes du modele objet
correspondant. Notamment, un syntagme est un ensemble de mots en relation avec un élément
central appele’ noyau. Par exemple, un syntagme nominal est un ensemble de mots dont le noyau
est un nom (ou un pronom). Cette relation entre un syntagme et sa catégorie noyau peut étre
formule’e explicitement par une relation d’un modele obj et.

La ﬁgure 1, décrit une catégorie de GP représentant un Nom. Le modele objet associe’, illustré
par la ﬁgure 2 comporte trois classes. La classe catTerminale est une abstraction intégrant
les traits communs 51 toutes les categories terminales, par des attributs propres mais également
par des relations de compostions avec notament la classe Accord qui implémente les traits
de genre, nombre et personne pour toute catégorie terminale. Ainsi, la classe N hérite des
attributs de caﬂerminale, l’attribut type lui étant spéciﬁque. Disposer d’un modele objet permet
d’introduire des classes qui réalisent des abstractions utiles pour la simpliﬁcation du modele.
La ﬁgure 2 illustre cette possibilité par l’insertion de l’abstraction eatTerm2'nale. L’eXemple
anbn développé en section 2 illustrera plus en détail cette possibilite’.

Accord
CatTerminale N

-Genre:S1ring 1 _ _
_Nombre:smng -phon:smng qj -type:sInng
-Pers:im 1

Figure 2: Un modele orienté objet simpliﬁé de la catégorie N

1.2 Traduction des propriétés en contraintes du modéle objet

Les proprie’tés peuvent étre Vues comme des contraintes et des relations adjointes du modele ob-
jet associe’ aux traits d’une grammaire de propriétés. Les symboles dénotant des categories sont
des lettres majuscules (e.g. S, A, B, C . . .). Lorsqu’il existe une relation entre deux categories

Application des OOCP it l’analyse du langage nature]

5' et A, on note s.A l’ensemble des A lies a une instance 3 de 5' donne’e et |s.A| sa cardinal-
ite’. Lorsque cela est possible, a des ﬁns de simplicité, on utilise la notation VS’ F plutot que
Vs E S’ F. La notation pointée habituelle est utilise’e pour désigner les attributs d’une classe
(ex : a.beg2'n désigne l’attribut begin de l’objet a). Chaque catégorie peut étre discrimine’e par
des attributs de ses éléments: par exemple Detwt] dénote l’ensemble des éléments appartenant
a la classe Det et de type art. Pour des raisons de place mais sans perte de ge’néralité, nous ne
décrivons pas ce cas géne’ral dans la suite. Enﬁn, 5' denote un syntagme quelconque.

Sur la base de ces de’ﬁnitions, nous proposons pour chaque type de proprie’te’ les traductions qui
suivent :

o Constituants (Const) :
La proprie’te’ C'0nst(S') = {Am}m€1A spéciﬁe qu’un S ne peut contenir que des éle’ments
appartenant a {Am}m€1A. Cette proprie’te’ est ade’quatement décrite dans un modele obj et
par des relations de cardinalite’ [0, n] entre la catégorie S’ et chacune des categories de
{Am}m€1A, comme illustré dans le modele objet sur la ﬁgue 3.

o Noyaux (Noyaux) :
La proprie’te’ N 0yauac(S') = {Am}m€1A spéciﬁe que tout S’ doit avoir pour noyau (un
représentant d’) une des catégories de l’ensemble {Am}m€1A. Le noyau est unique et
obligatoire dans tout syntagme. La relation N oyauac est un sous—ensemble de la rela-
tion Const. Une telle proprie’te’ est traduite en utilisant des relations comme pour les
C onstituants et des contraintes de cardinalité adéquates.

o Unicité (Unic) :
La proprie’te’ U m'c(S') = {Am}m€1A spéciﬁe que la catégorie S’ ne peut contenir qu’au
plus une instance de chaque Am. Les cardinalite’s des relations codant la propriété de
constitution permettent l’eXpression de ces contraintes. Traduire l’unicite’ revient a con-
traindre chaque relation S'.Am a avoir une cardinalite’ inférieure ou é gale a 1 (ce que dans
toute la suite en l’absence d’ambigu'1'té nous noterons |S'.Am| 3 1) :

|{ac : S'.C'0nst | an E Am}| 3 1

o Exigence (=>) :
La proprie’te’ {Am}me1A =>g {{Bn}ne1B,{C'0}oE1C} signiﬁe que toute occurence de la
totalite’ des Am dans un S’ implique nécessairement au moins une occurence d’un des
ensembles : {BR} ou {Co}. Cette proprie’te’ correspond a la contrainte :

vs(vm e IA |S.Am| 2 1) :~ ((Vn e 13 |S.Bn| 3 1) v (V0 e Io |s.00| 2 1))

o Exclusion (¢#>) :
La proprie’te’ {Am}me1A #>g {Bn}n€;B spéciﬁe que deux ensembles de catégories s’ex—
cluent mutuellement (=> désigne ici l’implication logique et non la propriété d’eXigence):

VS,{ (Vm E IA |S'.Am| Z 1) => (Vn E IB |S'.Bn| = 0) /\
’ (Vn E IB |S'.Bn| Z 1) => (Vm E IA |S'.Am| = 0)

o Linéarité (4) :
La proprie’te’ {Am}me1A <3 {Bn}n€;B signiﬁe que si des catégories de {Am}m€1A coex-
istent avec des categories de {Bn}nE1B alors elles les precedent dans le syntagme. A cette

Mathieu Eslratat, Laurent Henocque

ﬁn, la representation des categories dans le modele objet comporte deux attributs debut
et f in (des entiers). Cette propriete est traduite par la contrainte 3 :

VS’ Vm E IA Vn E I3, maw({2' E S'.Am 0  3  E S'.Bn o z'.debut})

o Dépendance (~—>) :
Cette propriete permet d’etablir des relations speciﬁques entre des categories distantes, en
rapport avec la semantique (pour traduire par exemple le lien existant entre un pronom et
son referent dans une phrase precedente). Chaque cas etant speciﬁque, la prise en compte
des dependances ne peut etre presentee de fagon generique.

Les sept proprietes ci—dessus sont transcrites sous forme de contraintes independantes. Il est
cependant possible de decrire par une seule contrainte plusieurs proprietes (existence et unic-
ite par exemple), notamment grace au controle ﬁn des cardinalites. L’exemple detaille suivant
(ﬁgure 3) illustrera cette possibilite. Les expressions logiques codant les proprietes presentees
ci—dessus se traduisent immediatement en terme de contrainte. Par exemple, la formule logique
|S'.Am| 3 1 pour la propriete d’unicite se traduit par: f 0rAll (S, leq(S'.getC'ard2'nal2'ty(”Am” ),
de maniere tres intuitive, en effet, l’operateur d’ingalite est postﬁxe dans la taduction et inﬁxe
dans la formule logique, de meme l’operateur de calcul de cardinalite est remplace par la meth-
ode getC'ardz'nal2'ty de la classe S’.

2 Application au langage a,"b"

Nous presentons maintenant une application a la representation et au parsage du langage a"b",
archetype des grammaires context free. Cet exemple illustre de facon simple l’adequation des
OOCP au probleme du parsage de grammaires arbitrairement complexes et recursiVes4, ce qui
est requis pour l’analyse du langage naturel et permet de realiser concretement un couplage
syntaxe/semantique5. (Blache, 2001) decrit le langage a"b" par les proprietes suivantes :

Constituants : C'0nst(S') = {S', a, b};
Noyauw : N0yauac(S') = {a};
Unicité : Um'c(S') = {S', a, b};

Eacigence : a =>g b;
Linarité: a <3 b; a <3 5'; 5' <5 b;

Cet exemple introduit trois categories : S'(non terminal), a et b (terminales). Cette grammaire
est recursive. S’ est un syntagme dont le noyau est un a. Un S’ contient exactement un a et un b et
optionnellement un autre S’ tels que a precede b ou a precede S’ et 5' precede b selon le cas. Nous
proposons le modele objet illustre par la ﬁgure 3 et les contraintes de conﬁguration associees
pour decrire et parser ce langage. Les classes 5', A, et B correspondent aux trois categories
precedentes. La classe Cat est une abstraction pour toutes les categories. Elle decrit notamment
les deux attributs debut et f in requis pour l’expression des proprietes de linearite, cela simpliﬁe
le modele, l’heritage permettant de ne pas repeter ces attributs dans les sous—classes. La classe
M at est une abstraction pour les categories terminales A et B qui heritent au passage de la
relation suivant. La categorie Cat factorise des attributs et la classe M at factorise des relations.

3{i E S'.Am 0 i.  denote l’ensemble des valeurs de l’attribut z'.fin pour i variant dans l’ensemble S'.Am

4La recursivite est tres presente dans le langage naturel. Notament la syntaxe du syntagme nominal (SN) est
recursive, par exemple 2 "[la selle [du velo [de ma grand-mere]]]".

5Dans l’exemple traite la semantique est simple, mais l’efﬁcacite du couplage syntaxe/semantique laisse
presager de bonnes dispositions de la part des OOCP a effectuer cette tache sur des grammaires plus complexes.

Application des OOCP it l’analyse du langage naturel

Phrase Sémantique
+n:int
Cat
+début:int
+fin:int
1.." + premier
{ordered}
Mot S
0--1 2.33 s
0..1 - i
sulvant 0H1
A B

Figure 3: Modele objet pour le langage a"b"

La classe Phrase permet de décrire une liste de mots. Elle est e’galement en relation avec le
premier mot de cette liste. Chaque M at hors le dernier possede un mot suivant. Chaque S’ est
en relation avec un A, un B et optionnellement un autre S’. La classe Sémantique mode'lise la
sémantique d’une entre’e (ici le nombre n de répétitions de A). Les classes 5' et Phrase sont
en relation entre elles (cela associe une phrase a sa représentation syntaxique), et avec la classe
Sémantique : Chaque unite’ syntaxique a une sémantique associée.

Dans cet exemple, les proprie’te’s de constitution, de noyau, d’um'cite’ et d’exigence sont im-
plicitement décrites par les relations du modele et leurs multiplicite’s, ce qui illustre la remarque
ﬁnale de la section précédente.

|S'.A| = 1; (tout S’ contient un A)
|S'.B| = 1; (tout S’ contient un B)
|S'.S'| = «[0, 1}; (tout S’ contient éventuellement un autre 5')

Les proprie’tés de line’arite’, sont décrites par des contraintes complémentaires a ce modele :

VS’ , S'.A.debut < S'.B.debut;
VS’ , (|S'.S'| == 1) => (S'.A.fz'n 3 S'.S'.debut);
VS’ , (|S'.S'| == 1) => (S'.B.debut Z S'.S'.f2'n);

2.1 Sémantique

Dans ce cas particulierement simple, la sémantique associe’e a une phrase de a"b" est naturelle—
ment le nombre n. La classe Sémantique du modele comprend donc un attribut de type entier
: n. Le nombre S'.S'émantz'que.n représente le nombre total de A dans un 5'. Les contraintes
qui lient la sémantique a la syntaxe sont les suivantes :

VS’ (|S'.S'| == 1) => S'.S'émantz'que.n = 1 + S'.S'.S'émant2'que.n
VS’ (|S'.S'| == 0) => S'.S'émantz'que.n = 1
‘v’Ph7'ase Ph7'ase.S'émant2'que = Ph7'ase.S'.S'émant2'que;

Mathieu Eslratat, Laurent Henocque

Ces contraintes déﬁnissent récursivement la sémantique associe’e a un S’ comme le nombre de
A qu’il contient, et la sémantique d’une phrase comme la sémantique associe’e a son syntagme
de plus haut niveau.

3 Parsage

Un programme de contraintes orienté objet est utilise’ de la maniere suivante : il regoit en
entre’e un groupe d’objets partiellement connus et partiellement inter connecte’s (par exemple des
instances de M at lie’s par la relation suivant). Les éle’ments ainsi fournis forment une partie de
la solution (s’il en existe). Un programme specialise’ (nous avons utilise’ le conﬁgurateur orienté
objet d’Ilog (Mailharro, 1998)) peut alors compléter les données entrées par de nouveaux objets,
par l’e’tablissement des relations manquantes et par la determination exacte des types et des
attributs. Dans notre cas, ce mode de fonctionnement permet d’utiliser la grammaire traduite
sous forme d’un programme de contraintes orienté objet soit en mode analyse, soit en mode
ge’nération, voire de maniere hybride, tout en prenant en compte la sémantique. Si une suite
de mots est fournie en entre’e, le programme produit l’arbre syntaxique et la sémantique. Si un
fragment de l’arbre syntaxique, ou la sémantique, ou une suite de mots incomplete, est donne’e,
le programme génere si elle existe la suite de mots Valide correspondante, tout en comple’tant
ce qui doit l’étre. La ﬁgure 4 illustre ce comportement. Les états du systeme y sont décrits par
des tuples (mots, syntaace, sémantique) (le caractere ? dénote un obj et inconnu et le caractere
<> un mot inconnu) et son comportement par des regles état entrée I—> état sortie. Les deux

aaabbb, ?, ?) I—> (aaabbb, S'(A, S'(A, S'(A, null, B), B), B), 3)
abbb,?,?) I—> false

<>a <> b,?,?) I—> (aabb,S'(A,S'(A,null,B),B),2)

?,?,2) I—> (aabb,S'(A,S'(A,null,B),B),2)

/\/\/\/\

Figure 4: Exemples de parsage

premiers cas sont des exemples de parsage pur. Dans le deuxieme cas, la phrase fournie en
entre’e n’appartient pas au langage. Les autres exemples illustrent le fonctionnement génératif
ou hybride du programme.

4 Résultats

La ﬁgure 5 présente les résultats obtenus6 pour des entrées (consistantes et inconsistantes) de
diffe’rentes tailles. Les résultats (nombre de backtracks, nombre de points de choix, temps
en secondes) sont donne’s d’une part pour la production de la premiere solution si elle existe,
d’autre part pour le parcours de l’espace de recherche complet. Une entre’e est déﬁnie par
une suite de M at lie’s entre eux par la relation suivant (c.f. ﬁgure 3) et n’incorpore aucune
autre information susceptible de guider le parsage. La totalite’ du travail d’analyse reste donc a
faire par le conﬁgurateur. Les temps de calcul qui peuvent paraitre éleve’s pour des "phrases"
de 100 mots sont fortement inﬂuence’s par l’utilisation du langage Java et par la complexite’
de la propagation des contraintes ensemblistes (qui est corre’lee polynomialement au nombre
d’objets). De facon plus remarquable, on observe que ce probleme n’est pas combinatoire.
On montrerait aisément que la profondeur de l’espace de recherche est en O(5n), n étant le
nombre de mots. On observe que le nombre de points de choix (appelés ici "noeuds") comme
le nombre de backtracks (ou "fails") sont bornés par cette valeur. L’espace de recherche est

6Pentium4 2,4GHz - 512 Mo DDR - VV1ndows XP Professional SP1 - Java 2 V.1.4.2 - Ilog Jconﬁgurator 2.08

Application des OOCP it l’analyse du langage naturel

mot Nb C ont Nb Var lemsolution terminaison
F ails N oeuds Tps F ails N oeuds Tps

aaabbb 105 74 0 20 0,38 S 20 20 0,41 S

<> a <> (2 145 104 0 29 0,5 S 29 29 0,53 S
a(10) b(10) 383 300 0 92 0,8 s 92 92 0,84 s
a(20) b(20) 723 580 0 182 1,44 s 182 182 1,66 s
a(50) b(50) 1743 1420 0 452 5,53 s 452 452 5,69 s
a(51) b(49) 1743 1420 — — — 1 0 4,62 s
<> a(50) b(49) 1740 1419 — — — 1 0 4,61 s

Figure 5: Re’sultats expérimentaux

de taille linéaire, donc le probleme est polynomial Si l’on tient compte des contraintes. De
plus, le fait que lorsque l’entre’e est inconsistante (a(51) b(49) et <> a(50) b(49)) le programme
termine sans point de choix montre que la propagation des contraintes sufﬁt a détecter cette
inconsistance. Notons que notre modele implémente une contrainte redondante tres générale
pour briser les symétries existant entre les instances des categories non—terminales (les Valeurs
des attributs begin de toutes les instances de 5' sont ordonne’es) et la sémantique.

5 Conclusion

Nous avons décrit une traduction des grammaires de proprie’tés sous forme d’un programme de
contraintes orienté objet, et montre’ que ce programme peut étre utilise’ aussi bien de maniere
analytique (construire l’arbre syntaxique d’une phrase bien formée) que de maniere générative
(produire une phrase bien forme’e sous contraintes). Cela place cette approche au niveau des
grammaires de clauses de’ﬁnies (Deﬁnite Clause Grammars en Prolog (Colmerauer, 1978)) et au
dessus des formalismes reposant sur l’utilisation de regles eXploite’es en chainage avant comme
les constraint grammars (Karlsson, 1990). La completion d’entre’e incomplete, ou la ge’nération
de phrases, a beaucoup d’applications pratiques.

(Blache, 2001) présente un formalisme reposant exclusivement sur des contraintes, mais em-
ploie un algorithme ad hoc pour la propagation et le parsage. De plus, la cooperation de la se’—
mantique avec la syntaxe lors de l’analyse n’est pas abordée. Mode’liser la syntaxe sous forme
d’un programme de contraintes orienté objet donne acces a la grande gamme de contraintes
disponibles dans ce cadre, et permet l’utilisation d’algorithmes généraux.

La sémantique Véhicule’e par des textes descriptifs simples peut étre décrite comme un OOCP
(de nombreux articles sur la conﬁguration utilisent un exemple de conﬁguration de PC (Soini—
nen et al., 2000)). Dans une telle situation nos expérimentations montrent que le modele se’—
mantique peut étre combiné avec le modele syntaxique. Ainsi, syntaxe et sémantique cooperent
étroitement lors de l’analyse ou de la génération. Nos recherches s’orientent actuellement Vers
l’implémentation d’un parseur du langage naturel pour un sous—ensemble du frangais, dans le
cadre de la description de scenes 3D (La Greca & Daniel, 2002).

Remerciements

Ces travaux de recherche ont pu étre re’alise’s grace a un ﬁnancement J emSTIC du CNRS.

Mathieu Estratat, Laurent Henocque

Références

BLACHE P. (2000). Property grammars and the problem of constraint satisfaction. In ESSLLI—2000
workshop on Linguistic Theory and Grammar Implementation.

BLACHE P. (2001). Les Grammaires de Proprie’te’s .' des contraintes pour le traitement automatique des
langues naturelles. Hermes Sciences.

COLMERAUER A. (1978). Metamorphosis grammars. Lecture Notes on Computer Science, 63, 133-
189.

COLMERAUER A. (1990). An introduction to prolog 3. communication of the ACM, 33(7), 69-90.

ESTRATAT M. (2003). Application de la conﬁguration a l’analyse syntaxico sémantique de descriptions.
Master’s thesis, Faculté des Sciences et Techniques de Saint Jerome, LSIS équipe InCA, Marseille,
France, submitted for the obtention of the DEA degree.

FARGIER H. & HENOCQUE H. (2002). Conﬁguration a base de contraintes. Information Interaction
Intelligence, Actes des 2iemes Assises nationales du GdR I3, p. 141-159.

FLEISCHANDERL G., FRIEDRICH G., HASELBDCK A., SCHREINER H. & STUMPTNER M. (1998).
Conﬁguring large—scale systems with generative constraint satisfaction. IEEE Intelligent Systems — Spe-
cial issue on Conﬁguration, 13(7).

FROMHERZ M., GUPTA V. & SARASWAT V. (1997). cc — a generic framework for dommain speciﬁc
languages. POPL Workshop on Domain Speciﬁc Languages, p. 89-96.

GAZDAR G., KLEIN E., PULLUM G. & SAG I. (1985). Generalized Phrase Structure Grammar. Ox-
ford: Blackwell.

GELFOND M. & LIFSCHITZ V. (1988). The stable modem semantics for logic programming. In 5th In-
ternational Confe’rence and Symposium on Logic Programming, p. 1070-1080, Cambridge: MIT Press.

HENOCQUE L. (2003). Modeling Object Oriented Constraint Programs in Z. Rapport interne, LSIS
Research Report, available at http://arXiv.org/abs/cs/0312020.

KARLSSON J. (1990). Constraint grammar as a framework for parsing running text. In COLING—90,
I 3th International Conference on Computational Linguistics, volume 3, p. 168-173: H. Karl gren.

LA GRECA R. & DANIEL M. (2002). Modélisation declarative : De la description vers les modeles. In
Proceedings of Journe’es Des Doctorants du LSIS, p. 3-12.

MAILHARRO D. (1998). A classiﬁcation and constraint based framework for conﬁguration. AI—EDAM .'
Special issue on Conﬁguration, 12(4), 383 - 397.

MITTAL S. & FALKENHAINER B. (1990). Dynamic constraint satisfaction problems. In Proceedings
ofAAAI—90, p. 25-32.

NEBEL B. (1990). Reasoning and revision in hybrid representation systems. Lecture Notes in Artiﬁcial
Intelligence, 422.

POLLARD C. & SAG I. (1994). Head—Driven Phrase Structure Grammar. Chicago: The University of
Chicago Press.

SABIN S. & FREUDER E. (1996). Conﬁguration as composite constraint satisfaction. Artiﬁcial Intelli-
gence and Manufacturing Research Planning Workshop, p. 153-161.

SOININEN T., NIEMEL6 I., TIIHONEN J. & SULONEN R. (2000). Uniﬁed conﬁguration knowledge
representation using weight constraint rules. In ECAI 2000 Conﬁguration Workshop.

STUMPTNER M. (1997). An overview of knowledge—based conﬁguration. AI Communications, 10(2),
1 1 1-125.

