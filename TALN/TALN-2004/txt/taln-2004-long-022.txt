TALN 2004, Fès, 19–21 avril 2004
Application des programmes de contraintes orientés objet à
l’analyse du langage naturel

Mathieu Estratat (1), Laurent Henocque (2)
LSIS
Université d’Aix-Marseille III
Avenue Escadrille Normandie-Niemen
13397 Marseille cedex 20
(1) mathieu.estratat@lsis.org
(2) henocque@esil.univ-mrs.fr
Résumé - Abstract

Les évolutions récentes des formalismes et théories linguistiques font largement appel au con-
cept de contrainte. De plus, les caractéristiques générales des grammaires de traits ont conduit
plusieurs auteurs à pointer la ressemblance existant entre ces notions et les objets ou frames.
Une évolution récente de la programmation par contraintes vers les programmes de contraintes
orientés objet (OOCP) possède une application possible au traitement des langages naturels.
Nous proposons une traduction systématique des concepts et contraintes décrits par les gram-
maires de propriétés sous forme d’un OOCP. Nous détaillons l’application de cette traduction
au langage "context free" archétypal an bn , en montrant que cette approche permet aussi bien
l’analyse que la génération de phrases, de prendre en compte la sémantique au sein du même
modèle et ne requiert pas l’utilisation d’algorithmes ad hoc pour le parsage.
Recent evolutions of linguistic theories heavily rely upon the concept of constraint. Also, sev-
eral authors have pointed the similitude existing between the categories of feature based theories
and the notions of objects or frames. A recent evolution of constraint programming to object
oriented constraint programs (OOCP) can be applied to natural language parsing. We propose
here a systematic translation of the concepts and constraints introduced by property grammars
to an OOCP. We apply this translation to the archetypal context free language an bn , and show
that this approach allows to both parse and generate, to account for the semantics in the same
formalism, and also that it does not require the use of ad hoc algorithms.
Mots-clefs – Keywords

Grammaires de propriétés, traitement du langage naturel, contraintes, configuration
Property grammars, natural language processing, constraints, configuration
Mathieu Estratat, Laurent Henocque
Introduction

Les évolutions récentes des formalismes et théories linguistiques font largement appel au con-
cept de contrainte (Pollard & Sag, 1994; Blache, 2000; Blache, 2001). Selon ces formalismes,
la validité d’une construction syntaxique est définie par le respect de contraintes portant sur les
traits. De plus, les caractéristiques générales des grammaires de traits (Gazdar et al., 1985)
ont conduit plusieurs auteurs à pointer la ressemblance existant entre ces notions et les objets
ou frames et l’héritage même multiple (Pollard & Sag, 1994). Dans le même temps, une évo-
lution de la programmation par contraintes vers les programmes de contraintes orientés objet
(OOCP) apporte une solution technique à un problème d’un grand intérêt industriel : la config-
uration1 (voir par exemple (Fargier & Henocque, 2002) pour une présentation générale et une
large bibliographie). Au delà de la configuration, les OOCPs sont des CSP quantifiés ayant des
applications générales à l’IA. Nous en présentons ici une application au traitement de langage
context free, travail qui a débuté avec (Estratat, 2003) et qui a pour objectif le traitement de
langages naturels.
programmes de contraintes orientés objet
Un OOCP est un CSP quantifié, dans lequel peuvent apparaître arbitrairement quantifications
existentielles et universelles qui s’apparente à un problème de la logique des prédicats, indé-
cidable dans le cas général. C’est donc un problème considérablement plus général que les
CSP, formulé explicitement comme un problème de recherche de modèles finis au premier or-
dre2 . Un tel programme est décrit par un modèle orienté objet (comme illustré par la figure 3),
assorti de contraintes de bonne formation. Une présentation formelle des OOCP figure dans
(Henocque, 2003). Résoudre techniquement le problème d’énumération associé à une requête
peut être fait en utilisant divers formalismes et approches techniques: extensions des CSP (Mit-
tal & Falkenhainer, 1990; Fleischanderl et al., 1998; Sabin & Freuder, 1996), approches baseés
sur la connaissance (Stumptner, 1997) ou sur les logiques terminologiques (Nebel, 1990), pro-
grammation logique étendue (chaînage avant et arrière, sémantiques non standard) (Colmerauer,
1990; Fromherz et al., 1997; Soininen et al., 2000; Gelfond & Lifschitz, 1988), approches "pur
objet". Nos expérimentations sont conduites avec un outil d’énumération de ce dernier type:
Ilog Jconfigurator (Mailharro, 1998). Nous avons choisis cet outil pour deux raisons majeures
: tout d’abord c’est un produit industriel aisément acquierable (bonne diffusion), installable
facilement et proposant un large support technique. D’un autre côté, ce configurateur pro-
pose une énumération orienteé objet des solutions. Son comportement lors de la recherche de
solutions est aisé à comprendre et facilite l’implémentation d’heuristiques. En effet, son com-
portement est celui d’un CSP étendu dans le paradigme orienté objet. De plus, la génération
de modèle est intuitive. Lors de la recherche de solution, la complexité d’un tel système est
lieé d’un côté au nombre de points de choix empruntés par le solveur et de l’autre au temps de
calcul dépendant du coût de propagation des contraintes dans le système.

1
Configurer consiste à simuler la réalisation d’un produit complexe à partir de composants choisis dans un
catalogue de types. Les composants sont soumis à des relations (cette information est appeleé "partonomique"),
et leurs types sont soumis à des relations d’héritage (information "taxonomique"). Des contraintes définissent
les produits réalisables. Un outil de configuration prend en entreé un fragment du produit final, et complète ces
donneés de façon à satisfaire à la fois les contraintes générales et les contraintes et objectifs particuliers à une
requête.
2
Il est impossible de connaître au départ le nombre et le type des composants qui interviendront dans une
solution d’un OOCP.
Application des OOCP à l’analyse du langage naturel
grammaires de propriétés
Les grammaires de propriétés (GP) (Blache, 2001) constituent une théorie baseé exclusivement
sur les contraintes qui propose d’une part une classification des contraintes de traits (appeleés
propriétés) et d’autre part un algorithme de parsage spécialisé exploitant la propagation de ces
contraintes. Indépendamment des algorithmes, les grammaires de propriétés s’articulent autour
de deux notions : les catégories qui représentent toute unité syntaxique du texte, associeé à
un mot isolé ou à un groupe de mots (voir figure 1), et les propriétés (ou contraintes) portant
sur ces catégories, qui spécifient les règles de bonne formation des syntagmes et les règles de
cohésion de la phrase.

catégories et programmation par contraintes
Les catégories sont des structures de traits : des fonctions partielles définies sur l’ensemble des
expressions linguistiques et à valeur dans un certain ensemble de valeurs de traits. Cette défi-
nition est récursive : la valeur d’un trait peut être un trait, ou une liste de traits. Une structure
de traits est un ensemble de couples (attribut,valeur), permettant d’étiqueter toute unité linguis-
tique, comme illustré figure 1, qui décrit Livre comme un nom commun masculin, employé à la
troisième personne du singulier. D’un point de vue fonctionnel, un trait est assimilable à une

⎡                                       ⎤
Cat:         N
⎢ Phon:        Livre                 ⎥
⎢              ⎡                   ⎤ ⎥
⎢                 Genre:      masc   ⎥
⎢                                    ⎥
⎢ Accord:      ⎣ Nombre:      sing ⎦ ⎥
⎢                                    ⎥
⎣                 Pers:       3      ⎦
Type :       commun
Figure 1: La catégorie N

variable de CSP et une structure de traits peut être vue comme une affectation de variables à des
valeurs prises dans le domaine adéquat (par exemple une énumération comme {Sing, P lur},
ou un entier comme {1, 2, 3}). En pratique, la valeur d’un trait pouvant être un autre trait, ou
un ensemble (ordonné) de traits, les variables des CSP classiques (à domaines finis) ne permet-
tent pas d’en rendre compte facilement. Il est nécessaire de disposer de variables ensemblistes,
comme celles introduites par (Mailharro, 1998).

propriétés et programmation par contraintes
Les propriétés sont des contraintes qui portent sur les catégories, et spécifient les règles de
bonne formation des syntagmes et de cohésion de la phrase. Il y a sept sortes de propriétés
: constitution (décrit les composants possibles d’un syntagme), noyau (décrit les constituants
noyaux), unicité (contraint un constituant à n’apparaître qu’une fois au plus), exigence (contraint
la cooccurence de groupes de catégories), exclusion (idem pour la non cooccurence), linéarité
(ordre de précédence entre catégories), et dépendance (contraintes entre catégories distantes).
Par exemple Const(SN ) = {Det, N, P ro, ...} est une propriété du français. Ces propriétés
correspondent directement à des contraintes poseés, soit sur le modèle objet sous forme de con-
traintes de cardinalité, soit en complément de ce dernier en spécifiant quelles relations doivent
entretenir les instances de classes entre elles. La section 1 propose une traduction automatique
de ces propriétés.
Mathieu Estratat, Laurent Henocque
plan
La section 1 présente une traduction systématique des grammaires de propriétés sous forme de
programmes de contraintes orientés objet. La section 2 décrit une application de cette approche
à la grammaire du langage context free an bn . La section 3 décrit l’utilisation du programme de
contraintes pour le parsage ou la génération, et illustre la prise en charge de la sémantique. La
section 4 présente les résultats obtenus. La section 5 fournit une conclusion et des perspectives.
1 Traduire les GP en OOCP
1.1 Un modèle objet de la syntaxe
Les éléments structurels des formalismes linguistiques modernes correspondent naturellement
à des concepts de programmation par contraintes orienteé objet. Un trait est un attribut dont
le domaine de définition est fini, qui correspond à une variable de CSP, ensembliste ou non,
de même domaine. Ce domaine est défini comme l’ensemble des valeurs possibles du trait
associé. Une structure de traits est un agrégat de traits, dont les affectations sont des ensembles
de couples (attribut,valeur). De tels agrégats sont bien modélisés par des classes d’un modèle
objet. Une catégorie est une structure de traits nommeé, qui correspond également à une classe
dans un modèle objet, inséreé dans une hiérarchie de classes utilisant l’héritage.
De nombreux traits ont pour valeur des structures de traits, ou des ensembles de telles structures.
Cette situation est adéquatement traduite par des relations entre les classes du modèle objet
correspondant. Notamment, un syntagme est un ensemble de mots en relation avec un élément
central appelé noyau. Par exemple, un syntagme nominal est un ensemble de mots dont le noyau
est un nom (ou un pronom). Cette relation entre un syntagme et sa catégorie noyau peut être
formuleé explicitement par une relation d’un modèle objet.
La figure 1, décrit une catégorie de GP représentant un Nom. Le modèle objet associé, illustré
par la figure 2 comporte trois classes. La classe catTerminale est une abstraction intégrant
les traits communs à toutes les catégories terminales, par des attributs propres mais également
par des relations de compostions avec notament la classe Accord qui implémente les traits
de genre, nombre et personne pour toute catégorie terminale. Ainsi, la classe N hérite des
attributs de catTerminale, l’attribut type lui étant spécifique. Disposer d’un modèle objet permet
d’introduire des classes qui réalisent des abstractions utiles pour la simplification du modèle.
La figure 2 illustre cette possibilité par l’insertion de l’abstraction catT erminale. L’exemple
an bn développé en section 2 illustrera plus en détail cette possibilité.
Accord
CatTerminale             N
−Genre:String    1
−phon:string      −type:string
−Nombre:String
−Pers:int            1
Figure 2: Un modèle orienté objet simplifié de la catégorie N
1.2 Traduction des propriétés en contraintes du modèle objet
Les propriétés peuvent être vues comme des contraintes et des relations adjointes du modèle ob-
jet associé aux traits d’une grammaire de propriétés. Les symboles dénotant des catégories sont
des lettres majuscules (e.g. S, A, B, C . . .). Lorsqu’il existe une relation entre deux catégories
Application des OOCP à l’analyse du langage naturel
S et A, on note s.A l’ensemble des A liés à une instance s de S donneé et |s.A| sa cardinal-
ité. Lorsque cela est possible, à des fins de simplicité, on utilise la notation ∀S F plutôt que
∀s ∈ S F . La notation pointeé habituelle est utiliseé pour désigner les attributs d’une classe
(ex : a.begin désigne l’attribut begin de l’objet a). Chaque catégorie peut être discrimineé par
des attributs de ses éléments: par exemple Det[art] dénote l’ensemble des éléments appartenant
à la classe Det et de type art. Pour des raisons de place mais sans perte de généralité, nous ne
décrivons pas ce cas général dans la suite. Enfin, S dénote un syntagme quelconque.
Sur la base de ces définitions, nous proposons pour chaque type de propriété les traductions qui
suivent :
• Constituants (Const) :
La propriété Const(S) = {Am }m∈IA spécifie qu’un S ne peut contenir que des éléments
appartenant à {Am }m∈IA . Cette propriété est adéquatement décrite dans un modèle objet
par des relations de cardinalité [0, n] entre la catégorie S et chacune des catégories de
{Am }m∈IA , comme illustré dans le modèle objet sur la figue 3.

• Noyaux (Noyaux) :
La propriété N oyaux(S) = {Am }m∈IA spécifie que tout S doit avoir pour noyau (un
représentant d’) une des catégories de l’ensemble {Am }m∈IA . Le noyau est unique et
obligatoire dans tout syntagme. La relation N oyaux est un sous-ensemble de la rela-
tion Const. Une telle propriété est traduite en utilisant des relations comme pour les
Constituants et des contraintes de cardinalité adéquates.

• Unicité (Unic) :
La propriété U nic(S) = {Am }m∈IA spécifie que la catégorie S ne peut contenir qu’au
plus une instance de chaque Am . Les cardinalités des relations codant la propriété de
constitution permettent l’expression de ces contraintes. Traduire l’unicité revient à con-
traindre chaque relation S.Am à avoir une cardinalité inférieure ou égale à 1 (ce que dans
toute la suite en l’absence d’ambiguïté nous noterons |S.Am | ≤ 1) :

|{x : S.Const | x ∈ Am }| ≤ 1

• Exigence (⇒) :
La propriété {Am }m∈IA ⇒S {{Bn }n∈IB , {Co }o∈IC } signifie que toute occurence de la
totalité des Am dans un S implique nécessairement au moins une occurence d’un des
ensembles : {Bn } ou {Co }. Cette propriété correspond à la contrainte :

∀S(∀m ∈ IA |S.Am | ≥ 1) ⇒ ((∀n ∈ IB |S.Bn | ≥ 1) ∨ (∀o ∈ IC |S.Co | ≥ 1))

• Exclusion ( ) :
La propriété {Am }m∈IA S {Bn }n∈IB spécifie que deux ensembles de catégories s’ex-
cluent mutuellement (⇒ désigne ici l’implication logique et non la propriété d’exigence):

(∀m ∈ IA |S.Am | ≥ 1) ⇒ (∀n ∈ IB |S.Bn | = 0) ∧
∀S,
(∀n ∈ IB |S.Bn | ≥ 1) ⇒ (∀m ∈ IA |S.Am | = 0)

• Linéarité (≺) :
La propriété {Am }m∈IA ≺S {Bn }n∈IB signifie que si des catégories de {Am }m∈IA coex-
istent avec des catégories de {Bn }n∈IB alors elles les précèdent dans le syntagme. A cette
Mathieu Estratat, Laurent Henocque
fin, la représentation des catégories dans le modèle objet comporte deux attributs debut
et f in (des entiers). Cette propriété est traduite par la contrainte 3 :

∀S ∀m ∈ IA ∀n ∈ IB , max({i ∈ S.Am • i.f in}) ≤ min({i ∈ S.Bn • i.debut})

• Dépendance ( ) :
Cette propriété permet d’établir des relations spécifiques entre des catégories distantes, en
rapport avec la sémantique (pour traduire par exemple le lien existant entre un pronom et
son référent dans une phrase précédente). Chaque cas étant spécifique, la prise en compte
des dépendances ne peut être présenteé de façon générique.

Les sept propriétés ci-dessus sont transcrites sous forme de contraintes indépendantes. Il est
cependant possible de décrire par une seule contrainte plusieurs propriétés (existence et unic-
ité par exemple), notamment grâce au contrôle fin des cardinalités. L’exemple détaillé suivant
(figure 3) illustrera cette possibilité. Les expressions logiques codant les propriétés présenteés
ci-dessus se traduisent immédiatement en terme de contrainte. Par exemple, la formule logique
|S.Am | ≤ 1 pour la propriété d’unicité se traduit par : f orAll(S, leq(S.getCardinality(”Am ”), 1)
de manière très intuitive, en effet, l’opérateur d’ingalité est postfixe dans la taduction et infixe
dans la formule logique, de même l’opérateur de calcul de cardinalité est remplacé par la méth-
ode getCardinality de la classe S.

2 Application au langage anbn
Nous présentons maintenant une application à la représentation et au parsage du langage an bn ,
archétype des grammaires context free. Cet exemple illustre de façon simple l’adéquation des
OOCP au problème du parsage de grammaires arbitrairement complexes et récursives4 , ce qui
est requis pour l’analyse du langage naturel et permet de réaliser concrètement un couplage
syntaxe/sémantique5 . (Blache, 2001) décrit le langage an bn par les propriétés suivantes :
⎪   Constituants : Const(S) = {S, a, b};
⎨        N oyaux : N oyaux(S) = {a};
e : U nic(S) = {S, a, b};
U nicit́
⎪       Exigence : a ⇒S b;
Linarité : a ≺S b; a ≺S S; S ≺S b;

Cet exemple introduit trois catégories : S(non terminal), a et b (terminales). Cette grammaire
est récursive. S est un syntagme dont le noyau est un a. Un S contient exactement un a et un b et
optionnellement un autre S tels que a précède b ou a précède S et S précède b selon le cas. Nous
proposons le modèle objet illustré par la figure 3 et les contraintes de configuration associeés
pour décrire et parser ce langage. Les classes S, A, et B correspondent aux trois catégories
précédentes. La classe Cat est une abstraction pour toutes les catégories. Elle décrit notamment
les deux attributs debut et f in requis pour l’expression des propriétés de linéarité, celà simplifie
le modèle, l’héritage permettant de ne pas répéter ces attributs dans les sous-classes. La classe
M ot est une abstraction pour les catégories terminales A et B qui héritent au passage de la
relation suivant. La catégorie Cat factorise des attributs et la classe M ot factorise des relations.
3
{i ∈ S.Am • i.f in} dénote l’ensemble des valeurs de l’attribut i.f in pour i variant dans l’ensemble S.Am
4
La récursivité est très présente dans le langage naturel. Notament la syntaxe du syntagme nominal (SN ) est
récursive, par exemple : "[la selle [du vélo [de ma grand-mère]]]".
5
Dans l’exemple traité la sémantique est simple, mais l’efficacité du couplage syntaxe/sémantique laisse
présager de bonnes dispositions de la part des OOCP à effectuer cette tâche sur des grammaires plus complexes.
Application des OOCP à l’analyse du langage naturel
Phrase                                   Sémantique
+n:int
Cat
+début:int
+fin:int
1..*     + premier
{ordered}
Mot                                            S
0..1
0..1                                                                + sub S
0..1 suivant
0..1
A                   B
Figure 3: Modèle objet pour le langage an bn
La classe P hrase permet de décrire une liste de mots. Elle est également en relation avec le
premier mot de cette liste. Chaque M ot hors le dernier possède un mot suivant. Chaque S est
en relation avec un A, un B et optionnellement un autre S. La classe Ś   emantique modélise la
sémantique d’une entreé (ici le nombre n de répétitions de A). Les classes S et P hrase sont
en relation entre elles (cela associe une phrase à sa représentation syntaxique), et avec la classe
Sémantique : chaque unité syntaxique a une sémantique associeé.
Dans cet exemple, les propriétés de constitution, de noyau, d’unicité et d’exigence sont im-
plicitement décrites par les relations du modèle et leurs multiplicités, ce qui illustre la remarque
finale de la section précédente.
⎨ |S.A| = 1; (tout S contient un A)
|S.B| = 1; (tout S contient un B)
|S.S| = {0, 1}; (tout S contient éventuellement un autre S)
Les propriétés de linéarité, sont décrites par des contraintes complémentaires à ce modèle :
⎨ ∀S , S.A.debut < S.B.debut;
∀S , (|S.S| == 1) ⇒ (S.A.f in ≤ S.S.debut);
∀S , (|S.S| == 1) ⇒ (S.B.debut ≥ S.S.f in);

2.1 Sémantique
Dans ce cas particulièrement simple, la sémantique associeé à une phrase de an bn est naturelle-
ment le nombre n. La classe Ś  emantique du modèle comprend donc un attribut de type entier
: n. Le nombre S.Ś  emantique.n représente le nombre total de A dans un S. Les contraintes
qui lient la sémantique à la syntaxe sont les suivantes :
⎨ ∀S (|S.S| == 1) ⇒ S.Ś    emantique.n = 1 + S.S.Ś emantique.n
∀S (|S.S| == 0) ⇒ S.Ś    emantique.n = 1
∀P hrase P hrase.Ś  emantique = P hrase.S.Ś  emantique;
Mathieu Estratat, Laurent Henocque
Ces contraintes définissent récursivement la sémantique associeé à un S comme le nombre de
A qu’il contient, et la sémantique d’une phrase comme la sémantique associeé à son syntagme
de plus haut niveau.

3 Parsage
Un programme de contraintes orienté objet est utilisé de la manière suivante : il reçoit en
entreé un groupe d’objets partiellement connus et partiellement inter connectés (par exemple des
instances de M ot liés par la relation suivant). Les éléments ainsi fournis forment une partie de
la solution (s’il en existe). Un programme spécialisé (nous avons utilisé le configurateur orienté
objet d’Ilog (Mailharro, 1998)) peut alors compléter les donneés entreés par de nouveaux objets,
par l’établissement des relations manquantes et par la détermination exacte des types et des
attributs. Dans notre cas, ce mode de fonctionnement permet d’utiliser la grammaire traduite
sous forme d’un programme de contraintes orienté objet soit en mode analyse, soit en mode
génération, voire de manière hybride, tout en prenant en compte la sémantique. Si une suite
de mots est fournie en entreé, le programme produit l’arbre syntaxique et la sémantique. Si un
fragment de l’arbre syntaxique, ou la sémantique, ou une suite de mots incomplète, est donneé,
le programme génère si elle existe la suite de mots valide correspondante, tout en complétant
ce qui doit l’être. La figure 4 illustre ce comportement. Les états du système y sont décrits par
des tuples mots, syntaxe, ś   emantique (le caractère ? dénote un objet inconnu et le caractère
un mot inconnu) et son comportement par des règles état entŕ    ee → état sortie. Les deux
⎪    aaabbb, ?, ? → aaabbb, S(A, S(A, S(A, null, B), B), B), 3
abbb, ?, ? → f alse
⎪      a b, ?, ? → aabb, S(A, S(A, null, B), B), 2
?, ?, 2 → aabb, S(A, S(A, null, B), B), 2
Figure 4: Exemples de parsage

premiers cas sont des exemples de parsage pur. Dans le deuxième cas, la phrase fournie en
entreé n’appartient pas au langage. Les autres exemples illustrent le fonctionnement génératif
ou hybride du programme.

4 Résultats
La figure 5 présente les résultats obtenus6 pour des entreés (consistantes et inconsistantes) de
différentes tailles. Les résultats (nombre de backtracks, nombre de points de choix, temps
en secondes) sont donnés d’une part pour la production de la première solution si elle existe,
d’autre part pour le parcours de l’espace de recherche complet. Une entreé est définie par
une suite de M ot liés entre eux par la relation suivant (c.f. figure 3) et n’incorpore aucune
autre information susceptible de guider le parsage. La totalité du travail d’analyse reste donc à
faire par le configurateur. Les temps de calcul qui peuvent paraître élevés pour des "phrases"
de 100 mots sont fortement influencés par l’utilisation du langage Java et par la complexité
de la propagation des contraintes ensemblistes (qui est corrélee polynomialement au nombre
d’objets). De façon plus remarquable, on observe que ce problème n’est pas combinatoire.
On montrerait aisément que la profondeur de l’espace de recherche est en O(5n), n étant le
nombre de mots. On observe que le nombre de points de choix (appelés ici "noeuds") comme
le nombre de backtracks (ou "fails") sont bornés par cette valeur. L’espace de recherche est
6
Pentium4 2,4GHz - 512 Mo DDR - Windows XP Professional SP1 - Java 2 V.1.4.2 - Ilog Jconfigurator 2.08
Application des OOCP à l’analyse du langage naturel
mot        N b Cont     N b V ar         1ère solution                terminaison
F ails N oeuds T ps           F ails N oeuds T ps
aaabbb           105         74        0           20     0,38 s     20       20    0,41 s
a b            145        104        0           29      0,5 s     29       29    0,53 s
a(10) b(10)        383        300        0           92      0,8 s     92       92    0,84 s
a(20) b(20)        723        580        0          182     1,44 s    182      182    1,66 s
a(50) b(50)       1743       1420        0          452     5,53 s    452      452    5,69 s
a(51) b(49)       1743       1420         -           -        -        1       0     4,62 s
a(50) b(49)      1740       1419         -           -        -        1       0     4,61 s
Figure 5: Résultats expérimentaux
de taille linéaire, donc le problème est polynomial si l’on tient compte des contraintes. De
plus, le fait que lorsque l’entreé est inconsistante (a(51) b(49) et a(50) b(49)) le programme
termine sans point de choix montre que la propagation des contraintes suffit à détecter cette
inconsistance. Notons que notre modèle implémente une contrainte redondante très générale
pour briser les symétries existant entre les instances des catégories non-terminales (les valeurs
des attributs begin de toutes les instances de S sont ordonneés) et la sémantique.
5 Conclusion
Nous avons décrit une traduction des grammaires de propriétés sous forme d’un programme de
contraintes orienté objet, et montré que ce programme peut être utilisé aussi bien de manière
analytique (construire l’arbre syntaxique d’une phrase bien formeé) que de manière générative
(produire une phrase bien formeé sous contraintes). Cela place cette approche au niveau des
grammaires de clauses définies (Definite Clause Grammars en Prolog (Colmerauer, 1978)) et au
dessus des formalismes reposant sur l’utilisation de règles exploiteés en chaînage avant comme
les constraint grammars (Karlsson, 1990). La complétion d’entreé incomplète, ou la génération
de phrases, a beaucoup d’applications pratiques.
(Blache, 2001) présente un formalisme reposant exclusivement sur des contraintes, mais em-
ploie un algorithme ad hoc pour la propagation et le parsage. De plus, la coopération de la sé-
mantique avec la syntaxe lors de l’analyse n’est pas abordeé. Modéliser la syntaxe sous forme
d’un programme de contraintes orienté objet donne accès à la grande gamme de contraintes
disponibles dans ce cadre, et permet l’utilisation d’algorithmes généraux.
La sémantique véhiculeé par des textes descriptifs simples peut être décrite comme un OOCP
(de nombreux articles sur la configuration utilisent un exemple de configuration de PC (Soini-
nen et al., 2000)). Dans une telle situation nos expérimentations montrent que le modèle sé-
mantique peut être combiné avec le modèle syntaxique. Ainsi, syntaxe et sémantique coopèrent
étroitement lors de l’analyse ou de la génération. Nos recherches s’orientent actuellement vers
l’implémentation d’un parseur du langage naturel pour un sous-ensemble du français, dans le
cadre de la description de scènes 3D (La Greca & Daniel, 2002).
Remerciements
Ces travaux de recherche ont pu être réalisés grâce à un financement JemSTIC du CNRS.
Mathieu Estratat, Laurent Henocque
Références
B LACHE P. (2000). Property grammars and the problem of constraint satisfaction. In ESSLLI-2000
workshop on Linguistic Theory and Grammar Implementation.
B LACHE P. (2001). Les Grammaires de Propriétés : des contraintes pour le traitement automatique des
langues naturelles. Hermès Sciences.
C OLMERAUER A. (1978). Metamorphosis grammars. Lecture Notes on Computer Science, 63, 133–
189.
C OLMERAUER A. (1990). An introduction to prolog 3. communication of the ACM, 33(7), 69–90.
E STRATAT M. (2003). Application de la configuration à l’analyse syntaxico sémantique de descriptions.
Master’s thesis, Faculté des Sciences et Techniques de Saint Jérôme, LSIS équipe InCA, Marseille,
France, submitted for the obtention of the DEA degree.
FARGIER H. & H ENOCQUE H. (2002). Configuration à base de contraintes. Information Interaction
Intelligence, Actes des 2ièmes Assises nationales du GdR I3, p. 141–159.
F LEISCHANDERL G., F RIEDRICH G., H ASELBÖCK A., S CHREINER H. & S TUMPTNER M. (1998).
Configuring large-scale systems with generative constraint satisfaction. IEEE Intelligent Systems - Spe-
cial issue on Configuration, 13(7).
F ROMHERZ M., G UPTA V. & S ARASWAT V. (1997). cc - a generic framework for dommain specific
languages. POPL Workshop on Domain Specific Languages, p. 89–96.
G AZDAR G., K LEIN E., P ULLUM G. & S AG I. (1985). Generalized Phrase Structure Grammar. Ox-
ford: Blackwell.
G ELFOND M. & L IFSCHITZ V. (1988). The stable modem semantics for logic programming. In 5th In-
ternational Conférence and Symposium on Logic Programming, p. 1070–1080, Cambridge: MIT Press.
H ENOCQUE L. (2003). Modeling Object Oriented Constraint Programs in Z. Rapport interne, LSIS
Research Report, available at http://arXiv.org/abs/cs/0312020.
K ARLSSON J. (1990). Constraint grammar as a framework for parsing running text. In COLING-90,
13th International Conference on Computational Linguistics, volume 3, p. 168–173: H. Karlgren.
L A G RECA R. & DANIEL M. (2002). Modélisation déclarative : De la description vers les modèles. In
Proceedings of Journeés Des Doctorants du LSIS, p. 3–12.
M AILHARRO D. (1998). A classification and constraint based framework for configuration. AI-EDAM :
Special issue on Configuration, 12(4), 383 – 397.
M ITTAL S. & FALKENHAINER B. (1990). Dynamic constraint satisfaction problems. In Proceedings
of AAAI-90, p. 25–32.
N EBEL B. (1990). Reasoning and revision in hybrid representation systems. Lecture Notes in Artificial
Intelligence, 422.
P OLLARD C. & S AG I. (1994). Head-Driven Phrase Structure Grammar. Chicago: The University of
Chicago Press.
S ABIN S. & F REUDER E. (1996). Configuration as composite constraint satisfaction. Artificial Intelli-
gence and Manufacturing Research Planning Workshop, p. 153–161.
S OININEN T., N IEMELÕ I., T IIHONEN J. & S ULONEN R. (2000). Unified configuration knowledge
representation using weight constraint rules. In ECAI 2000 Configuration Workshop.
S TUMPTNER M. (1997). An overview of knowledge-based configuration. AI Communications, 10(2),
111–125.
