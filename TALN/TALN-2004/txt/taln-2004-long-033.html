<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>D&#233;termination de contenu dans GEPHOX</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2004, F&#232;s, 19&#8211;21 avril 2004
</p>
<p>D&#233;termination de contenu dans GEPHOX
</p>
<p>Adil El Ghali
LATTICE / PPS - Universit&#233; Paris 7
</p>
<p>2, place jussieu
case 7003 - 75251 Paris
</p>
<p>adil@linguist.jussieu.fr
</p>
<p>R&#233;sum&#233; - Abstract
</p>
<p>Le g&#233;n&#233;rateur GEPHOX que nous r&#233;alisons a pour ambition de produire des textes pour des
d&#233;finition ou preuves math&#233;matiques &#233;crites &#224; l&#8217;aide de l&#8217;assistant de preuve PHOX. Dans
cet article nous nous concentrons sur le module de d&#233;termination de contenu ContDet de
GEPHOX. Apr&#232;s un aper&#231;u sur l&#8217;entr&#233;e du g&#233;n&#233;rateur, i.e. la preuve formelle et l&#8217;ensemble des
r&#232;gles ayant permis de l&#8217;obtenir, nous d&#233;crivons les base de connaissances du g&#233;n&#233;rateur et le
fonctionnement de l&#8217;algorithme de d&#233;termination de contenu.
</p>
<p>This paper deals with content determination in a text proofs generation system. Our system,
GEPHOX produces a textual version of a mathematical proof formalized using the proof assis-
tant PHOX. We start with a quick presentation of the input of the generator : the formal proof
and the set of rules that the proof assistant user employs in order to find it. We describe the
generator knowledge bases and define the reasoning tasks associated with the KB and show
how the content determination algorithm work.
</p>
<p>Mots-clefs &#8211; Keywords
</p>
<p>G&#233;n&#233;ration de textes, logique de description, d&#233;termination de contenu, bases de connaissance,
assistant de preuve
Natural language generation, description logic, content determination, knowledge bases, proof
assistant</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali
</p>
<p>Introduction
</p>
<p>La d&#233;termination de contenu est la premi&#232;re t&#226;che de tout syst&#232;me de g&#233;n&#233;ration de texte. Elle
a pour but de produire une repr&#233;sentation abstraite des donn&#233;es fournies en entr&#233;e du syst&#232;me.
C&#8217;est une des t&#226;ches les plus ardues et sans doute la plus importante du processus de g&#233;n&#233;ration
(Reiter &amp; Dale, 2000; Sripada et al., 2001). La plupart des utilisateurs d&#8217;un syst&#232;me de g&#233;n&#233;ra-
tion pr&#233;f&#232;rent avoir un texte dont le contenu est correct mais pauvrement exprim&#233; plut&#244;t qu&#8217;un
texte bien &#233;crit mais dont le contenu n&#8217;est pas satisfaisant.
</p>
<p>Le g&#233;n&#233;rateur GEPHOX que nous r&#233;alisons a pour ambition de produire des textes pour des
d&#233;finition ou preuves math&#233;matiques &#233;crites &#224; l&#8217;aide de l&#8217;assistant de preuve PHOX (Raffalli,
2002; Raffalli &amp; Roziere, 2002) . Dans cet article nous nous concentrons sur le module de
d&#233;termination de contenu ContDet de GEPHOX.
</p>
<p>Un certain nombre de travaux ont &#233;t&#233; men&#233;s dans ce domaine (Hallgren &amp; Ranta, 2000; Coscoy,
2000). Les approches propos&#233;es par ces auteurs sont des tentatives plus ou moins r&#233;ussies
d&#8217;&#233;tablir une correspondance directe entre objets math&#233;matiques et repr&#233;sentations linguis-
tiques. Le point de vue que nous d&#233;fendons est assez diff&#233;rent : nous pensons qu&#8217;au moins
un niveau de repr&#233;sentation interm&#233;diaire est n&#233;cessaire, afin de pouvoir raisonner et manipu-
ler non pas des preuves math&#233;matiques mais une vue de ces preuves qui pr&#233;c&#232;de leur mise en
langue. Ce point de vue se rapproche plus des travaux de (Fiedler, 2001a; Fiedler, 2001b) o&#249;
une repr&#233;sentation interm&#233;diaire en termes d&#8217;actes de langage est calcul&#233; pour chaque action de
preuve. Cependant, la d&#233;termination de contenu et la structuration de document sont confon-
dues dans son travail, alors que nous pensons qu&#8217;un certain nombre d&#8217;op&#233;rations de calcul de
contenu sont ind&#233;pendantes de la structuration et qu&#8217;il faut s&#233;parer les deux t&#226;ches.
</p>
<p>L&#8217;approche de d&#233;termination de contenu que nous proposons est centr&#233;e sur les connaissances
du syst&#232;me de g&#233;n&#233;ration. Nous voyons cette t&#226;che comme la construction d&#8217;un univers de
discours (section 3). Le module ContDet produit &#224; partir de l&#8217;entr&#233;e du syst&#232;me une repr&#233;sen-
tation (message) des connaissances qui vont figurer dans le texte, ce message est exprim&#233; en
logique de description i.e. il peut &#234;tre vu comme une A-Box. Par ailleurs, ce message est con-
struit de fa&#231;on &#224; pr&#233;server les &#233;l&#233;ments de structure de PHOX qui vont &#234;tre utiles pour la suite
du processus de g&#233;n&#233;ration, notamment pour la structuration de document.
</p>
<p>Base de
connaissance
</p>
<p>Services de
</p>
<p>raisonnement
</p>
<p>&#8656;=
=&#8658;
</p>
<p>entr&#233;e
&#8595;
</p>
<p>Traduction
S&#233;lection
</p>
<p>Instanciation
V&#233;rification
</p>
<p>&#8595;
message
</p>
<p>Figure 1: Architecture du module ContDet
</p>
<p>Le module ContDet repose sur une architecture en pipe-line &#224; quatre sous-modules, comme le
montre la figure 1. Il utilise une base connaissances &#233;crite en Logique de Description &#224; laquelle
on acc&#232;de via une interface fournissant des services de raisonnement (subsomption, unification
de concepts, ...).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>D&#233;termination de contenu dans GEPHOX
</p>
<p>L&#8217;article commence par une rapide pr&#233;sentation de PHOX et des &#233;l&#233;ments qui serviront comme
entr&#233;e pour notre g&#233;n&#233;rateur (section 1). Nous pr&#233;senterons ensuite les bases de connais-
sances du syst&#232;me et les services de raisonnement qui permettent d&#8217;y acc&#233;der (section 2) avant
d&#8217;expliciter le fonctionnement des diff&#233;rents sous-modules r&#233;alisant la d&#233;termination de con-
tenu (section 3).
</p>
<p>1 Entr&#233;e du g&#233;n&#233;rateur
</p>
<p>1.1 PHOX
</p>
<p>PHOX est un assistant de preuve bas&#233; sur le syst&#232;me AF21. Il permet de r&#233;aliser sur ordinateur
des preuves math&#233;matiques en d&#233;duction naturelle, mais aussi de d&#233;finir des th&#233;ories math&#233;ma-
tiques gr&#226;ce &#224; un syst&#232;me de gestion de modules. Il est par ailleurs extensible i.e. l&#8217;utilisateur
peut d&#233;finir ses propres commandes qui correspondent &#224; des tactiques de raisonnement d&#8217;un
niveau plus &#233;lev&#233; que les r&#232;gles de d&#233;duction habituelles.
</p>
<p>Un th&#233;or&#232;me &#224; prouver est consid&#233;r&#233; par PHOX comme un but. Le d&#233;roulement de la preuve est
une application successive de commandes qui r&#233;duisent le but courant en sous-buts plus sim-
ples. Cet ensemble de commandes est appel&#233; script de preuve. PHOX r&#233;pond aux commandes
du r&#233;dacteur2 en donnant le contexte courant de la preuve, c&#8217;est-&#224;-dire les hypoth&#232;ses &#224; dispo-
sition et le(s) but(s) courant(s) qui reste(nt) &#224; d&#233;montrer (les hypoth&#232;ses et les buts courants
forment un s&#233;quent). Par ailleurs, le syst&#232;me peut fournir &#224; chaque &#233;tape le fragment de l&#8217;arbre
de preuve construit i.e. les r&#232;gles et th&#233;or&#232;mes utilis&#233;s pour passer du s&#233;quent pr&#233;c&#233;dent au
s&#233;quent courant. La figure 2 montre un exemple d&#8217;entr&#233;e pour GEPHOX3 . Pour produire le
texte correspondant &#224; la preuve (ou &#224; une &#233;tape de celle-ci), le g&#233;n&#233;rateur prend en entr&#233;e toutes
ces informations.
</p>
<p>&lt; script &gt;goal &#8704;x (G x&#8596; G1 x &#8744; G2 x)&#8594; &#8704;x:G1 G2 x &#8744; &#8704;x:G2 G1 x.&lt; /script &gt;
&lt; phox &gt;
Here is the goal:
goal 1/1
&#5;&#8594; (&#8704; &#955;x (&#8596; (G x) (&#8744; (G1 x) (G2 x)))) (&#8744; (&#8704; &#955;x (&#8594; (G1 x) (G2 x))) (&#8704; &#955;x (&#8594; (G2 x) (G1 x))))
&lt; /phox &gt;
&lt; script &gt;intros.&lt; /script &gt;
&lt; proof &gt;
arrow_intro (&#8704; &#955;x (&#8596; (G x) (&#8744; (G1 x) (G2 x)))) &#955;H
(comment &quot;goal 1&quot;)
&lt; /proof &gt;
&lt; phox &gt;
New goal is:
goal 1/1
H := &#8704; &#955;x (&#8596; (G x) (&#8744; (G1 x) (G2 x)))
&#5; &#8744; (&#8704; &#955;x (&#8594; (G1 x) (G2 x))) (&#8704; &#955;x (&#8594; (G2 x) (G1 x)))
&lt; /phox &gt;
</p>
<p>Figure 2: Exemple d&#8217;entr&#233;e du g&#233;n&#233;rateur
</p>
<p>1Arithm&#233;tique fonctionnelle d&#8217;ordre 2 (Krivine, 1997)
2On d&#233;signe par r&#233;dacteur l&#8217;utilisateur de PHOX qui construit la version formelle de la preuve, et par utilisateur
</p>
<p>le destinataire du texte produit par GEPHOX.
3Les tags &lt; script &gt;,&lt; phox &gt; et &lt; proof &gt; d&#233;limitent respectivement au script de preuve rentr&#233; par le
</p>
<p>r&#233;dacteur, &#224; la r&#233;ponse de PHOX qui d&#233;finit le contexte courant et au fragment d&#8217;arbre de preuve correspondant.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali
</p>
<p>1.2 Les &#233;l&#233;ments de l&#8217;entr&#233;e
</p>
<p>Script de preuve Les scripts de preuve peuvent contenir deux types de commandes. D&#8217;une
part, les annonces qui regroupent, entre autres, les d&#233;clarations d&#8217;objets (types, variables, ...),
les d&#233;finitions ou les &#233;nonc&#233;s de th&#233;or&#232;mes. D&#8217;autre part, les commandes de preuve qui re-
groupent les r&#232;gles de d&#233;duction (r&#232;gles d&#8217;introduction ou d&#8217;&#233;limination de la d&#233;duction na-
turelle) ou tactiques de preuves (raisonnement par l&#8217;absurde, par r&#233;currence, ...) servant &#224;
avancer dans la recherche de preuve.
</p>
<p>Contexte &#192; chaque &#233;tape de la preuve, le r&#233;dacteur passe d&#8217;un s&#233;quent(un ensemble
d&#8217;hypoth&#232;ses et un but &#224; prouver) &#224; un autre en appliquant une r&#232;gle de d&#233;duction ou une tactique
de preuve. Le contexte est l&#8217;ensemble des hypoth&#232;ses et des buts disponibles &#224; chaque &#233;tape,
Par exemple, apr&#232;s l&#8217;application de la r&#232;gle d&#8217;introduction de &#8594; sur l&#8217;annonce du th&#233;or&#232;me &#224;
d&#233;montrer
</p>
<p>&#8704;x (G x &#8596; G1 x &#8744; G2 x) &#8594; &#8704;x &#8712; G1 G2x &#8744; &#8704;x &#8712; G2 G1x. 4
</p>
<p>le contexte r&#233;sultant contient l&#8217;hypoth&#232;se H: &#8704;x ((G x)&#8596; (G1 x &#8744; G2 x)) et le nouveau but
qu&#8217;il faut prouver (&#8704;x G1 x&#8594; G2 x) &#8744; (&#8704;x G2 x&#8594; G1 x).
</p>
<p>Arbre de preuve Cette partie de l&#8217;entr&#233;e nous fournit des informations sur ce que le prouveur
a utilis&#233; comme r&#232;gles &#233;l&#233;mentaires, th&#233;or&#232;mes, axiomes ou d&#233;finitions. Elle est plus informa-
tive que le script de preuve, e.g. l&#8217;application de la r&#232;gle d&#8217;introduction de&#8594; est implicite dans
le script mais elle ne l&#8217;est pas dans le fragment d&#8217;arbre de preuve correspondant &#224; cette com-
mande. Par ailleurs, quand le prouveur utilise la tactique automatique, les th&#233;or&#232;mes et r&#232;gles
utilis&#233;es ne sont explicit&#233;es5 que dans l&#8217;arbre de preuve.
</p>
<p>2 Bases de connaissances
</p>
<p>Le module ContDet utilise pour repr&#233;senter les connaissances du domaine une base de con-
naissances &#233;crite en Logique de Description. Ce choix est motiv&#233; par plusieurs raisons, prin-
cipalement : (i) les bonnes propri&#233;t&#233;s math&#233;matiques de ce formalisme nous permettent de
contr&#244;ler la complexit&#233; du processus de g&#233;n&#233;ration, (ii) la s&#233;paration entre connaissances inten-
sionnelles et extensionnelles est bien adapt&#233;e &#224; la g&#233;n&#233;ration de textes, (iii) l&#8217;existence de raison-
neurs optimis&#233;s fournissant les services standards de raisonnements facilite l&#8217;impl&#233;mentation du
syst&#232;me.
</p>
<p>2.1 Logique de description
</p>
<p>Les logiques de description (description logics terme abr&#233;g&#233; en DL) (Baader et al., 2003) sont
un formalisme de repr&#233;sentation des connaissances bas&#233; sur la logique du premier ordre et
</p>
<p>4Le th&#233;or&#232;me s&#8217;&#233;nonce ainsi: &#171; si dans un groupe G, tout &#233;l&#233;ment est dans l&#8217;un des deux sous-groupes G1 ou
G2 alors l&#8217;un des sous-groupes est inclu dans l&#8217;autre (tout &#233;l&#233;ment de G1 appartient &#224; G2 ou tout &#233;l&#233;ment de G2
appartient &#224; G1). &#187;
</p>
<p>5Ces informations sont importantes parce qu&#8217;elles doivent &#234;tre incluses dans le texte destin&#233; &#224; un utilisateur qui
ne les poss&#232;de pas dans sa base de connaissances personnelle (cf. section 2.2).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>D&#233;termination de contenu dans GEPHOX
</p>
<p>descendant des r&#233;seaux s&#233;mantiques et des syst&#232;mes &#224; base de frames. Dans ce formalisme, la
th&#233;orie est divis&#233;e en deux parties, (i) la T-Box qui regroupe les connaissances intensionnelles
(conceptuelles ou terminologiques) i.e. les concepts et les relations du domaine, et (ii) la A-
Box qui regroupe les connaissances extensionnelles (assertionelles) d&#233;crivant les individus du
domaine et les relations entre eux. Les concepts peuvent &#234;tre vus comme des classes d&#8217;individus
du domaine et les r&#244;les comme des relations binaires entre concepts/individus. Le formalisme
offre un certain nombre d&#8217;op&#233;rateurs (g&#233;n&#233;ralement appel&#233;s constructeurs) qui permettent de
d&#233;finir des concepts et r&#244;les complexes en fonction d&#8217;autres plus simples. Le langage que nous
utilisons comprend les constructeurs dont la syntaxe et la s&#233;mantique sont pr&#233;sent&#233;s dans la
table 1.
</p>
<p>Nom du constructeur Syntaxe S&#233;mantique
concept atomique A AI &#8838; &#8710;I
</p>
<p>top &#2; &#8710;I
</p>
<p>bottom &#8869; &#8709;
conjonction C &#8743; D CI&#8745; DI
</p>
<p>disjonction (U) C &#8744; D CI&#8746; DI
</p>
<p>complement (C) &#172;C &#8710;I CI
</p>
<p>quantification univ. &#8704;R.C { x | &#8704;y (x,y) &#8712; RI &#8658; y &#8712; CI}
quantification exist. (E) &#8707;R.C { x | &#8707;y (x,y) &#8712; RI &#8658; y &#8712; CI}
restrictions numeriques (N ) &gt;n R.C { x | &#1;{ y | &#8704;y (x,y) &#8712; RI} &gt; n }
</p>
<p>&#8804;n R.C { x | &#1;{ y | &#8704;y (x,y) &#8712; RI} &#8804; n }
collection d&#8217;individus (O) {a1,. . .,an} {aI1 ,. . .,a
</p>
<p>I
</p>
<p>n
}
</p>
<p>r&#244;le atomique P PI &#8838; &#8710;I &#215;&#8710;I
</p>
<p>conjonction de r&#244;le (R) Q &#8743;R RI &#8745;RI
</p>
<p>r&#244;le inverse R 1 {(a1,a2) | ((a2,a1) &#8712; RI}
composition de r&#244;les Q &#9702; R {(a1,a2) | &#8707;a3 (a1,a3) &#8712; QI&#8743; (a3,a2) &#8712; RI}
</p>
<p>Table 1: Syntaxe et s&#233;mantique des constructeurs de concepts et de r&#244;les
</p>
<p>Les DL offrent plusieurs services de raisonnement (Donini et al., 1996; Horrocks, 2002). Soit
une base de connaissances &#931;, on d&#233;signe par les lettres majuscules C, D des concepts com-
plexes, R, Q des r&#244;leset par les lettres minuscules a, b des individus. Les services de raison-
nements que nous utilisons sont d&#233;finis comme suit.
</p>
<p>Subsomption : ce qu&#8217;on &#233;crit &#931; &#6; C &#7; D. Ce service permet de tester si dans la base de
connaissances &#931;, C est subsum&#233; par D, ce qui est v&#233;rifi&#233; quand CI &#8838;DI dans tout mod&#232;le
I de &#931;. Pour les besoins de la d&#233;termination de contenu, la subsomption permet de dire si
un concept est plus sp&#233;cifique qu&#8217;un autre. Un service off-line li&#233; &#224; la subsomption est la
classification ou hi&#233;rarchisation des concepts d&#8217;une base de connaissances. Par ailleurs,
ont dit que C et D sont &#233;quivalents (not&#233; C &#8801; D) si C &#7; D et D &#7; C.
</p>
<p>Consistance : ce qu&#8217;on &#233;crit &#931; &#1;. Ce service permet de v&#233;rifier si &#931; est satisfiable, i.e. que
&#931; a un mod&#232;le. La consistance est utilis&#233;e par le module ContDet pour assurer que
le message d&#233;livr&#233; &#224; la sortie du module ne contient pas d&#8217;incoh&#233;rence, ce qui se verrait
dans le texte ou bloquerait le reste du processus de g&#233;n&#233;ration.
</p>
<p>Test d&#8217;instance : ce qu&#8217;on &#233;crit &#931; &#6; C(a) (resp. &#931; &#6; R(a, b)). Ce service permet de v&#233;rifier
si l&#8217;assertion C(a) (resp. R(a, b)) est satisfaite dans tous les mod&#232;les de &#931;, autrement dit,
que a est membre du concept C (resp. &#12296;a,b&#12297; est membre de la relation R).
</p>
<p>Unification : ce service de raisonnement, introduit dans (Baader et al., 2000; Baader &amp; Naren-
dran, 2001) a pour but, &#233;tant donn&#233;s C et D, de trouver une substitution &#963; (appel&#233;e uni-</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali
</p>
<p>fieur), telle que &#963;(C)&#8801; &#963;(D). Par exemple, si C = A&#8744;&#8704;R.A et D = (B1&#8743;B2)&#8744;&#8704;R.(B1&#8743;B2),
la substitution &#963; qui remplace A par B1&#8743;B2 dans C est un unifieur pour C et D. On utilise
ce service pour trouver un concept dont la d&#233;finition s&#8217;unifie avec une expression con-
ceptuelle et qui pourrait la d&#233;signer. Ce qui permet, par exemple, de d&#233;tecter des tactiques
de raisonnement complexes.
</p>
<p>Projection : c&#8217;est un service de raisonnement non standard qui met en jeu deux bases de con-
naissances &#931;1 et &#931;2 telles que &#931;2 &#8834; &#931;1. Pour tout concept C dans &#931;1 et n&#8217;appartenant pas
&#224; &#931;2, ce service permet de trouver une d&#233;finition de C avec uniquement des concepts de
&#931;2. La projection est utilis&#233; par le module ContDet pour adapter le message aux con-
naissances de chaque utilisateur : si au cours du processus de d&#233;termination de contenu,
on manipule un concept qui n&#8217;est pas connu par l&#8217;utilisateur, le message va &#234;tre enrichi
par la d&#233;finition de ce concept, ce qui assure une meilleure compr&#233;hension du texte final.
Par exemple, dans la pr&#233;sentation d&#8217;une preuve manipulant des groupes &#224; un utilisateur
ne ma&#238;trisant pas le concept de groupe, on explicitera qu&#8217;un groupe est un ensemble muni
d&#8217;une loi associative, poss&#233;dant un &#233;l&#233;ment neutre et dont tous les &#233;l&#233;ments poss&#232;dent
un inverse. Dans ce cas de figure, les concepts de Ensemble, Loi, Element, Inverse,
ElementNeutre sont dans la base de connaissances de l&#8217;utilisateur, mais pas celui de
Groupe.
</p>
<p>2.2 Bases de connaissances de GEPHOX
</p>
<p>GEPHOX dispose de deux bases de connaissances. Le premi&#232;re, DKB (Domain Knowledge
Base), contient toute les connaissances sur le domaine math&#233;matique dont dispose le syst&#232;me.
Elle est structur&#233;e en deux parties. D&#8217;une part, un noyau correspondant &#224; la base de PHOX : les
concepts d&#233;crivant les types de base, les commandes et les objets math&#233;matiques (variable,
operateurs-logique, ...) et m&#233;ta-math&#233;matiques (theoreme, definition, commandes-de-
preuves, ...) de bas niveau. D&#8217;autre part, un ensemble de modules (dont le d&#233;coupage est
calqu&#233; sur celui de PHOX) correspondant aux diff&#233;rentes th&#233;ories math&#233;matiques, e.g. un mod-
ule pour les entiers, un autre pour les groupes. Lorsque le syst&#232;me entame un processus de
g&#233;n&#233;ration, la base de connaissances qu&#8217;il utilise ne contiendra que le noyau et les modules
qui repr&#233;sentent les connaissances des th&#233;ories que le r&#233;dacteur de la preuve a choisi d&#8217;utiliser.
Ce d&#233;coupage en modules de la DKB r&#233;duit la taille de la base de connaissances effectivement
utilis&#233;e et am&#233;liore l&#8217;efficacit&#233; du syst&#232;me.
</p>
<p>La deuxi&#232;me base de connaissances dont dispose le syst&#232;me, UKB (User Knowledge Base), est
sp&#233;cifique &#224; chaque utilisateur ; il s&#8217;agit en fait d&#8217;un sous ensemble de la DKB qui refl&#232;te ses
connaissances.
</p>
<p>3 Algorithme de d&#233;termination de contenu
</p>
<p>Comme on l&#8217;a vu dans la section 1, l&#8217;entr&#233;e du g&#233;n&#233;rateur GEPHOX est riche car elle comporte
certains &#233;l&#233;ments qui peuvent &#234;tre vus comme du contenu &quot;pur&quot; (la description des objets math-
&#233;matiques, l&#8217;arbre de preuve) et d&#8217;autres qui sont plut&#244;t des informations sur la structure de la
preuve (les hypoth&#232;ses et buts interm&#233;diaires, les commandes appliqu&#233;es). Dans le d&#233;roulement
de la t&#226;che de d&#233;termination de contenu, chacun de ces &#233;l&#233;ments prend un statut particulier. Les
premiers vont nous donner les r&#233;f&#233;rents aux objets du domaine du discours, et les seconds des</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>D&#233;termination de contenu dans GEPHOX
</p>
<p>actes de langage et des actions de preuve. C&#8217;est pour cette raison qu&#8217;on a besoin de manipu-
ler dans le module ContDet des structures de donn&#233;es permettant de s&#233;parer ces deux types
d&#8217;informations. Ainsi le choix du contenu &#224; exprimer se fait en pr&#233;servant la structure de la
preuve, ce dont on aura besoin dans la t&#226;che de structuration de document (El Ghali &amp; Rous-
sarie, 2003).
</p>
<p>La structure de donn&#233;es &#233;l&#233;mentaire manipul&#233;e par le module ContDet que l&#8217;on appellera
segment est la traduction d&#8217;une &#233;tape de preuve dans PHOX. Elle comporte deux parties : la
premi&#232;re, data, qui contient les informations relatives aux objets math&#233;matiques manipul&#233;s dans
la preuve, et qui, du point de vue du syst&#232;me de g&#233;n&#233;ration, correspond &#224; du contenu pur. La
seconde, struct, qui contient les informations structurantes de la preuve math&#233;matique. Ces
deux parties sont exprim&#233;es en DL, ce sont des fragments d&#8217;une A-Box. Nous avons choisi de
les exprimer dans la m&#234;me terminologie pour rendre compte plus facilement des relations entre
les individus dans la partie data et ceux dans la partie struct.
</p>
<p>Le module ContDet va tout au long du traitement d&#8217;une entr&#233;e construire de mani&#232;re incr&#233;-
mentale un univers de discours qui sera compos&#233; de segments. Plus pr&#233;cis&#233;ment, on d&#233;finit les
structures de donn&#233;es comme suit :
</p>
<p>D&#233;finition 1 segment
Un segment est un quadruplet &#12296;data, struct, Rint, Rext&#12297; o&#249; data et struct sont deux ensem-
bles de triplets &#12296;individu, concept, type&#12297; correspondant aux individus, aux concepts auxquels
ils appartiennent et &#224; leur type, pour respectivement la composante donn&#233;es et la composante
structure. Rint (relations internes au segment) est un ensemble de relations binaires entre des
&#233;l&#233;ments de data &#8746; struct et Rext (relations externes au segment) est un ensemble de relations
binaires dont un participant est dans data &#8746; struct et l&#8217;autre dans un autre segment.
</p>
<p>D&#233;finition 2 univers de discours
Un univers de discours
</p>
<p>&#0;
</p>
<p>est une suite ordonn&#233;e de segments, telle qu&#8217;il n&#8217;existe pas d&#8217;individu
a appartenant &#224; deux segments diff&#233;rents, et telle que tout segment est reli&#233; &#224; au moins un autre
segment de
</p>
<p>&#0;
</p>
<p>i.e. &#8704; &#1; &#8712;
&#0;
</p>
<p>R &#2;ext &#15;= &#8709;. L&#8217;unicit&#233; des individus nous assure que notre message
ne contiendra pas de redondance. La condition de connexit&#233; de l&#8217;univers de discours quand &#224;
elle sert &#224; identifier les parties du textes qui ont pas de lien et qui correspondront &#224; des unit&#233;s
textuelles (paragraphes, sections, ...) diff&#233;rents dans le texte final.
</p>
<p>D&#233;finition 3 types d&#8217;individus
Les individus qui composent les segments sont typ&#233;s pour les besoins de la d&#233;termination de
contenu. Les types sont dynamiques et n&#8217;apparaissent pas dans la base de connaissances. La
proc&#233;dure de calcul du type d&#8217;un individu nous permet de distinguer les informations qui vont
appara&#238;tre dans le message final de celles qui n&#8217;y seront pas incluses. La visibilit&#233; d&#8217;un individu
signifie qu&#8217;il sera pr&#233;sent dans le message. Prenons le cas d&#8217;une formule f qui contient des
variables et des connecteurs logiques. Si les &#233;l&#233;ments qui composent f ne sont pas utilis&#233;s pour
avancer dans la preuve, les individus correspondant ne vont pas appara&#238;tre dans le message,
mais ils seront pr&#233;sents dans l&#8217;univers de discours en &#233;tant cach&#233;s. L&#8217;individu correspondant &#224;
f les repr&#233;sentera dans le message.
</p>
<p>On distingue donc trois types d&#8217;individu :
</p>
<p>visible c&#8217;est le type par d&#233;faut, les individus ayant ce type seront pr&#233;sents dans le message
final ;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali
</p>
<p>repr&#233;sentant pour les individus qui ont la particularit&#233; d&#8217;&#234;tre le seul lien d&#8217;un ensemble
d&#8217;individus avec le reste du segment ou de l&#8217;univers ;
</p>
<p>cach&#233; pour ceux qui appartiennent &#224; l&#8217;ensemble d&#8217;un individu repr&#233;sentant.
</p>
<p>Le sous-module de traduction traite une &#224; une les parties de l&#8217;entr&#233;e correspondant &#224; une com-
mande, le segment ainsi produit est int&#233;gr&#233; &#224; l&#8217;univers de discours courant en effectuant des
choix sur les parties &#224; garder et celles &#224; ne pas dire ; par la suite l&#8217;univers de discours produit
est instanci&#233; pour l&#8217;utilisateur courant, puis v&#233;rifi&#233; (cf. section 3.3).
</p>
<p>3.1 Traduction
</p>
<p>La t&#226;che du sous-module de traduction est de traduire l&#8217;entr&#233;e (script, r&#233;ponses de PHOX et
arbre de preuve) en DL. Cette op&#233;ration doit produire une repr&#233;sentation de toutes les informa-
tions disponibles dans l&#8217;entr&#233;e. Elle doit, par ailleurs, pr&#233;server la structure de la preuve qui va
servir &#224; la structuration de document. La strat&#233;gie adopt&#233;e pour la traduction est de traiter un
bloc compos&#233; d&#8217;une commande PHOX, de la r&#233;ponse &#224; cette commande et du fragment d&#8217;arbre
de preuve correspondant, pour construire une structure compos&#233;e d&#8217;une partie donn&#233;e et d&#8217;une
partie structure.
</p>
<p>Une commande PHOX est compos&#233; de deux parties : l&#8217;instruction de preuve
(intro, elim, goal, ...) et une partie arguments qui peut &#234;tre soit l&#8217;&#233;nonc&#233; (une formule) d&#8217;un
th&#233;or&#232;me &#224; prouver ou d&#8217;une d&#233;finition dans le cas des commandes def, goal, lem, ..., soit une
hypoth&#232;se, une variable, un op&#233;rateur logique, ... pour les autres commandes, soit vide quand
le r&#233;dacteur de la preuve laisse &#224; la tactique automatique le soin de choisir les arguments pour
sa commande. Les instructions de preuve vont &#234;tre traduites par des individus appartenant au
concept correspondant et cet individu sera rang&#233; dans la case struct du segment courant. Pour
la partie arguments nous avons deux cas de figures. D&#8217;une part, un argument peut introduire
un seul individu, c&#8217;est le cas pour les variables, les noms d&#8217;hypoth&#232;ses et les op&#233;rateurs ; le
module de traduction cr&#233;&#233; alors un individu pour ce r&#233;f&#233;rent et doit calculer le concept auquel
il appartient. D&#8217;autre part, un argument peut introduire plusieurs r&#233;f&#233;rents de discours; c&#8217;est le
cas pour une formule, les variables et connecteurs logiques composant une formule donneront
autant d&#8217;individus dans l&#8217;univers de discours. Par exemple, une commande goal f va produire
un individu g &#8838; Goal qui sera reli&#233; par le r&#244;le has-formula &#224; la traduction de f .
</p>
<p>3.2 S&#233;lection
</p>
<p>Le sous-module de s&#233;lection est le coeur de ContDet : c&#8217;est durant cette phase que les choix
les plus importants s&#8217;effectuent : d&#233;cider de ce qui va &#234;tre inclus dans le message et de ce qu&#8217;on
ne va pas dire, garantir que le message est assez informatif, mais pas trop et ne pas perdre la
structure g&#233;n&#233;rale de la preuve qui nous servira par la suite.
</p>
<p>Le module de s&#233;lection construit un univers de discours
&#0;
</p>
<p>de mani&#232;re incr&#233;mentale, le processus
commence par un univers de discours vide, on y ajoute au fur et &#224; mesure les segments fournis
par le module de traduction. Quand un segment est ajout&#233; &#224;
</p>
<p>&#0;
</p>
<p>, plusieurs proc&#233;dures sont
ex&#233;cut&#233;es :</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>D&#233;termination de contenu dans GEPHOX
</p>
<p>&#8226; on identifie dans le segment courant &#0; C , les individus d&#233;j&#224; pr&#233;sents dans
&#1;
</p>
<p>. Pour un tel
individu a, on efface l&#8217;occurrence de a dans &#0; C et on reporte les relations auxquelles il
participait dans &#0; C vers l&#8217;occurrence de a dans
</p>
<p>&#1;
</p>
<p>, les dites relations passeront de Rint &#224;
Rext dans &#0; C .
</p>
<p>&#8226; pour les individus correspondant aux commandes dans struct, v&#233;rifier s&#8217;ils peuvent se
combiner avec un ou plusieurs autres individus de m&#234;me nature dans les segments pr&#233;c&#233;-
dents pour produire une tactique plus complexe. On identifie, par exemple, un raison-
nement par cas en unifiant avec l&#8217;expression conceptuelle qui lui correspond dans la base
de connaissances (qui contient des concepts d&#233;crivant les diff&#233;rents cas et leurs preuves)
avec les concepts correspondant &#224; un ensemble d&#8217;individus dans le volet struct r&#233;alisant
un raisonnement par cas. On utilise pour cela l&#8217;unification entre les concepts correspon-
dant aux tactiques de haut niveau avec les concepts des individus correspondants aux
commandes. Lorsque l&#8217;unification est possible, les segments en question et &#0; C seront
fusionn&#233;s en un seul segment.
</p>
<p>&#8226; pour tous les individus modifi&#233;s dans l&#8217;univers (les individus de &#0; C et ceux qui en ont &#233;t&#233;
effac&#233;s), on recalcule les concepts aux quels ils appartiennent et qui, dans certains cas,
sont plus sp&#233;cifiques du fait des nouvelles relations. Cela revient &#224; calculer le concept le
plus sp&#233;cifique de l&#8217;individu (on utilise test d&#8217;instance et subsomption).
</p>
<p>&#8226; on identifie les nouveaux individus repr&#233;sentants et on marque comme cach&#233; les &#233;l&#233;ments
de leur ensemble, les individus cach&#233;s ne seront pas pr&#233;sents dans le message final. Quand
un individu repr&#233;sentant perd son statut, &#224; cause de la pr&#233;sence dans le segment courant
d&#8217;un &#233;l&#233;ment de son ensemble, ce dernier devient visible.
</p>
<p>3.3 Instanciation et v&#233;rification
</p>
<p>La phase de s&#233;lection produit un univers de discours qui est exprim&#233; dans la DKB. Pour que
ce message donne un texte compr&#233;hensible par l&#8217;utilisateur, on va le projeter dans la UKB,
autrement dit, pour tout concept pr&#233;sent dans l&#8217;univers et n&#8217;appartenant pas &#224; sa UKB, on en
calcule la projection dans la UKB. L&#8217;instanciation est en quelque sorte une mise au niveau
de l&#8217;utilisateur du message. La raison principale pour laquelle la s&#233;lection n&#8217;est pas faite en
utilisant directement la UKB est qu&#8217;il est parfois n&#233;cessaire d&#8217;expliquer certaines parties de la
preuve &#224; un utilisateur qui n&#8217;aurait pas assez de connaissances pour les comprendre, alors que
le syst&#232;me en dispose. Ce choix a &#233;t&#233; fait dans l&#8217;optique d&#8217;utiliser PHOX coupl&#233; &#224; GEPHOX
pour l&#8217;enseignement des math&#233;matiques (Raffalli &amp; David, 2002).
</p>
<p>Pour finir, on v&#233;rifie la consistance de la base de connaissances compos&#233; de la UKB et la A-Box
correspondant &#224; l&#8217;univers de discours. Ceci garantit que le message donnera un texte coh&#233;rent
par rapport aux connaissances de l&#8217;utilisateur.
</p>
<p>Conclusion
</p>
<p>Dans cet article nous avons d&#233;crit une m&#233;thode de d&#233;termination de contenu, bas&#233;e sur
l&#8217;exploitation des propri&#233;t&#233;s des bases de connaissances d&#233;crivant le domaine math&#233;matique et
les connaissances qu&#8217;en a le destinataire du texte. Cet algorithme s&#233;pare deux types d&#8217;inf&#233;rences
mises en oeuvre dans la d&#233;termination de contenu : la premi&#232;re correspond au d&#233;roulement</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Adil El Ghali
</p>
<p>de cette t&#226;che i.e. comment on combine les donn&#233;es en entr&#233;e du syst&#232;me pour construire
un message coh&#233;rent, la deuxi&#232;me, qui exploite les bases de connaissances du syst&#232;me et les
m&#233;canismes de raisonnement offerts par celles-ci, garantit &#224; notre message les propri&#233;t&#233;s de
minimalit&#233;, de qualit&#233; et de fid&#233;lit&#233; &#224; l&#8217;entr&#233;e tout en &#233;tant au niveau de l&#8217;utilisateur
</p>
<p>Remerciements
</p>
<p>Merci &#224; Laurence Danlos, Michel Parigot et Paul Rozi&#232;re pour leur patience et leurs remarques.
</p>
<p>R&#233;f&#233;rences
BAADER F., KUSTERS R. &amp; MOLITOR R. (2000). Rewriting Concepts Using Terminologies &#8211; Revisited.
Rapport interne 00-04, Germany.
</p>
<p>F. BAADER, D. L. MCGUINNESS, D. NARDI &amp; P. F. PATEL-SCHNEIDER, Eds. (2003). Description
Logics Handbook: Theory, Implementation and Applications. Cambridge University Press.
</p>
<p>BAADER F. &amp; NARENDRAN P. (2001). Unification of concept terms in description logics. Journal of
Symbolic Computation 31(3), p. 277&#8211;305.
</p>
<p>COSCOY Y. (2000). Explication textuelles de preuves pour le calcul des constructions inductives. Th&#232;se
d&#8217;universit&#233;, Universit&#233; de Nice-Sophia-Antipolis.
</p>
<p>DONINI F., LENZERINI M., NARDI D. &amp; SCHAERF A. (1996). Reasoning in description logics. In G.
BREWKA, Ed., Principles of Knowledge Representation and Reasoning, Studies in Logic, Language and
Information, p. 193&#8211;238. CLSI Publications.
</p>
<p>EL GHALI A. &amp; ROUSSARIE L. (2003). Computing the rhetoric of text proofs. In Proceeding of ICoS-4,
Nancy, France.
</p>
<p>FIEDLER A. (2001a). P.rex: An interactive proof explainer. In Proceedings of the 1st International Joint
Conference on Automated Reasoning (IJCAR&#8217;01).
</p>
<p>FIEDLER A. (2001b). User-adaptive proof explanation. PhD thesis, Naturwissenschaftlich-Technische
Fakult&#228;t I, Universit&#228;t des Saarlandes, Saarbr&#252;cken, Germany.
</p>
<p>HALLGREN T. &amp; RANTA A. (2000). An extensible proof text editor. In In Logic for Programming and
Automated Reasoning (LPAR&#8217;2000),, volume LNCS/LNAI 1955, p. 70&#8211;84: Springer Verlag,.
</p>
<p>HORROCKS I. (2002). Reasoning with expressive description logics: Theory and practice. In A.
VORONKOV, Ed., Proceedings of the 18th International Conference on Automated Deduction.
</p>
<p>KRIVINE J.-L. (1997). Lambda-calcul, types et mod&#232;les. Dunod.
</p>
<p>RAFFALLI C. (2002). User&#8217;s manual of the PhoX library. LAMA, Universit&#233; de Savoie.
</p>
<p>RAFFALLI C. &amp; DAVID R. (2002). Apprentissage du raisonnement assit&#233; par ordinateur. Quadrature
45, p. 25&#8211;36.
</p>
<p>RAFFALLI C. &amp; ROZIERE P. (2002). The PhoX Proof checker documentation. LAMA, Universit&#233; de
Savoie / Universit&#233; Paris 7.
</p>
<p>REITER E. &amp; DALE R. (2000). Buiding Natural Language Generation Systems. Studies in Natural
Language Processing. Cambridge University Press.
</p>
<p>SRIPADA S., REITER E., HUNTER J. &amp; YU J. (2001). A two-stage model for content determination. In
Proceedings of ENLGW-2001, p. 3&#8211;10.</p>

</div></div>
</body></html>