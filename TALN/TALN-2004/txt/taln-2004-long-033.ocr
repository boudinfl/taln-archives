TALN 2004, Fes, 19-21 aVn'12004

Determination de contenu dans GEPHOX

Adil El Ghali
LATTICE / PPS — Universite Paris 7
2, place jussieu
case 7003 — 75251 Paris
adil@linguist.jussieu.fr

Résumé - Abstract

Le generateur GEPHOX que nous realisons a pour ambition de produire des textes pour des
deﬁnition ou preuves mathematiques ecrites a l’aide de l’assistant de preuve PHOX. Dans
cet article nous nous concentrons sur le module de determination de contenu Con tDet de
GEPHOX. Apres un apergu sur l’entree du generateur, i. e. la preuve formelle et l’ensemble des
regles ayant permis de l’obtenir, nous decrivons les base de connaissances du generateur et le
fonctionnement de l’algorithme de determination de contenu.

This paper deals with content determination in a text proofs generation system. Our system,
GEPHOX produces a textual version of a mathematical proof formalized using the proof assis-
tant PHOX. We start with a quick presentation of the input of the generator : the formal proof
and the set of rules that the proof assistant user employs in order to ﬁnd it. We describe the
generator knowledge bases and deﬁne the reasoning tasks associated with the KB and show
how the content determination algorithm work.

Mots-clefs — Keywords

Generation de textes, logique de description, determination de contenu, bases de connaissance,
assistant de preuve

Natural language generation, description logic, content determination, knowledge bases, proof
assistant

Adi1E1 Ghali

Introduction

La determination de contenu est la premiere tache de tout systeme de generation de texte. Elle
a pour but de produire une representation abstraite des donnees fourI1ies en entree du systeme.
C’est une des taches les plus ardues et sans doute la plus importante du processus de generation
(Reiter & Dale, 2000; Sripada et al., 2001). La plupart des utilisateurs d’un systeme de genera-
tion preferent avoir un texte dont le contenu est correct mais pauvrement exprime plutét qu’un
texte bien e’crit mais dont le contenu n’est pas satisfaisant.

Le generateur GEPHOX que nous realisons a pour ambition de produire des textes pour des
deﬁnition ou preuves mathematiques ecrites a l’aide de l’assistant de preuve PHOX (Raffalli,
2002; Raffalli & Roziere, 2002) . Dans cet article nous nous concentrons sur le module de
determination de contenu Con tDet de GEPHOX.

Un certain nombre de travaux ont eté menes dans ce domaine (Hallgren & Ranta, 2000; Coscoy,
2000). Les approches proposees par ces auteurs sont des tentatives plus ou moins reussies
d’établir une correspondance directe entre objets mathématiques et representations linguis-
tiques. Le point de vue que nous defendons est assez different : nous pensons qu’au moins
un niveau de representation intermédiaire est necessaire, aﬁn de pouvoir raisonner et manipu-
ler non pas des preuves mathematiques mais une we de ces preuves qui precede leur mise en
langue. Ce point de vue se rapproche plus des travaux de (Fiedler, 2001a; Fiedler, 200lb) o1‘1
une representation intermédiaire en termes d’actes de langage est calcule pour chaque action de
preuve. Cependant, la determination de contenu et la structuration de document sont confou-
dues dans son travail, alors que nous pensons qu’un certain nombre d’opérations de calcul de
contenu sont indépendantes de la structuration et qu’il faut separer les deux taches.

L’ approche de determination de contenu que nous proposons est centrée sur les connaissances
du systeme de generation. Nous Voyons cette tache comme la construction d’un univers de
discours (section 3). Le module Con tDet produit a partir de l’entree du systeme une represen-
tation (message) des connaissances qui vont ﬁgurer dans le texte, ce message est exprime en
logique de description i.e. il peut etre vu comme une A-Box. Par ailleurs, ce message est con-
struit de facon a préserver les elements de structure de PHOX qui vont etre utiles pour la suite
du processus de generation, notamment pour la structuration de document.

entree
l
Traduction
Base de <= Selection
connaissance => Instanciation
Veriﬁcation
l

message

Services de

Figure 1: Architecture du module Con tDet

Le module Con tDet repose sur une architecture en pipe-line a quatre sous-modules, comme le
montre la ﬁgure 1. Il utilise une base connaissances ecrite en Logique de Description a laquelle
on accede via une interface fournissant des services de raisonnement (subsomption, uniﬁcation
de concepts, ...).

Determination de contenu dans GEPHOX

L’article commence par une rapide presentation de PHOX et des elements qui serviront comme
entree pour notre genérateur (section 1). Nous présenterons ensuite les bases de connais-
sances du systeme et les services de raisonnement qui permettent d’y accéder (section 2) avant
d’expliciter le fonctionnement des différents sous-modules realisant la determination de con-
tenu (section 3).

1 Entrée du générateur

1.1 PHOX

PHOX est un assistant de preuve base sur le systeme AF21. Il permet de realiser sur ordinateur
des preuves mathématiques en deduction naturelle, mais aussi de déﬁnir des theories mathema-
tiques grace a un systeme de gestion de modules. Il est par ailleurs extensible i.e. l’utilisateur
peut déﬁnir ses propres commandes qui correspondent a des tactiques de raisonnement d’un
niveau plus éleve que les regles de deduction habituelles.

Un théoreme a prouver est considere par PHOX comme un but. Le déroulement de la preuve est
une application successive de commandes qui reduisent le but courant en sous-buts plus sim-
ples. Cet ensemble de commandes est appele script de preuve. PHOX répond aux commandes
du redacteurz en donnant le contexte courant de la preuve, c’est-a-dire les hypotheses a dispo-
sition et le(s) but(s) courant(s) qui reste(nt) a démontrer (les hypotheses et les buts courants
forment un séquent). Par ailleurs, le systeme peut fournir a chaque étape le fragment de l’arbre
de preuve construit i.e. les regles et théoremes utilises pour passer du sequent precedent au
sequent courant. La ﬁgure 2 montre un exemple d’entrée pour GEPHOX3. Pour produire le
texte correspondant a la preuve (ou a une étape de celle-ci), le générateur prend en entree toutes
ces informations.

< script >goal VX (G X <—> G1 X V G2 X) —> VX:G1 G2 X V VX:G2 G1X.< /script >
< phoa: >

Here is the goal:

goal 1/1

|— —> (V AX (<—> (G X) (V (G1 X) (G2 X)))) (V (V AX (—> (G1 X) (G2 X))) (V AX (—> (G2 X) (G1 X))))
< /phoa: >

< script >intros.< /script >

< proof >

arrow_intro (V AX (<—> (G X) (V (G1 X) (G2 X)))) AH

(comment "goal 1")

< /proof >

< phoa: >

New goal is:

goal 1/1

H := V AX (<—> (G X) (V (G1 X) (G2 X)))

|- V (V AX (—> (G1 X) (G2 X))) (V AX (—> (G2 X) (G1 X)))

< /phoa: >

Figure 2: Exemple d’entree du générateur

1Arithmétique fonctionnelle d’ordre 2 (Krivine, 1997)

2On désigne par rédacteur l’uti]isateur de PHOX qui construit la version formelle de la preuve, et par utilisateur
le destinataire du texte produit par GEPHOX.

3Les tags < script >, < phoa: > et < proof > délimitent respectivement au script de preuve rentré par le
rédacteur, a la réponse de PHOX qui déﬁnit le contexte courant et au fragment d’arbre de preuve correspondant.

Adi1E1 Ghali

1.2 Les elements de l’entree

Script de preuve Les scripts de preuve peuvent contenir deux types de commandes. D’une
part, les annonces qui regroupent, entre autres, les declarations d’objets (types, variables, ...),
les deﬁnitions ou les enonces de theoremes. D’autre part, les commandes de preuve qui re-
groupent les regles de deduction (regles d’introduction ou d’elin1ination de la deduction na-
turelle) ou tactiques de preuves (raisonnement par l’absurde, par recurrence, ...) servant a
avancer dans la recherche de preuve.

Contexte A chaque etape de la preuve, le redacteur passe d’un se’quent(un ensemble
d’hypotheses et un but a prouver) a un autre en appliquant une regle de deduction ou une tactique
de preuve. Le contexte est l’ensemble des hypotheses et des buts disponibles a chaque etape,
Par exemple, apres l’application de la regle d’introduction de —> sur l’aImonce du theoreme a
demontrer

‘v’ac(Gac<—>G1ac V G2ac)‘v’acEG1G2acVVacEG2G1ac.4

le contexte resultant contient l’hypothese H: Vx ((G x) <—> (G1 x V G2 x)) et le nouveau but
qu’il faut prouver (Vx G1 x —> G2 x) V (Vx G2 x —> G1 x).

Arbre de preuve Cette partie de l’entree nous fourI1it des informations sur ce que le prouveur
a utilise comme regles elementaires, theoremes, axiomes ou deﬁnitions. Elle est plus informa-
tive que le script de preuve, e.g. l’application de la regle d’introduction de —> est implicite dans
le script mais elle ne l’est pas dans le fragment d’arbre de preuve correspondant a cette com-
mande. Par ailleurs, quand le prouveur utilise la tactique automatique, les theoremes et regles
utilisees ne sont explicitees5 que dans l’arbre de preuve.

2 Bases de connaissances

Le module Con tDet utilise pour representer les connaissances du domaine une base de con-
naissances ecrite en Logique de Description. Ce choix est motive par plusieurs raisons, prin-
cipalement : ( i ) les bonnes proprietes mathematiques de ce formalisme nous permettent de
controler la complexite du processus de generation, (ii) la separation entre connaissances inten-
sionnelles et extensionnelles est bien adaptee a la generation de textes, (iii) l’existence de raison-
neurs optimises fourI1issantles services standards de raisonnements facilite l’implementation du
systeme.

2.1 Logique de description

Les logiques de description (description logics terme abrege en DL) (Baader et al., 2003) sont
un formalisme de representation des connaissances base sur la logique du premier ordre et

4Le theoreme s’enonce ainsi: « si dans un groupe G, tout element est dans 1’un des deux sous-groupes G1 ou
G2 alors 1’un des sous-groupes est inclu dans l’autre (tout element de G1 appartient a G2 ou tout element de G2
appartient a G1). »

5Ces informations sont importantes parce qu’e]1es doivent étre incluses dans le texte destine a un utilisateur qui
ne les possede pas dans sa base de connaissances personnelle (cf. section 2.2).

Détermination de contenu dans GEPHOX

descendant des réseaux sémantiques et des systemes a base de frames. Dans ce formalisme, la
theorie est divisée en deux parties, (i) la T-Box qui regroupe les connaissances intensiormelles
(conceptuelles ou terminologiques) i.e. les concepts et les relations du domaine, et (ii) la A-
Box qui regroupe les connaissances extensiormelles (assertionelles) décrivant les individus du
domaine et les relations entre eux. Les concepts peuvent etre Vus comme des classes d’individus
du domaine et les rﬁles comme des relations binaires entre concepts/individus. Le formalisme
offre un certain nombre d’operateurs (généralement appelés constructeurs) qui permettent de
déﬁnir des concepts et roles complexes en fonction d’autres plus simples. Le langage que nous

utilisons comprend les constructeurs dont la syntaxe et la sémantique sont présentés dans la
table 1.

Nom du constructeur Syntaxe Sémantique

concept atomique A AI Q AI

top T AI

bottom J. I?)

conjonction C /\ D CI ﬂ DI

disjonction (U) C V D CI U DI

complement (C) -C AI CI

quantiﬁcation univ. \7’R.C { x I \7’y (x,y) 6 RI => y E CI}
quantiﬁcation exist. (8) E|R.C { xl Ely (x,y) 6 RI => y E CI}
restrictions numeriques (N) >n R.C { xl Ii{ y I \7’y (x,y) 6 RI} > n }

£nR.C {X|II{y|Vy(x.y)€RI}Sn}

collection d’individus ((9) {a1,. . .,a,,} {aI,. . .,a£}

role atomique P PI Q AI x AI

conjonction de role (’R,) Q /\ R RI ﬂ RI

role inverse R 1 {(a1,a2) I ((a2,a1) 6 RI}
composition de roles Q o R {(a1,a2) I Elag (a1,a3) E QI/\ (a3,a2) 6 RI}

Table 1: Syntaxe et semantique des constructeurs de concepts et de roles

Les DL offrent plusieurs services de raisonnement (Donini et al., 1996; Horrocks, 2002). Soit
une base de connaissances 2, on designe par les lettres majuscules C, D des concepts com-
plexes, R, Q des roleset par les lettres minuscules a, b des individus. Les services de raison-
nements que nous utilisons sont déﬁnis comme suit.

Subsomption : ce qu’on ecrit E I- C Q D. Ce service permet de tester si dans la base de
connaissances 2, C est subsume par D, ce qui est vériﬁe quand CI Q DI dans tout modele
I de 2. Pour les besoins de la determination de contenu, la subsomption permet de dire si
un concept est plus speciﬁque qu’un autre. Un service oﬁ”-line lie a la subsomption est la
classiﬁcation ou hiérarchisation des concepts d’une base de connaissances. Par ailleurs,
ont dit que C et D sont equivalents (note C E D) si C Q D et D Q C.

Consistance : ce qu’on ecrit 2 I5. Ce service permet de veriﬁer si 23 est satisﬁable, i.e. que
2 a un modele. La consistance est utilisee par le module ContDet pour assurer que
le message delivre a la sortie du module ne contient pas d’incohérence, ce qui se verrait
dans le texte ou bloquerait le reste du processus de generation.

Test d’instance : ce qu’on écrit E I- C(a) (resp. E I- R(a, b)). Ce service permet de veriﬁer
si l’assertion C(a) (resp. R(a, b)) est satisfaite dans tous les modeles de 2, autrement dit,
que a est membre du concept C (resp. (a,b) est membre de la relation R).

Uniﬁcation : ce service de raisonnement, introduit dans (Baader et al. , 2000; Baader & Naren-
dran, 2001) a pour but, etant domes C et D, de trouver une substitution 0 (appelée uni-

Adi1E1 Ghali

ﬁeur), telle que a(C) E o(D). Par exemple, si C = AV‘v’R.A et D = (B1/\B2)V‘v’R.(B1/\B2),
la substitution 0 qui remplace A par B1/\B2 dans C est un uniﬁeur pour C et D. On utilise
ce service pour trouver un concept dont la deﬁnition s’uniﬁe avec une expression con-
ceptuelle et qui pourrait la designer. Ce qui permet, par exemple, de detecter des tactiques
de raisonnement complexes.

Projection : c’est un service de raisonnement non standard qui met en jeu deux bases de con-
naissances 21 et 22 telles que 22 C 21. Pour tout concept C dans 21 et n’appartenant pas
a 22, ce service permet de trouver une deﬁnition de C avec uniquement des concepts de
22. La projection est utilise par le module Con tDet pour adapter le message aux con-
naissances de chaque utilisateur : si au cours du processus de determination de contenu,
on maI1ipule un concept qui n’est pas connu par l’utilisateur, le message va etre enrichi
par la deﬁnition de ce concept, ce qui assure une meilleure comprehension du texte ﬁnal.
Par exemple, dans la presentation d’une preuve manipulant des groupes a un utilisateur
ne maitrisant pas le concept de groupe, on explicitera qu’un groupe est un ensemble muni
d’une loi associative, possedant un element neutre et dont tous les elements possedent
un inverse. Dans ce cas de ﬁgure, les concepts de Ensemble, Loi, Element, Inverse,
E|ementNeutre sont dans la base de connaissances de l’utilisateur, mais pas celui de
Groupe.

2.2 Bases de connaissances de GEPHOX

GEPHOX dispose de deux bases de connaissances. Le premiere, DKB (Domain Knowledge
Base), contient toute les connaissances sur le domaine mathematique dont dispose le systeme.
Elle est structuree en deux parties. D’une part, un noyau correspondant a la base de PHOX : les
concepts decrivant les types de base, les commandes et les objets mathematiques (variable,
operateurs—|ogique, ...) et meta-mathematiques (theoreme, definition, commandes—de—
preuves, ...) de bas niveau. D’autre part, un ensemble de modules (dont le découpage est
calque sur celui de PHOX) correspondant aux differentes theories mathematiques, e.g. un mod-
ule pour les entiers, un autre pour les groupes. Lorsque le systeme entame un processus de
generation, la base de connaissances qu’il utilise ne contiendra que le noyau et les modules
qui representent les connaissances des theories que le redacteur de la preuve a choisi d’utiliser.
Ce decoupage en modules de la DKB reduit la taille de la base de connaissances effectivement
utilisee et ameliore l’efﬁcacite du systeme.

La deuxieme base de connaissances dont dispose le systeme, UKB (User Knowledge Base), est
speciﬁque a chaque utilisateur ; il s’agit en fait d’un sous ensemble de la DKB qui reﬂete ses
connaissances.

3 Algorithme de détermination de contenu

Come on l’a vu dans la section 1, l’entree du generateur GEPHOX est riche car elle comporte
certains elements qui peuvent etre vus comme du contenu "pur" (la description des objets math-
ematiques, l’arbre de preuve) et d’autres qui sont plutot des informations sur la structure de la
preuve (les hypotheses et buts intermediaires, les commandes appliquees). Dans le déroulement
de la tache de determination de contenu, chacun de ces elements prend un statut particulier. Les
premiers vont nous donner les referents aux objets du domaine du discours, et les seconds des

Determination de contenu dans GEPHOX

actes de langage et des actions de preuve. C’est pour cette raison qu’on a besoin de manipu-
ler dans le module ContDet des structures de données permettant de séparer ces deux types
d’informations. Ainsi le choix du contenu a exprimer se fait en préservant la structure de la
preuve, ce dont on aura besoin dans la tache de structuration de document (El Ghali & Rous-
sarie, 2003).

La structure de donnees elémentaire manipulee par le module Con tDet que l’on appellera
segment est la traduction d’une étape de preuve dans PHOX. Elle comporte deux parties : la
premiere, data, qui contient les informations relatives aux obj ets mathématiques manipules dans
la preuve, et qui, du point de vue du systeme de generation, correspond a du contenu pur. La
seconde, struct, qui contient les informations structurantes de la preuve mathématique. Ces
deux parties sont exprimees en DL, ce sont des fragments d’une A-Box. Nous avons choisi de
les exprimer dans la meme terminologie pour rendre compte plus facilement des relations entre
les individus dans la partie data et ceux dans la partie struct.

Le module Con tDet Va tout au long du traitement d’une entree construire de maniere incre-
mentale un univers de discours qui sera compose de segments. Plus précisement, on deﬁnit les
structures de donnees comme suit :

Déﬁnition 1 segment

Un segment est un quadruplet (data, struct, Rint, Rm) ou data et struct sont deux ensem-
bles de triplets (individu, concept, type) correspondant aux individus, aux concepts auxquels
ils appartiennent et a leur type, pour respectivement la composante donnees et la composante
structure. Rim (relations internes au segment) est un ensemble de relations binaires entre des
elements de data U struct et Rm (relations externes au segment) est un ensemble de relations
binaires dont un participant est dans data U struct et l’autre dans un autre segment.

Déﬁnition 2 univers de discours

Un univers de discours 1U est une suite ordonnee de segments, telle qu’il n’existe pas d’individu
a appartenant a deux segments différents, et telle que tout segment est relie a au moins un autre
segment de 1U i.e. VS E U Rfwt aé (Z). L’unicite des individus nous assure que notre message
ne contiendra pas de redondance. La condition de connexité de l’uniVers de discours quand a
elle sert a identiﬁer les parties du textes qui ont pas de lien et qui correspondront a des unites

textuelles (paragraphes, sections, ...) différents dans le texte ﬁnal.

Déﬁnition 3 types d’individus

Les individus qui composent les segments sont types pour les besoins de la determination de
contenu. Les types sont dynamiques et n’apparaissent pas dans la base de connaissances. La
procedure de calcul du type d’un individu nous permet de distinguer les informations qui vont
apparaitre dans le message ﬁnal de celles qui n’y seront pas incluses. La visibilite’ d’un individu
signiﬁe qu’il sera present dans le message. Prenons le cas d’une formule f qui contient des
variables et des connecteurs logiques. Si les elements qui composent f ne sont pas utilises pour
avancer dans la preuve, les individus correspondant ne vont pas apparaitre dans le message,
mais ils seront presents dans l’uniVers de discours en etant cachés. L’individu correspondant a
f les représerztera dans le message.

On distingue donc trois types d’individu :

visible c’est le type par défaut, les individus ayant ce type seront presents dans le message
ﬁnal ;

Adi1E1 Ghali

représentant pour les individus qui ont la particularité d’étre le seul lien d’un ensemble
d’individus avec le reste du segment ou de l’uniVers ;

caché pour ceux qui appartiennent a l’ensemble d’un individu représentant.

Le sous-module de traduction traite une a une les parties de l’entree correspondant a une com-
mande, le segment ainsi produit est intégré a l’uniVers de discours courant en effectuant des
choix sur les parties a garder et celles a ne pas dire ; par la suite l’univers de discours produit
est instancié pour l’utilisateur courant, puis vériﬁé (cf. section 3.3).

3.1 Traduction

La tache du sous-module de traduction est de traduire l’entrée (script, réponses de PHOX et
arbre de preuve) en DL. Cette operation doit produire une representation de toutes les informa-
tions disponibles dans l’entrée. Elle doit, par ailleurs, preserver la structure de la preuve qui Va
servir a la structuration de document. La stratégie adoptée pour la traduction est de traiter un
bloc compose d’une commande PHOX, de la reponse a cette commande et du fragment d’arbre
de preuve correspondant, pour construire une structure composée d’une partie donnée et d’une
partie structure.

Une commande PHOX est compose de deux parties : l’instruction de preuve
(intro, elim, goal, ...) et une partie arguments qui peut étre soit l’énonce (une formule) d’un
théoreme a prouver ou d’une deﬁnition dans le cas des commandes de f , goal, lem, ..., soit une
hypothese, une variable, un opérateur logique,  pour les autres commandes, soit vide quand
le rédacteur de la preuve laisse a la tactique automatique le soin de choisir les arguments pour
sa commande. Les instructions de preuve vont étre traduites par des individus appartenant au
concept correspondant et cet individu sera range dans la case struct du segment courant. Pour
la partie arguments nous avons deux cas de ﬁgures. D’une part, un argument peut introduire
un seul individu, c’est le cas pour les variables, les noms d’hypotheses et les opérateurs ; le
module de traduction crée alors un individu pour ce referent et doit calculer le concept auquel
il appartient. D’autre part, un argument peut introduire plusieurs référents de discours; c’est le
cas pour une formule, les variables et connecteurs logiques composant une formule donneront
autant d’individus dans l’univers de discours. Par exemple, une commande goal f va produire
un individu g Q Goal qui sera relié par le role has - formula a la traduction de f.

3.2 Sélection

Le sous-module de selection est le coeur de Con tDet : c’est durant cette phase que les choix
les plus importants s’effectuent : decider de ce qui Va étre inclus dans le message et de ce qu’on
rze va pas dire, garantir que le message est assez informatif, mais pas trop et ne pas perdre la
structure génerale de la preuve qui nous servira par la suite.

Le module de selection construit un univers de discours 1U de maniere incrémentale, le processus
commence par un univers de discours vide, on y ajoute au fur et a mesure les segments fourI1is
par le module de traduction. Quand un segment est ajoute a U, plusieurs procedures sont
executees :

Determination de contenu dans GEPHOX

0 on identiﬁe dans le segment courant So, les individus déja presents dans 1U. Pour un tel
individu a, on efface l’occurrence de a dans SC et on reporte les relations auxquelles il
participait dans SC vers l’occurrence de a dans U, les dites relations passeront de Rint a
Rm dans So.

0 pour les individus correspondant aux commandes dans struct, veriﬁer s’ils peuvent se
combiner avec un ou plusieurs autres individus de meme nature dans les segments prece-
dents pour produire une tactique plus complexe. On identiﬁe, par exemple, un raison-
nement par cas en uniﬁant avec l’expression conceptuelle qui lui correspond dans la base
de connaissances (qui contient des concepts décrivant les différents cas et leurs preuves)
avec les concepts correspondant a un ensemble d’individus dans le volet struct realisant
un raisonnement par cas. On utilise pour cela l’uniﬁcation entre les concepts correspon-
dant aux tactiques de haut niveau avec les concepts des individus correspondants aux
commandes. Lorsque l’uniﬁcation est possible, les segments en question et So seront
fusionnes en un seul segment.

0 pour tous les individus modiﬁes dans l’univers (les individus de SC et ceux qui en ont ete
effacés), on recalcule les concepts aux quels ils appartiennent et qui, dans certains cas,
sont plus spéciﬁques du fait des nouvelles relations. Cela revient a calculer le concept le
plus spéciﬁque de l’individu (on utilise test d’instance et subsomption).

0 on identiﬁe les nouveaux individus représentants et on marque comme caché les elements
de leur ensemble, les individus caches ne seront pas presents dans le message ﬁnal. Quand
un individu representant perd son statut, a cause de la presence dans le segment courant
d’un element de son ensemble, ce derI1ier devient visible.

3.3 Instanciation et vériﬁcation

La phase de selection produit un uI1ivers de discours qui est exprime dans la DKB. Pour que
ce message donne un texte comprehensible par l’utilisateur, on Va le projeter dans la UKB,
autrement dit, pour tout concept present dans l’univers et n’appartenant pas a sa UKB, on en
calcule la projection dans la UKB. L’instanciation est en quelque sorte une mise au niveau
de l’utilisateur du message. La raison principale pour laquelle la selection n’est pas faite en
utilisant directement la UKB est qu’il est parfois necessaire d’expliquer certaines parties de la
preuve a un utilisateur qui n’aurait pas assez de connaissances pour les comprendre, alors que
le systeme en dispose. Ce choix a ete fait dans l’optique d’utiliser PHOX couple a GEPHOX
pour l’enseignement des mathématiques (Raffalli & David, 2002).

Pour ﬁnir, on veriﬁe la consistance de la base de connaissances compose de la UKB et la A-Box
correspondant a l’univers de discours. Ceci garantit que le message donnera un texte coherent
par rapport aux connaissances de l’utilisateur.

Conclusion

Dans cet article nous avons décrit une méthode de determination de contenu, basee sur
l’exploitation des proprietes des bases de connaissances décrivant le domaine mathématique et
les connaissances qu’en a le destinataire du texte. Cet algorithme sépare deux types d’inférences
mises en oeuvre dans la determination de contenu : la premiére correspond au déroulement

Adi1E1 Ghali

de cette tache i.e. comment on combine les données en entree du systeme pour construire
un message coherent, 1a deuxiéme, qui exploite les bases de connaissances du systeme et les
mecanismes de raisonnement offerts par ce11es-ci, garantit a notre message les proprietes de
minimalite, de qualité et de ﬁdélite a 1’entrée tout en etant au niveau de 1’uti1isateur

Remerciements

Merci a Laurence Danlos, Michel Pari got et Paul Roziere pour 1eur patience et leurs remarques.

Références

BAADER F., KUSTERS R. & MOLITOR R. (2000). Rewriting Concepts Using Terminologies -Revisited.
Rapport inteme 00-04, Germany.

F. BAADER, D. L. MCGUINNESS, D. NARDI & P. F. PATEL-SCHNEIDER, Eds. (2003). Description
Logics Handbook: Theory, Implementation and Applications. Cambridge University Press.

BAADER F. & NARENDRAN P. (2001). Uniﬁcation of concept terms in description logics. Journal of
Symbolic Computation 31(3), p. 277-305.

COSCOY Y. (2000). Explication textuelles de preuves pour le calcul des constructions inductives. These
d’université, Université de Nice-Sophia-Antipolis.

DONINI F., LENZERINI M., NARDI D. & SCHAERF A. (1996). Reasoning in description logics. In G.
BREWKA, Ed., Principles of Knowledge Representation and Reasoning, Studies in Logic, Language and
Information, p. 193-238. CLSI Publications.

EL GHALI A. & ROUSSARIE L. (2003). Computing the rhetoric of text proofs. In Proceeding of I CoS—4,
Nancy, France.

FIEDLER A. (2001a). P.rex: An interactive proof explainer. In Proceedings of the I st International Joint
Conference on Automated Reasoning (IJCAR ’0I).

FIEDLER A. (2001b). User—adaptive proof explanation. PhD thesis, Naturwissenschaftlich-Technische
Fakultat I, Universitat des Saarlandes, Saarbriicken, Germany.

HALLGREN T. & RANTA A. (2000). An extensible proof text editor. In In Logic for Programming and
Automated Reasoning (LPAR’2000),, volume LNCS/LNAI 1955, p. 70-84: Springer Verlag,.

HORROCKS I. (2002). Reasoning with expressive description logics: Theory and practice. In A.
VORONKOV, Ed., Proceedings of the I 8th International Conference on Automated Deduction.

KRIVINE J.-L. (1997). Lambda-calcul, types et modeles. Dunod.
RAFFALLI C. (2002). User’s manual of the PhoX library. LAMA, Université de Savoie.

RAFFALLI C. & DAVID R. (2002). Apprentissage du raisonnement assité par ordinateur. Quadrature
45, p. 25-36.

RAFFALLI C. & ROZIERE P. (2002). The PhoX Proof checker documentation. LAMA, Université de
Savoie / Université Paris 7.

REITER E. & DALE R. (2000). Buiding Natural Language Generation Systems. Studies in Natural
Language Processing. Cambridge University Press.

SRIPADA S., REITER E., HUNTER J. & YU J . (2001). A two-stage model for content determination. In
Proceedings of ENLGW—200I , p. 3-10.

