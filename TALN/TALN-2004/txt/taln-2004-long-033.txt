TALN 2004, FÃ¨s, 19â€“21 avril 2004
DÃ©termination de contenu dans GEPHOX
Adil El Ghali
LATTICE / PPS - UniversitÃ© Paris 7
2, place jussieu
case 7003 - 75251 Paris
adil@linguist.jussieu.fr
RÃ©sumÃ© - Abstract
Le gÃ©nÃ©rateur GEPHOX que nous rÃ©alisons a pour ambition de produire des textes pour des
dÃ©finition ou preuves mathÃ©matiques Ã©crites Ã  lâ€™aide de lâ€™assistant de preuve PHOX. Dans
cet article nous nous concentrons sur le module de dÃ©termination de contenu ContDet de
GEPHOX. AprÃ¨s un aperÃ§u sur lâ€™entrÃ©e du gÃ©nÃ©rateur, i.e. la preuve formelle et lâ€™ensemble des
rÃ¨gles ayant permis de lâ€™obtenir, nous dÃ©crivons les base de connaissances du gÃ©nÃ©rateur et le
fonctionnement de lâ€™algorithme de dÃ©termination de contenu.
This paper deals with content determination in a text proofs generation system. Our system,
GEPHOX produces a textual version of a mathematical proof formalized using the proof assis-
tant PHOX. We start with a quick presentation of the input of the generator : the formal proof
and the set of rules that the proof assistant user employs in order to find it. We describe the
generator knowledge bases and define the reasoning tasks associated with the KB and show
how the content determination algorithm work.
Mots-clefs â€“ Keywords
GÃ©nÃ©ration de textes, logique de description, dÃ©termination de contenu, bases de connaissance,
assistant de preuve
Natural language generation, description logic, content determination, knowledge bases, proof
assistant
Adil El Ghali
Introduction
La dÃ©termination de contenu est la premiÃ¨re tÃ¢che de tout systÃ¨me de gÃ©nÃ©ration de texte. Elle
a pour but de produire une reprÃ©sentation abstraite des donnÃ©es fournies en entrÃ©e du systÃ¨me.
Câ€™est une des tÃ¢ches les plus ardues et sans doute la plus importante du processus de gÃ©nÃ©ration
(Reiter & Dale, 2000; Sripada et al., 2001). La plupart des utilisateurs dâ€™un systÃ¨me de gÃ©nÃ©ra-
tion prÃ©fÃ¨rent avoir un texte dont le contenu est correct mais pauvrement exprimÃ© plutÃ´t quâ€™un
texte bien Ã©crit mais dont le contenu nâ€™est pas satisfaisant.
Le gÃ©nÃ©rateur GEPHOX que nous rÃ©alisons a pour ambition de produire des textes pour des
dÃ©finition ou preuves mathÃ©matiques Ã©crites Ã  lâ€™aide de lâ€™assistant de preuve PHOX (Raffalli,
2002; Raffalli & Roziere, 2002) . Dans cet article nous nous concentrons sur le module de
dÃ©termination de contenu ContDet de GEPHOX.
Un certain nombre de travaux ont Ã©tÃ© menÃ©s dans ce domaine (Hallgren & Ranta, 2000; Coscoy,
2000). Les approches proposÃ©es par ces auteurs sont des tentatives plus ou moins rÃ©ussies
dâ€™Ã©tablir une correspondance directe entre objets mathÃ©matiques et reprÃ©sentations linguis-
tiques. Le point de vue que nous dÃ©fendons est assez diffÃ©rent : nous pensons quâ€™au moins
un niveau de reprÃ©sentation intermÃ©diaire est nÃ©cessaire, afin de pouvoir raisonner et manipu-
ler non pas des preuves mathÃ©matiques mais une vue de ces preuves qui prÃ©cÃ¨de leur mise en
langue. Ce point de vue se rapproche plus des travaux de (Fiedler, 2001a; Fiedler, 2001b) oÃ¹
une reprÃ©sentation intermÃ©diaire en termes dâ€™actes de langage est calculÃ© pour chaque action de
preuve. Cependant, la dÃ©termination de contenu et la structuration de document sont confon-
dues dans son travail, alors que nous pensons quâ€™un certain nombre dâ€™opÃ©rations de calcul de
contenu sont indÃ©pendantes de la structuration et quâ€™il faut sÃ©parer les deux tÃ¢ches.
Lâ€™approche de dÃ©termination de contenu que nous proposons est centrÃ©e sur les connaissances
du systÃ¨me de gÃ©nÃ©ration. Nous voyons cette tÃ¢che comme la construction dâ€™un univers de
discours (section 3). Le module ContDet produit Ã  partir de lâ€™entrÃ©e du systÃ¨me une reprÃ©sen-
tation (message) des connaissances qui vont figurer dans le texte, ce message est exprimÃ© en
logique de description i.e. il peut Ãªtre vu comme une A-Box. Par ailleurs, ce message est con-
struit de faÃ§on Ã  prÃ©server les Ã©lÃ©ments de structure de PHOX qui vont Ãªtre utiles pour la suite
du processus de gÃ©nÃ©ration, notamment pour la structuration de document.
Services de entrÃ©e
raisonnement â†“
Traduction
Base de â‡= SÃ©lection
connaissance =â‡’ Instanciation
VÃ©rification
â†“
message
Figure 1: Architecture du module ContDet
Le module ContDet repose sur une architecture en pipe-line Ã  quatre sous-modules, comme le
montre la figure 1. Il utilise une base connaissances Ã©crite en Logique de Description Ã  laquelle
on accÃ¨de via une interface fournissant des services de raisonnement (subsomption, unification
de concepts, ...).
DÃ©termination de contenu dans GEPHOX
Lâ€™article commence par une rapide prÃ©sentation de PHOX et des Ã©lÃ©ments qui serviront comme
entrÃ©e pour notre gÃ©nÃ©rateur (section 1). Nous prÃ©senterons ensuite les bases de connais-
sances du systÃ¨me et les services de raisonnement qui permettent dâ€™y accÃ©der (section 2) avant
dâ€™expliciter le fonctionnement des diffÃ©rents sous-modules rÃ©alisant la dÃ©termination de con-
tenu (section 3).
1 EntrÃ©e du gÃ©nÃ©rateur
1.1 PHOX
PHOX est un assistant de preuve basÃ© sur le systÃ¨me AF 12 . Il permet de rÃ©aliser sur ordinateur
des preuves mathÃ©matiques en dÃ©duction naturelle, mais aussi de dÃ©finir des thÃ©ories mathÃ©ma-
tiques grÃ¢ce Ã  un systÃ¨me de gestion de modules. Il est par ailleurs extensible i.e. lâ€™utilisateur
peut dÃ©finir ses propres commandes qui correspondent Ã  des tactiques de raisonnement dâ€™un
niveau plus Ã©levÃ© que les rÃ¨gles de dÃ©duction habituelles.
Un thÃ©orÃ¨me Ã  prouver est considÃ©rÃ© par PHOX comme un but. Le dÃ©roulement de la preuve est
une application successive de commandes qui rÃ©duisent le but courant en sous-buts plus sim-
ples. Cet ensemble de commandes est appelÃ© script de preuve. PHOX rÃ©pond aux commandes
du rÃ©dacteur2 en donnant le contexte courant de la preuve, câ€™est-Ã -dire les hypothÃ¨ses Ã  dispo-
sition et le(s) but(s) courant(s) qui reste(nt) Ã  dÃ©montrer (les hypothÃ¨ses et les buts courants
forment un sÃ©quent). Par ailleurs, le systÃ¨me peut fournir Ã  chaque Ã©tape le fragment de lâ€™arbre
de preuve construit i.e. les rÃ¨gles et thÃ©orÃ¨mes utilisÃ©s pour passer du sÃ©quent prÃ©cÃ©dent au
sÃ©quent courant. La figure 2 montre un exemple dâ€™entrÃ©e pour GEPHOX3 . Pour produire le
texte correspondant Ã  la preuve (ou Ã  une Ã©tape de celle-ci), le gÃ©nÃ©rateur prend en entrÃ©e toutes
ces informations.
< script >goal âˆ€x (G xâ†” G1 x âˆ¨ G2 x)â†’ âˆ€x:G1 G2 x âˆ¨ âˆ€x:G2 G1 x.< /script >
< phox >
Here is the goal:
goal 1/1
â†’ (âˆ€ Î»x (â†” (G x) (âˆ¨ (G1 x) (G2 x)))) (âˆ¨ (âˆ€ Î»x (â†’ (G1 x) (G2 x))) (âˆ€ Î»x (â†’ (G2 x) (G1 x))))
< /phox >
< script >intros.< /script >
< proof >
arrow_intro (âˆ€ Î»x (â†” (G x) (âˆ¨ (G1 x) (G2 x)))) Î»H
(comment "goal 1")
< /proof >
< phox >
New goal is:
goal 1/1
H := âˆ€ Î»x (â†” (G x) (âˆ¨ (G1 x) (G2 x)))
 âˆ¨ (âˆ€ Î»x (â†’ (G1 x) (G2 x))) (âˆ€ Î»x (â†’ (G2 x) (G1 x)))
< /phox >
Figure 2: Exemple dâ€™entrÃ©e du gÃ©nÃ©rateur
1ArithmÃ©tique fonctionnelle dâ€™ordre 2 (Krivine, 1997)
2On dÃ©signe par rÃ©dacteur lâ€™utilisateur de PHOX qui construit la version formelle de la preuve, et par utilisateur
le destinataire du texte produit par GEPHOX.
3Les tags < script >,< phox > et < proof > dÃ©limitent respectivement au script de preuve rentrÃ© par le
rÃ©dacteur, Ã  la rÃ©ponse de PHOX qui dÃ©finit le contexte courant et au fragment dâ€™arbre de preuve correspondant.
Adil El Ghali
1.2 Les Ã©lÃ©ments de lâ€™entrÃ©e
Script de preuve Les scripts de preuve peuvent contenir deux types de commandes. Dâ€™une
part, les annonces qui regroupent, entre autres, les dÃ©clarations dâ€™objets (types, variables, ...),
les dÃ©finitions ou les Ã©noncÃ©s de thÃ©orÃ¨mes. Dâ€™autre part, les commandes de preuve qui re-
groupent les rÃ¨gles de dÃ©duction (rÃ¨gles dâ€™introduction ou dâ€™Ã©limination de la dÃ©duction na-
turelle) ou tactiques de preuves (raisonnement par lâ€™absurde, par rÃ©currence, ...) servant Ã 
avancer dans la recherche de preuve.
Contexte Ã€ chaque Ã©tape de la preuve, le rÃ©dacteur passe dâ€™un sÃ©quent(un ensemble
dâ€™hypothÃ¨ses et un but Ã  prouver) Ã  un autre en appliquant une rÃ¨gle de dÃ©duction ou une tactique
de preuve. Le contexte est lâ€™ensemble des hypothÃ¨ses et des buts disponibles Ã  chaque Ã©tape,
Par exemple, aprÃ¨s lâ€™application de la rÃ¨gle dâ€™introduction de â†’ sur lâ€™annonce du thÃ©orÃ¨me Ã 
dÃ©montrer
âˆ€x (G x â†” G1 x âˆ¨ G2 x) â†’ âˆ€x âˆˆ G1 G2x âˆ¨ âˆ€x âˆˆ G2 G1x. 4
le contexte rÃ©sultant contient lâ€™hypothÃ¨se H: âˆ€x ((G x)â†” (G1 x âˆ¨ G2 x)) et le nouveau but
quâ€™il faut prouver (âˆ€x G1 xâ†’ G2 x) âˆ¨ (âˆ€x G2 xâ†’ G1 x).
Arbre de preuve Cette partie de lâ€™entrÃ©e nous fournit des informations sur ce que le prouveur
a utilisÃ© comme rÃ¨gles Ã©lÃ©mentaires, thÃ©orÃ¨mes, axiomes ou dÃ©finitions. Elle est plus informa-
tive que le script de preuve, e.g. lâ€™application de la rÃ¨gle dâ€™introduction deâ†’ est implicite dans
le script mais elle ne lâ€™est pas dans le fragment dâ€™arbre de preuve correspondant Ã  cette com-
mande. Par ailleurs, quand le prouveur utilise la tactique automatique, les thÃ©orÃ¨mes et rÃ¨gles
utilisÃ©es ne sont explicitÃ©es5 que dans lâ€™arbre de preuve.
2 Bases de connaissances
Le module ContDet utilise pour reprÃ©senter les connaissances du domaine une base de con-
naissances Ã©crite en Logique de Description. Ce choix est motivÃ© par plusieurs raisons, prin-
cipalement : (i) les bonnes propriÃ©tÃ©s mathÃ©matiques de ce formalisme nous permettent de
contrÃ´ler la complexitÃ© du processus de gÃ©nÃ©ration, (ii) la sÃ©paration entre connaissances inten-
sionnelles et extensionnelles est bien adaptÃ©e Ã  la gÃ©nÃ©ration de textes, (iii) lâ€™existence de raison-
neurs optimisÃ©s fournissant les services standards de raisonnements facilite lâ€™implÃ©mentation du
systÃ¨me.
2.1 Logique de description
Les logiques de description (description logics terme abrÃ©gÃ© en DL) (Baader et al., 2003) sont
un formalisme de reprÃ©sentation des connaissances basÃ© sur la logique du premier ordre et
4Le thÃ©orÃ¨me sâ€™Ã©nonce ainsi: Â« si dans un groupe G, tout Ã©lÃ©ment est dans lâ€™un des deux sous-groupes G1 ou
G2 alors lâ€™un des sous-groupes est inclu dans lâ€™autre (tout Ã©lÃ©ment de G1 appartient Ã  G2 ou tout Ã©lÃ©ment de G2
appartient Ã  G1). Â»
5Ces informations sont importantes parce quâ€™elles doivent Ãªtre incluses dans le texte destinÃ© Ã  un utilisateur qui
ne les possÃ¨de pas dans sa base de connaissances personnelle (cf. section 2.2).
DÃ©termination de contenu dans GEPHOX
descendant des rÃ©seaux sÃ©mantiques et des systÃ¨mes Ã  base de frames. Dans ce formalisme, la
thÃ©orie est divisÃ©e en deux parties, (i) la T-Box qui regroupe les connaissances intensionnelles
(conceptuelles ou terminologiques) i.e. les concepts et les relations du domaine, et (ii) la A-
Box qui regroupe les connaissances extensionnelles (assertionelles) dÃ©crivant les individus du
domaine et les relations entre eux. Les concepts peuvent Ãªtre vus comme des classes dâ€™individus
du domaine et les rÃ´les comme des relations binaires entre concepts/individus. Le formalisme
offre un certain nombre dâ€™opÃ©rateurs (gÃ©nÃ©ralement appelÃ©s constructeurs) qui permettent de
dÃ©finir des concepts et rÃ´les complexes en fonction dâ€™autres plus simples. Le langage que nous
utilisons comprend les constructeurs dont la syntaxe et la sÃ©mantique sont prÃ©sentÃ©s dans la
table 1.
Nom du constructeur Syntaxe SÃ©mantique
concept atomique A AI âŠ† Iâˆ†
top  Iâˆ†
bottom âŠ¥ âˆ…
conjonction C âˆ§ D CIâˆ© DI
disjonction (U) C âˆ¨ D CIâˆª DI
complement (C) Â¬C Iâˆ† CI
quantification univ. âˆ€R.C { x | âˆ€y (x,y) âˆˆ RI â‡’ y âˆˆ CI}
quantification exist. (E) âˆƒR.C { x | âˆƒy (x,y) âˆˆ RI â‡’ y âˆˆ CI}
restrictions numeriques (N ) >n R.C { x | { y | âˆ€y (x,y) âˆˆ RI} > n }
â‰¤n R.C { x | { y | âˆ€y (x,y) âˆˆ RI} â‰¤ n }
collection dâ€™individus (O) {a1,. . .,an} {aI ,. . .,aI}1 n
rÃ´le atomique P PI âŠ† I Iâˆ† Ã—âˆ†
conjonction de rÃ´le (R) Q âˆ§R RI âˆ©RI
rÃ´le inverse R 1 {(a1,a2) | ((a2,a1) âˆˆ RI}
composition de rÃ´les Q â—¦ R {(a1,a2) | âˆƒa3 (a1,a3) âˆˆ QIâˆ§ (a3,a2) âˆˆ RI}
Table 1: Syntaxe et sÃ©mantique des constructeurs de concepts et de rÃ´les
Les DL offrent plusieurs services de raisonnement (Donini et al., 1996; Horrocks, 2002). Soit
une base de connaissances Î£, on dÃ©signe par les lettres majuscules C, D des concepts com-
plexes, R, Q des rÃ´leset par les lettres minuscules a, b des individus. Les services de raison-
nements que nous utilisons sont dÃ©finis comme suit.
Subsomption : ce quâ€™on Ã©crit Î£  C  D. Ce service permet de tester si dans la base de
connaissances Î£, C est subsumÃ© par D, ce qui est vÃ©rifiÃ© quand CI âŠ†DI dans tout modÃ¨le
I de Î£. Pour les besoins de la dÃ©termination de contenu, la subsomption permet de dire si
un concept est plus spÃ©cifique quâ€™un autre. Un service off-line liÃ© Ã  la subsomption est la
classification ou hiÃ©rarchisation des concepts dâ€™une base de connaissances. Par ailleurs,
ont dit que C et D sont Ã©quivalents (notÃ© C â‰¡ D) si C  D et D  C.
Consistance : ce quâ€™on Ã©crit Î£ . Ce service permet de vÃ©rifier si Î£ est satisfiable, i.e. que
Î£ a un modÃ¨le. La consistance est utilisÃ©e par le module ContDet pour assurer que
le message dÃ©livrÃ© Ã  la sortie du module ne contient pas dâ€™incohÃ©rence, ce qui se verrait
dans le texte ou bloquerait le reste du processus de gÃ©nÃ©ration.
Test dâ€™instance : ce quâ€™on Ã©crit Î£  C(a) (resp. Î£  R(a, b)). Ce service permet de vÃ©rifier
si lâ€™assertion C(a) (resp. R(a, b)) est satisfaite dans tous les modÃ¨les de Î£, autrement dit,
que a est membre du concept C (resp. ã€ˆa,bã€‰ est membre de la relation R).
Unification : ce service de raisonnement, introduit dans (Baader et al., 2000; Baader & Naren-
dran, 2001) a pour but, Ã©tant donnÃ©s C et D, de trouver une substitution Ïƒ (appelÃ©e uni-
Adil El Ghali
fieur), telle que Ïƒ(C)â‰¡ Ïƒ(D). Par exemple, si C = Aâˆ¨âˆ€R.A et D = (B1âˆ§B2)âˆ¨âˆ€R.(B1âˆ§B2),
la substitution Ïƒ qui remplace A par B1âˆ§B2 dans C est un unifieur pour C et D. On utilise
ce service pour trouver un concept dont la dÃ©finition sâ€™unifie avec une expression con-
ceptuelle et qui pourrait la dÃ©signer. Ce qui permet, par exemple, de dÃ©tecter des tactiques
de raisonnement complexes.
Projection : câ€™est un service de raisonnement non standard qui met en jeu deux bases de con-
naissances Î£1 et Î£2 telles que Î£2 âŠ‚ Î£1. Pour tout concept C dans Î£1 et nâ€™appartenant pas
Ã  Î£2, ce service permet de trouver une dÃ©finition de C avec uniquement des concepts de
Î£2. La projection est utilisÃ© par le module ContDet pour adapter le message aux con-
naissances de chaque utilisateur : si au cours du processus de dÃ©termination de contenu,
on manipule un concept qui nâ€™est pas connu par lâ€™utilisateur, le message va Ãªtre enrichi
par la dÃ©finition de ce concept, ce qui assure une meilleure comprÃ©hension du texte final.
Par exemple, dans la prÃ©sentation dâ€™une preuve manipulant des groupes Ã  un utilisateur
ne maÃ®trisant pas le concept de groupe, on explicitera quâ€™un groupe est un ensemble muni
dâ€™une loi associative, possÃ©dant un Ã©lÃ©ment neutre et dont tous les Ã©lÃ©ments possÃ¨dent
un inverse. Dans ce cas de figure, les concepts de Ensemble, Loi, Element, Inverse,
ElementNeutre sont dans la base de connaissances de lâ€™utilisateur, mais pas celui de
Groupe.
2.2 Bases de connaissances de GEPHOX
GEPHOX dispose de deux bases de connaissances. Le premiÃ¨re, DKB (Domain Knowledge
Base), contient toute les connaissances sur le domaine mathÃ©matique dont dispose le systÃ¨me.
Elle est structurÃ©e en deux parties. Dâ€™une part, un noyau correspondant Ã  la base de PHOX : les
concepts dÃ©crivant les types de base, les commandes et les objets mathÃ©matiques (variable,
operateurs-logique, ...) et mÃ©ta-mathÃ©matiques (theoreme, definition, commandes-de-
preuves, ...) de bas niveau. Dâ€™autre part, un ensemble de modules (dont le dÃ©coupage est
calquÃ© sur celui de PHOX) correspondant aux diffÃ©rentes thÃ©ories mathÃ©matiques, e.g. un mod-
ule pour les entiers, un autre pour les groupes. Lorsque le systÃ¨me entame un processus de
gÃ©nÃ©ration, la base de connaissances quâ€™il utilise ne contiendra que le noyau et les modules
qui reprÃ©sentent les connaissances des thÃ©ories que le rÃ©dacteur de la preuve a choisi dâ€™utiliser.
Ce dÃ©coupage en modules de la DKB rÃ©duit la taille de la base de connaissances effectivement
utilisÃ©e et amÃ©liore lâ€™efficacitÃ© du systÃ¨me.
La deuxiÃ¨me base de connaissances dont dispose le systÃ¨me, UKB (User Knowledge Base), est
spÃ©cifique Ã  chaque utilisateur ; il sâ€™agit en fait dâ€™un sous ensemble de la DKB qui reflÃ¨te ses
connaissances.
3 Algorithme de dÃ©termination de contenu
Comme on lâ€™a vu dans la section 1, lâ€™entrÃ©e du gÃ©nÃ©rateur GEPHOX est riche car elle comporte
certains Ã©lÃ©ments qui peuvent Ãªtre vus comme du contenu "pur" (la description des objets math-
Ã©matiques, lâ€™arbre de preuve) et dâ€™autres qui sont plutÃ´t des informations sur la structure de la
preuve (les hypothÃ¨ses et buts intermÃ©diaires, les commandes appliquÃ©es). Dans le dÃ©roulement
de la tÃ¢che de dÃ©termination de contenu, chacun de ces Ã©lÃ©ments prend un statut particulier. Les
premiers vont nous donner les rÃ©fÃ©rents aux objets du domaine du discours, et les seconds des
DÃ©termination de contenu dans GEPHOX
actes de langage et des actions de preuve. Câ€™est pour cette raison quâ€™on a besoin de manipu-
ler dans le module ContDet des structures de donnÃ©es permettant de sÃ©parer ces deux types
dâ€™informations. Ainsi le choix du contenu Ã  exprimer se fait en prÃ©servant la structure de la
preuve, ce dont on aura besoin dans la tÃ¢che de structuration de document (El Ghali & Rous-
sarie, 2003).
La structure de donnÃ©es Ã©lÃ©mentaire manipulÃ©e par le module ContDet que lâ€™on appellera
segment est la traduction dâ€™une Ã©tape de preuve dans PHOX. Elle comporte deux parties : la
premiÃ¨re, data, qui contient les informations relatives aux objets mathÃ©matiques manipulÃ©s dans
la preuve, et qui, du point de vue du systÃ¨me de gÃ©nÃ©ration, correspond Ã  du contenu pur. La
seconde, struct, qui contient les informations structurantes de la preuve mathÃ©matique. Ces
deux parties sont exprimÃ©es en DL, ce sont des fragments dâ€™une A-Box. Nous avons choisi de
les exprimer dans la mÃªme terminologie pour rendre compte plus facilement des relations entre
les individus dans la partie data et ceux dans la partie struct.
Le module ContDet va tout au long du traitement dâ€™une entrÃ©e construire de maniÃ¨re incrÃ©-
mentale un univers de discours qui sera composÃ© de segments. Plus prÃ©cisÃ©ment, on dÃ©finit les
structures de donnÃ©es comme suit :
DÃ©finition 1 segment
Un segment est un quadruplet ã€ˆdata, struct, Rint, Rextã€‰ oÃ¹ data et struct sont deux ensem-
bles de triplets ã€ˆindividu, concept, typeã€‰ correspondant aux individus, aux concepts auxquels
ils appartiennent et Ã  leur type, pour respectivement la composante donnÃ©es et la composante
structure. Rint (relations internes au segment) est un ensemble de relations binaires entre des
Ã©lÃ©ments de data âˆª struct et Rext (relations externes au segment) est un ensemble de relations
binaires dont un participant est dans data âˆª struct et lâ€™autre dans un autre segment.
DÃ©finition 2 univers de discours
 
Un univers de discours est une suite ordonnÃ©e de segments, telle quâ€™il nâ€™existe pas dâ€™individu
a appartenant Ã  deux segments diffÃ©rents, et telle que tout segment est reliÃ© Ã  au moins un autre
   
segment de i.e. âˆ€  âˆˆ Re xt = âˆ…. Lâ€™unicitÃ© des individus nous assure que notre message
ne contiendra pas de redondance. La condition de connexitÃ© de lâ€™univers de discours quand Ã 
elle sert Ã  identifier les parties du textes qui ont pas de lien et qui correspondront Ã  des unitÃ©s
textuelles (paragraphes, sections, ...) diffÃ©rents dans le texte final.
DÃ©finition 3 types dâ€™individus
Les individus qui composent les segments sont typÃ©s pour les besoins de la dÃ©termination de
contenu. Les types sont dynamiques et nâ€™apparaissent pas dans la base de connaissances. La
procÃ©dure de calcul du type dâ€™un individu nous permet de distinguer les informations qui vont
apparaÃ®tre dans le message final de celles qui nâ€™y seront pas incluses. La visibilitÃ© dâ€™un individu
signifie quâ€™il sera prÃ©sent dans le message. Prenons le cas dâ€™une formule f qui contient des
variables et des connecteurs logiques. Si les Ã©lÃ©ments qui composent f ne sont pas utilisÃ©s pour
avancer dans la preuve, les individus correspondant ne vont pas apparaÃ®tre dans le message,
mais ils seront prÃ©sents dans lâ€™univers de discours en Ã©tant cachÃ©s. Lâ€™individu correspondant Ã 
f les reprÃ©sentera dans le message.
On distingue donc trois types dâ€™individu :
visible câ€™est le type par dÃ©faut, les individus ayant ce type seront prÃ©sents dans le message
final ;
Adil El Ghali
reprÃ©sentant pour les individus qui ont la particularitÃ© dâ€™Ãªtre le seul lien dâ€™un ensemble
dâ€™individus avec le reste du segment ou de lâ€™univers ;
cachÃ© pour ceux qui appartiennent Ã  lâ€™ensemble dâ€™un individu reprÃ©sentant.
Le sous-module de traduction traite une Ã  une les parties de lâ€™entrÃ©e correspondant Ã  une com-
mande, le segment ainsi produit est intÃ©grÃ© Ã  lâ€™univers de discours courant en effectuant des
choix sur les parties Ã  garder et celles Ã  ne pas dire ; par la suite lâ€™univers de discours produit
est instanciÃ© pour lâ€™utilisateur courant, puis vÃ©rifiÃ© (cf. section 3.3).
3.1 Traduction
La tÃ¢che du sous-module de traduction est de traduire lâ€™entrÃ©e (script, rÃ©ponses de PHOX et
arbre de preuve) en DL. Cette opÃ©ration doit produire une reprÃ©sentation de toutes les informa-
tions disponibles dans lâ€™entrÃ©e. Elle doit, par ailleurs, prÃ©server la structure de la preuve qui va
servir Ã  la structuration de document. La stratÃ©gie adoptÃ©e pour la traduction est de traiter un
bloc composÃ© dâ€™une commande PHOX, de la rÃ©ponse Ã  cette commande et du fragment dâ€™arbre
de preuve correspondant, pour construire une structure composÃ©e dâ€™une partie donnÃ©e et dâ€™une
partie structure.
Une commande PHOX est composÃ© de deux parties : lâ€™instruction de preuve
(intro, elim, goal, ...) et une partie arguments qui peut Ãªtre soit lâ€™Ã©noncÃ© (une formule) dâ€™un
thÃ©orÃ¨me Ã  prouver ou dâ€™une dÃ©finition dans le cas des commandes def, goal, lem, ..., soit une
hypothÃ¨se, une variable, un opÃ©rateur logique, ... pour les autres commandes, soit vide quand
le rÃ©dacteur de la preuve laisse Ã  la tactique automatique le soin de choisir les arguments pour
sa commande. Les instructions de preuve vont Ãªtre traduites par des individus appartenant au
concept correspondant et cet individu sera rangÃ© dans la case struct du segment courant. Pour
la partie arguments nous avons deux cas de figures. Dâ€™une part, un argument peut introduire
un seul individu, câ€™est le cas pour les variables, les noms dâ€™hypothÃ¨ses et les opÃ©rateurs ; le
module de traduction crÃ©Ã© alors un individu pour ce rÃ©fÃ©rent et doit calculer le concept auquel
il appartient. Dâ€™autre part, un argument peut introduire plusieurs rÃ©fÃ©rents de discours; câ€™est le
cas pour une formule, les variables et connecteurs logiques composant une formule donneront
autant dâ€™individus dans lâ€™univers de discours. Par exemple, une commande goal f va produire
un individu g âŠ† Goal qui sera reliÃ© par le rÃ´le has-formula Ã  la traduction de f .
3.2 SÃ©lection
Le sous-module de sÃ©lection est le coeur de ContDet : câ€™est durant cette phase que les choix
les plus importants sâ€™effectuent : dÃ©cider de ce qui va Ãªtre inclus dans le message et de ce quâ€™on
ne va pas dire, garantir que le message est assez informatif, mais pas trop et ne pas perdre la
structure gÃ©nÃ©rale de la preuve qui nous servira par la suite.
 
Le module de sÃ©lection construit un univers de discours de maniÃ¨re incrÃ©mentale, le processus
commence par un univers de discours vide, on y ajoute au fur et Ã  mesure les segments fournis
 
par le module de traduction. Quand un segment est ajoutÃ© Ã  , plusieurs procÃ©dures sont
exÃ©cutÃ©es :
DÃ©termination de contenu dans GEPHOX

â€¢ on identifie dans le segment courant   C , les individus dÃ©jÃ  prÃ©sents dans . Pour un tel
individu a, on efface lâ€™occurrence de a dans   C et on reporte les relations auxquelles il

participait dans   C vers lâ€™occurrence de a dans , les dites relations passeront de Rint Ã 
Rext dans   C .
â€¢ pour les individus correspondant aux commandes dans struct, vÃ©rifier sâ€™ils peuvent se
combiner avec un ou plusieurs autres individus de mÃªme nature dans les segments prÃ©cÃ©-
dents pour produire une tactique plus complexe. On identifie, par exemple, un raison-
nement par cas en unifiant avec lâ€™expression conceptuelle qui lui correspond dans la base
de connaissances (qui contient des concepts dÃ©crivant les diffÃ©rents cas et leurs preuves)
avec les concepts correspondant Ã  un ensemble dâ€™individus dans le volet struct rÃ©alisant
un raisonnement par cas. On utilise pour cela lâ€™unification entre les concepts correspon-
dant aux tactiques de haut niveau avec les concepts des individus correspondants aux
commandes. Lorsque lâ€™unification est possible, les segments en question et   C seront
fusionnÃ©s en un seul segment.
â€¢ pour tous les individus modifiÃ©s dans lâ€™univers (les individus de   C et ceux qui en ont Ã©tÃ©
effacÃ©s), on recalcule les concepts aux quels ils appartiennent et qui, dans certains cas,
sont plus spÃ©cifiques du fait des nouvelles relations. Cela revient Ã  calculer le concept le
plus spÃ©cifique de lâ€™individu (on utilise test dâ€™instance et subsomption).
â€¢ on identifie les nouveaux individus reprÃ©sentants et on marque comme cachÃ© les Ã©lÃ©ments
de leur ensemble, les individus cachÃ©s ne seront pas prÃ©sents dans le message final. Quand
un individu reprÃ©sentant perd son statut, Ã  cause de la prÃ©sence dans le segment courant
dâ€™un Ã©lÃ©ment de son ensemble, ce dernier devient visible.
3.3 Instanciation et vÃ©rification
La phase de sÃ©lection produit un univers de discours qui est exprimÃ© dans la DKB. Pour que
ce message donne un texte comprÃ©hensible par lâ€™utilisateur, on va le projeter dans la UKB,
autrement dit, pour tout concept prÃ©sent dans lâ€™univers et nâ€™appartenant pas Ã  sa UKB, on en
calcule la projection dans la UKB. Lâ€™instanciation est en quelque sorte une mise au niveau
de lâ€™utilisateur du message. La raison principale pour laquelle la sÃ©lection nâ€™est pas faite en
utilisant directement la UKB est quâ€™il est parfois nÃ©cessaire dâ€™expliquer certaines parties de la
preuve Ã  un utilisateur qui nâ€™aurait pas assez de connaissances pour les comprendre, alors que
le systÃ¨me en dispose. Ce choix a Ã©tÃ© fait dans lâ€™optique dâ€™utiliser PHOX couplÃ© Ã  GEPHOX
pour lâ€™enseignement des mathÃ©matiques (Raffalli & David, 2002).
Pour finir, on vÃ©rifie la consistance de la base de connaissances composÃ© de la UKB et la A-Box
correspondant Ã  lâ€™univers de discours. Ceci garantit que le message donnera un texte cohÃ©rent
par rapport aux connaissances de lâ€™utilisateur.
Conclusion
Dans cet article nous avons dÃ©crit une mÃ©thode de dÃ©termination de contenu, basÃ©e sur
lâ€™exploitation des propriÃ©tÃ©s des bases de connaissances dÃ©crivant le domaine mathÃ©matique et
les connaissances quâ€™en a le destinataire du texte. Cet algorithme sÃ©pare deux types dâ€™infÃ©rences
mises en oeuvre dans la dÃ©termination de contenu : la premiÃ¨re correspond au dÃ©roulement
Adil El Ghali
de cette tÃ¢che i.e. comment on combine les donnÃ©es en entrÃ©e du systÃ¨me pour construire
un message cohÃ©rent, la deuxiÃ¨me, qui exploite les bases de connaissances du systÃ¨me et les
mÃ©canismes de raisonnement offerts par celles-ci, garantit Ã  notre message les propriÃ©tÃ©s de
minimalitÃ©, de qualitÃ© et de fidÃ©litÃ© Ã  lâ€™entrÃ©e tout en Ã©tant au niveau de lâ€™utilisateur
Remerciements
Merci Ã  Laurence Danlos, Michel Parigot et Paul RoziÃ¨re pour leur patience et leurs remarques.
RÃ©fÃ©rences
BAADER F., KUSTERS R. & MOLITOR R. (2000). Rewriting Concepts Using Terminologies â€“ Revisited.
Rapport interne 00-04, Germany.
F. BAADER, D. L. MCGUINNESS, D. NARDI & P. F. PATEL-SCHNEIDER, Eds. (2003). Description
Logics Handbook: Theory, Implementation and Applications. Cambridge University Press.
BAADER F. & NARENDRAN P. (2001). Unification of concept terms in description logics. Journal of
Symbolic Computation 31(3), p. 277â€“305.
COSCOY Y. (2000). Explication textuelles de preuves pour le calcul des constructions inductives. ThÃ¨se
dâ€™universitÃ©, UniversitÃ© de Nice-Sophia-Antipolis.
DONINI F., LENZERINI M., NARDI D. & SCHAERF A. (1996). Reasoning in description logics. In G.
BREWKA, Ed., Principles of Knowledge Representation and Reasoning, Studies in Logic, Language and
Information, p. 193â€“238. CLSI Publications.
EL GHALI A. & ROUSSARIE L. (2003). Computing the rhetoric of text proofs. In Proceeding of ICoS-4,
Nancy, France.
FIEDLER A. (2001a). P.rex: An interactive proof explainer. In Proceedings of the 1st International Joint
Conference on Automated Reasoning (IJCARâ€™01).
FIEDLER A. (2001b). User-adaptive proof explanation. PhD thesis, Naturwissenschaftlich-Technische
FakultÃ¤t I, UniversitÃ¤t des Saarlandes, SaarbrÃ¼cken, Germany.
HALLGREN T. & RANTA A. (2000). An extensible proof text editor. In In Logic for Programming and
Automated Reasoning (LPARâ€™2000),, volume LNCS/LNAI 1955, p. 70â€“84: Springer Verlag,.
HORROCKS I. (2002). Reasoning with expressive description logics: Theory and practice. In A.
VORONKOV, Ed., Proceedings of the 18th International Conference on Automated Deduction.
KRIVINE J.-L. (1997). Lambda-calcul, types et modÃ¨les. Dunod.
RAFFALLI C. (2002). Userâ€™s manual of the PhoX library. LAMA, UniversitÃ© de Savoie.
RAFFALLI C. & DAVID R. (2002). Apprentissage du raisonnement assitÃ© par ordinateur. Quadrature
45, p. 25â€“36.
RAFFALLI C. & ROZIERE P. (2002). The PhoX Proof checker documentation. LAMA, UniversitÃ© de
Savoie / UniversitÃ© Paris 7.
REITER E. & DALE R. (2000). Buiding Natural Language Generation Systems. Studies in Natural
Language Processing. Cambridge University Press.
SRIPADA S., REITER E., HUNTER J. & YU J. (2001). A two-stage model for content determination. In
Proceedings of ENLGW-2001, p. 3â€“10.
