TALN 2005, Dourdan, 6-10 juin 2005

XMG : Un Compilateur de Méta-Grammaires Extensible*

Denys Duchier (1), Joseph Le Roux (2), Yannick Parmentier (2)
(1) LIFL - UMR CNRS 8022- Université des Sciences et Technologies de Lille
Batiment M3 59655 Villeneuve d’Ascq Cédex
duchier@liﬂ.fr
(2) INRIA / LORIA - Institut National Polytechnique de Lorraine - Université
Henri Poincare Nancy 1
615, rue du Jardin Botanique - 54 600 Villers-Les-Nancy
{leroux,parmenti} @loria.fr

Mots-clefs I Grammaires, compilation, ressources linguistiques, Grammaires d’Arbres
Adjoints, Grammaires d’Interaction

Keywords: Grammars, compilation, linguistic resources, Tree Adjoining Grammars, In-
teraction Grammars

Résumé Dans cet article, nous présentons un outil permettant de produire automatique-
ment des ressources linguistiques, en l’occurence des grammaires. Cet outil se caractérise par
son extensibilité, tant du point de vue des formalismes grammaticaux supportés (grammaires
d’arbres adjoints et grammaires d’interaction a l’heure actuelle), que de son architecture mo-
dulaire, qui facilite l’intégration de nouveaux modules ayant pour but de vériﬁer la validité des
structures produites. En outre, cet outil offre un support adapté au développement de gram-
maires a portée sémantique.

Abstract In this paper, we introduce a new tool for automatic generation of linguistic
resources such as grammars. This tool’s main feature consists of its extensibility from different
points of view. On top of supporting several grammatical formalisms (Tree Adjoining Gram-
mars and Interaction Grammars for now), it has a modular architecture which eases the integra-
tion of modules dedicated to the checking of the output structures. Furthermore, this tool offers
adapted support to the development of grammars with semantic information.

* Nous tenons a remercier Benoit Crabbé, Claire Gardent, Guy Perrier et Eric De La Clergerie pour les
nombreuses discussions qui nous ont aidées dans le cadre de ce travail.

D. Duchier, J. Le Roux et Y. Parmentier

1 La production automatique de grammaires

Dans le cadre du développement d’ applications de TALN (analyseurs syntaxiques par exemple),
un certain nombre de ressources linguistiques est nécessaire, parmi lesquelles des grammaires.
Nous nous intéressons ici aux grammaires fortement lexicalisées associant a chaque mot un
ensemble de structures syntaxiques décrivant son comportement dans chaque emploi.

1.1 Le besoin de production automatique

Par opposition aux grammaires de regles, les grammaires fortement lexicalisées utilisées en lin-
guistique informatique, comme les grammaires d’arbres adjoints lexicalisées (TAG), les gram-
maires d’interaction (IG) ou les grammaires catégorielles reportent la connaissance de la langue
dans le lexique. Un tel lexique peut étre vu comme une fonction associant a un mot de la langue
l’ensemble des structures syntaxiques représentant ses usages. Pour avoir une bonne couverture,
il est nécessaire que le lexique associe a chaque mot un maximum de structures. Par exemple
pour analyser les expressions ci-dessous, le lexique doit associer au verbe mange (en TAG) les
structures suivantes :

Jean mange la pomme. La pomme que Jean mange  Jean qui mange une pomme.

A N
/N /\ N/\P

N Y N N P /l\
mange l /\ N Y N
que N Y qui mange

mange

Cette taille de lexique ne va pas sans problemel. Comme les regles syntaxiques sont e’clate’es a
travers le lexique, l’analyse d’un nouveau phénomene linguistique ou, pire, sa révision peuvent
avoir de graves consequences sur la cohérence de la grammaire. Si les premiers lexiques a
large couverture furent écrits a la main, leur génération automatique devient de plus en plus
pressante, de maniere a (1) pouvoir garantir la cohérence de l’ensemble et (2) pouvoir réviser
une gramInaire rapidement, méme quand le lexique devient important. Nous avons développé
un formalisme, dont l’implantation est XMG, qui, a partir d’une description métagrammaticale
concise génere toutes les structures associées aux mots du lexique. Notre approche se veut la
plus indépendante possible des formalismes grammaticaux et capable de gérer simultanément
les aspects syntaxiques et sémantiques du lexique.

1.2 Principes de la production automatique

Le lexique est extrémement redondant : d’une part, une méme structure syntaxique peut étre
associée a plusieurs entrées lexicales (e.g. les verbes transitifs auront un grand nombre de struc-
tures syntaxiques en commun) et d’autre part les différentes structures lexicales partagent des

1Les problémes purement infonnatiques ne sont pas évoqués ici.

XMG : Un Compilateur de Méta-Grammaires Extensible

fragments communs importants (e.g. le fragment sujet-verbe se retrouve de tres nombreuses
fois). L’idée qui s’est imposée des les premiers travaux de génération automatique de lexique
par (Candito, 1996) est de ne décrire que ces fragments élémentaires, pouvant hériter les uns des
autres, puis de les combiner pour former toutes les structures syntaxiques du lexique. Ces com-
binaisons constituent la justiﬁcation linguistique de cette approchez. En effet elles doivent expli-
quer la formation des différentes structures apparentées (par exemple la relation entre les formes
actives et passives d’un méme verbe). Les différents formalismes métagrammaticaux doivent
donc rendre exprimables la notion de fragments réutilisables, la spéciﬁcation de leur structure
et la maniere de les combiner pour produire des structures completes. Par exemple, (Candito,
1996) explique les croisements par un ensemble de contraintes (de 3 types) que doivent veri-
ﬁer les structures ﬁnales et (Gaiffe, Crabbé et Roussanaly, 2002) les justiﬁe en assouplissant
la notion de contrainte par une approche o1‘1 besoins et ressources doivent étre satisfaits. Notre
approche les explique par deux actions primitives l ’accumulation et la composition disjonctive
auxquelles peuvent étre ajoutées des contraintes (sensibilité aux ressources, comme par exemple
un langage de couleur, voir section 2.2). Mais XMG se distingue des approches antérieures par
trois aspects fondamentaux :

1. XMG est multi-formalisme, c’est a dire qu’il ne se liIr1ite pas a un formalisme syntaxique
en particulier,

2. XMG est extensible, d’une part on peut lui aj outer des niveaux de description pour traiter
de nouveaux formalismes (aussi bien syntaxiques que sémantiques), et d’autre part, on
peut l’étendre en déﬁnissant des modules de contraintes additionnelles que les structures
grammaticales produites doivent respecter,

3. la description métagrammaticale est vue comme un programme logique dont XMG est
le compilateur, ce qui nous permet de réutiliser des techniques issues de la programmation
logique.

1.3 L’extensibilité de XMG

XMG présente une grande originalité vis a vis des autres cadres méta-grammaticaux : il est a la
fois multi-formalisme 3 (génere aussi bien des TAG que des IG), et extensible. Cette extensibilité
est atteinte d’une part grace a un langage de controle muni des opérations d’accumulation et de
composition disjonctive qui sont générales, et ne décrivent que des relations de fragment a frag-
ment. Ce langage est donc indépendant du formalisme grammatical cible et permet d’exprimer
des combinaisons tres ﬁnes. D’autre part, dans XMG, chaque fragment peut contenir un nombre
arbitraire de niveaux de description (appelés aussi dimensions) tels que le niveau syntaxique,
sémantique, etc. Ces dimensions ne sont pas completement indépendantes puisqu’elles peuvent
partager de l’information (en particulier pour l’interface syntaxe / sémantique). En outre, chaque
dimension est munie de son propre langage de description qui varie selon le type d’information
contenue. Par exemple, pour les TAG et les IG la dimension syntaxique est représentée par
un langage de description d’arbres intégrant l’uniﬁcation et ou chaque noeud est équipé d’une
structure de traits, tandis que pour les grammaires de dépendances extensibles (XDG) les entrées
lexicales seraient des structures de traits atoIr1iques. Enﬁn, XMG est extensible par l’ajout de
modules spéciﬁques pour traiter les structures intermédiaires produites. I1 existe deux types de

2Les approches antérieures ne s’intéressaient qu’au probléme de redondance.

3Les approches de méta—grammaires précédentes ne permettaient que la production de grammaires TAG, bien
que les travaux de (Clément et Kinyon, 2003) montrent qu’il est possible d’adapter le résultat obtenu pour générer
des grammaires fonctionnelles lexicales (LFG).

D. Duchier, J. Le Roux et Y. Parmentier

modules : (1) ceux qui créent de nouvelles structures (par exemple, pour TAG, en produisant des
arbres a partir de descriptions) et (2) ceux qui ﬁltrent les structures correctes suivant des criteres
linguistiques (voir section 2.2).

A ce jour, la support du multi-formalisme a été validé dans XMG via TAG et IG, cependant il
n’est pas encore possible de sélectionner la dimension syntaxique a utiliser (seule un langage
de description d’arbres a été implanté) : l’extensibilité déclarative n’est pas encore atteinte.

Par la suite, nous allons tout d’abord présenter le procédé de compilation de XMG, ensuite
nous verrons concretement comment produire automatiquement une graInInaire TAG, enﬁn nous
aborderons la question de l’intégration de XMG dans une chaine de TALN.

2 Un procédé de compilation basé sur des techniques de pro-
grammation logique

Dans cette section, nous allons décrire le procédé de compilation de méta-grammaire utilisé par
XMG. Plus précisément, nous allons présenter (a) le langage abstrait dont XMG est l’implan-
tation. Notons que nous ne présentons pas ici la syntaxe concréte du langage (voir section 3
pour cela), mais le langage de plus bas niveau dans lequel cette syntaxe est traduite lors de la
compilation. Nous présenterons également (b) l’architecture de XMG, qui par sa modularité,
s’adapte aisément a différents formalismes grammaticaux.

2.1 Un langage de représentation étendu

Combinaison de fragments Nous avons vu a la section précédente que la compilation d’une
méta-grammaire correspondait a la combinaison de fragments4. Nous pouvons déﬁnir de telles
combinaisons sous forme de regles de réécriture. Par exemple, considérons l’arbre syntaxique
associé a une entrée lexicale telle que voit (i. e. un verbe transitif) dans le formalisme TAG. Dis-
posant des fragments d’arbres Sujet, Acti f et Object, nous pouvons réécrire l’arbre VerbeTransz'ti f
comme la conjonction de ces 3 fragments :

VerbeTransitif Sujet Actif Objet

A A3 T R

N V N _ N V + V + V N
Voit   Voit

Ce qui s’écrit également comme suit :
VerbeTransitif —> Sujet /\ Actif /\ Objet (1)
Nous nous ramenons ainsi au formalisme des grammaires de clauses déﬁnies (DCG), dans le-

quel les terminaux ne seraient pas des mots mais des fragments d’arbres. La compilation d’une
méta-grammaire s’identiﬁe alors a la compilation d’un programme logique. Dans XMG, la

4Nous laissons provisoirement de coté la question de la contrainte des combinaisons, Voir 2.2.

XMG : Un Compilateur de Méta-Grammaires Extensible

méta-grammaire est décrite au moyen d’un langage de représentation, qui comprend les notions
d’abstraction (cf 2) et de composition conjonctive et disjonctive (cf 3).

Clause ::= Nom —> But (2)
But ::= Description | Nom | ButVBut | But/\But (3)

On remarque que XMG fournit un langage expressif incluant la disj onction et de ce fait introduit
de l’indéterminisme dans la combinaison des fragments d’arbres. Ainsi, nous pouvons préciser
l’exemple précédent de l’arbre associé aux verbes transitifs en spéciﬁant que le sujet peut étre
sous forme canonique on sous forme relative, etc. Cela s’énonce via la regle suivante :

Sujet —> SujetCan V SujetRel V . . . (4)

Description des fragments Les fragments dénotés par les abstractions (nommées également
classes) de notre langage de représentation sont décrits au moyen de contraintes de dominance :

Description ::= 1:—>y | 1:—>+y | J:—>*y | J:<y | 1:<+y | J:<*y I  | 1:(p:E)
(5)

011 1:, y représentent des variables de noeuds, —> la dominance immédiate, —>+ la dominance
stricte, —>* la dominance large, < la précédence immédiate, <+ la précédence stricte, <* la
précédence large, a:[ f :E] l’association du trait f au noeud :13 et a:(p:E) l’association de la pro-
priété p a ce meme noeud 1:.

Ainsi, nous disposons d’un langage sufﬁsamment expressif pour supporter les formalismes syn-
taxiques basés sur les descriptions d’arbres, telles que les grammaires TAG et IG.

Représentation sémantique L’extensibi1ité de XMG se retrouve également dans le fait qu’i1
offre un support adéquat a l’intégration d’une représentation sémantique dans la méta-grammaire.
En effet, notre langage de représentation permet non seulement de placer dans les classes des
informations syntaxiques (e.g. descriptions d’arbres), mais également des representations sé-
mantiques. A l’heure actuelle, un langage a base de structures prédicatives a été implanté :

Description 2:: €:p(E1,...,E,,) | -u€:p(E1,...,E,,) | E, < E, (6)

Ici, €:p(E1, ..., En) représente le prédicat p avec les arguments E1, .., En, et étiqueté par 3, -I
l’opérateur de négation, et E, < E, la portée entre les variables sémantiques E, et Ej.

Un tel langage peut servir, par exemple, a associer aux arbres des informations de type séman-
tique plate comme dans (Gardent et Kallmeyer, 2003).

En reprenant notre comparaison entre méta-grammaire et DCG se pose la question de la dis-
tinction entre information syntaxique et information sémantique. Cela est rendu possible par
l’utilisation de dimensions, correspondant chacune a un accumulateur spéciﬁque dans le for-
malisme des grammaires de clauses de’ﬁnies e’tendues (EDCG) (Van Roy, 1990).

Ainsi, la combinaison de classes (i. e. d’informations syntaxiques ou sémantiques) donne lieu a
l’accumulation de leur contenu dans des structures dédiées. L’ expression (3) vue précédemment
est alors étendue en remplacant Description par :

Dimension += Description

D. Duchier, J. Le Roux et Y. Parmentier

Ce type accumulation permet de traiter plusieurs dimensions. A l’heure actuelle, XMG dispose
de 3 dimensions, notées syn, sem et dyn. Les deux premieres représentent les dimensions syn-
taxique et sémantique et la demiere une dimension utilisée pour l’accumulation d’informations
lexicales.

Notons que ces dimensions peuvent partager des variables logiques, ce qui permet un develop-
pement relativement naturel d’une interface syntaxe / sémantique au niveau méta-grammatical.

Portée des variables Dans les approches antérieures les noms de variables ont une portée glo-
bale a la méta-grammaire. Ce qui pose des problemes de conﬂits de noms, passé un certain
nombre de classes. Dans XMG, les identiﬁants ont par défaut une portée limitée a la clause, a
laquelle est intégré un procédé d’export d’identiﬁants. Ainsi, il est possible de spéciﬁer avec
précision le domaine de visibilité d’une variable. Plus précisément, a chaque clause est associée
une structure de traits contenant les identiﬁants exportés, (2) devient :

Clause ::= (f1:E1, . . . , f,,:E,,) <= Nom —> But (7)

Et l’appel de classe s’accompagne de l’acces a la structure d’eXport (notée Var ici), (3) est
remplacée par :

But ::= Dim += Description | Var <= Nom | But V But | But /\ But (8)

On peut accéder alors a un identiﬁant X via la notation pointée Var.X.

2.2 Une architecture modulaire

En section 1, nous avons présenté les caractéristiques de XMG, dont le fait qu’il supporte plu-
sieurs formalismes syntaxiques. Cette caractéristique est fortement liée a l’architecture modu-
laire du compilateur.

Des modules dédiés La compilation d’une méta-grammaire se fait en plusieurs phases, dont
certaines different suivant le formalisme. Chacune de ces phases est prise en charge par un
module spéciﬁque.

Actuellement XMG comporte 3 modules principaux :

a) La partie avant (i. e. le compilateur proprement dit) traduit la méta-grammaire en instructions
exprimées dans un langage de plus bas niveau.

b) Ces instructions sont ensuite exécutées par une machine virtuelle (MV) de type Warren ’s
Abstract Machine (WAM, Voir (Ait-Kaci, 1991)).

Cette MV réalise l’uniﬁcation des structures de données de la méta-grammaire (i. e. struc-
tures de traits associées aux noeuds, traits polarisés pour IG, etc), puis l’accumulation des
dimensions pour une combinaison de classes donnée. En sortie de la MV, nous disposons
de données accumulées dans chaque dimension, dans le cas des TAG, des descriptions
d’arbres dont il faut calculer les solutions.

c) En plus de la partie avant et de la MV, qui sont communes aux formalismes des TAG et
des IG, )ﬂ\/[G integre un module de résolution de descriptions d’arbres. Ce module est
programmé sous forme d’un résolveur de contraintes (Voir (Duchier et Niehren, 2000)
pour une description complete du procédé).

XMG : Un Compilateur de Méta-Grammaires Extensible

Un résolveur extensible La modularité dans XMG est encore étendue par la programmation
de modules additionnels optionnels et paramétrables. Ces modules permettent d’étendre les
fonctionnalités du module de résolution pour, par exemple, contraindre les modeles produits
par XMG selon des criteres spéciﬁques, appelés aussi principes.

Les principes instanciables présents dans XMG actuellement sont de 3 types :

i) un principe de couleurs. Comme annoncé a la section 1.2, dans un contexte de développe-
ment de grammaires a large couverture par combinaison de fragments, une idée majeure
consiste a contraindre les combinaisons acceptables en intégrant un systeme de gestion
de ressources. Pour gérer les ressources en TAG, XMG integre un langage de couleurs. Ce
langage permet d’indiquer quels fragments d’arbres nécessitent quels autres fragments
pour former un modele valide (une présentation de l’emploi d’un langage de couleurs
pour produire une grammaire TAG est donnée dans (Crabbe et Duchier, 2004)).

ii) un principe d’unicité paramétré par une propriété de noeuds. Ce principe permet de garantir
la validité des solutions produites par XMG par rapport a une contrainte linguistique
d’unicité telle que : dans un arbre TAG, il ne peut y avoir deux extracti0ns5.

iii) un principe de rang paramétré par un nombre entier, permettant de réaliser l’ordonnance-
ment des clitiques dans les arbres TAG produits.

3 Cas d’étude : une méta-grammaire pour TAG

Voyons a present comment écrire une méta-grammaire pour TAG avec XMG. Pour cela nous
allons introduire la syntaxe concréte de XMG, qui est destinée a étre traduite dans le langage
abstrait présenté précédemment lors de la compilation. Notons que nous n’entrons pas ici dans
les aspects du développement de grammaires a large couverture, nous nous focalisons sur un
exemple simple, introductif vis a vis des possibilités offertes par XMG.

Nous allons considérer la méta-grammaire permettant de générer les arbres TAG pour les verbes
transitifs a l’actif avec sujet canonique ou extrait et objet sous forme canonique (exemple 1 de
la section 2.1)6.

Les déclarations La premiere information que doit fournir notre méta-grammaire consiste en
la spéciﬁcation du résolveur utilisé (si nous en utilisons un). Ici nous allons utiliser le principe
d’unicité de la fonction grammaticale sujet :

use unicity with (fg = suj) dims (syn)

Cette instruction indique a XMG que le résolveur ne doit accepter que les solutions pour les-
quelles il n’y a qu’un seul noeud ayant la propriété fg = suj (respect du principe d’unicité).

Ensuite, nous déclarons les types de données utilisés. Ces types permettent de typer les proprié-
tés et structures de traits qui seront associées aux noeuds dans les descriptions syntaxiques :

type CAT= { n, v, p}
type FG={suj,obj}
property fg : FG
feature cat : CAT

5 Nous adoptons cette convention dans un contexte méta—grammatical, bien que certains exemples de phrases a
double extraction existent (cf (Abeillé, 2002)).

5Nous ne présentons pas le formalisme TAG ici, le lecteur est djrigé Vers (J oshi et Schabes, 1997) pour une telle
introduction.

D. Duchier, J. Le Roux et Y. Parmentier

Les classes A present, nous pouvons deﬁnir le contenu de nos classes, i. e. les fragments d’arbres.
Considerons le fragment correspondant au sujet canonique. Celui-ci est compose de 3 noeuds
1:, y et 2, tels que 1: —> y /\ 1: —> z /\ y < 2. Ce qui s’ecrit comme suit dans la syntaxe de XMG
(:13 —> y correspond a node ?X{node ?Y}):

class SujetCan

export ?X ?Z

declare ?X ?Y ?Z

{ <syn>{

node ?X [cat = s]{

node ?Y (fg=suj)[cat=n]
node ?Z [cat = v]

}

La classe ObjetCan s’ecrit de facon similaire. La classe SujetRel correspond a l’arbre du sujet
en position relative. Le fragment d’arbre correspondant etant :

class SujetRel
export ?Y ?Z
declare ?X ?Y ?Z ?U ?V

{ <syn>{ N
node ?U [cat = n]{ ///\\\
node ?V [cat = n] N P
node ?X [cat = p]{ //N\
node ?Y (fg=suj)[cat=n] Pl ‘V

node ?Z [cat = v]

}

I1 ne nous reste plus alors qu’a deﬁnir les classes Actif et VerbeTransitif. La classe Actif contient
deux noeuds 1:, y tels que :1? —> y et la classe VerbeTransitif se deﬁnit en suivant la regle donnee
en (4) :

class VerbeTransitif
declare ?SU ?OB ?AC
{

{ ?SU = SujetCan[] I ?SU = SujetRel[] } ;
?OB = ObjetCan[] ; ?AC = Actif[] ;
?SU.?X = ?OB.?X ; ?SU.?Z = ?OB.?Y ;

?SU.?X = ?AC.?X ; ?SU.?Z = ?AC.?Y

Dans cette classe, on remarque la presence de conjonctions representees par le symbole ; et
d’une disjonction representee par | . On utilise la variable SU (respectivement OB et AC) pour
designer la structure de traits d’eXport de la classe SujetCan ou de la classe SujetRel (respecti-
vement de la classe ObjetCan et de la classe Actif).

On remarque ici que nous procedons par egalite entre noeuds pour contraindre la combinaison
des fragments d’arbres. I1 s’agit du procede de base. Pour passer au developpement de meta-
grammaires de taille importante, l’emploi d’un langage de couleur offre une meilleure ﬂexibilite
dans la deﬁnition des classe et permet d’alleger la gestion des noms de variables.

XMG : Un Compilateur de Méta-Grammaires Extensible

 

X —i-‘J ‘us’erheTranSifif-Liéulution I - III X

I syntax  semantics I X —i::I  _§»;_;1gt__l_.-;__1n-:3. . [3 ;.{

.\ l -
Cat: n T syntax | semantics |

“J... trace I trace

 \ EIb'etI2an Cat I P ? U
r_,»- at J Dbjetﬂan
catfn Cat . F] V'3Vb'3Tr3n3”if F,--”T“‘mH VerbeTransitif
' '_ Actif As". 1'35 '.-Jﬁtif

‘'/,,-«=- 1‘ ~-..,,‘‘‘* I 3._U-emel cat : n cat : V cat: n I Sujetcan
cat: n cat: H-' cat : n Interface mnterface _,
,- trace summary ,r trace summary

FIG. 1 — Arbres TAG produits par XMG

Les évaluations Une fois les classes de notre méta-grammaire écrites, nous pouvons demander
a )ﬂ\/[G de calculer tous les arbres TAG correspondants. Cela se fait en demandant l’e’valuati0n
de la classe : value VerbeTransitif

Résultat La classe VerbeTransitif génere deux solutions, qui correspondent aux arbres de la
ﬁgure 1.

4 Intégration dans une cha'1‘ne de TALN

Le systeme XMG produit des grammaires au format XML7 utilisables pour l’analyse syntaxique
ou la génération :

Analyse syntaxique Nous avons vu en section 1 que l’un des buts de la production automatique
de grammaires était d’éviter les problemes lies a la redondance entre structures syntaxiques.
Dans le cas de TAG, on évite aussi cette redondance en utilisant un lexique a 3 niveaux : lemmes,
formes ﬂéchies et structures syntaxiques. Dans ce contexte, la méta-grammaire produit non pas
des arbres qui seraient associés chacun a une ou plusieurs unité(s) lexicale(s), mais un ensemble
de structures syntaxiques non-ancrées L’ association structure syntaxique — unité(s) lexicale(s)
est alors réalisée par l’analyseur syntaxique. Pour cela, il est nécessaire d’ajouter a ces structures
non-ancrées certaines informations sur la morphologie des unités lexicales qui peuvent étre
accueillies. Ces informations prennent la forme de structures de traits (voir (Crabbé, Gaiffe et
Roussanaly, 2003)). XMG, par sa dimension dyn contenant des matrices attributs-valeurs, offre
un support adéquat pour cette association.

Génération L’ utilisation de grammaires produites automatiquement en génération pose des pro-
blemes différents. Un générateur aura pour but de produire un ensemble de phrases a partir d’une
représentation sémantique. La aussi, pour éviter la redondance, il y a un découpage structures
syntaxiques — unité(s) leXicale(s). Par contre, leur association s’accompagne de l’instanciation
des arguments du prédicat sémantique dans l’arbre. Pour pouvoir accéder a ces arguments dans
la structure syntaxique, nous pouvons utiliser la dimension dyn et la coindexation entre traits
(voir (Gardent et Kow, 2004)).

7les DTD pour grammaires TAG et IG sont foumies dans le systéme XMG disponible librement a l’adresse
http : //sourcesup . cru . fr/xmg.

D. Duchier, J. Le Roux et Y. Parmentier

Conclusion

XMG offre un cadre de travail adapté au développement de grammaires de taille relativement
importante (voir (Crabbé, 2005a)). Une grammaire TAG du Frangais a large couverture a ainsi
pu étre développée par B. Crabbé (Crabbé, 2005b), celle-ci est en cours d’évaluation en analyse
syntaxique sur la suite de tests TSNLP. Les premiers résultats sont encourageants, la couverture
de la grammaire produite étant supérieure a 75%. Pour donner un ordre d’idée, cette meta-
grammaire contient 246 classes, représentant 55 familles (ie cadres de sous-categorisation), et
générant 5075 arbres non-ancrés en 20 minutes de compilation (sur Pentium 4 - 2,66 Ghz et
1 Go de mémoire vive).

Nous travaillons a l’heure actuelle a la production de grammaires a portée sémantique dans une
optique d’analyse syntaxique combinée avec un calcul sémantique. Nous visons également l’in-
tégration a XMG d’une bibliotheque de dimensions ayant chacune un langage de representation
propre. Cette bibliotheque a pour but d’offrir a l’utilisateur des outils adaptés lui permettant de
créer des instances de méta-grammaire pour un formalisme cible arbitraire.

Références

Abeillé A. (2002), Une grammaire électronique du frangais , CNRS Editions, Paris.

Ait-Kaci H. (1991) , Warren’s Abstract Machine 2 A Tutorial Reconstruction, Logic Programming : Proc.
of the Eighth International Conference, K. Furukawa , MIT Press, Cambridge, MA.

Candito M.H. (1996), A principle-based hierarchical representation of LTAGs , Proceedings of the 15th
International Conference on Computational Linguistics (COLING’96), Kopenhagen.

Clément L., Kinyon A. (2003), Generating LFGs with a MetaGrammar , Proceedings of the 8th Interna-
tional Lexical Functional Grammar Conference, Saratoga Springs, NY.

Crabbé B. (2005a), Grammatical development with XMG, Fifth International Conference on Logical
Aspects of Computational Linguistics (IACL05), Bordeaux.

Crabbé B. (2005b), Représentation informatique de grammaires fortement lexicalisées - Application 51 la
grammaire d’arbres adjoints, The‘se de Doctorat (a paraitre), Universite’ Nancy 2.

Crabbé B., Gaiffe B., Roussanaly A. (2003), Une plate-forme de conception et d’exploitation d’une
grammaire d’arbres adj oints lexicalisés, Actes de la confe’rence TALN’2003 Batz-sur-mer.

Crabbé B., Duchier D. (2004), Metagrammar Redux , International Workshop on Constraint Solving and
Language Processing - CSLP 2004, Copenhagen.

Duchier D., Niehren J. (2000), Dominance Constraints with Set Operators, Proceedings of the First
International Conference on Computational Logic (CL2000).

Gaiffe B., Crabbé B., Roussanaly A. (2002), A New Metagrammar Compiler , Proceedings of the 6th
International Workshop on Tree Adjoining Grammars and Related Frameworks (TAG+6), Venice.
Gardent C., Kallmeyer L. (2003), Semantic construction in FTAG , Proceedings of the 10th meeting of
the European Chapter of the Association for Computational Linguistics, Budapest.

Gardent C., Kow E. (2004) , Génération et sélection de paraphrases grammaticales , joumée ATAIA sur
la génération de Langue Naturelle, Paris.

J oshi A., Schabes Y. (1997), Tree-Adjoining Grammars , Handbook of Formal Languages , G. Rozenberg
and A. Salomaa , Springer, Berlin, New York.

Van Roy P. (1990), Extended DCG Notation : A Tool for Applicative Programming in Prolog, Technical
Report U CB/CSD 90/583, Computer Science Division, U C Berkeley.

