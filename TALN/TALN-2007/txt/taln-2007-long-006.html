<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Structures de traits typ&#233;es et morphologie &#224; partitions</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2007, Toulouse, 5&#8211;8 juin 2007
</p>
<p>Structures de traits typ&#233;es et morphologie &#224; partitions
</p>
<p>Fran&#231;ois BARTH&#201;LEMY1, 2
1 CNAM, C&#233;dric, 292 rue Saint-Martin, 75003 Paris
</p>
<p>2 INRIA, Atoll, 78153 Le Chesnay cedex
barthe@cnam.fr
</p>
<p>R&#233;sum&#233;. Les structures de traits typ&#233;es sont une fa&#231;on abstraite et agr&#233;able de repr&#233;senter
une information partielle. Dans cet article, nous montrons comment la combinaison de deux
techniques relativement classiques permet de d&#233;finir une variante de morphologie &#224; deux ni-
veaux int&#233;grant harmonieusement des structures de traits et se compilant en une machine finie.
La premi&#232;re de ces techniques est la compilation de structure de traits en expressions r&#233;gu-
li&#232;res, la seconde est la morphologie &#224; partition. Nous illustrons au moyen de deux exemples
l&#8217;expressivit&#233; d&#8217;un formalisme qui rapproche les grammaires &#224; deux niveaux des grammaires
d&#8217;unification.
</p>
<p>Abstract. Feature Structures are an abstract and convenient way of representing partial
information. In this paper, we show that the combination of two relatively classical techniques
makes possible the definition of a variant of two-level morphology which integrates harmo-
niously feature structures and compiles into finite-state machines. The first technique is the
compilation of feature structures into regular expressions, the second one is partition-based
morphology. Two examples are given, which show that our formalism is close to unification
grammars.
</p>
<p>Mots-cl&#233;s : morphologie &#224; deux niveaux, transducteurs finis &#224; &#233;tats, structure de traits.
Keywords: two-level morphology, finite-state transducers, feature structures.
</p>
<p>1 Introduction
</p>
<p>La morphologie &#224; &#233;tats finis est un courant important de la morphologie informatique qui pro-
pose des formalismes de r&#232;gles contextuelles (grammaires &#224; deux niveaux ou r&#232;gles de r&#233;&#233;cri-
ture) pour d&#233;crire la morphologie des langues. Ces r&#232;gles d&#233;notent une relation rationnelle re-
connue au moyen d&#8217;un transducteur fini.
</p>
<p>L&#8217;utilisation de structures de traits pour la morphologie &#224; &#233;tats finis est une pratique relative-
ment courante, que ce soit dans la litt&#233;rature ou dans les syst&#232;mes diffus&#233;s comme PC-Kimmo
(Antworth, 1995), Xerox Finite-State Tools (Beesley &amp; Karttunen, 2003) ou MMORPH (Petit-
pierre &amp; Russel, 1995). On peut distinguer deux approches : l&#8217;une consiste &#224; compiler les traits
statiquement dans les machines finies, l&#8217;autre consiste &#224; v&#233;rifier les contraintes apr&#232;s ex&#233;cution
de la machine finie au moyen d&#8217;une proc&#233;dure d&#8217;unification dynamique. Cette derni&#232;re option
est co&#251;teuse en temps de calcul &#224; effectuer lors de chaque analyse, mais elle permet d&#8217;utiliser
</p>
<p>69</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois BARTH&#201;LEMY
</p>
<p>toute la puissance de l&#8217;unification. Elle est utilis&#233;e notamment dans PC-Kimmo version 2 et
dans MMORPH.
</p>
<p>La compilation de structure de traits en machines finies impose des contraintes sp&#233;cifiques qui
ont &#233;t&#233; abord&#233;es de deux fa&#231;ons diff&#233;rentes : avec ou sans changement du formalisme des ma-
chines finies. Dans la premi&#232;re cat&#233;gorie, nous trouvons R&#233;mi Zajac (Zajac, 1998) qui propose
d&#8217;utiliser les structures de traits pour le niveau lexical d&#8217;un syst&#232;me de morphologie &#224; deux
niveau et remplace sur ce niveau la concat&#233;nation par l&#8217;unification. Jan Amtrup (Amtrup, 2003)
propose quant &#224; lui d&#8217;utiliser des machines pond&#233;r&#233;es par une structure de trait utilis&#233;e comme
un poids. Cette approche est correcte parce que les structures de traits munies de l&#8217;union et
de l&#8217;unification forment un semi-anneau. La limite de ces deux travaux est que la structure de
traits est unique et doit s&#8217;enrichir de fa&#231;on monotone, c&#8217;est &#224; dire que les calculs successifs ne
peuvent que pr&#233;ciser la valeur des traits, jamais la changer.
</p>
<p>L&#8217;approche qui consiste &#224; compiler les traits en symboles ordinaires dans des machines finies
standards est repr&#233;sent&#233;e par XFST d&#8217;une part et George Kiraz d&#8217;autre part (Kiraz, 1997). Dans
XFST, il n&#8217;y a pas &#224; proprement parler de structure de traits, mais des traits isol&#233;s que l&#8217;on
peut mentionner &#224; tout endroit dans les expressions r&#233;guli&#232;res pour leur appliquer une op&#233;ration
(fixer, unifier ou red&#233;finir leur valeur). Ces traits ont une port&#233;e globale sur toute une cha&#238;ne et
les op&#233;rations d&#8217;&#233;valuation sont effectu&#233;es dans un parcours gauche-droite des cha&#238;nes. Kiraz
propose quant &#224; lui de vraies structures de traits &#224; port&#233;e locale, ayant pour seul but un filtrage
des r&#232;gles contextuelle en fonction de traits pr&#233;cis&#233;s dans le lexique.
</p>
<p>Nous proposons une utilisation plus libre et plus syst&#233;matique de traits compil&#233;s sous forme
d&#8217;expressions r&#233;guli&#232;res ordinaires, avec la possibilit&#233; d&#8217;avoir des structures &#224; port&#233;e soit locale
(par exemple ne concernant qu&#8217;un morph&#232;me), soit globale (concernant toute une forme), soit
encore l&#8217;utilisation simultan&#233;e de diff&#233;rentes structures de traits ayant des port&#233;es diff&#233;rentes.
Les traits peuvent &#234;tre pr&#233;cis&#233;s et utilis&#233;s aussi bien dans le lexique que dans les r&#232;gles.
</p>
<p>Des restrictions sont apport&#233;es &#224; la forme que peuvent prendre les structures de traits ainsi que
leurs domaines pour permettre une compilation en expression r&#233;guli&#232;re. Par ailleurs, l&#8217;impl&#233;-
mentation de la notion de port&#233;e d&#8217;une structure de trait repose sur les concepts et techniques
de la morphologie &#224; partition, une approche de la morphologie &#224; &#233;tats finis dont le principal
contributeur est George Kiraz (Kiraz, 2001).
</p>
<p>Dans la section suivante, nous allons voir comment compiler des structures de traits en ex-
pressions r&#233;guli&#232;res. Nous verrons ensuite comment ces expressions r&#233;guli&#232;res peuvent &#234;tre
int&#233;gr&#233;es aux autre composantes d&#8217;une description morphologique et nous proposerons un for-
malisme ad&#233;quat. Nous illustrerons l&#8217;int&#233;r&#234;t de ce formalisme au moyen de deux exemples,
l&#8217;un n&#8217;utilisant qu&#8217;une structure de traits globale et l&#8217;autre utilisant une v&#233;ritable grammaire de
structure de traits.
</p>
<p>2 Compilation des structures de traits
</p>
<p>Dans cette section, nous abordons la question de la compilation de structures de traits en auto-
mates finis. Plus pr&#233;cis&#233;ment, nous allons nous int&#233;resser &#224; un sous-ensemble des structures de
traits dont la compilation est triviale : il s&#8217;agit des structures de traits acycliques prenant leurs
valeurs dans des ensembles finis petits.
</p>
<p>L&#8217;int&#233;r&#234;t essentiel de ces structures est d&#8217;offrir une syntaxe agr&#233;able pour repr&#233;senter une in-
</p>
<p>70</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Structures de traits typ&#233;es et morphologie &#224; partitions
</p>
<p>formation partielle, susceptible d&#8217;&#234;tre compl&#233;t&#233;e via des op&#233;rations alg&#233;briques (unification ou
application de r&#232;gles).
</p>
<p>Dans un premier temps, consid&#233;rons des structures de traits plates, c&#8217;est-&#224;-dire sans struc-
tures imbriqu&#233;es. Chaque trait identifi&#233; par son nom prend une valeur dans un ensemble fini
de valeurs connu. On peut repr&#233;senter chaque couple nom-valeur par un symbole sp&#233;cial et
une structure par une cha&#238;ne obtenue par concat&#233;nation des symboles correspondant &#224; ses
diff&#233;rents traits. Prenons par exemple les marques de nombre et personne utiles &#224; d&#233;crire la
conjugaison du fran&#231;ais. Le nombre peut prendre les deux valeurs singulier et pluriel, la per-
sonne peut prendre les trois valeurs 1, 2 ou 3. Cela conduit &#224; d&#233;crire un alphabet avec les
cinq symboles &lt;nombre=singulier&gt;, &lt;nombre=pluriel&gt;, &lt;personne=1&gt;, &lt;personne=2&gt; et
&lt;personne=3&gt;. Une structure [nombre = singulier, personne = 1] se compile en la cha&#238;ne
&lt;nombre=singulier&gt;&lt;personne=1&gt;.
</p>
<p>Pour assurer l&#8217;unicit&#233; de la repr&#233;sentation d&#8217;une structure, on peut imposer un ordre fixe entre
symboles d&#8217;une structure bas&#233; sur le seul nom des traits, par exemple en utilisant l&#8217;ordre lexi-
cographique.
</p>
<p>Si l&#8217;on conna&#238;t &#224; l&#8217;avance l&#8217;ensemble des traits susceptibles de venir enrichir au fil des calculs
un structure de traits, on peut repr&#233;senter une information partielle au moyen d&#8217;une expres-
sion r&#233;guli&#232;re repr&#233;sentant l&#8217;ensemble des traits. Par exemple, la structure [personne = 3] se
compile en (&lt;nombre=singulier&gt;|&lt;nombre=pluriel&gt;)&lt;personne=3&gt;. L&#8217;int&#233;r&#234;t de cette repr&#233;-
sentation vient de ce que l&#8217;unification de structures de ce genre s&#8217;impl&#233;mente par l&#8217;intersection
des expressions correspondantes. En d&#233;finissant une classe de caract&#232;res &lt;nom=_&gt; comme
l&#8217;union des caract&#232;res &lt;nom=x&gt; repr&#233;sentants les valeurs que peut prendre le trait nom, cette
expression peut s&#8217;&#233;crire de fa&#231;on &#233;quivalente &lt;nombre=_&gt;&lt;personne=3&gt;.
</p>
<p>L&#8217;unification n&#8217;est pas la seule op&#233;ration que l&#8217;on peut d&#233;sirer r&#233;aliser avec des structures de
traits. Des r&#232;gles de grammaires peuvent d&#233;crire la construction d&#8217;un structure &#224; partir d&#8217;une
ou plusieurs structures, en sp&#233;cifiant ce qui doit &#234;tre emprunt&#233; &#224; l&#8217;une ou &#224; l&#8217;autre au moyen de
variables. Par exemple la r&#232;gle suivante d&#233;crit l&#8217;adjonction d&#8217;un suffixe &#224; une base pourvue de
la bonne cat&#233;gorie syntaxique :
</p>
<p>&#63726;&#63728;cat 1
nombre 2
</p>
<p>&#63737;&#63739;&#8594;[cat 3 ]
&#63726;&#63727;&#63727;&#63728;
cat 1
de_cat 3
nombre 2
</p>
<p>&#63737;&#63738;&#63738;&#63739;
Le trait cat d&#233;crit la cat&#233;gorie syntaxique de la base (premier op&#233;rande), du r&#233;sultat de l&#8217;ad-
jonction du suffixe, alors que le trait de_cat (second op&#233;rande) sp&#233;cifie la cat&#233;gorie syntaxique
de la base pour que la d&#233;rivation soit correcte.
</p>
<p>Une telle r&#232;gle peut &#234;tre impl&#233;ment&#233;e par un transducteur &#224; trois bandes, une pour chaque op&#233;-
rande et une pour le r&#233;sultat. Ce transducteur, sous certaines conditions1, peut &#234;tre obtenu par
intersection de transducteurs impl&#233;mentant chacun une des variables de la r&#232;gle. Si l&#8217;on suppose
que les diff&#233;rents rubans sont synchronis&#233;s sur les valeurs des traits, cela donne :
1 : (_ :_ :_)*(_ :P :P)(_ :_ :_)* where P in &lt;cat=_&gt;
2 : (_ :_ :_)*(_ :C :C)(_ :_ :_)* where C in &lt;nombre=_&gt;
3 : (_ :_ :_)*(&lt;cat=X&gt; :_ :_)(_ :_ :_)*(_ :&lt;de_cat=X&gt; :_)(_ :_ :_)*(_ :C :C)(_ :_ :_)*
where X in dom(cat)&#8745;dom(de_cat)
</p>
<p>1L&#8217;intersection de transducteurs n&#8217;est pas d&#233;finie pour les transducteurs en g&#233;n&#233;ral, mais elle l&#8217;est pour certaines
sous-classes particuli&#232;res.
</p>
<p>71</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois BARTH&#201;LEMY
</p>
<p>Au sein d&#8217;une structure de traits, une variable peut &#234;tre utilis&#233;e pour noter le fait que plusieurs
traits partagent une m&#234;me valeur. Une telle structure est compil&#233;e en une disjonction de cha&#238;nes,
chacune d&#8217;elle repr&#233;sentant une des valeurs possibles de la variable.
</p>
<p>Le technique de compilation que nous venons de voir s&#8217;&#233;tend facilement aux structures imbri-
qu&#233;es acycliques. Il faut simplement remplacer la notion de nom de trait par celle de chemin.
Par exemple, la structure suivante :
</p>
<p>&#63726;&#63727;&#63727;&#63727;&#63728;
cat nom
</p>
<p>agr
[
genre masc
nombre pluriel
</p>
<p>]
&#63737;&#63738;&#63738;&#63738;&#63739;
</p>
<p>se compile en &lt;agr.genre=masc&gt;&lt;agr.nombre=pluriel&gt;&lt;cat=nom&gt;. L&#8217;int&#233;r&#234;t de cette imbri-
cation est de pouvoir repr&#233;senter au moyen d&#8217;une seule variable l&#8217;&#233;galit&#233; de tous les traits de la
sous-structure.
</p>
<p>3 Pr&#233;sentation du formalisme
</p>
<p>Le formalisme que nous proposons est bas&#233; sur la morphologie &#224; partition. L&#8217;historique de ce
courant se trouve dans (Kiraz, 2001) alors que sa compilation en automate fini est d&#233;crite dans
(Barth&#233;lemy, 2005). L&#8217;id&#233;e centrale consiste &#224; d&#233;finir des relations n-aires dont les diff&#233;rentes
cha&#238;nes sont divis&#233;es en un nombre &#233;gal de sous-cha&#238;nes. Par exemple, on peut relier une repr&#233;-
sentation &#233;crite et une repr&#233;sentation phonologique de la fa&#231;on suivante :
</p>
<p>e x em p l es
e gs &#227; p l
</p>
<p>Comme on le voit, les sous-cha&#238;nes mises en correspondances peuvent &#234;tre de longueurs diff&#233;-
rentes et &#233;ventuellement nulles.
</p>
<p>Les relations r&#233;guli&#232;res partitionn&#233;es sont la classe de relations qu&#8217;on peut d&#233;crire avec des ex-
pressions r&#233;guli&#232;res augment&#233;es d&#8217;une construction nouvelle que nous appellerons tuple, per-
mettant de mettre en relation deux ou plusieurs sous-cha&#238;nes. Par exemple, l&#8217;expression r&#233;gu-
li&#232;re : &lt; [lettre]&#8727;, [phoneme]&#8727; &gt;&#8727;&lt; e, ! &gt; d&#233;note l&#8217;ensemble des cha&#238;nes termin&#233;es par un e
muet. Les op&#233;rations comme la concat&#233;nation, la disjonction, l&#8217;&#233;toile, peuvent intervenir aussi
bien &#224; l&#8217;int&#233;rieur d&#8217;un tuple que sur un tuple.
</p>
<p>Le formalisme que nous proposons autorise la description de relations n-aires et non seulement
binaires, ce qui correspond &#224; une morphologie &#224; n niveaux, n pouvant &#234;tre diff&#233;rent de 2. Les
niveaux suppl&#233;mentaires peuvent &#234;tre utilis&#233;s soit pour distinguer des facteurs ind&#233;pendants &#224;
un niveau donn&#233;, comme c&#8217;est le cas par exemple pour la description du Syriaque dans (Kiraz,
2000), soit pour distinguer des niveaux interm&#233;diaires dans une cascade de traitements comme
c&#8217;est le cas dans l&#8217;analyseur morphologique de l&#8217;akkadien d&#233;crit dans (Barth&#233;lemy, 2006).
</p>
<p>Le formalisme est fond&#233; sur des expressions r&#233;guli&#232;res &#233;tendues pour prendre en compte les
notions de partition et de structures de traits. Les r&#232;gles contextuelles sont admises en tant que
raccourcis syntaxiques d&#233;notant des expressions r&#233;guli&#232;res.
</p>
<p>Une description comporte les sections suivantes : domaines des traits, types de structures de
traits, d&#233;finition de l&#8217;alphabet, types des diff&#233;rents niveaux, types des tuples, autres types d&#8217;ex-
pressions r&#233;guli&#232;res, d&#233;finition des machines finies.
</p>
<p>72</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Structures de traits typ&#233;es et morphologie &#224; partitions
</p>
<p>Nous allons donner en exemple une description sch&#233;matique de la conjugaison des verbes fran-
&#231;ais. Nous discuterons cet exemple dans la section suivante. Les points de suspension mat&#233;ria-
lisent des coupures que nous avons r&#233;alis&#233; dans l&#8217;exemple pour gagner de la place.
</p>
<p>PACKAGE verbes;
FEATURES VALUES
</p>
<p>temps: present, futur, passe, imparfait;
mode: indicatif, subjonctif, conditionnel, imperatif;
personne: 1, 2, 3;
nombre: singulier, pluriel;
conjugaison: 1, 2, 3, irreg;
</p>
<p>END VALUES
FEATURE STRUCTURES
</p>
<p>verbe: temps, mode, personne, nombre, conjugaison;
END STRUCTURES
ALPHABET
</p>
<p>[lettre]: a, b, c, d ...
[voyelle]: a, &#224;, &#226;, e, &#233; ...
[consonne]: b, c, d ...
</p>
<p>END ALPHABET
LEVELS
</p>
<p>1: [verbe:_];
2: [lettre]+;
3: [lettre]*;
4: [lettre]*;
</p>
<p>END LEVELS
TUPLES
</p>
<p>&lt;3| LEVEL 3: [lettre], LEVEL 4: [lettre] |3&gt;;
&lt;2| &lt;3|_|3&gt;* |2&gt;;
&lt;1| LEVEL 0, LEVEL 1, &lt;2|_|2&gt;&lt;2|_|2&gt; |&gt;;
</p>
<p>END TUPLES
TYPES
</p>
<p>&lt;radical: LEVEL 1, LEVEL 2, LEVEL 3 &gt; =&gt;
&lt;1| #1, #2, &lt;2| /LEVEL 3: #3/ |2&gt;&lt;2|_|2&gt; |1&gt;;
</p>
<p>&lt;suffixe: LEVEL 2, LEVEL 3 &gt; =&gt;
&lt;1| _, #1, &lt;2|_|2&gt; &lt;2| /LEVEL 3: #2/ |2&gt;;
</p>
<p>END
</p>
<p>Les domaines de traits sont des listes de valeurs que peuvent prendre les diff&#233;rents traits.
D&#8217;autres domaines finis de valeurs peuvent &#233;galement &#234;tre d&#233;fini et une m&#234;me valeur peut ap-
partenir &#224; plusieurs domaines. Les structures de traits sont typ&#233;es au moyen d&#8217;un nom de type
associ&#233; &#224; la liste des traits de la structure. Dans la syntaxe, le nom de type appara&#238;t en d&#233;but de
structure, suivi de deux points.
</p>
<p>Chaque niveau est caract&#233;ris&#233; par un num&#233;ro et son type est une expression r&#233;guli&#232;re d&#233;finis-
sant un sur-ensemble des cha&#238;nes susceptibles d&#8217;&#234;tre lues sur ce niveau. Le type d&#8217;un tuple est
constitu&#233; de la liste ordonn&#233;e de ses niveaux, avec pour chacun d&#8217;entre eux une expression r&#233;gu-
li&#232;re restreignant la sous-cha&#238;ne pouvant appara&#238;tre sur ce niveau. Les diff&#233;rents tuples peuvent
diff&#233;rer par leur arit&#233;, les niveaux qu&#8217;ils comportent et leur degr&#233; d&#8217;imbrication. D&#8217;autres types
d&#8217;expressions r&#233;guli&#232;res peuvent &#234;tre d&#233;finis pour faciliter l&#8217;&#233;criture des expressions r&#233;guli&#232;res,
par exemple en sp&#233;cifiant un contenu sous-entendu pour certains niveaux de certains tuples.
</p>
<p>73</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois BARTH&#201;LEMY
</p>
<p>Les relations r&#233;guli&#232;res sont nomm&#233;es. Elles peuvent &#234;tre d&#233;finies de trois mani&#232;res diff&#233;rentes.
La premi&#232;re forme est celle d&#8217;une expression r&#233;guli&#232;re utilisant des symboles de l&#8217;alphabet,
des constructeurs de tuples et diff&#233;rentes facilit&#233;s syntaxiques. Par exemple, on peut utiliser
des variables prenant leur valeur dans un ensemble fini. L&#8217;expression d&#233;not&#233;e est l&#8217;union des
expressions obtenue par substitution de la variable par une de ses valeurs. Par ailleurs, on au-
torise l&#8217;utilisation d&#8217;un joker (wildcard) not&#233; _ dans diff&#233;rents contextes. La projection not&#233;e
/LEVEL x: _/ permet de ne sp&#233;cifier que le contenu d&#8217;un niveau dans une expression qui
en comporte plusieurs. La construction REGEXP r&#233;alise implicitement l&#8217;union des expressions
r&#233;guli&#232;res qu&#8217;elle contient, chacune &#233;tant termin&#233;e par un point-virgule.
</p>
<p>REGEXP les_radicaux IS
&lt;radical: lancer, [verbe:conjugaison=1], lanC &gt;;
&lt;radical: polir, [verbe:conjugaison=2], poli &gt;;
&lt;radical: pouvoir, [verbe:conjugaison=3], p[OU_EU]v &gt;;
...
</p>
<p>END
REGEXP terminaisons IS
</p>
<p>&lt;suffixe: [verbe:temps=present,mode=indicatif,
nombre=singulier,personne=1|3,conjugaison=1], e&gt;;
</p>
<p>&lt;suffixe: [verbe:temps=present,mode=indicatif,
nombre=singulier,personne=1|2,conjugaison=2|3], s&gt;;
</p>
<p>...
END
LET formes=intersect(les_radicaux,terminaisons);
</p>
<p>Le deuxi&#232;me moyen de sp&#233;cifier une relation r&#233;guli&#232;re est par application d&#8217;op&#233;rations sur des
relations d&#233;finies auparavant. Les op&#233;rations comprennent les op&#233;rations ensemblistes (union,
intersection, diff&#233;rence) et les op&#233;rations rationnelles (concat&#233;nation, &#233;toile). La projection per-
met d&#8217;&#233;liminer certains niveaux. Sous certaines conditions, l&#8217;op&#233;ration de jointure permet de
composer deux relations ayant des domaines diff&#233;rents.
</p>
<p>Le dernier moyen de d&#233;crire une relation r&#233;guli&#232;re est l&#8217;utilisation de r&#232;gles contextuelles. Ce
sont des adaptations aux relations n-aires des r&#232;gles classiques de la morphologie &#224; deux niveau.
Les r&#232;gles de coercition sp&#233;cifient un certain motif et contraignent les valeurs que peuvent
prendre, en contexte, les sous-cha&#238;nes filtr&#233;es par ce motif. Par exemple, la r&#232;gle suivante d&#233;crit
la r&#233;alisation d&#8217;un m&#233;ta-caract&#232;re C susceptible de s&#8217;&#233;crire &#231; ou c selon le contexte (comme par
exemple dans le verbe lancer, je lan&#231;ais) :
</p>
<p>&lt;3| C, _ |3&gt; =&gt; &lt;3| C, &#231; |3&gt;
IF _ &lt;2| &lt;3_|3&gt;* XXX |2&gt;&lt;2| &lt;3|_, [lettre]-(i|e)|3&gt; _ |2&gt; _
</p>
<p>Le motif appara&#238;t &#224; gauche de la fl&#232;che et la restriction &#224; droite de la fl&#232;che. Le contexte est
d&#233;crit en utilisant XXX pour d&#233;signer le centre de la r&#232;gle, &#224; distinguer de _, utilis&#233; ici comme
joker. Dans notre syst&#232;me multi-niveaux, il n&#8217;y a pas de distinction explicite entre niveau lexical
et niveau de surface. N&#8217;importe quel ensemble de niveaux peut &#234;tre pr&#233;cis&#233; dans le motif et deux
r&#232;gles diff&#233;rentes peuvent utiliser des ensembles de niveaux diff&#233;rents, ce qui introduit plus de
souplesse et justifie le changement de nom de coercition de surface en coercition tout court.
</p>
<p>Une r&#232;gle de restriction de contexte d&#233;crit un contexte dans lequel un motif peut exclusivement
appara&#238;tre (syntaxe : motif ONLY IF contexte). Une r&#232;gle composite est un r&#232;gle qui
cumule les deux contraintes de coercition et de restriction de contexte.
</p>
<p>74</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Structures de traits typ&#233;es et morphologie &#224; partitions
</p>
<p>L&#8217;utilisation de r&#232;gles contextuelles posent des probl&#232;mes de conflits, quand deux r&#232;gles sont
d&#8217;une certaine fa&#231;on contradictoires. Nous ne traiterons pas de ce probl&#232;me en d&#233;tail dans cet
article dont ce n&#8217;est pas l&#8217;objet. L&#8217;existence de ces conflits justifie qu&#8217;on consid&#232;re les r&#232;gles
comme un ensemble et non s&#233;par&#233;ment. La d&#233;tection des conflits peut &#234;tre automatis&#233;e (Beesley
&amp; Karttunen, 2003) et leur r&#233;solution peut &#234;tre aid&#233;e par une proc&#233;dure interactive.
</p>
<p>4 Exemple avec structure de traits unique
</p>
<p>Dans ce premier exemple, nous voulons insister sur la question du niveau abstrait d&#8217;une re-
pr&#233;sentation et promouvoir l&#8217;id&#233;e que la multiplicit&#233; des niveaux permet d&#8217;offrir une r&#233;ponse
ad&#233;quate. Ce qu&#8217;on appelle le niveau lexical dans un syst&#232;me de morphologie &#224; deux niveaux
traditionnel est une repr&#233;sentation relativement concr&#232;te sur laquelle il faut appliquer quelques
transformations pour obtenir une repr&#233;sentation de surface. Il s&#8217;agit en fait d&#8217;une approximation
aussi pr&#233;cise qu&#8217;on peut faire de la repr&#233;sentation de surface d&#8217;un morph&#232;me avant application
des m&#233;canismes de d&#233;rivation et/ou de flexion.
</p>
<p>Dans un syst&#232;me comme PC-Kimmo, la repr&#233;sentation abstraite de la forme est ce qu&#8217;on appelle
la glose (gloss), une cha&#238;ne de caract&#232;re pr&#233;cis&#233;e dans le lexique et destin&#233;e &#224; &#234;tre affich&#233;e en
r&#233;ponse &#224; certaines requ&#234;tes. Nous proposons d&#8217;inclure cette information dans un ou plusieurs
niveaux, sans exclure les deux repr&#233;sentations classiques : approximation avant composition et
forme de surface.
</p>
<p>R&#233;mi Zajac (Zajac, 1998) propose d&#8217;utiliser une structure de traits comme niveau abstrait d&#8217;un
syst&#232;me &#224; deux niveaux. Nous allons affiner cette id&#233;e pour permettre une compilation en ma-
chine finie : il faut repr&#233;senter sous forme d&#8217;une structure de trait uniquement les traits &#233;l&#233;men-
taires prenant leur valeur dans un ensemble fini et petit et sous la forme d&#8217;une cha&#238;ne utilisant
un niveau sp&#233;cifique les informations structur&#233;es ou ayant un grand nombre de valeurs.
</p>
<p>Dans l&#8217;exemple de la conjugaison du verbe fran&#231;ais, une forme abstraite doit pr&#233;ciser le lemme,
le temps, le mode, la personne, le nombre. Le nombre de lemmes est grand. Cr&#233;er un symbole
par lemme conduit &#224; multiplier le nombre de symboles au-del&#224; de ce qui est couramment accept&#233;
par les impl&#233;mentations de machines finies. Le lemme sera donc not&#233; sous la forme d&#8217;une
cha&#238;ne de caract&#232;re et cela constitue le niveau 1. Les autres informations ont peu de valeurs,
on les regroupe donc dans une structure de traits qui occupe le niveau 2. Les niveaux 3 et 4
sont consacr&#233;s aux repr&#233;sentations interm&#233;diaire et de surface. Par ailleurs, pour coordonner
les lemmes et les terminaisons, il faut conna&#238;tre le paradigme de conjugaison utilis&#233;. Cette
information pourrait &#234;tre mise sur un niveau de service, mais pour simplifier la description,
nous la pla&#231;ons dans la structure de traits du niveau 1.
</p>
<p>Cet exemple illustre comment le typage permet de ne pr&#233;ciser que l&#8217;information pertinente pour
les radicaux et les terminaisons, tout en ayant une repr&#233;sentation sous-jacente unique, ce qui
permet d&#8217;op&#233;rer une intersection. Cette intersection r&#233;alise l&#8217;unification des structures de traits
sp&#233;cifi&#233;es dans les deux expressions r&#233;guli&#232;res, et notamment l&#8217;identification de leur unique
trait commun, conjugaison. Par exemple,
&lt;radical: lancer, [verbe:conjugaison=1], lanC &gt; est une notation &#233;quiva-
lente &#224; l&#8217;expression :
&lt;1| lancer, [verbe:conjugaison=1],
</p>
<p>&lt;2| &lt;3|l,_|3&gt;&lt;3|a,_|3&gt;&lt;3|n,_|3&gt;&lt;3|C,_|3&gt; |2&gt;&lt;2|_|2&gt; |1&gt;.
</p>
<p>75</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois BARTH&#201;LEMY
</p>
<p>Il convient ensuite de compl&#233;ter la description en pr&#233;cisant comment relier le niveau interm&#233;-
diaire (niveau 3) avec la r&#233;alisation de surface (niveau 4).
</p>
<p>RULE SET
&lt;3| $L,$L |3&gt; where $L in [lettre];
&lt;3| C, c |3&gt;
</p>
<p>ONLY IF _ XXX /Level 3: (e|i) _/;
&lt;3| s,_ |3&gt; =&gt; &lt;3| s,x |3&gt;
</p>
<p>IF &lt;1| [verbe:temps=present,nombre=singulier,
mode=indicatif],
pouvoir|vouloir, &lt;2|_|2&gt;&lt;2| XXX |2&gt; |1&gt;;
</p>
<p>...
</p>
<p>La derni&#232;re r&#232;gle illustre comment une r&#232;gle contextuelle peut &#234;tre conditionn&#233;e par la valeur
des traits en utilisant simplement la notion de contexte habituelle.
</p>
<p>5 Exemple avec plusieurs structures de traits
</p>
<p>Nous allons prendre comme exemple une grammaire ayant une structure lin&#233;aire, d&#233;crivant une
morphologie bas&#233;e exclusivement sur des suffixes. Les machines finies permettent de repr&#233;-
senter plus facilement de telles structures que des arbres quelconques. Une morphologie bas&#233;e
&#224; la fois sur des pr&#233;fixes et des suffixes, voire des circonfixes, est plus difficile &#224; traiter. Ces
probl&#232;mes techniques ne sont pas insurmontables, mais alourdiraient trop notre exemple. Nous
allons donc nous limiter &#224; des suffixes susceptibles de changer la cat&#233;gorie syntaxique d&#8217;un mot
et donc son type de flexion.
</p>
<p>&#63726;&#63727;&#63727;&#63728;
cat nom
genre fem
nombre pl
</p>
<p>&#63737;&#63738;&#63738;&#63739;
!!!!!!!!!
&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
</p>
<p>&#63726;&#63727;&#63727;&#63728;
cat nom
genre fem
nombre sg
</p>
<p>&#63737;&#63738;&#63738;&#63739;
#######
$$$$$$$
</p>
<p>&#63726;&#63728;cat verbe
conj 1
</p>
<p>&#63737;&#63739;
%%%
&amp;&amp;&amp;
</p>
<p>[]
[
type racine
</p>
<p>]
mang
</p>
<p>&#63726;&#63728;type deriv
de_cat verbe
</p>
<p>&#63737;&#63739;
euse
</p>
<p>&#63726;&#63728;type flex
trait nombre
</p>
<p>&#63737;&#63739;
s
</p>
<p>FIG. 1 &#8211; Exemple de structure
</p>
<p>76</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Structures de traits typ&#233;es et morphologie &#224; partitions
</p>
<p>La figure 1 donne un exemple de structure que nous voulons repr&#233;senter, celle qui correspond
&#224; la forme mangeuses. Dans cette structure binaire, des informations doivent &#234;tre propag&#233;es
comme par exemple le genre, qui n&#8217;est pas modifi&#233; par la marque de pluriel. Les suffixes de
flexion modifient une partie de la structure, pr&#233;servant le reste, alors que les suffixes de d&#233;riva-
tion bloquent la transmission d&#8217;information qui n&#8217;est plus pertinente compte tenu du change-
ment de cat&#233;gorie syntaxique. C&#8217;est ici le cas du paradigme de conjugaison.
</p>
<p>Nous voyons dans cet exemple que le nombre de noeuds internes de la structure est &#233;gal au
nombre de morph&#232;mes, ce qui permet d&#8217;utiliser le m&#234;me tuple pour d&#233;crire un morph&#232;me et
son p&#232;re. Dans chacun de ces tuples, il y aura donc deux structure de traits : une associ&#233;e au
seul morph&#232;me, l&#8217;autre concernant la structure regroupant le morph&#232;me et tous ceux qui le
pr&#233;c&#232;dent.
</p>
<p>REGEXP affixes IS
&lt;affixe: [verbe:cat=verbe,conj=1], [racine], mang &gt;;
&lt;affixe: [nom:cat=nom,genre=fem,nombre=sg],
</p>
<p>[deriv:de_cat=verbe], euse &gt;;
&lt;affixe: [nom:cat=nom,nombre=pl], [flex:trait=nombre], s &gt;;
...
END
RULE SET composition IS
</p>
<p>&lt;affixe: _, [deriv:de_cat=$A], _ &gt;
ONLY IF _ &lt;affixe: [_:cat=$A], _ , _&gt; XXX _;
</p>
<p>&lt;affixe: [nom:genre=$G], [flex:trait=nombre], _ &gt;
ONLY IF _ &lt;affixe: [nom:genre=$G],_,_&gt; XXX _;
</p>
<p>...
</p>
<p>La d&#233;rivation peut &#234;tre trait&#233;e au moyen d&#8217;une r&#232;gle contextuelle unique qui v&#233;rifie que la base
poss&#232;de la cat&#233;gorie syntaxique requise. Pour la flexion, en revanche, il faut une r&#232;gle pour
chaque type de suffixe, car les traits propag&#233;s et les traits r&#233;vis&#233;s ne sont pas les m&#234;mes.
</p>
<p>Les deux r&#232;gles r&#232;gles donn&#233;es en exemple illustrent comment les diff&#233;rentes structures de traits
interagissent et notamment comment certains traits en sont unifi&#233;s. Elles pourraient aussi bien
s&#8217;exprimer sous forme de r&#232;gle de grammaires de traits. Par exemple la seconde :&#63726;&#63727;&#63727;&#63728;
nom
genre 1
nombre 2
</p>
<p>&#63737;&#63738;&#63738;&#63739;&#8594;
&#63726;&#63728;nom
genre 1
</p>
<p>&#63737;&#63739;
&#63726;&#63727;&#63727;&#63728;
flex
nombre 2
trait nombre
</p>
<p>&#63737;&#63738;&#63738;&#63739;
</p>
<p>6 Conclusion
</p>
<p>Dans cet article, nous montrons comment l&#8217;utilisation simultan&#233;e de deux techniques pr&#233;exis-
tantes, &#224; savoir la compilation de structure de traits en cha&#238;nes de caract&#232;res et la morphologie
&#224; partition, offre un pouvoir de description int&#233;ressant.
</p>
<p>Il n&#8217;y a bien s&#251;r aucune augmentation de puissance du formalisme. Il s&#8217;agit de facilit&#233; d&#8217;&#233;cri-
ture : les structures de traits sont pratiques parce qu&#8217;on ne pr&#233;cise que l&#8217;information connue et
que l&#8217;ordre des traits n&#8217;est pas significatif. De plus ce formalisme est familier aux personnes
travaillant dans le TAL.
</p>
<p>77</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois BARTH&#201;LEMY
</p>
<p>La technique que nous proposons offre un risque d&#8217;explosion de la taille des machines. Ce risque
est important si l&#8217;on multiplie les traits, les valeurs et surtout les unifications entre structures
&#233;loign&#233;es. Notre exp&#233;rience montre que ce risque n&#8217;est pas r&#233;dhibitoire. Nous avons r&#233;alis&#233; un
prototype qui compile une description syntaxique en un automate fini, en utilisant la bo&#238;te &#224;
outils FSM (Mohri et al., 2002). Nous avons &#233;crit des grammaires relativement grosses (&#8764; 50
r&#232;gles) sans provoquer d&#8217;explosion incontr&#244;l&#233;e (Barth&#233;lemy, 2006).
</p>
<p>L&#8217;outil de Xerox (xfst) offre une possibilit&#233; int&#233;ressante pour &#233;viter l&#8217;explosion combinatoire :
elle consiste &#224; choisir entre un calcul statique ou dynamique pour les valeurs de traits. Dans
le cas d&#8217;un calcul dynamique, ce ne sont pas les seules valeurs de traits qui sont repr&#233;sent&#233;es
sous forme de symboles dans les machines, mais les calculs &#224; r&#233;aliser sur ces traits lors d&#8217;une
&#233;valuation de gauche &#224; droite. A priori, il semble possible d&#8217;adapter cette technique &#224; notre
formalisme.
</p>
<p>Notre proposition permet une utilisation plus g&#233;n&#233;rale des traits que les travaux ant&#233;rieurs pro-
posant une compilation en machine finie. Par rapport &#224; (Zajac, 1998), (Amtrup, 2003), l&#8217;apport
principal est la notion de port&#233;e d&#8217;une structure qui peut &#234;tre locale &#224; un tuple, ce qui autorise la
multiplicit&#233; de structures ayant certains traits communs dont les valeurs sont ind&#233;pendantes. Les
interactions entre structures de traits sont plus riche que dans (Kiraz, 1997). Par rapport aux ap-
proches qui proposent une &#233;valuation dynamique des structures de traits, les gains proviennent
d&#8217;une meilleure int&#233;gration avec les calculs d&#8217;automates (par exemple, calcul d&#8217;intersection)
ainsi qu&#8217;une plus grande efficacit&#233;.
</p>
<p>R&#233;f&#233;rences
AMTRUP J. W. (2003). Feature structures as weights in finite state morphology. In FSMNLP,
Budapest, Hongrie.
ANTWORTH E. L. (1995). User&#8217;s guide to pc-kimmo version 2.
BARTH&#201;LEMY F. (2005). Partitioning multitape transducers. In International Workshop on
Finite State Methods in Natural Language Processing (FSMNLP), Helsinki, Finlande.
BARTH&#201;LEMY F. (2006). Un analyseur morphologique utilisant la jointure. In In Traitement
Automatique de la Langue Naturelle (TALN&#8217;06), Leuven, Belgique.
BEESLEY K. R. &amp; KARTTUNEN L. (2003). Finite State Morphology. CSLI Publications.
KIRAZ G. A. (1997). Compiling regular formalisms with rule features into finite-state auto-
mata. In ACL, Madrid, Espagne.
KIRAZ G. A. (2000). Multitiered nonlinear morphology using multitape finite automata : a
case study on syriac and arabic. Computational Linguistics, 26(1), 77&#8211;105.
KIRAZ G. A. (2001). Computational Nonlinear Morphology. Cambridge University Press.
MOHRI M., PEREIRA F. C. N. &amp; RILEY M. (2002). Weighted finite-state transducers in
speech recognition. Computer Speech and Language, 16(1), 69&#8211;88.
PETITPIERRE D. &amp; RUSSEL G. (1995). Mmorph : the multex morphology program.
ZAJAC R. (1998). Feature structures, unification and finite-state transducers. In FSMNLP&#8217;98,
Ankara, Turquie.
</p>
<p>78</p>

</div></div>
</body></html>