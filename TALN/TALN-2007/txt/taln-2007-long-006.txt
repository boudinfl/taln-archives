TALN 2007, Toulouse, 5-8 juin 2007

Structures de traits typées et morphologie it partitions

Frangois BARTHELEMY1’ 2
1 CNAM, Cédric, 292 rue Saint-Martin, 75003 Paris
2 INRIA, Atoll, 78153 Le Chesnay cedex
barthe@cnam. fr

Résumé. Les structures de traits typées sont une facon abstraite et agréable de représenter
une information partielle. Dans cet article, nous montrons comment la combinaison de deux
techniques relativement classiques permet de déﬁnir une variante de morphologie a deux ni-
veaux intégrant harmonieusement des structures de traits et se compilant en une machine ﬁnie.
La premiere de ces techniques est la compilation de structure de traits en expressions régu-
lieres, la seconde est la morphologie a partition. Nous illustrons au moyen de deux exemples
l’expressivité d’un formalisme qui rapproche les grarmnaires a deux niveaux des grarmnaires
d’uniﬁcation.

Abstract. Feature Structures are an abstract and convenient way of representing partial
information. In this paper, we show that the combination of two relatively classical techniques
makes possible the deﬁnition of a variant of two-level morphology which integrates harmo-
niously feature structures and compiles into ﬁnite-state machines. The ﬁrst technique is the
compilation of feature structures into regular expressions, the second one is partition-based
morphology. Two examples are given, which show that our formalism is close to uniﬁcation
grammars.

Mots-clés 2 morphologie a deux niveaux, transducteurs ﬁnis a états, structure de traits.

Keywords: two-level morphology, ﬁnite-state transducers, feature structures.

1 Introduction

La morphologie a états ﬁnis est un courant important de la morphologie informatique qui pro-
pose des formalismes de regles contextuelles (grarmnaires a deux niveaux ou regles de réécri-
ture) pour décrire la morphologie des langues. Ces regles dénotent une relation rationnelle re-
connue au moyen d’un transducteur ﬁni.

L’utilisation de structures de traits pour la morphologie a états ﬁnis est une pratique relative-
ment courante, que ce soit dans la littérature ou dans les systemes diffusés comme PC-Kimmo
(Antworth, 1995), Xerox Finite-State Tools (Beesley & Karttunen, 2003) ou MMORPH (Petit-
pierre & Russel, 1995). On peut distinguer deux approches 2 l’une consiste a compiler les traits
statiquement dans les machines ﬁnies, l’autre consiste a vériﬁer les contraintes apres exécution
de la machine ﬁnie au moyen d’une procédure d’uniﬁcation dymamique. Cette derniere option
est coﬁteuse en temps de calcul a effectuer lors de chaque analyse, mais elle permet d’utiliser

69

Francois BARTHELEMY

toute la puissance de l’uniﬁcation. Elle est utilisée notannnent dans PC-Kimmo version 2 et
dans MMORPH.

La compilation de structure de traits en machines ﬁnies impose des contraintes spéciﬁques qui
ont été abordées de deux facons différentes 2 avec ou sans changement du formalisme des ma-
chines ﬁnies. Dans la premiere catégorie, nous trouvons Rémi Zajac (Zajac, 1998) qui propose
d’utiliser les structures de traits pour le niveau lexical d’un systeme de morphologie a deux
niveau et remplace sur ce niveau la concaténation par l’uniﬁcation. Jan Amtrup (Amtrup, 2003)
propose quant a lui d’utiliser des machines pondérées par une structure de trait utilisée comme
un poids. Cette approche est correcte parce que les structures de traits munies de l’union et
de l’uniﬁcation forment un semi-armeau. La limite de ces deux travaux est que la structure de
traits est unique et doit s’en1ichir de facon monotone, c’ est a dire que les calculs successifs ne
peuvent que préciser la valeur des traits, jamais la changer.

L’ approche qui consiste a compiler les traits en symboles ordinaires dans des machines ﬁnies
standards est représentée par XFST d’ une part et George Kiraz d’autre part (Kiraz, 1997). Dans
XFST, il n’y a pas a proprement parler de structure de traits, mais des traits isolés que l’on
peut mentionner a tout endroit dans les expressions régulieres pour leur appliquer une opération
(ﬁxer, uniﬁer ou redéﬁnir leur valeur). Ces traits ont une portée globale sur toute une cha’1‘ne et
les opérations d’évaluation sont effectuées dans un parcours gauche-droite des cha’1‘nes. Kiraz
propose quant a lui de vraies structures de traits a portée locale, ayant pour seul but un ﬁltrage
des regles contextuelle en fonction de traits précisés dans le lexique.

Nous proposons une utilisation plus libre et plus systématique de traits compilés sous forme
d’expressions régulieres ordinaires, avec la possibilité d’ avoir des structures a portée soit locale
(par exemple ne concemant qu’un morpheme), soit globale (concemant toute une forme), soit
encore l’utilisation simultanée de différentes structures de traits ayant des portées différentes.
Les traits peuvent étre précisés et utilisés aussi bien dans le lexique que dans les regles.

Des restrictions sont apportées a la forme que peuvent prendre les structures de traits ainsi que
leurs domaines pour permettre une compilation en expression réguliere. Par ailleurs, l’implé-
mentation de la notion de portée d’une structure de trait repose sur les concepts et techniques
de la morphologie a partition, une approche de la morphologie a états ﬁnis dont le principal
contributeur est George Kiraz (Kiraz, 2001).

Dans la section suivante, nous allons voir comment compiler des structures de traits en ex-
pressions régulieres. Nous verrons ensuite comment ces expressions régulieres peuvent étre
intégrées aux autre composantes d’une description morphologique et nous proposerons un for-
malisme adéquat. Nous illustrerons l’intérét de ce fonnalisme au moyen de deux exemples,
l’un n’utilisant qu’une structure de traits globale et l’autre utilisant une véritable grarmnaire de
structure de traits.

2 Compilation des structures de traits

Dans cette section, nous abordons la question de la compilation de structures de traits en auto-
mates ﬁnis. Plus précisément, nous allons nous intéresser a un sous-ensemble des structures de
traits dont la compilation est triviale 2 il s’agit des structures de traits acycliques prenant leurs
Valeurs dans des ensembles ﬁnis petits.

L’intérét essentiel de ces structures est d’ offrir une switaxe agréable pour représenter une in-

70

Structures de traits typees et morphologie a partitions

formation partielle, susceptible d’etre completee via des operations algebriques (uniﬁcation ou
application de regles).

Dans un premier temps, considerons des structures de traits plates, c’est-a-dire sans struc-
tures imbriquees. Chaque trait identiﬁe par son nom prend une valeur dans un ensemble ﬁni
de valeurs connu. On peut representer chaque couple nom-valeur par un symbole special et
une structure par une cha’1‘ne obtenue par concatenation des symboles correspondant a ses
differents traits. Prenons par exemple les marques de nombre et personne utiles a decrire la
conjugaison du francais. Le nombre peut prendre les deux valeurs singulier et pluriel, la per-
sonne peut prendre les trois valeurs 1, 2 ou 3. Cela conduit a decrire un alphabet avec les
cinq symboles <nombre=singulier>, <nombre=pluriel>, <personne=1>, <personne=2> et
<personne=3>. Une structure [nombre = singulier, personne = 1] se compile en la cha’1‘ne
<nombre=singulier> <personne=1 >.

Pour assurer l’unicite de la representation d’une structure, on peut imposer un ordre ﬁxe entre
symboles d’une structure base sur le seul nom des traits, par exemple en utilisant l’ordre lexi-
cographique.

Si l’on conna’1‘t a l’avance l’ ensemble des traits susceptibles de venir enrichir au ﬁl des calculs
un structure de traits, on peut representer une information partielle au moyen d’une expres-
sion reguliere representant l’ensemble des traits. Par exemple, la structure [personne = 3] se
compile en (<nombre=singulier>I<nombre=pluriel>)<personne=3>. L’ interet de cette repre-
sentation vient de ce que l’uniﬁcation de structures de ce genre s’implemente par l’intersection
des expressions correspondantes. En deﬁnissant une classe de caracteres <nom=_> comme
l’union des caracteres <nom=x> representants les valeurs que peut prendre le trait nom, cette
expression peut s’ ecrire de facon equivalente <nombre=_> <personne=3>.

L’uniﬁcation n’ est pas la seule operation que l’on peut desirer realiser avec des structures de
traits. Des regles de grammaires peuvent decrire la construction d’un structure a partir d’une
ou plusieurs structures, en speciﬁant ce qui doit etre emprunte a l’une ou a l’autre au moyen de
variables. Par exemple la regle suivante decrit l’adjonction d’un sufﬁxe a une base pourvue de
la bonne categorie switaxique 2

cat cat
[nombre J —> [cat J de_cat
nombre

Le trait cat decrit la categorie symtaxique de la base (premier operande), du resultat de 1’ ad-
jonction du sufﬁxe, alors que le trait de_cat (second operande) speciﬁe la categorie syntaxique
de la base pour que la derivation soit correcte.

Une telle regle peut etre implementee par un transducteur a trois bandes, une pour chaque ope-
rande et une pour le resultat. Ce transducteur, sous certaines conditionsl, peut etre obtenu par
intersection de transducteurs implementant chacun une des variables de la regle. Si l’on suppose
que les differents rubans sont synchronises sur les valeurs des traits, cela donne 2

2 (_ 2_ 2_)*(_ 2P 2P)(_ 2_ 2_)* where P in <cat=_>

2 (_ 2_ 2_)*(_ 2C 2C)(_ 2_ 2_)* where C in <nombre=_>

2 (_ 2_ 2_)*(<cat=X> 2_ 2_)(_ 2_ 2_)*(_ 2<de_cat=X> 2_)(_ 2_ 2_)*(_ 2C 2C)(_ 2_ 2_)*

where X in dom(cat) ﬂdom(de_cat)

1L‘intersection dc transducteurs n‘est pas deﬁnie pour les transducteurs en general, mais elle l‘est pour certaines
sous-classes particuliéres.

71

Francois BARTHELEMY

Au sein d’une structure de traits, une variable peut etre utilisee pour noter le fait que plusieurs
traits partagent une meme valeur. Une telle structure est compilee en une disjonction de cha’1‘nes,
chacune d’ elle representant une des valeurs possibles de la variable.

Le technique de compilation que nous venons de voir s’etend facilement aux structures imbri-
quees acycliques. ll faut simplement remplacer la notion de nom de trait par celle de chemin.
Par exemple, la structure suivante 2 cat nom

genre masc
agf .
nombre plunel

 

se compile en <agr.genre=masc><agr.nombre=pluriel><cat=nom>. L’interet de cette imb1i-
cation est de pouvoir representer au moyen d’une seule variable l’egalite de tous les traits de la
sous-structure.

3 Presentation du formalisme

Le formalisme que nous proposons est base sur la moiphologie a partition. L’historique de ce
courant se trouve dans (Kiraz, 2001) alors que sa compilation en automate ﬁni est decrite dans
(Barthelemy, 2005). L’idee centrale consiste a deﬁnir des relations n-aires dont les differentes
cha’1‘nes sont divisees en un nombre egal de sous-cha’1‘nes. Par exemple, on peut relier une repre-
sentation ecrite et une representation phonologique de la facon suivante 2

e x em p 1 es

egsapl

Come on le voit, les sous-cha’1‘nes n1ises en correspondances peuvent etre de longueurs diffe-
rentes et eventuellement nulles.

Les relations regulieres partitionnees sont la classe de relations qu’ on peut decrire avec des ex-
pressions regulieres augmentees d’une construction nouvelle que nous appellerons tuple, per-
mettant de mettre en relation deux ou plusieurs sous-cha’1‘nes. Par exemple, l’expression regu-
liere 2 < [lettre]*, [phoneme]* >*< e, 6 > denote l’ensemble des cha’1‘nes terminees par un e
muet. Les operations comme la concatenation, la disjonction, l’etoile, peuvent intervenir aussi
bien a l’interieur d’ un tuple que sur un tuple.

Le formalisme que nous proposons autorise la description de relations n-aires et non seulement
binaires, ce qui correspond a une morphologie a n niveaux, n pouvant etre different de 2. Les
niveaux supplementaires peuvent etre utilises soit pour distinguer des facteurs independants a
un niveau donne, comme c’est le cas par exemple pour la description du Syriaque dans (Kiraz,
2000), soit pour distinguer des niveaux intermediaires dans une cascade de traitements comme
c’est le cas dans l’analyseur moiphologique de l’akkadien decrit dans (Barthelemy, 2006).

Le formalisme est fonde sur des expressions regulieres etendues pour prendre en compte les
notions de partition et de structures de traits. Les regles contextuelles sont admises en tant que
raccourcis symtaxiques denotant des expressions regulieres.

Une description comporte les sections suivantes 2 domaines des traits, types de structures de
traits, deﬁnition de l’alphabet, types des differents niveaux, types des tuples, autres types d’ex-
pressions regulieres, deﬁnition des machines ﬁnies.

72

Structures de traits typées et moiphologie a partitions

Nous allons donner en exemple une description schématique de la conjugaison des verbes fran-
cais. Nous discuterons cet exemple dans la section suivante. Les points de suspension materia-
lisent des coupures que nous avons réalisé dans1’exemp1e pour gagner de la place.

PACKAGE verbes;
FEATURES VALUES
temps: present, futur, passe, imparfait;
mode: indicatif, subjonctif, conditionnel, imperatif;
personne: 1, 2, 3;
nombre: singulier, pluriel;
conjugaison: 1, 2, 3, irreg;
END VALUES
FEATURE STRUCTURES
verbe: temps, mode, personne, nombre, conjugaison;
END STRUCTURES
ALPHABET
[lettre]: a, b, c, d
[voyelle]: a, é, a, e, e
[consonne]: b, c, d
END ALPHABET
LEVELS
1: [verbe:_];
2: [lettre]+;
3: [lettre]*;
4: [1ettre]*;
END LEVELS
TUPLES
<3| LEVEL 3: [lettre], LEVEL 4: [lettre] |3>;
<2| <3|_|3>* |2>;
<1| LEVEL 0, LEVEL 1, <2|_|2><2|_|2> |>;
END TUPLES
TYPES
<radical: LEVEL 1, LEVEL 2, LEVEL 3 > =>
<1| #1, #2, <2| /LEVEL 3: #3/ |2><2|_|2> |1>;
<suffixe: LEVEL 2, LEVEL 3 > =>
<1| _, #1, <2|_|2> <2| /LEVEL 3: #2/ |2>;
END

Les domaines de traits sont des listes de valeurs que peuvent prendre les différents traits.
D’autres domaines ﬁnis de valeurs peuvent également étre déﬁni et une meme valeur peut ap-
partenir a plusieurs domaines. Les structures de traits sont typées au moyen d’un nom de type
associé a la liste des traits de la structure. Dans la syntaxe, le nom de type appara’1‘t en début de
structure, suivi de deux points.

Chaque niveau est caractérisé par un numéro et son type est une expression réguliere déﬁnis-
sant un sur-ensemble des cha’1‘nes susceptibles d’étre lues sur ce niveau. Le type d’un tuple est
constitué de la liste ordonnée de ses niveaux, avec pour chacun d’entre eux une expression regu-
liere restreignant la sous-cha’1‘ne pouvant apparaitre sur ce niveau. Les différents tuples peuvent
différer par leur arité, les niveaux qu’i1s compoitent et leur degré d’imbrication. D’autres types
d’expressions régulieres peuvent étre déﬁnis pour faci1iter1’écriture des expressions régulieres,
par exemple en spéciﬁant un contenu sous-entendu pour certains niveaux de certains tuples.

73

Francois BARTHELEMY

Les relations regulieres sont nommees. Elles peuvent etre deﬁnies de trois manieres differentes.
La premiere forme est celle d’une expression reguliere utilisant des symboles de l’ alphabet,
des constructeurs de tuples et differentes facilites syntaxiques. Par exemple, on peut utiliser
des variables prenant leur valeur dans un ensemble ﬁni. L’ expression denotee est l’union des
expressions obtenue par substitution de la variable par une de ses valeurs. Par ailleurs, on au-
torise l’utilisation d’un joker (wildcard) note _ dans differents contextes. La projection notee
/ LEVEL x: _/ permet de ne speciﬁer que le contenu d’un niveau dans une expression qui
en comporte plusieurs. La construction REGEXP realise implicitement l’union des expressions
regulieres qu’elle contient, chacune etant terminee par un point-virgule.

REGEXP les_radicaux IS
<radical: lancer, [verbe:conjugaison=l], lanC >;
<radical: polir, [verbe:conjugaison=2], poli >;
<radical: pouvoir, [verbe:conjugaison=3], p[OU_EU]v >;

END
REGEXP terminaisons IS
<suffixe: [verbe:temps=present,mode=indicatif,
nombre=singulier,personne=l|3,conjugaison=l], e>;
<suffixe: [verbe:temps=present,mode=indicatif,
nombre=singulier,personne=l|2,conjugaison=2l3], s>;
END
LET formes=intersect(les_radicaux,terminaisons);

Le deuxieme moyen de speciﬁer une relation reguliere est par application d’ operations sur des
relations deﬁnies auparavant. Les operations comprennent les operations ensemblistes (union,
intersection, difference) et les operations rationnelles (concatenation, etoile). La projection per-
met d’ elin1iner certains niveaux. Sous certaines conditions, 1’ operation de jointure permet de
composer deux relations ayant des domaines differents.

Le demier moyen de decrire une relation reguliere est l’utilisation de regles contextuelles. Ce
sont des adaptations aux relations n-aires des regles classiques de la morphologie a deux niveau.
Les regles de coercition speciﬁent un certain motif et contraignent les valeurs que peuvent
prendre, en contexte, les sous-chaines ﬁltrees par ce motif. Par exemple, la regle suivante decrit
la realisation d’un meta-caractere C susceptible de s’ ecrire c ou c selon le contexte (comme par
exemple dans le verbe lancer, je lancais) 2

<3l C, _ |3> => <3| C, c |3>

IF _ <2| <3_|3>* XXX |2><2| <3|_, [lettre]-(iIe)|3> |2>

Le motif appara’1‘t a gauche de la ﬂeche et la restriction a droite de la ﬂeche. Le contexte est
decrit en utilisant XXX pour designer le centre de la regle, a distinguer de _, utilise ici comme
joker. Dans notre systeme multi-niveaux, il n’y a pas de distinction explicite entre niveau lexical
et niveau de surface. N’importe quel ensemble de niveaux peut etre precise dans le motif et deux
regles differentes peuvent utiliser des ensembles de niveaux differents, ce qui introduit plus de
souplesse et justiﬁe le changement de nom de coercition de surface en coercition tout court.

Une regle de restriction de contexte decrit un contexte dans lequel un motif peut exclusivement
appara1"tre (symtaxe 2 motif ONLY IF contexte). Une regle composite est un regle qui
cumule les deux contraintes de coercition et de restriction de contexte.

74

Structures de traits typees et morphologie a partitions

L’utilisation de regles contextuelles posent des problemes de conﬂits, quand deux regles sont
d’une certaine facon contradictoires. Nous ne traiterons pas de ce probleme en detail dans cet
article dont ce n’est pas l’objet. L’existence de ces conﬂits justiﬁe qu’on considere les regles
comme un ensemble et non separement. La detection des conﬂits peut etre automatisee (Beesley
& Karttunen, 2003) et leur resolution peut etre aidee par une procedure interactive.

4 Exemple avec structure de traits unique

Dans ce premier exemple, nous voulons insister sur la question du niveau abstrait d’une re-
presentation et promouvoir l’idee que la multiplicite des niveaux permet d’ offrir une reponse
adequate. Ce qu’on appelle le niveau lexical dans un systeme de morphologie a deux niveaux
traditionnel est une representation relativement concrete sur laquelle il faut appliquer quelques
transformations pour obtenir une representation de surface. 11 s’agit en fait d’une approximation
aussi precise qu’ on peut faire de la representation de surface d’un morpheme avant application
des mecanismes de derivation et/ou de ﬂexion.

Dans un systeme comme PC-Kimmo, la representation abstraite de la forme est ce qu’on appelle
la glose (gloss), une cha’1‘ne de caractere precisee dans le lexique et destinee a etre afﬁchee en
reponse a certaines requetes. Nous proposons d’inclure cette information dans un ou plusieurs
niveaux, sans exclure les deux representations classiques 2 approximation avant composition et
forme de surface.

Remi Zajac (Zajac, 1998) propose d’utiliser une structure de traits comme niveau abstrait d’un
systeme a deux niveaux. Nous allons afﬁner cette idee pour permettre une compilation en ma-
chine ﬁnie : il faut representer sous forme d’une structure de trait uniquement les traits elemen-
taires prenant leur valeur dans un ensemble ﬁni et petit et sous la forme d’une chaine utilisant
un niveau speciﬁque les informations structurees ou ayant un grand nombre de valeurs.

Dans l’exemple de la conjugaison du verbe francais, une forme abstraite doit preciser le lemme,
le temps, le mode, la personne, le nombre. Le nombre de lemmes est grand. Creer un symbole
par lemme conduit a multiplier le nombre de symboles au-dela de ce qui est couranunent accepte
par les implementations de machines ﬁnies. Le lemme sera donc note sous la forme d’une
cha’1‘ne de caractere et cela constitue le niveau 1. Les autres informations ont peu de valeurs,
on les regroupe donc dans une structure de traits qui occupe le niveau 2. Les niveaux 3 et 4
sont consacres aux representations intermediaire et de surface. Par ailleurs, pour coordonner
les lemmes et les terminaisons, il faut conna1"tre le paradigme de conjugaison utilise. Cette
information pourrait etre 1r1ise sur un niveau de service, mais pour simpliﬁer la description,
nous la placons dans la structure de traits du niveau 1.

Cet exemple illustre comment le typage permet de ne preciser que l’information pertinente pour
les radicaux et les terminaisons, tout en ayant une representation sous-jacente unique, ce qui
permet d’operer une intersection. Cette intersection realise l’uniﬁcation des structures de traits
speciﬁees dans les deux expressions regulieres, et notanunent l’identiﬁcation de leur unique
trait commun, con j ugai son. Par exemple,

<radical: lancer, [verbe : conjugaison=1] , lanc > est une notation equiva-
lente a 1’ expression :

<1 I lancer, [verbe : conjugaison=1] ,

<2 I <3 I l,_| 3><3 I a,_| 3><3|n,_| 3><3 I C,_| 3> |2><2 |_| 2> |1>.

75

Francois BARTHELEMY

Il convient ensuite de compléter la description en précisant comment relier le niveau intenné-
diaire (I1iveau 3) avec la realisation de surface (I1iveau 4).

RULE SET
<3| $L,$L |3> where $L in [lettre];
<3| C, c |3>
ONLY IF _ xxx /Level 3: (e|i) _/;
<3| s,_ |3> => <3| s,x |3>
IF <l| [verbe:temps=present,nombre=singulier,
mode=indicatif],
pouvoirlvouloir, <2|_|2><2| XXX |2> |1>;

La derniere regle illustre comment une regle contextuelle peut étre conditionnée par la valeur
des traits en utilisant simplement la notion de contexte habituelle.

5 Exemple avec plusieurs structures de traits

Nous allons prendre comme exemple une grammaire ayant une structure linéaire, décrivant une
molphologie basée exclusivement sur des sufﬁxes. Les machines ﬁnies permettent de repre-
senter plus facilement de telles structures que des arbres quelconques. Une mo1phologie basée
a la fois sur des preﬁxes et des sufﬁxes, voire des circonﬁxes, est plus difﬁcile a traiter. Ces
problemes techniques ne sont pas insurmontables, mais alourdiraient trop notre exemple. Nous
allons donc nous limiter a des sufﬁxes susceptibles de changer la catégorie symtaxique d’un mot
et donc son type de ﬂexion.

cat nom
genre fem
nombre pl

{T
[type ﬂex J

cat nom trait nombre

genre fem S

nombre sg

/\

type deriv
Cat Verbe de_cat verbe
conj 1

euse
53
|] [type racine]
mang

FIG. 1 — Exemple de structure

76

Structures de traits typees et morphologie a partitions

La ﬁgure 1 donne un exemple de structure que nous vo11lons representer, celle qui correspond
a la forme mangeuses. Dans cette structure binaire, des informations doivent etre propagees
comme par exemple le genre, qui n’est pas modiﬁe par la marque de pluriel. Les sufﬁxes de
ﬂexion modiﬁent une partie de la structure, preservant le reste, alors que les sufﬁxes de deriva-
tion bloquent la transmission d’information qui n’est plus pertinente compte tenu du change-
ment de categorie syntaxique. C’est ici le cas du paradigme de conjugaison.

Nous voyons dans cet exemple que le nombre de noeuds intemes de la structure est egal au
nombre de morphemes, ce qui permet d’utiliser le meme tuple pour decrire un morpheme et
son pere. Dans chacun de ces tuples, il y aura donc deux structure de traits 2 une associee au
seul morpheme, l’autre concemant la structure regroupant le morpheme et tous ceux qui le
precedent.

REGEXP affixes IS

<affixe: [verbe:cat=verbe,conj=l] , [racine] , mang >;

<affixe: [nom: cat=nom, genre=fem, nombre=sg] ,
[deriv:de_cat=verbe] , euse >;

<affixe: [nom:cat=nom,nombre=pl] , [flex:trait=nombre] , s >;

END

RULE SET composition IS
<affixe: _, [deriv:de_cat=$A], _ >
ONLY IF _ <affixe: [_:cat=$A], _ , _> XXX _;
<affixe: [nom:genre=$G], [flex:trait=nombre], _ >

ONLY IF <affixe: [nom:genre=$G],_,_> XXX _;

La derivation peut etre traitee au moyen d’une regle contextuelle unique qui veriﬁe que la base
possede la categorie switaxique requise. Pour la ﬂexion, en revanche, il faut une regle pour
chaque type de sufﬁxe, car les traits propages et les traits revises ne sont pas les memes.

Les deux regles regles donnees en exemple illustrent comment les differentes structures de traits
interagissent et notannnent comment certains traits en sont uniﬁes. Elles pourraient aussi bien
s’exprimer sous forme de regle de grarmnaires de traits. Par exemple la seconde 2

 

nom ﬂex
nom

genre —> nombre
genre .

nombre trait nombre

6 Conclusion

Dans cet a11'.icle, nous montrons comment l’utilisation sim11ltanee de deux techniques preexis-
tantes, a savoir la compilation de structure de traits en chaines de caracteres et la morphologie
a pa11'.ition, offre un pouvoir de description interessant.

Il n’y a bien sﬁr aucune augmentation de puissance du formalisme. ll s’ agit de facilite d’ecri-
ture 2 les structures de traits sont pratiques parce qu’ on ne precise que l’information connue et
que l’ordre des traits n’ est pas signiﬁcatif. De plus ce fonnalisme est familier aux personnes
travaillant dans le TAL.

77

Francois BARTHELEMY

La technique que nous proposons offre un risque d’ explosion de la taille des machines. Ce risque
est important si l’on multiplie les traits, les valeurs et surtout les uniﬁcations entre structures
éloignées. Notre expérience montre que ce risque n’est pas rédhibitoire. Nous avons réalisé un
prototype qui compile une description symtaxique en un automate ﬁni, en utilisant la bo’1‘te a
outils FSM (Mohri et al., 2002). Nous avons écrit des grarmnaires relativement grosses (~ 50
regles) sans provoquer d’ explosion incontrolée (Barthélemy, 2006).

L’ outil de Xerox (xfst) offre une possibilité intéressante pour éviter l’explosion combinatoire 2
elle consiste a choisir entre un calcul statique ou dymamique pour les valeurs de traits. Dans
le cas d’un calcul dynamique, ce ne sont pas les seules valeurs de traits qui sont représentées
sous forme de symboles dans les machines, mais les calculs a réaliser sur ces traits lors d’une
évaluation de gauche a droite. A priori, il semble possible d’adapter cette technique a notre
forrrralisme.

Notre proposition permet une utilisation plus générale des traits que les travaux antérieurs pro-
posant une compilation en machine ﬁnie. Par rapport a (Zajac, 1998), (Amtrup, 2003), l’apport
principal est la notion de portée d’une structure qui peut étre locale a un tuple, ce qui autorise la
multiplicité de structures ayant certains traits communs dont les valeurs sont indépendantes. Les
interactions entre structures de traits sont plus riche que dans (Kiraz, 1997). Par rapport aux ap-
proches qui proposent une évaluation dymamique des structures de traits, les gains proviennent
d’une meilleure intégration avec les calculs d’ autonrates (par exemple, calcul d’intersection)
ainsi qu’une plus grande efﬁcacité.

Références

AMTRUP J. W. (2003). Feature structures as weights in ﬁnite state morphology. In FSMNLP,
Budapest, Hongrie.

ANTWORTH E. L. (1995). User’s guide to pc-kimmo version 2.

BARTHELEMY F. (2005). Partitioning multitape transducers. In International Workshop on
Finite State Methods in Natural language Processing (FSMNLP), Helsinki, Finlande.

BARTHELEMY F. (2006). Un analyseur morphologique utilisant la jointure. In In Traitement
Automatique de la Iangue Naturelle (TALN’06), Leuven, Belgique.

BEESLEY K. R. & KARTTUNEN L. (2003). Finite State Morphology. CSLI Publications.

KIRAZ G. A. (1997). Compiling regular formalisms with rule features into ﬁnite-state auto-
mata. In ACL, Madrid, Espagne.

KIRAZ G. A. (2000). Multitiered nonlinear morphology using multitape ﬁnite automata 2 a
case study on syriac and arabic. Computational Linguistics, 26(1), 77-105.

KIRAZ G. A. (2001). Computational Nonlinear Morphology. Cambridge University Press.

MOHRI M., PEREIRA F. C. N. & RILEY M. (2002). Weighted ﬁnite-state transducers in
speech recognition. Computer Speech and Language, 16(1), 69-88.

PETITPIERRE D. & RUSSEL G. (1995). Mmorph 2 the multex morphology program.

ZAJAC R. (1998). Feature structures, uniﬁcation and ﬁnite-state transducers. In FSMNLP’98,
Ankara, Turquie.

78

