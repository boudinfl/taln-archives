<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Alignements monolingues avec d&#233;placements</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2007, Toulouse, 5&#8211;8 juin 2007
</p>
<p>Alignements monolingues avec d&#233;placements
</p>
<p>Julien BOURDAILLET, Jean-Gabriel GANASCIA
Laboratoire d&#8217;Informatique de Paris 6
</p>
<p>Universit&#233; Pierre et Marie Curie, 104 Quai Kennedy, 75016 Paris
{julien.bourdaillet,jean-gabriel.ganascia}@lip6.fr
</p>
<p>R&#233;sum&#233;. Ce travail pr&#233;sente une application d&#8217;alignement monolingue qui r&#233;pond &#224; une
probl&#233;matique pos&#233;e par la critique g&#233;n&#233;tique textuelle, une &#233;cole d&#8217;&#233;tudes litt&#233;raires qui s&#8217;in-
t&#233;resse &#224; la gen&#232;se textuelle en comparant les diff&#233;rentes versions d&#8217;une oeuvre. Ceci n&#233;cessite
l&#8217;identification des d&#233;placements, cependant, le probl&#232;me devient ainsi NP-complet. Notre algo-
rithme heuristique est bas&#233; sur la reconnaissance des homologies entre s&#233;quences de caract&#232;res.
Nous pr&#233;sentons une validation exp&#233;rimentale et montrons que notre logiciel obtient de bons
r&#233;sultats ; il permet notamment l&#8217;alignement de livres entiers.
Abstract. This paper presents a monolingual alignment application that addresses a pro-
blem which occurs in textual genetic criticism, a humanities discipline of literary studies which
compares texts&#8217; versions to understand texts&#8217; genesis. It requires the move detection, but this
characteristic makes the problem NP-complete. Our heuristic algorithm is based on pattern mat-
ching in character sequences. We present an experimental validation where we show that our
application obtains good results ; in particular it enables whole book alignment.
Mots-cl&#233;s : alignement monolingue, distance d&#8217;&#233;dition avec d&#233;placements, critique g&#233;-
n&#233;tique textuelle.
</p>
<p>Keywords: monolingual alignment, edit distance with moves, textual genetic criticism.
</p>
<p>1 Introduction
L&#8217;alignement textuel monolingue consiste &#224; comparer deux textes plus ou moins proches afin
d&#8217;identifier leurs similitudes et leurs dissemblances ; ou plus pr&#233;cis&#233;ment, &#224; rechercher les par-
ties communes &#224; ces deux textes et les parties propres &#224; chaque texte. Les premiers travaux d&#8217;ali-
gnements automatique peuvent &#234;tre attribu&#233;s &#224; (Levenshtein, 1966) qui a introduit la distance
d&#8217;&#233;dition : le nombre minimum d&#8217;op&#233;rations d&#8217;&#233;dition (insertions, suppressions et remplace-
ments) permettant de transformer un texte en un autre. Par la suite, cette approche consid&#233;rant
les textes comme deux s&#233;quences de caract&#232;res a &#233;t&#233; beaucoup &#233;tudi&#233;e en informatique th&#233;o-
rique, voir (Bergroth et al., 2000) pour une synth&#232;se r&#233;cente, et appliqu&#233;e o&#249; des programmes
de comparaison de code source comme Diff ont &#233;t&#233; d&#233;velopp&#233;s.
Ces m&#233;thodes d&#8217;alignement de code source, &#224; savoir des langages formels et structur&#233;s, ont
ensuite &#233;t&#233; naturellement adapt&#233;es pour comparer les textes en langage naturel. Dans les lan-
gages formels, on a g&#233;n&#233;ralement une seule instruction par ligne ; ainsi entre deux versions
d&#8217;un fichier, il est relativement simple d&#8217;identifier les modifications. Par contre, dans les textes
</p>
<p>303</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Julien BOURDAILLET, Jean-Gabriel GANASCIA
</p>
<p>en langage naturel, une unit&#233; entre ligne et phrase n&#8217;a pas de raison d&#8217;&#234;tre, si l&#8217;on s&#8217;en tient au
texte et que l&#8217;on omet les questions de mise en page li&#233;es au support. Et il se trouve en effet que
les logiciels d&#8217;alignement existants pr&#233;sentent de mauvais r&#233;sultats pour les textes en langage
naturel, comme nous l&#8217;avons montr&#233; dans (Bourdaillet &amp; Ganascia, 2006).
En Traduction Automatique, il existe une litt&#233;rature importante sur l&#8217;alignement bilingue de
textes qui sont g&#233;n&#233;ralement la traduction de l&#8217;un dans l&#8217;autre (bitexte). Ces alignements sont
relatifs &#224; des structures de haut niveau, &#224; savoir paragraphes, phrases et plus difficilement mots
(Chiao et al., 2006). Nous pr&#233;sentons ici un algorithme d&#8217;alignement monolingue au niveau des
caract&#232;res, entre textes pouvant &#234;tre tr&#232;s diff&#233;rents l&#8217;un de l&#8217;autre puisqu&#8217;ils peuvent comporter
des insertions, suppressions, remplacements et m&#234;me d&#233;placements. Notre algorithme est plus
proche de ceux utilis&#233;s en biologie mol&#233;culaire tels que (Bray et al., 2003), mais n&#233;anmoins il
induit un alignement aux niveaux sup&#233;rieurs.
C&#8217;est l&#8217;&#233;tude des processus de r&#233;&#233;criture, dans le cadre d&#8217;un travail commun avec l&#8217;Institut des
Textes et Manuscrits Modernes (ITEM), qui nous a amen&#233;e &#224; &#233;tudier l&#8217;alignement monolingue.
C&#8217;est dans ce laboratoire qu&#8217;est n&#233;e la critique g&#233;n&#233;tique textuelle (de Biasi, 2000), une &#233;cole
d&#8217;&#233;tudes litt&#233;raires &#233;tudiant la gen&#232;se des oeuvres litt&#233;raires &#224; travers les diff&#233;rents &#233;tats d&#8217;un
texte laiss&#233;s par un &#233;crivain. Ces diff&#233;rentes versions, c&#8217;est-&#224;-dire les brouillons successifs, sont
annot&#233;es par l&#8217;auteur qui corrige une faute d&#8217;orthographe, affine son vocabulaire ou encore
soigne son style en d&#233;pla&#231;ant un terme. D&#8217;un point de vue computationnel, les trois op&#233;rateurs
classiques de la distance d&#8217;&#233;dition ne sont pas suffisants pour caract&#233;riser ces r&#233;&#233;critures ; il
est n&#233;cessaire d&#8217;introduire un op&#233;rateur de d&#233;placement d&#8217;un bloc de caract&#232;res d&#8217;une position
dans le premier texte vers une position diff&#233;rente dans le second. Cette mod&#233;lisation correspond
&#224; la notion de distance d&#8217;&#233;dition avec d&#233;placements.
Les g&#233;n&#233;ticiens du texte ont red&#233;couvert empiriquement cette notion, mais celle-ci avait &#233;t&#233;
introduite auparavant en informatique par (Tichy, 1984). (Lopresti &amp; Tomkins, 1997) ont &#233;tendu
la notion en introduisant plusieurs mod&#232;les de distance d&#8217;&#233;dition par blocs. (Shapira &amp; Storer,
2002) ont prouv&#233; que le calcul de la distance d&#8217;&#233;dition avec d&#233;placements entre deux textes
est un probl&#232;me NP-complet ; il n&#8217;existe donc pas actuellement d&#8217;algorithme le r&#233;solvant en un
temps polynomial et ils ont propos&#233; un algorithme heuristique glouton pour ce calcul.
L&#8217;automatisation de ce travail de comparaison textuelle n&#233;cessaire &#224; la critique g&#233;n&#233;tique s&#8217;av&#232;re
donc &#234;tre un probl&#232;me difficile. Dans la section 2 nous pr&#233;sentons l&#8217;algorithme de notre logi-
ciel, appel&#233; MEDITE1, traitant ce probl&#232;me. Dans un pr&#233;c&#233;dent travail, nous avions montr&#233;
son utilit&#233; pour la critique g&#233;n&#233;tique (Ganascia &amp; Bourdaillet, 2006). Nous montrons ici que
l&#8217;algorithme glouton de (Shapira &amp; Storer, 2002) ne permet pas de mod&#233;liser correctement ce
probl&#232;me et que MEDITE supporte maintenant le passage &#224; l&#8217;&#233;chelle en permettant d&#8217;aligner
diff&#233;rentes versions d&#8217;un livre entier (section 3).
L&#8217;alignement d&#8217;ouvrages complets est une probl&#233;matique r&#233;cente n&#233;e de l&#8217;essor des projets de
num&#233;risation de livres &#224; grande &#233;chelle, comme le &#8220;Million Book Project&#8221; ou celui de Google
(Feng &amp; Manmatha, 2006). De plus, la taille des textes rapproche ce probl&#232;me de l&#8217;alignement
des s&#233;quences d&#8217;acides nucl&#233;iques en bioinformatique (Gusfield, 1997). N&#233;anmoins la prise en
compte des d&#233;placements n&#8217;a pas ou peu &#233;t&#233; trait&#233;e dans ces deux domaines.
Nous pouvons maintenant formuler le probl&#232;me de mani&#232;re plus pr&#233;cise. Il consiste &#224; aligner
deux textes en langage naturel A et B. Ceux-ci peuvent &#234;tre vus comme des s&#233;quences de
caract&#232;res de tailles respectives m et n, telles que A = a1, a2, ..., am = [ai]1&#8804;i&#8804;m et B =
</p>
<p>1librement t&#233;l&#233;chargeable en ligne : http://www-poleia.lip6.fr/~ganascia/medite
304</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Alignements monolingues avec d&#233;placements
</p>
<p>b1, b2, ..., bn = [bj]1&#8804;j&#8804;n et d&#233;finies sur un alphabet &#931; de taille finie.
Nous d&#233;finissons la notion de paire de blocs (ou bi-bloc) par un tuplet (p, lA, q, lB) avec &#8722;1 &#8804;
p &#8804; |A| = m, 0 &#8804; lA &#8804; m et&#8722;1 &#8804; q &#8804; |B| = n, 0 &#8804; lB &#8804; n. Cela signifie qu&#8217;une sous-chaine
A[p..p+ lA &#8722; 1] de la premi&#232;re s&#233;quence est en relation avec une sous-chaine B[q..q + lB &#8722; 1]
de la seconde s&#233;quence.
Finalement, nous d&#233;finissons un alignement A(A,B) entre deux s&#233;quences A et B comme un
tuplet tel que A(A,B) = (INV, SUP, INS,REMP,DEP ) avec INV, SUP, INS, REMP
et DEP les ensembles de bi-blocs respectivement invariants, supprim&#233;s, ins&#233;r&#233;s, remplac&#233;s et
d&#233;plac&#233;s constituant cet alignement. Ainsi, le type de relation entre les sous-chaines constituant
un bi-bloc est d&#233;fini par l&#8217;ensemble auquel le bi-bloc appartient dans A(A,B). Les invariants,
remplacements et d&#233;placements sont des appariements de blocs effectivement pr&#233;sents dans A
et B, alors que les suppressions et insertions sont des pseudo-appariements avec un bloc vide.
Pour ce faire, un bloc ayant p ou q &#233;gal &#224; &#8722;1 repr&#233;sente respectivement une insertion ou une
suppression ; dans ce cas lA ou lB valent respectivement 0, ce qui correspond &#224; un bloc vide.
</p>
<p>2 Algorithme
</p>
<p>Notre algorithme se d&#233;compose en cinq &#233;tapes.
La premi&#232;re &#233;tape est un pr&#233;-traitement qui per-
met d&#8217;&#233;tablir des classes d&#8217;&#233;quivalence entre ca-
ract&#232;res. La seconde &#233;tape identifie les blocs de
caract&#232;res r&#233;p&#233;t&#233;s entre A et B. La troisi&#232;me
&#233;tape aligne ces blocs r&#233;p&#233;t&#233;s afin de d&#233;termi-
ner lesquels sont invariants et lesquels sont d&#233;-
plac&#233;s. La quatri&#232;me &#233;tape consiste &#224; r&#233;p&#233;ter les
&#233;tapes 2 et 3 sur les sous-s&#233;quences situ&#233;es entre
les blocs align&#233;s lors de l&#8217;&#233;tape 3. La derni&#232;re
&#233;tape est la d&#233;duction des insertions, suppres-
sions et d&#233;placements. La figure 1 pr&#233;sente cet
algorithme.
</p>
<p>Identification des blocs r&#233;p&#233;t&#233;s
</p>
<p>Pr&#233;!traitement
</p>
<p>Etape r&#233;cursive
</p>
<p>D&#233;duction des blocs non r&#233;p&#233;t&#233;s
</p>
<p>Identification des invariants
et des d&#233;placements
</p>
<p>FIG. 1 &#8211; Algorithme de MEDITE
</p>
<p>2.1 Pr&#233;-traitement
Un pr&#233;-traitement optionnel peut &#234;tre appliqu&#233; aux s&#233;quences A et B. En langage naturel, il
existe des caract&#232;res que l&#8217;on peut vouloir consid&#233;rer comme &#233;quivalents : les caract&#232;res iden-
tiques mais avec une casse diff&#233;rente, par exemple &#8220;J&#8221; et &#8220;j&#8221; ; les caract&#232;res avec ou sans signe
diacritique, par exemple &#8220;&#231;&#8221; et &#8220;c&#8221; ; ou encore les s&#233;parateurs, par exemple &#8220; ?&#8221; et &#8220; !&#8221;. Pour cela
les majuscules sont converties en minuscules, les caract&#232;res avec diacritique en leur &#233;quivalent
sans diacritique, et tous les signes de ponctuation en un m&#234;me signe, &#224; savoir le caract&#232;re point.
Ce pr&#233;-traitement peut &#234;tre appliqu&#233; sur A et B en un temps lin&#233;aire. Ainsi, lors des &#233;tapes
ult&#233;rieures de l&#8217;algorithme, des blocs identiques modulo les classes d&#8217;&#233;quivalence pourront &#234;tre
</p>
<p>305</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Julien BOURDAILLET, Jean-Gabriel GANASCIA
</p>
<p>appari&#233;s m&#234;me si ces blocs sont diff&#233;rents dans A et B, et ceci pour un co&#251;t computationnel
faible.
Pour illustrer l&#8217;algorithme, nous utilisons l&#8217;exemple suivant o&#249; nous cherchons &#224; aligner ces
deux courts textes : &#8220;Ce matin le chat observa de petits oiseaux dans les arbres.&#8221; et &#8220;Le chat &#233;tait
en train d&#8217;observer des oiseaux dans les petits arbres ce matin. Il observa les oiseaux pendant
deux heures.&#8221; Apr&#232;s pr&#233;-traitement, les phrases deviennent : &#8220;ce.matin.le.chat.observa.de.petits.
oiseaux.dans.les.arbres.&#8221; et &#8220;le.chat.&#233;tait.en.train.d.observer.des.oiseaux.dans.les.petits.arbres.
ce.matin.il.observa.les.oiseaux.pendant.deux.heures.&#8221;
</p>
<p>2.2 Identification des blocs r&#233;p&#233;t&#233;s
L&#8217;identification des blocs de caract&#232;res r&#233;p&#233;t&#233;s, c&#8217;est-&#224;-dire pr&#233;sents dans les deux textes, est
effectu&#233;e en construisant un arbre des suffixes g&#233;n&#233;ralis&#233; entre A et B (Ukkonen, 1995). Cette
structure de donn&#233;es permet en effet d&#8217;identifier l&#8217;ensemble des blocs r&#233;p&#233;t&#233;s entre A et B
en un temps lin&#233;aire. Toutefois la taille de cet ensemble de blocs est exponentielle et seul un
sous-ensemble est int&#233;ressant, celui des appariements exacts super-maximaux (Gusfield, 1997).
Un bi-bloc (p, lA, q, lB) est un appariement exact super-maximal si et seulement si :
&#8211; A[p..p+ lA &#8722; 1] = B[q..q + lA &#8722; 1] (appariement exact) ;
&#8211; A[p&#8722; 1] &quot;= B[q &#8722; 1] et A[p+ lA] &quot;= B[q + lB] (maximalit&#233;) ;
&#8211; et ni A[p..p + lA &#8722; 1] ni B[q..q + lB &#8722; 1] ne sont inclus dans un autre appariement exact
</p>
<p>maximal (super-maximalit&#233;).
Cette d&#233;finition n&#8217;emp&#234;che pas les chevauchements entre appariements exacts super-maximaux
(bien que les inclusions le soient). Ces chevauchements peuvent &#234;tre r&#233;solus heuristiquement en
les scindant sur les s&#233;parateurs, en effet il est pr&#233;f&#233;rable d&#8217;avoir des coupures entre les mots plu-
t&#244;t qu&#8217;&#224; l&#8217;int&#233;rieur dans les s&#233;quences en langage naturel. Le r&#233;sultat de cette seconde &#233;tape se
pr&#233;sente sous la forme de deux listes A&#8242; et B&#8242; de blocs (des s&#233;quences A et B) qui ont &#233;t&#233; iden-
tifi&#233;s comme faisant partie de l&#8217;ensemble des bi-blocs super-maximaux et non-chevauchants.
Dans l&#8217;exemple, avant la r&#233;solution des chevauchements, les blocs super-maximaux &#8220;s.arbres.&#8221;
chevauchent les blocs &#8220;oiseaux.dans.les.&#8221; et &#8220;petits.&#8221; ; la c&#233;sure sur le s&#233;parateur permet de
r&#233;soudre le conflit. Finalement, apr&#232;s la seconde &#233;tape, les blocs super-maximaux non-chevau-
chants suivants sont identifi&#233;s : &#8220;
</p>
<p>!
&quot;
</p>
<p>#
$ce.matin.
!
&quot;
</p>
<p>#
$le.chat.
!
&quot;
</p>
<p>#
$observa. de.
</p>
<p>!
&quot;
</p>
<p>#
$petits.
!
&quot;
</p>
<p>#
$oiseaux.dans.les.!
</p>
<p>&quot;
#
$arbres. &#8221; et &#8220;
</p>
<p>!
&quot;
</p>
<p>#
$le.chat. &#233;tait.en.train.d.observer.des.
</p>
<p>!
&quot;
</p>
<p>#
$oiseaux.dans.les.
!
&quot;
</p>
<p>#
$petits.
!
&quot;
</p>
<p>#
$arbres.!
</p>
<p>&quot;
#
$ce. matin. il.
</p>
<p>!
&quot;
</p>
<p>#
$observa. les.oiseaux. pendant.deux.heures.&#8221;. Le mot &#8220;oiseaux&#8221; est r&#233;p&#233;t&#233; trois
</p>
<p>fois mais n&#8217;apparait pas dans la liste des blocs super-maximaux car les deux premi&#232;res occur-
rences sont incluses dans des blocs plus longs qui eux sont super-maximaux.
</p>
<p>2.3 Identification des blocs invariants et d&#233;plac&#233;s
Les blocs invariants sont ceux qui apparaissent &#224; la m&#234;me position dans A et B, et les d&#233;plac&#233;s
ceux dont la position a chang&#233;. Or chacun des blocs super-maximaux identifi&#233;s lors de l&#8217;&#233;tape
pr&#233;c&#233;dente peut &#234;tre soit un bloc invariant, soit un bloc d&#233;plac&#233;. En effet, lorsque deux blocs sont
permut&#233;s, on peut &#233;tablir que l&#8217;un est invariant et l&#8217;autre d&#233;plac&#233; ou vice-versa, et il n&#8217;existe pas
de variable permettant de prendre la bonne d&#233;cision de fa&#231;on certaine. N&#233;anmoins nous pouvons
utiliser le crit&#232;re heuristique suivant : entre une telle paire de blocs, le plus long sera consid&#233;r&#233;
</p>
<p>306</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Alignements monolingues avec d&#233;placements
</p>
<p>comme invariant et l&#8217;autre comme d&#233;plac&#233;.
La m&#233;thode exhaustive permettant de prendre l&#8217;ensemble de ces d&#233;cisions pour tous les blocs
consiste &#224; parcourir l&#8217;espace des alignements possibles afin de trouver l&#8217;optimum suivant une
certaine fonction de co&#251;t. Or la taille de cet espace est combinatoire, ce qui rend cette recherche
peu op&#233;rationnelle. C&#8217;est pourquoi nous utilisons l&#8217;algorithme de type A* suivant.
Les alignements possibles sont &#233;valu&#233;s &#224; l&#8217;aide d&#8217;une fonction de co&#251;t c ; l&#8217;objectif est de trou-
ver un alignement de co&#251;t minimal. Ceci est &#233;quivalent &#224; un probl&#232;me de plus court chemin
dans un graphe o&#249; l&#8217;&#233;tat final correspond &#224; l&#8217;alignement de co&#251;t minimal et l&#8217;&#233;tat initial &#224; l&#8217;&#233;tat
o&#249; aucune d&#233;cision n&#8217;a encore &#233;t&#233; prise. A chaque &#233;tape de l&#8217;algorithme, une d&#233;cision est prise
en choisissant de d&#233;signer l&#8217;appariement d&#8217;un bloc A&#8242;i avec un bloc B&#8242;j comme &#233;tant un bi-bloc
invariant. Ce choix est conduit gr&#226;ce &#224; la fonction de co&#251;t c qui estime le co&#251;t de l&#8217;alignement
final induit par ce choix. Lorsque l&#8217;&#233;tat final est atteint, c&#8217;est-&#224;-dire lorsque l&#8217;on ne peut plus
choisir de bloc invariant, tous les blocs qui n&#8217;ont pas &#233;t&#233; choisis durant le parcours sont consid&#233;-
r&#233;s comme des blocs d&#233;plac&#233;s. Afin d&#8217;atteindre l&#8217;&#233;tat final, c doit &#234;tre admissible, c&#8217;est-&#224;-dire ne
jamais surestimer le co&#251;t de l&#8217;alignement ; nous d&#233;taillons ci-dessous pourquoi c est admissible.
L&#8217;&#233;valuation du co&#251;t de l&#8217;alignement induit par le choix de l&#8217;appariement deA&#8242;i etB&#8242;j est calcul&#233;
par la fonction c(i, j). Celle-ci d&#233;compose ce co&#251;t en un co&#251;t g(i, j) de l&#8217;alignement effectu&#233;
lors des &#233;tapes pr&#233;c&#233;dentes, et une estimation heuristique h(i, j) du co&#251;t de l&#8217;alignement qu&#8217;il
reste &#224; effectuer durant les &#233;tapes ult&#233;rieures, tel que c(i, j) = g(i, j) + h(i, j). Ces co&#251;ts sont
calcul&#233;s de la fa&#231;on suivante :
&#8211; NA(i, j) = non&#8722;apparie&#769;s(A&#8242;[1..i &#8722; 1], B&#8242;[1..j &#8722; 1]) est l&#8217;ensemble des blocs non appa-
</p>
<p>ri&#233;s durant les &#233;tapes pr&#233;c&#233;dentes, ceux qui n&#8217;ont pas &#233;t&#233; choisis comme invariants et seront
consid&#233;r&#233;s comme d&#233;plac&#233;s.
</p>
<p>&#8211; g(i, j) = &#8721;b&#8712;NA(i,j) |b| est la somme de la taille des blocs pr&#233;c&#233;demment non choisis comme
&#233;tant invariants, c&#8217;est-&#224;-dire que seuls les d&#233;placements vont p&#233;naliser le co&#251;t d&#8217;un aligne-
ment.
</p>
<p>&#8211; DS(i, j) = A&#8242;[i+ 1..|A&#8242;|]&quot;B&#8242;[j + 1..|B&#8242;|] est la diff&#233;rence sym&#233;trique des deux ensembles
de blocs &#224; aligner durant les &#233;tapes suivantes. Ces blocs sont pr&#233;sents soit uniquement dans
A&#8242;[i+1..|A&#8242;|] soit uniquement dansB&#8242;[j+1..|B&#8242;|], il ne sera donc pas possible de les apparier
ult&#233;rieurement.
</p>
<p>&#8211; h(i, j) = &#8721;b&#8712;DS(i,j) |b| est la somme de la taille des blocs de DS(i, j). h(i, j) est la borne
inf&#233;rieure du co&#251;t des blocs restant &#224; aligner. h ne surestime jamais le co&#251;t de l&#8217;alignement,
c&#8217;est pourquoi c est admissible et A* trouve l&#8217;alignement optimal au sens de notre crit&#232;re.
</p>
<p>Ce calcul permet de rechercher un alignement optimal au sens de la maximisation de la taille
des blocs invariants et de la minimisation de la taille des blocs d&#233;plac&#233;s.
Dans notre exemple, apr&#232;s cette &#233;tape, les blocs encadr&#233;s en gras d&#233;signent les invariants
et les autres blocs encadr&#233;s les d&#233;placements : &#8220;
</p>
<p>!
&quot;
</p>
<p>#
$ce.matin.
!
&quot;
</p>
<p>#
$le.chat.
!
&quot;
</p>
<p>#
$observa. de.
</p>
<p>!
&quot;
</p>
<p>#
$petits.!
</p>
<p>&quot;
#
$oiseaux.dans.les.
!
&quot;
</p>
<p>#
$arbres. &#8221; et &#8220;
</p>
<p>!
&quot;
</p>
<p>#
$le.chat. &#233;tait.en.train.d.observer.des.
</p>
<p>!
&quot;
</p>
<p>#
$oiseaux.dans.les.!
</p>
<p>&quot;
#
$petits.
!
&quot;
</p>
<p>#
$arbres.
!
&quot;
</p>
<p>#
$ce. matin. il.
</p>
<p>!
&quot;
</p>
<p>#
$observa. les.oiseaux. pendant.deux.heures.&#8221;.
</p>
<p>2.4 Recherche r&#233;cursive d&#8217;appariements
Lors de cette quatri&#232;me &#233;tape, on consid&#232;re chaque sous-chaine de A et B situ&#233;e entre deux
bi-blocs invariants. Ces sous-chaines sont examin&#233;es &#224; nouveau par les &#233;tapes 2 et 3 afin de
d&#233;couvrir d&#8217;&#233;ventuels nouveaux bi-blocs invariants, auquel cas ceux-ci sont ensuite inclus dans
</p>
<p>307</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Julien BOURDAILLET, Jean-Gabriel GANASCIA
</p>
<p>l&#8217;alignement principal. Cette &#233;tape r&#233;cursive permet de r&#233;pondre aux effets de masquage qui
se produisent lorsque les s&#233;quences A et B comportent un nombre important de sous-chaines
r&#233;p&#233;t&#233;es : dans ces cas l&#224;, les algorithmes classiques d&#8217;alignement omettent des appariements
importants qui sont masqu&#233;s par des appariements moins importants (Ganascia &amp; Bourdaillet,
2006). De tels ph&#233;nom&#232;nes ont &#233;galement &#233;t&#233; identifi&#233;s dans les s&#233;quences d&#8217;acides nucl&#233;iques
en biologie mol&#233;culaire (Arslan et al., 2001).
Dans notre exemple, entre les bi-blocs invariants &#8220;le.chat.&#8221; et &#8220;oiseaux.dans.les.&#8221; se trouvent
les sous-chaines &#8220;observa.de.petits.&#8221; et &#8220;&#233;tait.en.train.d.observer.des.&#8221;. L&#8217;&#233;tape r&#233;cursive va per-
mettre d&#8217;identifier le bi-bloc &#8220;observ&#8221; comme invariant, ce qui donne l&#8217;alignement final sui-
vant : &#8220;
</p>
<p>!
&quot;
</p>
<p>#
$ce.matin.
!
&quot;
</p>
<p>#
$le.chat.
!
&quot;
</p>
<p>#
$observ a.de.
</p>
<p>!
&quot;
</p>
<p>#
$petits.
!
&quot;
</p>
<p>#
$oiseaux.dans.les.
!
&quot;
</p>
<p>#
$arbres. &#8221; et &#8220;
</p>
<p>!
&quot;
</p>
<p>#
$le.chat.
</p>
<p>&#233;tait.en.train.d.
!
&quot;
</p>
<p>#
$observ er.des.
</p>
<p>!
&quot;
</p>
<p>#
$oiseaux.dans.les.
!
&quot;
</p>
<p>#
$petits.
!
&quot;
</p>
<p>#
$arbres.
!
&quot;
</p>
<p>#
$ce. matin. il.observa.les.
</p>
<p>oiseaux.pendant.deux.heures.&#8221;. Ainsi, un bi-bloc d&#233;plac&#233; a &#233;t&#233; perdu (&#8220;observa.&#8221;) mais un bi-
bloc invariant a &#233;t&#233; gagn&#233; (&#8220;observ&#8221;) ; ceci permet de favoriser les appariements locaux au
d&#233;triment des appariements longue-distance et les invariants plut&#244;t que les d&#233;placements.
</p>
<p>2.5 D&#233;duction des autres types de blocs
Les insertions, suppressions et remplacements peuvent finalement &#234;tre d&#233;duits des &#233;tapes pr&#233;-
c&#233;dentes. En effet, les suppressions sont les blocs non r&#233;p&#233;t&#233;s et pr&#233;sents uniquement dans A,
et les insertions ceux pr&#233;sents uniquement dans B.
L&#8217;identification des remplacements se fait de mani&#232;re heuristique : lorsqu&#8217;entre deux bi-blocs
invariants se trouve un bloc supprim&#233; s dans A et un bloc ins&#233;r&#233; i dans B et que le ratio entre
leur taille |s|/|i| atteint un certain seuil t, alors ces blocs sont retir&#233;s des ensembles SUP et
INS (cf. section 1), et appari&#233;s en un bi-bloc r plac&#233; dans REMP , signifiant ainsi que le bloc
dans A a &#233;t&#233; remplac&#233; par le bloc dans B. Le seuil t est fix&#233; par d&#233;faut &#224; 0, 5.
Dans l&#8217;exemple, le bi-bloc constitu&#233; des chaines &#8220;a.de.&#8221; et &#8220;er.des.&#8221; sera consid&#233;r&#233; comme un
remplacement et les deux autres blocs non encadr&#233;s de la seconde s&#233;quence comme des inser-
tions.
Finalement, un post-traitement permet de retrouver les positions des blocs dans les s&#233;quences
originales (c&#8217;est-&#224;-dire sans les classes d&#8217;&#233;quivalence).
</p>
<p>3 Validation exp&#233;rimentale
</p>
<p>3.1 Application &#224; la critique g&#233;n&#233;tique textuelle
Cette exp&#233;rience consiste &#224; aligner deux versions d&#8217;un m&#234;me texte et &#233;valuer l&#8217;alignement r&#233;-
sultant. Pour ce faire, nous allons comparer les r&#233;sultats de MEDITE &#224; ceux de GREEDY qui
est un algorithme glouton de calcul de la distance d&#8217;&#233;dition avec d&#233;placements (Shapira &amp; Sto-
rer, 2002). Ce dernier s&#233;lectionne &#224; chaque it&#233;ration le plus grand appariement qu&#8217;il consid&#232;re
comme un d&#233;placement et finalement calcule une distance d&#8217;&#233;dition classique par programma-
tion dynamique.
L&#8217;&#233;valuation des alignements r&#233;sultants se fait en calculant les fonctions de score suivantes &#224;
partir d&#8217;un alignement A(A,B) :
</p>
<p>308</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Alignements monolingues avec d&#233;placements
</p>
<p>&#8211; Nous d&#233;finissons au pr&#233;alable une fonction somme(S) = &#8721;(p,lA,q,lB)&#8712;S lA+ lB qui somme la
taille de tous les bi-blocs d&#8217;un ensemble de bi-blocs S.
</p>
<p>&#8211; On cherche &#224; maximiser la somme de la taille des blocs invariants et &#224; minimiser la somme
de la taille des autres types de bloc, d&#8217;o&#249; la fonction :
</p>
<p>x =
</p>
<p>(
1 +
</p>
<p>somme(INV )&#8722;
&#8721;
</p>
<p>s&#8712;S somme(s)
</p>
<p>|A|+ |B|
</p>
<p>)
/2 (1)
</p>
<p>avec S = {SUP, INS,REMP,DEP}
</p>
<p>&#8211; On cherche &#224; maximiser la taille moyenne des blocs afin d&#8217;&#233;viter la fragmentation de l&#8217;ali-
gnement :
</p>
<p>y =
</p>
<p>(&#8721;
s&#8712;S
</p>
<p>(
somme(s)
</p>
<p>|s|
</p>
<p>)
/max(s)
</p>
<p>)
/5 (2)
</p>
<p>avec S = {INV, SUP, INS,REMP,DEP},
|s| le nombre de blocs dans s
et max(s) la taille du plus grand bloc de s
</p>
<p>&#8211; On cherche &#224; maximiser le ratio des d&#233;placements par rapport aux autres blocs non-invariants
et le ratio des remplacements par rapport aux autres blocs non-invariants (sauf les d&#233;place-
ments) :
</p>
<p>z =
</p>
<p>(
somme(MOV )
</p>
<p>somme(S1)
+
somme(REMP )
</p>
<p>somme(S2)
</p>
<p>)
/2 (3)
</p>
<p>avec S1 = {SUP, INS,REMP,DEP}
et S2 = {SUP, INS,REMP}
</p>
<p>&#8211; Finalement, ceci nous permet de d&#233;finir une fonction de similarit&#233; globale combinant les
&#233;quations pr&#233;c&#233;dentes ; les pond&#233;rations sont fix&#233;es arbitrairement mais refl&#232;tent les priorit&#233;s
accord&#233;es aux diff&#233;rentes fonctions :
</p>
<p>sim = 0.5x+ 0.35y + 0.15z (4)
Les termes de normalisation rendent ces &#233;quations un peu charg&#233;es, mais les id&#233;es sous-jacentes
sont tr&#232;s simples.
Les textes &#224; aligner sont les suivants : deux versions d&#8217;un po&#232;me d&#8217;Andr&#233;e Chedid &#8220;La Robe
Noire&#8221; de 2 Ko, nomm&#233; A ci-dessous ; un cahier d&#8217;exp&#233;rience de Claude Bernard et une syn-
th&#232;se acad&#233;mique de ce cahier (7.5 Ko, B) ; un sous-ensemble de la partie fran&#231;aise du Hansard
et la traduction en fran&#231;ais de la partie correspondante anglaise2 (20 Ko, C) ; et deux versions
d&#8217;un texte de Louis Althusser &#8220;Freud et Lacan&#8221; (50 Ko, D). Le tableau 1 pr&#233;sente les r&#233;sultats
de ces alignements.
On peut constater que MEDITE obtient de meilleurs r&#233;sultats pour tous les textes et crit&#232;res
(sauf pour z sur B et C). Le crit&#232;re x signifie que MEDITE trouve plus de blocs invariants que
GREEDY ; y signifie que les blocs align&#233;s sont plus longs ; et z qu&#8217;on favorise les d&#233;placements
au d&#233;triment des autres types de blocs non-invariants et les remplacements au d&#233;triment des
insertions et suppressions, en effet ces blocs apportent plus d&#8217;informations. On remarquera aussi
les diff&#233;rences consid&#233;rables en temps de calcul.
</p>
<p>2corpus pr&#233;-trait&#233; et mis &#224; disposition par le RALI
309</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Julien BOURDAILLET, Jean-Gabriel GANASCIA
</p>
<p>Algorithme GREEDY MEDITE
Texte A B C D A B C D
x 0.3654 0.2657 0.4106 0.7835 0.4934 0.2697 0.4936 0.9223
y 0.1161 0.0793 0.0784 0.1397 0.3331 0.2488 0.1951 0.2318
z 0.1971 0.2340 0.4096 0.1653 0.2003 0.1676 0.2937 0.2587
</p>
<p>sim 0.2529 0.1957 0.2942 0.4655 0.3933 0.2471 0.3591 0.5811
Temps 0mn 18s 12mn 5s 1h 1mn 29mn 3s 0mn 1s 0mn 2s 0mn 6s 0mn 2s
</p>
<p>TAB. 1 &#8211; Alignements avec GREEDY et MEDITE
</p>
<p>3.2 Alignement de donn&#233;es synth&#233;tiques
</p>
<p>Le but de cette seconde exp&#233;rience est d&#8217;&#233;valuer la qualit&#233; des alignements de MEDITE sur
des donn&#233;es synth&#233;tiques o&#249; il existe un alignement de r&#233;f&#233;rence. Etant donn&#233; un texte et un
g&#233;n&#233;rateur de bruit, un second texte est g&#233;n&#233;r&#233; en alt&#233;rant le premier. L&#8217;alignement entre les
deux textes est enregistr&#233; durant le processus d&#8217;alt&#233;ration ; il est alors possible d&#8217;&#233;valuer la
qualit&#233; d&#8217;un aligneur en comparant ses r&#233;sultats avec l&#8217;alignement de r&#233;f&#233;rence.
</p>
<p>Premier g&#233;n&#233;rateur de bruit Le g&#233;n&#233;rateur de bruit permet de g&#233;n&#233;rer un second texte &#224;
partir de l&#8217;original de la fa&#231;on suivante. Des ratios d&#8217;insertions, suppressions et remplacements
sont fix&#233;s avant de commencer. Des blocs de caract&#232;res sont alors ins&#233;r&#233;s dans le second texte,
supprim&#233;s dans l&#8217;original et remplac&#233;s entre les deux textes, de fa&#231;on r&#233;p&#233;t&#233;e jusqu&#8217;&#224; ce que
les ratios soient atteints. Les positions des modifications sont choisies al&#233;atoirement sur toute
la longueur des textes (le chevauchement d&#8217;op&#233;rations n&#8217;est pas permis). La taille des blocs est
choisie al&#233;atoirement entre 1 et 25 caract&#232;res. Durant ce processus, les positions des modifica-
tions sont enregistr&#233;es, ce qui permet d&#8217;obtenir un alignement de r&#233;f&#233;rence.
Pour cette exp&#233;rience, nous avons choisi un texte de 520 Ko comme texte original, soit la taille
d&#8217;un livre d&#8217;environ 350 pages. Cinq textes synth&#233;tiques diff&#233;rents ont &#233;t&#233; g&#233;n&#233;r&#233;s et align&#233;s
chacun avec l&#8217;original via MEDITE, puis les scores de pr&#233;cision calcul&#233;s. Deux s&#233;ries de tests
avec diff&#233;rents ratios de modifications ont &#233;t&#233; men&#233;es : dans la premi&#232;re il y a 5% d&#8217;insertions,
5 % de suppressions et 5 % de remplacements, ce qui signifie que les textes alt&#233;r&#233;s pr&#233;sentent
15 % de diff&#233;rences avec l&#8217;original ; dans la seconde s&#233;rie, les ratios sont port&#233;s &#224; 10 %, ce qui
signifie qu&#8217;il y 30 % de diff&#233;rences entre les textes.
Pour chacun des quatre types de caract&#232;res (invariants, insertions, suppressions et remplace-
ments) le taux de pr&#233;cision est d&#233;fini comme le nombre de caract&#232;res correctement align&#233;s / le
nombre total de ces caract&#232;res. Les pr&#233;cisions moyennes sur les cinq alignements sont alors cal-
cul&#233;es. Pour la pr&#233;cision pond&#233;r&#233;e, les pr&#233;cisions de chaque type sont pond&#233;r&#233;es par leurs poids
respectifs dans les textes ; par exemple pour la premi&#232;re s&#233;rie de tests on aura Prec.ponde&#769;re&#769;e =
0.85 &#8727; Prec.INV + 0.05 &#8727; Prec.INS + 0.05 &#8727; Prec.SUP + 0.05 &#8727; Prec.REMP . Les deux
premi&#232;res colonnes du tableau 2 pr&#233;sentent les r&#233;sultats de cette exp&#233;rience.
On peut constater que les pr&#233;cisions moyennes sont bonnes, en particulier les pr&#233;cisions pond&#233;-
r&#233;es, et que les temps de calcul sont raisonnables ; il serait inenvisageable de traiter ces textes
avec GREEDY. L&#8217;exp&#233;rience a &#233;t&#233; r&#233;alis&#233;e sur un Pentium 4, 2.4 GHz avec 1 Go de RAM.
MEDITE est impl&#233;ment&#233; en Python, un langage de haut niveau, bon pour le prototypage mais
</p>
<p>310</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Alignements monolingues avec d&#233;placements
</p>
<p>G&#233;n&#233;rateur de bruit sans d&#233;placements avec d&#233;placements
Ratio de modifications 5 % 10 % 5 % 10 %
Pr&#233;cision moyenne 94.48 % 89.27 % 86.56 % 78.36 %
</p>
<p>Pr&#233;cision pond&#233;r&#233;e moyenne 98.16 % 94.0 % 95.19 % 86.18 %
Temps moyen 11 mn 5 s 27 mn 53 s 27 mn 8 s 77 mn 17 s
</p>
<p>TAB. 2 &#8211; Alignement de donn&#233;es synth&#233;tiques avec MEDITE
</p>
<p>lent. Une impl&#233;mentation en C permettrait de gagner consid&#233;rablement en vitesse d&#8217;ex&#233;cution.
N&#233;anmoins, le goulot d&#8217;&#233;tranglement de notre algorithme reste le calcul des diff&#233;rences sym&#233;-
triques entre listes de blocs (voir section 2.4), qui est quadratique par rapport &#224; la taille de ces
listes.
</p>
<p>G&#233;n&#233;rateur de bruit avec d&#233;placements Ce second g&#233;n&#233;rateur de bruit est similaire au pre-
mier mais en plus des d&#233;placements seront g&#233;n&#233;r&#233;s entre texte original et texte alt&#233;r&#233;. Ainsi, des
blocs de caract&#232;res sont d&#233;plac&#233;s d&#8217;une position dans le texte original vers une seconde dans
le texte alt&#233;r&#233;. Les ratios de modifications sont toujours fix&#233;s &#224; 5 et 10 % par op&#233;rations, ce
qui donne des textes avec 20 et 40 % de diff&#233;rences respectivement. Deux s&#233;ries de tests sont
&#224; nouveau conduites et les moyennes des r&#233;sultats pr&#233;sent&#233;es dans les deux derni&#232;res colonnes
du tableau 2.
On peut constater que les pr&#233;cisions moyennes d&#233;croissent significativement mais que les pr&#233;-
cisions pond&#233;r&#233;es conservent de meilleurs scores. Il faut toutefois garder &#224; l&#8217;esprit que les ratios
de diff&#233;rences sont de 20 et 40 % contre 15 et 30 % avec le premier g&#233;n&#233;rateur de bruit. De
plus, la diff&#233;rence entre les pr&#233;cisions pond&#233;r&#233;es et non-pond&#233;r&#233;es indiquent que les blocs inva-
riants ont un meilleur taux de classification. Ceci est confirm&#233; dans le tableau 3 qui pr&#233;sente la
moyenne des matrices de confusion : les blocs de r&#233;f&#233;rence sont en lignes et ceux trouv&#233;s par
MEDITE en colonnes. Les erreurs les plus importantes proviennent des d&#233;placements qui sont
identifi&#233;s comme insertions et suppressions ; or un d&#233;placement peut &#234;tre consid&#233;r&#233; comme une
suppression suivie d&#8217;une insertion. De m&#234;me les insertions et suppressions sont confondues avec
des remplacements ; or les remplacements peuvent aussi &#234;tre consid&#233;r&#233;s comme une suppres-
sion suivie d&#8217;une insertion. Ceci implique un probl&#232;me de d&#233;cision : notre mod&#232;le de d&#233;cision
est tr&#232;s simple et pourrait &#234;tre am&#233;lior&#233; ; n&#233;anmoins les r&#233;sultats pr&#233;sent&#233;s ont le m&#233;rite d&#8217;&#234;tre
consistants.
</p>
<p>Ratio de modifications 5 % 10 %
Type de bloc INV INS SUP REMP DEP INV INS SUP REMP DEP
Invariants 98.07 0.56 0.52 0.76 0.08 94.0 1.75 1.6 2.32 0.32
Insertions 0.21 92.16 0 7.55 0.07 0.21 85.1 0 14.52 0.17
</p>
<p>Suppressions 0.14 0 87.76 9.25 1.76 1.46 0 76.77 17.78 3.99
Remplacements 0.70 5.40 4.65 88.40 0.84 0.72 11.32 9.43 76.34 2.18
D&#233;placements 1.43 13.70 14.05 4.38 66.43 1.47 15.16 15.55 8.25 59.56
</p>
<p>TAB. 3 &#8211; Moyenne des matrices de confusion (en %) pour le g&#233;n&#233;rateur de bruit avec d&#233;place-
ments
</p>
<p>311</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Julien BOURDAILLET, Jean-Gabriel GANASCIA
</p>
<p>4 Conclusion
Nous avons pr&#233;sent&#233; MEDITE, un aligneur monolingue d&#233;tectant les d&#233;placements entre deux
textes. Nous traitons ce probl&#232;me d&#8217;alignement difficile par un algorithme heuristique de re-
cherche d&#8217;homologies dans les s&#233;quences. Notre validation exp&#233;rimentale montre que MEDITE
pr&#233;sente de bons r&#233;sultats et qu&#8217;il est capable d&#8217;aligner des livres entiers en un temps raison-
nable, tout en identifiant les d&#233;placements.
MEDITE est maintenant utilis&#233; par les g&#233;n&#233;ticiens du texte pour aligner diff&#233;rentes versions de
livres entiers. Ce travail fastidieux n&#233;cessiterait plusieurs mois, voire plusieurs ann&#233;es de travail
sans l&#8217;usage de la machine. Nous projetons maintenant de l&#8217;utiliser pour &#233;tablir des &#233;ditions
&#233;lectroniques d&#8217;ouvrages en int&#233;grant directement le logiciel dans le support &#233;lectronique.
</p>
<p>R&#233;f&#233;rences
ARSLAN A. N., EGECIOGLU O. &amp; PEVZNER P. A. (2001). A new approach to sequence
comparison : normalized sequence alignment. Bioinformatics, 17(4), 327&#8211;337.
BERGROTH L., HAKONEN H. &amp; RAITA T. (2000). A Survey of Longest Common Subse-
quence Algorithms. In SPIRE &#8217;00 : Proceedings of the Seventh International Symposium on
String Processing Information Retrieval.
BOURDAILLET J. &amp; GANASCIA J.-G. (2006). MEDITE : A unilingual textual aligner. In Pro-
ceedings of FinTAL, 5th International Conference on Natural Language Processing, Lecture
Notes in Artificial Intelligence, 4139, 458&#8211;469.
BRAY N., DUBCHAK I. &amp; PACHTER L. (2003). AVID : A Global Alignment Program. Ge-
nome Res., 13(1), 97&#8211;102.
CHIAO Y.-C., KRAIF O., LAURENT D., NGUYEN T. M. H., SEMMAR N., STUCK F., V&#201;-
RONIS J. &amp; ZAGHOUANI W. (2006). Evaluation of multilingual text alignment systems : the
ARCADE II project. Proceedings of the LREC 2006 Conference.
DE BIASI P.-M. (2000). La G&#233;n&#233;tique des Textes. Nathan Universit&#233;.
FENG S. &amp; MANMATHA R. (2006). A hierarchical, HMM-based automatic evaluation of
OCR accuracy for a digital library of books. In JCDL&#8217;06, p. 109&#8211;118 : ACM Press.
GANASCIA J.-G. &amp; BOURDAILLET J. (2006). Alignements unilingues avec MEDITE. In
8e&#769;mes Journ&#233;es Internationales d&#8217;Analyse Statistique des Donn&#233;es Textuelles (JADT 2006).
GUSFIELD D. (1997). Algorithms on Strings, Trees and Sequences : Computer Science and
Computer Biology. Cambridge University Press.
LEVENSHTEIN V. (1966). Binary codes capable of correcting deletions, insertions and rever-
sal. Cybernetics and Control Theory, 10(8), 707&#8211;710.
LOPRESTI D. P. &amp; TOMKINS A. (1997). Block Edit Models for Approximate String Mat-
ching. Theoretical Computer Science, 181(1), 159&#8211;179.
SHAPIRA D. &amp; STORER J. A. (2002). Edit Distance with Move Operations. In CPM, volume
2373 of Lecture Notes in Computer Science, p. 85&#8211;98 : Springer.
TICHY W. F. (1984). The String-to-String Correction Problem with Block Moves. ACM
Trans. Comput. Syst., 2(4), 309&#8211;321.
UKKONEN E. (1995). On-Line Construction of Suffix Trees. Algorithmica, 14(3), 249&#8211;260.
</p>
<p>312</p>

</div></div>
</body></html>