<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Ambigu&#239;t&#233; de port&#233;e et approche fonctionnelle des grammaires d&#8217;arbres adjoints</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2007, Toulouse, 5&#8211;8 juin 2007
</p>
<p>Ambigu&#239;t&#233; de port&#233;e et approche fonctionnelle
des grammaires d&#8217;arbres adjoints
</p>
<p>Sylvain POGODALLA
LORIA/INRIA Lorraine
</p>
<p>sylvain.pogodalla@loria.fr
</p>
<p>R&#233;sum&#233;. En s&#8217;appuyant sur la notion d&#8217;arbre de d&#233;rivation des Grammaires d&#8217;Arbres Ad-
joints (TAG), cet article propose deux objectifs : d&#8217;une part rendre l&#8217;interface entre syntaxe et
s&#233;mantique ind&#233;pendante du langage de repr&#233;sentation s&#233;mantique utilis&#233;, et d&#8217;autre part offrir
un noyau qui permette le traitement s&#233;mantique des ambigu&#239;t&#233;s de port&#233;e de quantificateurs sans
utiliser de langage de repr&#233;sentation sous-sp&#233;cifi&#233;e.
Abstract. Relying on the derivation tree of the Tree Adjoining Grammars (TAG), this pa-
per has to goals : on the one hand, to make the syntax/semantics interface independant from the
semantic representation language, and on the other hand to propose an architecture that enables
the modeling of scope ambguities without using underspecified representation formalisms.
Mots-cl&#233;s : interface syntaxe et s&#233;mantique, s&#233;mantique formelle, grammaires d&#8217;arbres
adjoints, grammaires cat&#233;gorielles.
</p>
<p>Keywords: syntax/semantics interface, formal semantics, tree adjoining grammars, ca-
tegorial grammars.
</p>
<p>1 Introduction
La notion d&#8217;arbre de d&#233;rivation dans les grammaires d&#8217;arbres adjoints (TAG) (Joshi &amp; Schabes,
1997; Abeill&#233;, 1993) est cens&#233;e repr&#233;senter les d&#233;pendances entre les diff&#233;rents items lexicaux
d&#8217;une phrase. &#192; ce titre, l&#8217;arbre de d&#233;rivation appara&#238;t comme le candidat privil&#233;gi&#233; pour r&#233;ali-
ser le transfert structurel entre la syntaxe et la s&#233;mantique de mani&#232;re compositionnelle. Or, sa
repr&#233;sentation ne rendant pas explicite certains liens, il a &#233;t&#233; propos&#233;, afin de le rendre op&#233;ration-
nel dans le cadre du calcul de la repr&#233;sentation s&#233;mantique, soit de l&#8217;&#233;tendre (Kallmeyer, 2002;
Joshi et al., 2003), soit de ne pas l&#8217;utiliser et de calculer la repr&#233;sentation s&#233;mantique directe-
ment sur l&#8217;arbre d&#233;riv&#233; (Frank &amp; van Genabith, 2001; Gardent &amp; Kallmeyer, 2003; Gardent,
2007).
Cet article propose d&#8217;utiliser la notion d&#8217;arbre de d&#233;rivation telle qu&#8217;introduite dans (Pogodalla,
2004). En effet, cette notion, qui pr&#233;cise simplement la notion originale, y est montr&#233;e comme
ad&#233;quate pour la repr&#233;sentation des d&#233;pendances longue distance. N&#233;anmoins, le langage de
repr&#233;sentation s&#233;mantique qui est utilis&#233; est un formalisme sous-sp&#233;cifi&#233;. Ces derniers posent
parfois probl&#232;me, comme dans le cas de la coordination de groupes nominaux quantifi&#233;s (Willis,
2007). De plus, nous voulons un cadre g&#233;n&#233;ral qui laisse &#224; l&#8217;utilisateur le choix d&#8217;utiliser ou
</p>
<p>325</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain POGODALLA
</p>
<p>non de tels formalismes, tout en gardant la possibilit&#233; de mod&#233;liser les ambigu&#239;t&#233;s. Ainsi, nous
utilisons un formalisme plus proche de celui propos&#233; par Montague (Montague, 1974) et une
architecture qui permet de traiter des ph&#233;nom&#232;nes d&#8217;ambigu&#239;t&#233;. Nous nous appuyons sur les
Grammaires Cat&#233;gorielles Abstraites (ACG) (de Groote, 2001), et, tout en gardant un seul arbre
d&#233;riv&#233;, nous montrons comment le principe d&#8217;&#233;l&#233;vation de type des grammaires cat&#233;gorielles
permet d&#8217;obtenir plusieurs lectures s&#233;mantiques.
Dans les deux prochaines sections, nous pr&#233;sentons l&#8217;arbre de d&#233;rivation de (Pogodalla, 2004)
sur des exemples. Puis nous d&#233;finissons dans la section 4 la notion d&#8217;ACG et les architectures
qu&#8217;elle rend possible pour l&#8217;interface entre la syntaxe et la s&#233;mantique. La section 5 met finale-
ment en &#339;uvre une telle architecture pour mod&#233;liser l&#8217;ambigu&#239;t&#233; de port&#233;e des quantificateurs.
</p>
<p>2 Lecture fonctionnelle de l&#8217;arbre d&#233;riv&#233;
La pr&#233;sentation habituelle des arbres &#233;l&#233;mentaires des TAG en donne une vision relativement
statique, les op&#233;rations de substitution et d&#8217;adjonction se chargeant de donner la dynamique
du langage en combinant selon certaines r&#232;gles les arbres entre eux. Dans cette section, nous
nous proposons d&#8217;int&#233;grer cette notion de dynamique aux arbres &#233;l&#233;mentaires eux-m&#234;mes, en
d&#233;crivant comment chacun prend part aux op&#233;rations de substitution et d&#8217;adjonction. Cette des-
cription se fait sur base d&#8217;exemples.
Soit l&#8217;arbre auxiliaire suivant : N
</p>
<p>un N&#8727;
. Lorsqu&#8217;il est adjoint &#224; un autre arbre &#224; un n&#339;udN0,
</p>
<p>cet arbre remplace son propre n&#339;ud N&#8727; par le sous-arbre de racine N0. Si l&#8217;on appelle x ce sous-
arbre, on peut donc consid&#233;rer l&#8217;arbre auxiliaire comme une fonction qui transforme un arbre x
en un nouvel arbre N
</p>
<p>un x
. Soit, avec la notation &#224; l&#8217;aide du &#955;-calcul, une repr&#233;sentation
</p>
<p>de cet arbre par le terme suivant :
cun = &#955;x. N
</p>
<p>un x
</p>
<p>Consid&#233;rons maintenant l&#8217;arbre initial suivant : N
chat
</p>
<p>. Cet arbre peut se voir adjoindre un arbre
</p>
<p>auxiliaire au n&#339;ud N. Dans ce cas, il donnera comme argument &#224; cet arbre auxiliaire (on a vu
que l&#8217;arbre auxiliaire peut &#234;tre d&#233;crit comme &#233;tant une fonction qui prend un arbre en argument
et retourne un arbre) le sous arbre N
</p>
<p>chat
(dans le cas pr&#233;sent, le sous-arbre param&#232;tre est l&#8217;arbre
</p>
<p>tout entier car l&#8217;adjonction a lieu au n&#339;ud racine).
On peut donc repr&#233;senter l&#8217;arbre initial comme une fonction qui prend comme param&#232;tre un
arbre auxiliaire, c&#8217;est-&#224;-dire une fonction des arbres dans les arbres. Soit, avec la notation en
&#955;-calcul :
</p>
<p>&#955;a.a( N
chat
</p>
<p>)
</p>
<p>326</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ambigu&#239;t&#233; de port&#233;e et approche fonctionnelle des TAG
</p>
<p>On constate alors que l&#8217;op&#233;ration d&#8217;adjonction qui permet d&#8217;obtenir l&#8217;arbre N
un N
</p>
<p>chat
</p>
<p>est
</p>
<p>d&#233;crite par l&#8217;application de la fonction (du terme) cchat au terme cun. En effet :
cchatcun = (&#955;a.a( N
</p>
<p>chat
))(&#955;x. N
</p>
<p>un x
)&#8594;&#946; (&#955;x. N
</p>
<p>un x
)( N
chat
</p>
<p>)&#8594;&#946; N
un N
</p>
<p>chat
</p>
<p>On peut finalement avoir un arbre qui combine la possibilit&#233; de subir une adjonction et une
substitution. Prenons par exemple l&#8217;arbre initial suivant : S
</p>
<p>N&#8595; VP
dort
</p>
<p>. Sa particularit&#233; est qu&#8217;il
</p>
<p>attend un arbre qui peut &#234;tre substitu&#233; au n&#339;ud N d&#8217;une part, et qu&#8217;il peut subir une adjonction
au n&#339;ud VP. On choisit donc de le repr&#233;senter comme une fonction qui prend en premier
argument un arbre auxiliaire, c&#8217;est-&#224;-dire une fonction, et en deuxi&#232;me argument un arbre x qui
est celui qui est substitu&#233; au n&#339;ud N. On peut alors le repr&#233;senter de la mani&#232;re suivante :
</p>
<p>cdort = &#955;ax. S
x a(VP )
</p>
<p>dort
</p>
<p>Bien entendu, il est possible qu&#8217;aucune adjonction n&#8217;ait lieu sur le n&#339;ud VP1. Dans l&#8217;optique
que nous avons choisie, cela signifie que la fonction qui a &#233;t&#233; adjointe est l&#8217;identit&#233; I = &#955;x.x.
L&#8217;arbre d&#233;riv&#233; S
</p>
<p>N
un N
</p>
<p>chat
</p>
<p>VP
dort
</p>
<p>est alors repr&#233;sent&#233; par le terme cdort I (cchatcun).
</p>
<p>Avec une repr&#233;sentation ad&#233;quate de l&#8217;adverbe, par exemple cpaisiblement =
&#955;x. VP
</p>
<p>x paisiblement
, on peut &#233;galement construire l&#8217;arbre d&#233;riv&#233; repr&#233;sent&#233; par le terme
</p>
<p>cdortcpaisiblement(cchatcun) :
</p>
<p>S
N
</p>
<p>un N
chat
</p>
<p>VP
VP
dort
</p>
<p>paisiblement
</p>
<p>1Pour des raisons de clart&#233; dans la pr&#233;sentation, nous avons omis la possibilit&#233; d&#8217;une adjonction sur le n&#339;ud S,
et donc supprim&#233; le param&#232;tre correspondant. On voit &#233;galement par l&#224; comment interdire des adjonctions.
</p>
<p>327</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain POGODALLA
</p>
<p>Si l&#8217;on appelle &#947; le type des arbres, on voit que l&#8217;on a les constantes et le typage suivants :
cun : &#947;! &#947;
cchat : (&#947;! &#947;)! &#947;
cdort : (&#947;! &#947;)! &#947;! &#947;
</p>
<p>cpaisiblement : &#947;! &#947;
I : &#947;! &#947;
</p>
<p>o&#249;! d&#233;signe l&#8217;implication lin&#233;aire2.
</p>
<p>3 R&#244;le de l&#8217;arbre de d&#233;rivation
En typant les constantes repr&#233;sentant les arbres auxiliaires et initiaux de cette mani&#232;re, nous
perdons toutefois une information importante : les arbres ont tous le m&#234;me type &#947;, et aucune
distinction n&#8217;est faire entre eux. Ainsi, la composition cchatcpaisiblement serait tout &#224; fait licite.
C&#8217;est pourquoi nous allons donner aux constantes un type plus abstrait3, correspondant aux
non-terminaux qui &#233;tiquettent leur racine. Nous nous donnons donc les types de base suivants :
VP, S, V, N ainsi que les types qui correspondent aux racines des n&#339;uds auxiliaires : VPA, SA,
VA, NA.
Ainsi, en reprenant les exemples ci-dessus et en introduisant de nouvelles constantes, nous
avons les typages suivants :
</p>
<p>Cdort : VPA! N! S
Cchat : NA! N
</p>
<p>Cun : NA
Cpaisiblement : VPA
IVP : VPA
</p>
<p>On peut alors avoir le terme CdortIVP(CchatCun), de type S, tandis que le terme CchatCpaisiblement
n&#8217;est pas typable. Il reste &#224; &#233;tablir le lien avec le terme cdort(cchatcun) de la section pr&#233;c&#233;dente.
Cela se fait par une fonction de conversion :=syntax, le lexique, qui convertit les types et les
constantes ainsi :
</p>
<p>S :=syntax &#947;
VP :=syntax &#947;
N :=syntax &#947;
NA :=syntax &#947;! &#947;
VPA :=syntax &#947;! &#947;
</p>
<p>Cdort :=syntax cdort
Cun :=syntax cdort
Cchat :=syntax cchat
Cpaisiblement :=syntax cpaisiblement
IX :=syntax &#955;x.x pour tout type X
</p>
<p>TAB. 1 &#8211; D&#233;finition du lexique
</p>
<p>On alors :
CdortIVP(CchatCun) :=syntax cdortI(cchatcun)
</p>
<p>et
CdortCpaisiblement(CchatCun) :=syntax cdortcpaisiblement(cchatcun)
</p>
<p>Si l&#8217;on adopte une repr&#233;sentation arborescente des &#955;-termes (il n&#8217;y a pas d&#8217;abstraction), on peut
repr&#233;senter CdortCpaisiblement(CchatCun) par :
</p>
<p>2Nous ne dirons rien du calcul logique sous-jacent, ni de la mani&#232;re d&#8217;introduire de la non-lin&#233;arit&#233; avec l&#8217;im-
plication intuitionniste habituelle&#8594;. Nous renvoyons les lecteurs int&#233;ress&#233;s &#224; (de Groote, 2001; Pogodalla, 2004).
</p>
<p>3Car pouvant &#234;tre r&#233;alis&#233;, ou instanci&#233;, de diff&#233;rentes mani&#232;res : arbre (&#947;) pour la syntaxe, mais aussi individu
(e), pr&#233;dicat (e! t), etc. pour la s&#233;mantique.
</p>
<p>328</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ambigu&#239;t&#233; de port&#233;e et approche fonctionnelle des TAG
</p>
<p>Cdort
</p>
<p>Cpaisiblement Cchat
</p>
<p>Cun
</p>
<p>Cet arbre rappelle tr&#232;s pr&#233;cis&#233;ment l&#8217;arbre de d&#233;rivation tel qu&#8217;il est d&#233;fini classiquement dans
les TAG. En fait, il s&#8217;agit de la m&#234;me notion o&#249; sont cependant explicit&#233;s :
&#8211; l&#8217;ordre des arguments, qui doit &#234;tre le m&#234;me pour la constante qui est repr&#233;sent&#233;e dans l&#8217;arbre
</p>
<p>de d&#233;rivation et pour la constante qui lui est associ&#233;e dans les arbres d&#233;riv&#233;s. Le choix est
libre, mais une fois qu&#8217;il est fait, il doit &#234;tre coh&#233;rent ;
</p>
<p>&#8211; l&#8217;ordre des adjonctions lors d&#8217;une d&#233;rivation. Contrairement &#224; la notion classique, o&#249; cet
ordre n&#8217;est pas pr&#233;cis&#233;, le r&#233;sultat &#233;tant le m&#234;me, ici l&#8217;ordre des op&#233;rations est sp&#233;cifi&#233;. Cela
ne change pas le pouvoir expressif, cela permet par contre de doter les TAG d&#8217;une s&#233;mantique
compositionnelle bas&#233;e sur l&#8217;arbre de d&#233;rivation.
</p>
<p>Cette mani&#232;re de repr&#233;senter les arbres d&#233;riv&#233;s, les arbres de d&#233;rivation, et les relations qu&#8217;il y
a entre eux, correspond en fait &#224; la mod&#233;lisation des TAG dans le formalisme des ACG.
</p>
<p>4 Mod&#233;lisation des TAG dans les ACG
Nous ne reprenons pas ici le d&#233;tail la mod&#233;lisation syst&#233;matique des TAG dans les ACG, donn&#233;
dans (de Groote, 2002; Pogodalla, 2004). Nous allons simplement donner les d&#233;finitions pr&#233;-
cises des ACG qui ont &#233;t&#233; mises en &#339;uvre dans les exemples pr&#233;c&#233;dents, afin d&#8217;en tirer l&#8217;ar-
chitecture g&#233;n&#233;rale que nous utiliserons pour mod&#233;liser les ambigu&#239;t&#233;s de port&#233;e des quantifica-
teurs.
Une ACG d&#233;finit deux langages : un langage abstrait, qui peut &#234;tre vu comme un ensemble
abstrait de structures grammaticales, et un langage objet, repr&#233;sentant les formes r&#233;alis&#233;es des
structures abstraites, qu&#8217;elle met en relation. Ici, le langage abstrait correspond &#224; la structure
grammaticale que l&#8217;on veut manipuler : l&#8217;arbre de d&#233;rivation. Dans l&#8217;exemple pr&#233;c&#233;dent, il est
mis en relation avec le langage objet des arbres d&#233;riv&#233;s gr&#226;ce au lexique.
</p>
<p>Definition 1 (Signature d&#8217;ordre sup&#233;rieur). Une signature d&#8217;ordre sup&#233;rieure est un triplet
&#931; = &#12296;A,C, &#964;&#12297; o&#249; :
&#8211; A est un ensemble de types atomiques ;
&#8211; C est un ensemble fini de constantes ;
&#8211; &#964; : C &#8594; T (A) qui assigne &#224; chaque constante de C un type de T (A) o&#249; T (A) ::=
A|T (A)! T (A).
</p>
<p>On appel &#923;&#931; l&#8217;ensemble des &#955;-termes que l&#8217;on peut construire avec la signature &#931;.
</p>
<p>Ainsi, dans l&#8217;exemple pr&#233;c&#233;dent, nous avions deux signatures d&#8217;ordre sup&#233;rieur. La premi&#232;re
contenait les types atomiques S,N,VPA. . . et les constantesCchat ,Cun. . . tandis que la deuxi&#232;me
signature d&#8217;ordre sup&#233;rieur contenait l&#8217;unique type atomique &#947; et les constante cchat , cun. . .
</p>
<p>Definition 2 (Lexique). &#201;tant donn&#233;es une signature d&#8217;ordre sup&#233;rieur &#931;1 = &#12296;A1, C1, &#964;1&#12297; et
une signature d&#8217;ordre sup&#233;rieur &#931;2 = &#12296;A2, C2, &#964;2&#12297;, un lexique := de &#931;1 vers &#931;2 est d&#233;fini par
la donn&#233;e de &#964;:= et c:= tels que :
</p>
<p>329</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain POGODALLA
</p>
<p>&#8211; &#964;:= : A1 &#8594; T (A2) est une fonction d&#8217;interpr&#233;tation des types atomiques de &#931;1 comme
des types implicatifs construits &#224; partir de A2. On appellera &#964;:= &#233;galement son extension
homomorphique &#224; tous les types de T (A1) ;
</p>
<p>&#8211; c:= : C1 &#8594; &#923;&#931;2 est une fonction d&#8217;interpr&#233;tation des constantes de &#931;1 comme des &#955;-termes
construits &#224; partir de &#931;2. On appellera c:= &#233;galement son extension homomorphique &#224; tous
les termes de &#923;&#931;1 ;
</p>
<p>&#8211; les fonctions d&#8217;interpr&#233;tation sont compatibles avec la relation de typage, c&#8217;est-&#224;-dire que
pour tout c &#8712; C1 et t : &#945; &#8712; &#923;&#931;2 tels que c
</p>
<p>c
:= t, alors &#964;1(c) &#964;:= &#945; (le type de l&#8217;image de c est
</p>
<p>l&#8217;image du type de c).
Dans la suite, on utilisera sans ambigu&#239;t&#233; := pour &#964;:= ou c:=.
</p>
<p>Le tableau 1 d&#233;finit bien un lexique. La colonne de gauche donne l&#8217;interpr&#233;tation des types
atomiques (on remarquera avec l&#8217;interpr&#233;tation du type VPA que l&#8217;interpr&#233;tation d&#8217;un type
atomique peut &#234;tre un type non atomique). La colonne de droite donne l&#8217;interpr&#233;tation des
constantes.
Definition 3 (Grammaire cat&#233;gorielle abstraite). Une grammaire cat&#233;gorielle abstraite est un
quadruplet G = &#12296;&#931;1,&#931;2, :=, s&#12297; o&#249; :
&#8211; &#931;1 est une signature d&#8217;ordre sup&#233;rieure, et &#931;2 une signature d&#8217;ordre sup&#233;rieure. Ils sont
</p>
<p>appel&#233;s vocabulaire abstrait et vocabulaire objet ;
&#8211; := : &#931;1 &#8594; &#931;2 est un lexique ;
&#8211; s est un type atomique du vocabulaire abstrait, appel&#233; le type distingu&#233; de la grammaire.
Definition 4 (Langages abstrait et objet). Soit G = &#12296;&#931;1,&#931;2, :=, s&#12297; une grammaire cat&#233;go-
rielle abstraite.
</p>
<p>1. Le langage abstrait A(G) engendr&#233; par G est d&#233;fini par A(G) = {t &#8712; &#923;&#931;1|t : s}
2. Le langage objet O(G) engendr&#233; par G est d&#233;fini par
</p>
<p>O(G) = {t &#8712; &#923;&#931;2 |&#8707;u &#8712; A(G) avec u := t}
</p>
<p>Ainsi, les termes pris en exemple appartiennent bien aux vocabulaires abstrait et objet. Il est
&#224; noter que cette d&#233;finition permet d&#8217;&#233;viter que le terme cdort(cchatcpaisiblement), qui est bien un
arbre (de type &#947;), appartienne effectivement au langage objet des arbres d&#233;riv&#233;s. En effet, il
serait l&#8217;image de Cdort(CchatCpaisiblement) qui n&#8217;est pas de type S (ce terme n&#8217;est m&#234;me pas
typable) et qui n&#8217;appartient donc pas au langage abstrait des arbres de d&#233;rivation.
La d&#233;finition des ACG permet de consid&#233;rer diff&#233;rents types d&#8217;architecture. Par exemple, si
deux ACG partagent le m&#234;me vocabulaire abstrait, on aura le sch&#233;ma de composition de la
figure 1(a). C&#8217;est par exemple celui adopt&#233; dans (Pogodalla, 2004) pour doter les TAG d&#8217;une
repr&#233;sentation s&#233;mantique sous-sp&#233;cifi&#233;e.
On peut &#233;galement composer deux ACG en faisant que le vocabulaire objet de l&#8217;une soit &#233;ga-
lement le vocabulaire abstrait de l&#8217;autre (figure 1(b)). C&#8217;est par exemple le cas si l&#8217;on veut
consid&#233;rer le lien entre les arbres d&#233;riv&#233;s, cette fois vus comme un langage abstrait, et leur
production (yield en anglais) comme langage de cha&#238;ne.
Bien entendu, on peut m&#233;langer ces deux types de composition. La mod&#233;lisation que nous
proposons pour les ph&#233;nom&#232;nes d&#8217;ambigu&#239;t&#233; de port&#233;e des quantificateurs repose sur le sch&#233;ma
de la figure 1(c). Dans tous les cas, on retrouve un sch&#233;ma classique du TAL, m&#234;me si la relation
est d&#233;crite par un autre formalisme : celui de la composition de transducer.
</p>
<p>330</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ambigu&#239;t&#233; de port&#233;e et approche fonctionnelle des TAG
</p>
<p>GURLGsyntax
</p>
<p>(a) Composition par partage de vocabulaire abstrait
</p>
<p>Gsyntax
Gyield
</p>
<p>(b) Composition par identification de vocabulaires
abstrait et objet
</p>
<p>Gsyntax
</p>
<p>Gsem
Gamb
</p>
<p>(c) Composition par combinaison des deux modes
</p>
<p>FIG. 1 &#8211; Exemples d&#8217;architectures possibles
</p>
<p>5 Composition d&#8217;ACG et mod&#233;lisation des ambigu&#239;t&#233;s de
port&#233;e
</p>
<p>Proposition. Notre objectif est de proposer pour les TAG un cadre dans lequel mod&#233;liser
les ambigu&#239;t&#233;s de port&#233;e sans utiliser de formalisme sous-sp&#233;cifi&#233; (contrairement &#224; (Pogodalla,
2004)), tout en gardant la contrainte d&#8217;avoir un unique arbre d&#233;riv&#233; auquel peuvent &#234;tre asso-
ci&#233;es plusieurs repr&#233;sentations s&#233;mantiques. Pour l&#8217;architecture que nous proposons, il nous faut
d&#233;finir deux nouvelles ACG. La premi&#232;re, Gamb, permettra d&#8217;associer &#224; un arbre de d&#233;rivation
unique deux structures plus profondes. La seconde, Gsem, correspondra &#224; la r&#233;alisation dans un
langage de formes logiques du type de Montague de ces structures plus profondes.
On pourra penser que ces diff&#233;rents niveaux ajoutent de la complexit&#233; conceptuelle. Nous pen-
sons pour notre part que cela permet de modulariser les difficult&#233;s (en ne traitant qu&#8217;&#224; leurs
niveaux respectifs la syntaxe, avec Gsyntax, et la s&#233;mantique, avec Gamb et Gsem). Par ailleurs,
nous avons vu que cette notion de composition est d&#233;j&#224; pr&#233;sente en TAL avec l&#8217;utilisation de
transducer et de leur composition, pour le traitement de la morphologie par exemple. Si au final
seule la relation entre les langages d&#8217;entr&#233;e et sortie nous int&#233;resse, il est tout &#224; fait possible de
compiler deux ACG, par exemple Gamb et Gsyntax en une seule, leur compos&#233;e.
Supposons que la grammaire Gsyntax contiennent &#233;galement les arbres suivants :
cchasse = &#955;axy. S
</p>
<p>x a(VP )
chasse y
</p>
<p>, cchien = &#955;a.a( N
chien
</p>
<p>) et ctout = &#955;x. N
tout x
</p>
<p>, ainsi que les
</p>
<p>constantes Cchien : NA ! N, Cchasse : VPA ! N! N! S et Ctout : NA mis en relation par
le lexique de la mani&#232;re suivante : Cchasse:=syntaxcchasse, Cchien:=syntaxcchien et Ctout :=syntaxctout .
</p>
<p>331</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain POGODALLA
</p>
<p>Alors l&#8217;arbre de d&#233;rivation correspondant &#224; l&#8217;arbre d&#233;riv&#233;
</p>
<p>cchasse(cchienctout)(cchatcun):=syntax S
N
</p>
<p>tout N
chien
</p>
<p>VP
chasse N
</p>
<p>un N
chat
</p>
<p>est t0 = CchasseIVP(CchienCtout)(CchatCun).
D&#233;finissons maintenant Gamb, dont le vocabulaire objet est le vocabulaire abstrait de Gsyntax, et
dont le vocabulaire abstrait contient les m&#234;mes symboles de type que le vocabulaire objet mais
les constantes typ&#233;es Dchasse : VPA ! N ! N ! S, Dchien : NA ! (N ! S) ! S,
Dchat : NA ! (N! S)! S, Dtout : NA, Dun : NA et IDVP : VPA. Le lexique :=amb est tel que
pour tout type X , X:=ambX et :
</p>
<p>Dchasse :=amb Cchasse
Dtout :=amb Ctout
Dun :=amb Cun
</p>
<p>Dchien :=amb &#955;aP.P (Cchien a)
Dchat :=amb &#955;aP.P (Cchat a)
IDVP :=amb IVP
</p>
<p>Soit alors les termes :
t1 = (DchienDtout)(&#955;x.(DchatDun)(&#955;y.DchasseIDVP x y))
t2 = (DchatDun)(&#955;y.(DchienDtout)(&#955;x.DchasseIDVP x y))
</p>
<p>On pourra v&#233;rifier que t1 et t2 sont bien typ&#233;s et que t1:=amb t0 et t2:=amb t0. Ainsi, nous avons
d&#233;sormais deux structures profondes (t1 et t2) reli&#233;es &#224; un seul arbre de d&#233;rivation (t0).
Il nous reste &#224; transformer ces structures en formules logiques &#224; l&#8217;aide d&#8217;une nouvelle ACG
Gsem. Celle-ci partage son vocabulaire abstrait avec Gamb, et, au niveau objet, met en &#339;uvre les
types habituels e et t pour les repr&#233;sentations &#224; la Montague. Avec le lexique :=sem4 suivant5 :
</p>
<p>S :=sem t
N :=sem e
NA :=sem (e&#8594; t)&#8594; (e&#8594; t)&#8594; t
VPA :=sem (e&#8594; t)&#8594; (e&#8594; t)
</p>
<p>Dchasse :=sem &#955;aso.(a(&#955;x.chasse x o))s
Dtout :=sem &#955;PQ.&#8704;x.P x&#8658; Qx
Dun :=sem &#955;PQ.&#8707;x.P x &#8743;Qx
Dchat :=sem &#955;q.q(&#955;x.chat x)
Dchien :=sem &#955;q.q(&#955;x.chienx)
IDVP :=sem &#955;x.x
</p>
<p>Nous laissons le lecteur v&#233;rifier que l&#8217;on obtient bien alors les deux lectures :
t1 :=sem &#8704;x.chienx&#8658; (&#8707;y.chat y &#8743; chasse x y)
t2 :=sem &#8707;y.chat y &#8743; (&#8704;x.chienx&#8658; chasse x y)
</p>
<p>Faute de place, nous ne pouvons illustrer &#233;galement la coordination de groupes nominaux
quantifi&#233;s avec les constantes Cet : N ! N ! N, Det : ((N ! S) ! S) ! ((N !
</p>
<p>4On suppose pr&#233;sentes dans la signature objet les constantes chasse : e ! e ! t, chien : e ! t, chat :
e! t, &#8704; : (e&#8594; t)! t et &#8707; : (e&#8594; t)! t.
</p>
<p>5Notons que c&#8217;est la pr&#233;sence du param&#232;tre a dans la formule s&#233;mantique qui r&#233;alise Dchasse qui permet, en
int&#233;grant la contribution des &#233;ventuels sous-arbres adjoints, la prise en compte des d&#233;pendances longue distance.
</p>
<p>332</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Ambigu&#239;t&#233; de port&#233;e et approche fonctionnelle des TAG
</p>
<p>S) ! S) ! ((N ! S) &#8594; S) et leur r&#233;alisation Det :=amb &#955;PQr.P (&#955;x.Q(&#955;y.r(Cet x y))) et
Det :=sem &#955;PQr.P r &#8743;Qr. On aurait par exemple les deux termes
</p>
<p>t3 = Det(DchatDtout)(DchienDun)(&#955;x.(DsourisDune)(&#955;y.DchasseIDVP x y))
t4 = (DsourisDune)(&#955;y.Det(DchatDtout)(DchienDun)(&#955;x.DchasseIDVP x y))
</p>
<p>qui donneraient les deux lectures attendues pour tout chat et un chien chassent une souris.
Contrairement au probl&#232;me soulev&#233; par les repr&#233;sentations sous-sp&#233;cifi&#233;es dans (Willis, 2007),
on n&#8217;a pas la lecture o&#249; tout chat a une port&#233;e diff&#233;rente de un chien vis &#224; vis de la port&#233;e de une
souris. On obtient ainsi une architecture dans laquelle mod&#233;liser les ph&#233;nom&#232;nes d&#8217;ambigu&#239;t&#233;
de port&#233;e sans imposer l&#8217;utilisation de formalismes sous-sp&#233;cifi&#233;s.
</p>
<p>Limitations. Actuellement, nous ne savons pas exprimer les contraintes de port&#233;e des quan-
tificateurs, telles celles des &#238;lots de port&#233;e. Ce probl&#232;me est comparable &#224; celui rencontr&#233; par
les grammaires de types logiques. En effet, l&#8217;approche propos&#233;e ici repose sur le principe de
l&#8217;&#233;l&#233;vation de type, qui est &#224; la base de la prise en compte des ambigu&#239;t&#233;s de port&#233;e dans ces
grammaires. Ici, nous avons gard&#233; la contrainte suppl&#233;mentaire que, bien entendu, l&#8217;arbre d&#233;-
riv&#233; et l&#8217;arbre de d&#233;rivation restent uniques. La solution que nous envisageons repose sur une
extension du syst&#232;me de type des ACG, et va bien au-del&#224; du sujet de cet article6.
</p>
<p>6 Conclusion
Nous avons montr&#233; comment, en se basant sur la d&#233;finition pr&#233;cise de l&#8217;arbre de d&#233;rivation
de (Pogodalla, 2004), nous pouvons d&#233;finir un calcul des repr&#233;sentations s&#233;mantiques pour les
TAG qui ne n&#233;cessite pas l&#8217;usage de formalismes sous-sp&#233;cifi&#233;s tout en permettant le traitement
de l&#8217;ambigu&#239;t&#233;. Cela nous permet d&#8217;une part de renforcer l&#8217;ind&#233;pendance entre le formalisme
syntaxique des TAG et le formalisme choisi par l&#8217;utilisateur pour la repr&#233;sentation s&#233;mantique,
et d&#8217;autre par de confirmer l&#8217;importance de cette notion d&#8217;arbre de d&#233;rivation. Par ailleurs,
notre approche a de forts liens avec les approches de Glue Semantics (Dalrymple, 2001), et
la proposition (Frank &amp; van Genabith, 2001) (utilisant les principes de Glue Semantics depuis
l&#8217;arbre d&#233;riv&#233;) pourrait sans doute &#234;tre reconsid&#233;r&#233;e avec cette notion d&#8217;arbre de d&#233;rivation.
</p>
<p>R&#233;f&#233;rences
ABEILL&#201; A. (1993). Les nouvelles syntaxes. Paris : Armand Colin &#201;diteur.
DALRYMPLE M. (2001). Lexical Functional Grammar, volume 42 of Syntax and Semantics
series. Academic Press.
DE GROOTE P. (2001). Towards abstract categorial grammars. In Association for Computa-
tional Linguistics, 39th Annual Meeting and 10th Conference of the European Chapter, Pro-
ceedings of the Conference, p. 148&#8211;155.
DE GROOTE P. (2002). Tree-adjoining grammars as abstract categorial grammars. In TAG+6,
Proceedings of the sixth International Workshop on Tree Adjoining Grammars and Related
Frameworks, p. 145&#8211;150 : Universit&#224; di Venezia.
</p>
<p>6Faute de place, nous ne pouvons pas exposer comment l&#8217;architecture propos&#233;e ici permet &#233;galement de d&#233;pas-
ser la limitation mentionn&#233;e dans (Pogodalla, 2004) pour les verbes &#224; contr&#244;le.
</p>
<p>333</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain POGODALLA
</p>
<p>FRANK A. &amp; VAN GENABITH J. (2001). Glue tag : Linear logic based semantics construction
for LTAG - and what it teaches us about the relation between LFG and LTAG. In M. BUTT &amp;
T. H. KING, Eds., Proceedings of the LFG &#8217;01 Conference, Online Proceedings : CSLI Publi-
cations. http://cslipublications.stanford.edu/LFG/6/lfg01.html.
GARDENT C. (2007). Tree adjoining grammar, semantic calculi and labelling invariants. In
(Getzen et al., 2007).
GARDENT C. &amp; KALLMEYER L. (2003). Semantic construction in feature-based tag. In Pro-
ceedings of the 10th Meeting of the European Chapter of the Association for Computational
Linguistics (EACL).
J. GETZEN, E. THIJSSE, H. BUNT &amp; A. SCHIFFRIN, Eds. (2007). Proceedings of the Seventh
International Workshop on Computational Semantics, IWCS-7. Tilburg University.
JOSHI A. K., KALLMEYER L. &amp; ROMERO M. (2003). Flexible composition in ltag : Quan-
tifier scope and inverse linking. In H. BUNT, I. VAN DER SLUIS &amp; R. MORANTE, Eds.,
Proceedings of the Fifth International Workshop on Computational Semantics IWCS-5.
JOSHI A. K. &amp; SCHABES Y. (1997). Tree-adjoining grammars. In G. ROZENBERG &amp; A.
SALOMAA, Eds., Handbook of formal languages, chapter 2. Springer.
KALLMEYER L. (2002). Using an enriched tag derivation structure as basis for semantics.
In Proceedings of the Sixth International Workshop on Tree Adjoining Grammar and Related
Frameworks (TAG+6).
MONTAGUE R. (1974). The proper treatment of quantification in ordinary english. In P.
PORTNER &amp; B. H. PARTEE, Eds., Formal Semantics : The Essential Readings, chapter 1.
Blackwell Publishers. 2002 edition.
POGODALLA S. (2004). Computing semantic representation : Towards ACG abstract terms
as derivation trees. In Proceedings of the Seventh International Workshop on Tree Adjoining
Grammar and Related Formalisms (TAG+7), p. 64&#8211;71.
WILLIS A. (2007). NP coordination in underspecified scope representations. In (Getzen et al.,
2007).
</p>
<p>334</p>

</div></div>
</body></html>