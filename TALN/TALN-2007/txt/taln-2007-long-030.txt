TALN 2007, Toulouse, 5–8 juin 2007
Ambiguïté de portée et approche fonctionnelle
des grammaires d’arbres adjoints
Sylvain POGODALLA
LORIA/INRIA Lorraine
sylvain.pogodalla@loria.fr
Résumé. En s’appuyant sur la notion d’arbre de dérivation des Grammaires d’Arbres Ad-
joints (TAG), cet article propose deux objectifs : d’une part rendre l’interface entre syntaxe et
sémantique indépendante du langage de représentation sémantique utilisé, et d’autre part offrir
un noyau qui permette le traitement sémantique des ambiguïtés de portée de quantificateurs sans
utiliser de langage de représentation sous-spécifiée.
Abstract. Relying on the derivation tree of the Tree Adjoining Grammars (TAG), this pa-
per has to goals : on the one hand, to make the syntax/semantics interface independant from the
semantic representation language, and on the other hand to propose an architecture that enables
the modeling of scope ambguities without using underspecified representation formalisms.
Mots-clés : interface syntaxe et sémantique, sémantique formelle, grammaires d’arbres
adjoints, grammaires catégorielles.
Keywords: syntax/semantics interface, formal semantics, tree adjoining grammars, ca-
tegorial grammars.
1 Introduction
La notion d’arbre de dérivation dans les grammaires d’arbres adjoints (TAG) (Joshi & Schabes,
1997; Abeillé, 1993) est censée représenter les dépendances entre les différents items lexicaux
d’une phrase. À ce titre, l’arbre de dérivation apparaît comme le candidat privilégié pour réali-
ser le transfert structurel entre la syntaxe et la sémantique de manière compositionnelle. Or, sa
représentation ne rendant pas explicite certains liens, il a été proposé, afin de le rendre opération-
nel dans le cadre du calcul de la représentation sémantique, soit de l’étendre (Kallmeyer, 2002;
Joshi et al., 2003), soit de ne pas l’utiliser et de calculer la représentation sémantique directe-
ment sur l’arbre dérivé (Frank & van Genabith, 2001; Gardent & Kallmeyer, 2003; Gardent,
2007).
Cet article propose d’utiliser la notion d’arbre de dérivation telle qu’introduite dans (Pogodalla,
2004). En effet, cette notion, qui précise simplement la notion originale, y est montrée comme
adéquate pour la représentation des dépendances longue distance. Néanmoins, le langage de
représentation sémantique qui est utilisé est un formalisme sous-spécifié. Ces derniers posent
parfois problème, comme dans le cas de la coordination de groupes nominaux quantifiés (Willis,
2007). De plus, nous voulons un cadre général qui laisse à l’utilisateur le choix d’utiliser ou
325
Sylvain POGODALLA
non de tels formalismes, tout en gardant la possibilité de modéliser les ambiguïtés. Ainsi, nous
utilisons un formalisme plus proche de celui proposé par Montague (Montague, 1974) et une
architecture qui permet de traiter des phénomènes d’ambiguïté. Nous nous appuyons sur les
Grammaires Catégorielles Abstraites (ACG) (de Groote, 2001), et, tout en gardant un seul arbre
dérivé, nous montrons comment le principe d’élévation de type des grammaires catégorielles
permet d’obtenir plusieurs lectures sémantiques.
Dans les deux prochaines sections, nous présentons l’arbre de dérivation de (Pogodalla, 2004)
sur des exemples. Puis nous définissons dans la section 4 la notion d’ACG et les architectures
qu’elle rend possible pour l’interface entre la syntaxe et la sémantique. La section 5 met finale-
ment en œuvre une telle architecture pour modéliser l’ambiguïté de portée des quantificateurs.
2 Lecture fonctionnelle de l’arbre dérivé
La présentation habituelle des arbres élémentaires des TAG en donne une vision relativement
statique, les opérations de substitution et d’adjonction se chargeant de donner la dynamique
du langage en combinant selon certaines règles les arbres entre eux. Dans cette section, nous
nous proposons d’intégrer cette notion de dynamique aux arbres élémentaires eux-mêmes, en
décrivant comment chacun prend part aux opérations de substitution et d’adjonction. Cette des-
cription se fait sur base d’exemples.
Soit l’arbre auxiliaire suivant : N . Lorsqu’il est adjoint à un autre arbre à un nœudN0,
un N∗
cet arbre remplace son propre nœud N∗ par le sous-arbre de racine N0. Si l’on appelle x ce sous-
arbre, on peut donc considérer l’arbre auxiliaire comme une fonction qui transforme un arbre x
en un nouvel arbre N . Soit, avec la notation à l’aide du λ-calcul, une représentation
un x
de cet arbre par le terme suivant :
cun = λx. N
un x
Considérons maintenant l’arbre initial suivant : N . Cet arbre peut se voir adjoindre un arbre
chat
auxiliaire au nœud N. Dans ce cas, il donnera comme argument à cet arbre auxiliaire (on a vu
que l’arbre auxiliaire peut être décrit comme étant une fonction qui prend un arbre en argument
et retourne un arbre) le sous arbre N (dans le cas présent, le sous-arbre paramètre est l’arbre
chat
tout entier car l’adjonction a lieu au nœud racine).
On peut donc représenter l’arbre initial comme une fonction qui prend comme paramètre un
arbre auxiliaire, c’est-à-dire une fonction des arbres dans les arbres. Soit, avec la notation en
λ-calcul :
λa.a( N )
chat
326
Ambiguïté de portée et approche fonctionnelle des TAG
On constate alors que l’opération d’adjonction qui permet d’obtenir l’arbre N est
un N
chat
décrite par l’application de la fonction (du terme) cchat au terme cun. En effet :
cchatcun = (λa.a( N ))(λx. N )→β (λx. N )( N )→β N
chat un x un x chat un N
chat
On peut finalement avoir un arbre qui combine la possibilité de subir une adjonction et une
substitution. Prenons par exemple l’arbre initial suivant : S . Sa particularité est qu’il
N↓ VP
dort
attend un arbre qui peut être substitué au nœud N d’une part, et qu’il peut subir une adjonction
au nœud VP. On choisit donc de le représenter comme une fonction qui prend en premier
argument un arbre auxiliaire, c’est-à-dire une fonction, et en deuxième argument un arbre x qui
est celui qui est substitué au nœud N. On peut alors le représenter de la manière suivante :
cdort = λax. S
x a(VP )
dort
Bien entendu, il est possible qu’aucune adjonction n’ait lieu sur le nœud VP1. Dans l’optique
que nous avons choisie, cela signifie que la fonction qui a été adjointe est l’identité I = λx.x.
L’arbre dérivé S est alors représenté par le terme cdort I (cchatcun).
N VP
un N dort
chat
Avec une représentation adéquate de l’adverbe, par exemple cpaisiblement =
λx. VP , on peut également construire l’arbre dérivé représenté par le terme
x paisiblement
cdortcpaisiblement(cchatcun) :
S
N VP
un N VP paisiblement
chat dort
1Pour des raisons de clarté dans la présentation, nous avons omis la possibilité d’une adjonction sur le nœud S,
et donc supprimé le paramètre correspondant. On voit également par là comment interdire des adjonctions.
327
Sylvain POGODALLA
Si l’on appelle γ le type des arbres, on voit que l’on a les constantes et le typage suivants :
cun : γ! γ c
c paisiblement
: γ! γ
chat : (γ! γ)! γ I : γ! γ
cdort : (γ! γ)! γ! γ
où! désigne l’implication linéaire2.
3 Rôle de l’arbre de dérivation
En typant les constantes représentant les arbres auxiliaires et initiaux de cette manière, nous
perdons toutefois une information importante : les arbres ont tous le même type γ, et aucune
distinction n’est faire entre eux. Ainsi, la composition cchatcpaisiblement serait tout à fait licite.
C’est pourquoi nous allons donner aux constantes un type plus abstrait3, correspondant aux
non-terminaux qui étiquettent leur racine. Nous nous donnons donc les types de base suivants :
VP, S, V, N ainsi que les types qui correspondent aux racines des nœuds auxiliaires : VPA, SA,
VA, NA.
Ainsi, en reprenant les exemples ci-dessus et en introduisant de nouvelles constantes, nous
avons les typages suivants :
: N
C Adort : VPA! N! S CunC
C paisiblement
: VPA
chat : NA! N IVP : VPA
On peut alors avoir le terme CdortIVP(CchatCun), de type S, tandis que le terme CchatCpaisiblement
n’est pas typable. Il reste à établir le lien avec le terme cdort(cchatcun) de la section précédente.
Cela se fait par une fonction de conversion :=syntax, le lexique, qui convertit les types et les
constantes ainsi :
S :=syntax γ Cdort :=syntax cdort
VP :=syntax γ Cun :=syntax cdort
N :=syntax γ Cchat :=syntax cchat
NA :=syntax γ! γ Cpaisiblement :=syntax cpaisiblement
VPA :=syntax γ! γ IX :=syntax λx.x pour tout type X
TAB. 1 – Définition du lexique
On alors :
CdortIVP(CchatCun) :=syntax cdortI(cchatcun)
et
CdortCpaisiblement(CchatCun) :=syntax cdortcpaisiblement(cchatcun)
Si l’on adopte une représentation arborescente des λ-termes (il n’y a pas d’abstraction), on peut
représenter CdortCpaisiblement(CchatCun) par :
2Nous ne dirons rien du calcul logique sous-jacent, ni de la manière d’introduire de la non-linéarité avec l’im-
plication intuitionniste habituelle→. Nous renvoyons les lecteurs intéressés à (de Groote, 2001; Pogodalla, 2004).
3Car pouvant être réalisé, ou instancié, de différentes manières : arbre (γ) pour la syntaxe, mais aussi individu
(e), prédicat (e! t), etc. pour la sémantique.
328
Ambiguïté de portée et approche fonctionnelle des TAG
Cdort
Cpaisiblement Cchat
Cun
Cet arbre rappelle très précisément l’arbre de dérivation tel qu’il est défini classiquement dans
les TAG. En fait, il s’agit de la même notion où sont cependant explicités :
– l’ordre des arguments, qui doit être le même pour la constante qui est représentée dans l’arbre
de dérivation et pour la constante qui lui est associée dans les arbres dérivés. Le choix est
libre, mais une fois qu’il est fait, il doit être cohérent ;
– l’ordre des adjonctions lors d’une dérivation. Contrairement à la notion classique, où cet
ordre n’est pas précisé, le résultat étant le même, ici l’ordre des opérations est spécifié. Cela
ne change pas le pouvoir expressif, cela permet par contre de doter les TAG d’une sémantique
compositionnelle basée sur l’arbre de dérivation.
Cette manière de représenter les arbres dérivés, les arbres de dérivation, et les relations qu’il y
a entre eux, correspond en fait à la modélisation des TAG dans le formalisme des ACG.
4 Modélisation des TAG dans les ACG
Nous ne reprenons pas ici le détail la modélisation systématique des TAG dans les ACG, donné
dans (de Groote, 2002; Pogodalla, 2004). Nous allons simplement donner les définitions pré-
cises des ACG qui ont été mises en œuvre dans les exemples précédents, afin d’en tirer l’ar-
chitecture générale que nous utiliserons pour modéliser les ambiguïtés de portée des quantifica-
teurs.
Une ACG définit deux langages : un langage abstrait, qui peut être vu comme un ensemble
abstrait de structures grammaticales, et un langage objet, représentant les formes réalisées des
structures abstraites, qu’elle met en relation. Ici, le langage abstrait correspond à la structure
grammaticale que l’on veut manipuler : l’arbre de dérivation. Dans l’exemple précédent, il est
mis en relation avec le langage objet des arbres dérivés grâce au lexique.
Definition 1 (Signature d’ordre supérieur). Une signature d’ordre supérieure est un triplet
Σ = 〈A,C, τ〉 où :
– A est un ensemble de types atomiques ;
– C est un ensemble fini de constantes ;
– τ : C → T (A) qui assigne à chaque constante de C un type de T (A) où T (A) ::=
A|T (A)! T (A).
On appel ΛΣ l’ensemble des λ-termes que l’on peut construire avec la signature Σ.
Ainsi, dans l’exemple précédent, nous avions deux signatures d’ordre supérieur. La première
contenait les types atomiques S,N,VPA. . . et les constantesCchat ,Cun. . . tandis que la deuxième
signature d’ordre supérieur contenait l’unique type atomique γ et les constante cchat , cun. . .
Definition 2 (Lexique). Étant données une signature d’ordre supérieur Σ1 = 〈A1, C1, τ1〉 et
une signature d’ordre supérieur Σ2 = 〈A2, C2, τ2〉, un lexique := de Σ1 vers Σ2 est défini par
la donnée de τ:= et c:= tels que :
329
Sylvain POGODALLA
– τ:= : A1 → T (A2) est une fonction d’interprétation des types atomiques de Σ1 comme
des types implicatifs construits à partir de A2. On appellera τ:= également son extension
homomorphique à tous les types de T (A1) ;
– c:= : C1 → ΛΣ2 est une fonction d’interprétation des constantes de Σ1 comme des λ-termes
construits à partir de Σ2. On appellera c:= également son extension homomorphique à tous
les termes de ΛΣ1 ;
– les fonctions d’interprétation sont compatibles avec la relation de typage, c’est-à-dire que
pour tout c ∈ C1 et t : α ∈ ΛΣ2 tels que
c
c := t, alors ττ1(c) := α (le type de l’image de c est
l’image du type de c).
Dans la suite, on utilisera sans ambiguïté := pour τ:= ou c:=.
Le tableau 1 définit bien un lexique. La colonne de gauche donne l’interprétation des types
atomiques (on remarquera avec l’interprétation du type VPA que l’interprétation d’un type
atomique peut être un type non atomique). La colonne de droite donne l’interprétation des
constantes.
Definition 3 (Grammaire catégorielle abstraite). Une grammaire catégorielle abstraite est un
quadruplet G = 〈Σ1,Σ2, :=, s〉 où :
– Σ1 est une signature d’ordre supérieure, et Σ2 une signature d’ordre supérieure. Ils sont
appelés vocabulaire abstrait et vocabulaire objet ;
– := : Σ1 → Σ2 est un lexique ;
– s est un type atomique du vocabulaire abstrait, appelé le type distingué de la grammaire.
Definition 4 (Langages abstrait et objet). Soit G = 〈Σ1,Σ2, :=, s〉 une grammaire catégo-
rielle abstraite.
1. Le langage abstrait A(G) engendré par G est défini par A(G) = {t ∈ ΛΣ1|t : s}
2. Le langage objet O(G) engendré par G est défini par
O(G) = {t ∈ ΛΣ2 |∃u ∈ A(G) avec u := t}
Ainsi, les termes pris en exemple appartiennent bien aux vocabulaires abstrait et objet. Il est
à noter que cette définition permet d’éviter que le terme cdort(cchatcpaisiblement), qui est bien un
arbre (de type γ), appartienne effectivement au langage objet des arbres dérivés. En effet, il
serait l’image de Cdort(CchatCpaisiblement) qui n’est pas de type S (ce terme n’est même pas
typable) et qui n’appartient donc pas au langage abstrait des arbres de dérivation.
La définition des ACG permet de considérer différents types d’architecture. Par exemple, si
deux ACG partagent le même vocabulaire abstrait, on aura le schéma de composition de la
figure 1(a). C’est par exemple celui adopté dans (Pogodalla, 2004) pour doter les TAG d’une
représentation sémantique sous-spécifiée.
On peut également composer deux ACG en faisant que le vocabulaire objet de l’une soit éga-
lement le vocabulaire abstrait de l’autre (figure 1(b)). C’est par exemple le cas si l’on veut
considérer le lien entre les arbres dérivés, cette fois vus comme un langage abstrait, et leur
production (yield en anglais) comme langage de chaîne.
Bien entendu, on peut mélanger ces deux types de composition. La modélisation que nous
proposons pour les phénomènes d’ambiguïté de portée des quantificateurs repose sur le schéma
de la figure 1(c). Dans tous les cas, on retrouve un schéma classique du TAL, même si la relation
est décrite par un autre formalisme : celui de la composition de transducer.
330
Ambiguïté de portée et approche fonctionnelle des TAG
Gsyntax
G
G yield
Gsyntax URL
(a) Composition par partage de vocabulaire abstrait (b) Composition par identification de vocabulaires
abstrait et objet
G
mb semGa
Gsyntax
(c) Composition par combinaison des deux modes
FIG. 1 – Exemples d’architectures possibles
5 Composition d’ACG et modélisation des ambiguïtés de
portée
Proposition. Notre objectif est de proposer pour les TAG un cadre dans lequel modéliser
les ambiguïtés de portée sans utiliser de formalisme sous-spécifié (contrairement à (Pogodalla,
2004)), tout en gardant la contrainte d’avoir un unique arbre dérivé auquel peuvent être asso-
ciées plusieurs représentations sémantiques. Pour l’architecture que nous proposons, il nous faut
définir deux nouvelles ACG. La première, Gamb, permettra d’associer à un arbre de dérivation
unique deux structures plus profondes. La seconde, Gsem, correspondra à la réalisation dans un
langage de formes logiques du type de Montague de ces structures plus profondes.
On pourra penser que ces différents niveaux ajoutent de la complexité conceptuelle. Nous pen-
sons pour notre part que cela permet de modulariser les difficultés (en ne traitant qu’à leurs
niveaux respectifs la syntaxe, avec Gsyntax, et la sémantique, avec Gamb et Gsem). Par ailleurs,
nous avons vu que cette notion de composition est déjà présente en TAL avec l’utilisation de
transducer et de leur composition, pour le traitement de la morphologie par exemple. Si au final
seule la relation entre les langages d’entrée et sortie nous intéresse, il est tout à fait possible de
compiler deux ACG, par exemple Gamb et Gsyntax en une seule, leur composée.
Supposons que la grammaire Gsyntax contiennent également les arbres suivants :
cchasse = λaxy. S , cchien = λa.a( N ) et ctout = λx. N , ainsi que les
x a(VP ) chien tout x
chasse y
constantes Cchien : NA ! N, Cchasse : VPA ! N! N! S et Ctout : NA mis en relation par
le lexique de la manière suivante : Cchasse:=syntaxcchasse, Cchien:=syntaxcchien et Ctout :=syntaxctout .
331
Sylvain POGODALLA
Alors l’arbre de dérivation correspondant à l’arbre dérivé
cchasse(cchienctout)(cchatcun):=syntax S
N VP
tout N chasse N
chien un N
chat
est t0 = CchasseIVP(CchienCtout)(CchatCun).
Définissons maintenant Gamb, dont le vocabulaire objet est le vocabulaire abstrait de Gsyntax, et
dont le vocabulaire abstrait contient les mêmes symboles de type que le vocabulaire objet mais
les constantes typées Dchasse : VPA ! N ! N ! S, Dchien : NA ! (N ! S) ! S,
Dchat : NA ! (N! S)! S, Dtout : NA, Dun : NA et IDVP : VPA. Le lexique :=amb est tel que
pour tout type X , X:=ambX et :
Dchasse :=amb Cchasse Dchien :=amb λaP.P (Cchien a)
Dtout :=amb Ctout Dchat :=amb λaP.P (Cchat a)
Dun :=amb Cun IDVP :=amb IVP
Soit alors les termes :
t1 = (DchienDtout)(λx.(DchatDun)(λy.DchasseIDVP x y))
t2 = (DchatDun)(λy.(DchienDtout)(λx.DchasseIDVP x y))
On pourra vérifier que t1 et t2 sont bien typés et que t1:=amb t0 et t2:=amb t0. Ainsi, nous avons
désormais deux structures profondes (t1 et t2) reliées à un seul arbre de dérivation (t0).
Il nous reste à transformer ces structures en formules logiques à l’aide d’une nouvelle ACG
Gsem. Celle-ci partage son vocabulaire abstrait avec Gamb, et, au niveau objet, met en œuvre les
types habituels e et t pour les représentations à la Montague. Avec le lexique :=sem4 suivant5 :
Dchasse :=sem λaso.(a(λx.chasse x o))s
S :=sem t Dtout :=sem λPQ.∀x.P x⇒ Qx
N :=sem e Dun :=sem λPQ.∃x.P x ∧Qx
NA :=sem (e→ t)→ (e→ t)→ t Dchat :=sem λq.q(λx.chat x)
VPA :=sem (e→ t)→ (e→ t) Dchien :=sem λq.q(λx.chienx)
IDVP :=sem λx.x
Nous laissons le lecteur vérifier que l’on obtient bien alors les deux lectures :
t1 :=sem ∀x.chienx⇒ (∃y.chat y ∧ chasse x y)
t2 :=sem ∃y.chat y ∧ (∀x.chienx⇒ chasse x y)
Faute de place, nous ne pouvons illustrer également la coordination de groupes nominaux
quantifiés avec les constantes Cet : N ! N ! N, Det : ((N ! S) ! S) ! ((N !
4On suppose présentes dans la signature objet les constantes chasse : e ! e ! t, chien : e ! t, chat :
e! t, ∀ : (e→ t)! t et ∃ : (e→ t)! t.
5Notons que c’est la présence du paramètre a dans la formule sémantique qui réalise Dchasse qui permet, en
intégrant la contribution des éventuels sous-arbres adjoints, la prise en compte des dépendances longue distance.
332
Ambiguïté de portée et approche fonctionnelle des TAG
S) ! S) ! ((N ! S) → S) et leur réalisation Det :=amb λPQr.P (λx.Q(λy.r(Cet x y))) et
Det :=sem λPQr.P r ∧Qr. On aurait par exemple les deux termes
t3 = Det(DchatDtout)(DchienDun)(λx.(DsourisDune)(λy.DchasseIDVP x y))
t4 = (DsourisDune)(λy.Det(DchatDtout)(DchienDun)(λx.DchasseIDVP x y))
qui donneraient les deux lectures attendues pour tout chat et un chien chassent une souris.
Contrairement au problème soulevé par les représentations sous-spécifiées dans (Willis, 2007),
on n’a pas la lecture où tout chat a une portée différente de un chien vis à vis de la portée de une
souris. On obtient ainsi une architecture dans laquelle modéliser les phénomènes d’ambiguïté
de portée sans imposer l’utilisation de formalismes sous-spécifiés.
Limitations. Actuellement, nous ne savons pas exprimer les contraintes de portée des quan-
tificateurs, telles celles des îlots de portée. Ce problème est comparable à celui rencontré par
les grammaires de types logiques. En effet, l’approche proposée ici repose sur le principe de
l’élévation de type, qui est à la base de la prise en compte des ambiguïtés de portée dans ces
grammaires. Ici, nous avons gardé la contrainte supplémentaire que, bien entendu, l’arbre dé-
rivé et l’arbre de dérivation restent uniques. La solution que nous envisageons repose sur une
extension du système de type des ACG, et va bien au-delà du sujet de cet article6.
6 Conclusion
Nous avons montré comment, en se basant sur la définition précise de l’arbre de dérivation
de (Pogodalla, 2004), nous pouvons définir un calcul des représentations sémantiques pour les
TAG qui ne nécessite pas l’usage de formalismes sous-spécifiés tout en permettant le traitement
de l’ambiguïté. Cela nous permet d’une part de renforcer l’indépendance entre le formalisme
syntaxique des TAG et le formalisme choisi par l’utilisateur pour la représentation sémantique,
et d’autre par de confirmer l’importance de cette notion d’arbre de dérivation. Par ailleurs,
notre approche a de forts liens avec les approches de Glue Semantics (Dalrymple, 2001), et
la proposition (Frank & van Genabith, 2001) (utilisant les principes de Glue Semantics depuis
l’arbre dérivé) pourrait sans doute être reconsidérée avec cette notion d’arbre de dérivation.
Références
ABEILLÉ A. (1993). Les nouvelles syntaxes. Paris : Armand Colin Éditeur.
DALRYMPLE M. (2001). Lexical Functional Grammar, volume 42 of Syntax and Semantics
series. Academic Press.
DE GROOTE P. (2001). Towards abstract categorial grammars. In Association for Computa-
tional Linguistics, 39th Annual Meeting and 10th Conference of the European Chapter, Pro-
ceedings of the Conference, p. 148–155.
DE GROOTE P. (2002). Tree-adjoining grammars as abstract categorial grammars. In TAG+6,
Proceedings of the sixth International Workshop on Tree Adjoining Grammars and Related
Frameworks, p. 145–150 : Università di Venezia.
6Faute de place, nous ne pouvons pas exposer comment l’architecture proposée ici permet également de dépas-
ser la limitation mentionnée dans (Pogodalla, 2004) pour les verbes à contrôle.
333
Sylvain POGODALLA
FRANK A. & VAN GENABITH J. (2001). Glue tag : Linear logic based semantics construction
for LTAG - and what it teaches us about the relation between LFG and LTAG. In M. BUTT &
T. H. KING, Eds., Proceedings of the LFG ’01 Conference, Online Proceedings : CSLI Publi-
cations. http://cslipublications.stanford.edu/LFG/6/lfg01.html.
GARDENT C. (2007). Tree adjoining grammar, semantic calculi and labelling invariants. In
(Getzen et al., 2007).
GARDENT C. & KALLMEYER L. (2003). Semantic construction in feature-based tag. In Pro-
ceedings of the 10th Meeting of the European Chapter of the Association for Computational
Linguistics (EACL).
J. GETZEN, E. THIJSSE, H. BUNT & A. SCHIFFRIN, Eds. (2007). Proceedings of the Seventh
International Workshop on Computational Semantics, IWCS-7. Tilburg University.
JOSHI A. K., KALLMEYER L. & ROMERO M. (2003). Flexible composition in ltag : Quan-
tifier scope and inverse linking. In H. BUNT, I. VAN DER SLUIS & R. MORANTE, Eds.,
Proceedings of the Fifth International Workshop on Computational Semantics IWCS-5.
JOSHI A. K. & SCHABES Y. (1997). Tree-adjoining grammars. In G. ROZENBERG & A.
SALOMAA, Eds., Handbook of formal languages, chapter 2. Springer.
KALLMEYER L. (2002). Using an enriched tag derivation structure as basis for semantics.
In Proceedings of the Sixth International Workshop on Tree Adjoining Grammar and Related
Frameworks (TAG+6).
MONTAGUE R. (1974). The proper treatment of quantification in ordinary english. In P.
PORTNER & B. H. PARTEE, Eds., Formal Semantics : The Essential Readings, chapter 1.
Blackwell Publishers. 2002 edition.
POGODALLA S. (2004). Computing semantic representation : Towards ACG abstract terms
as derivation trees. In Proceedings of the Seventh International Workshop on Tree Adjoining
Grammar and Related Formalisms (TAG+7), p. 64–71.
WILLIS A. (2007). NP coordination in underspecified scope representations. In (Getzen et al.,
2007).
334
