<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Calculs d&#8217;unification sur les arbres de d&#233;rivation TAG</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2008, Avignon, 9&#8211;13 juin 2008
</p>
<p>Calculs d&#8217;unification sur les arbres de d&#233;rivation TAG
</p>
<p>Sylvain Schmitz1 Joseph Le Roux2
</p>
<p>(1) LORIA, INRIA Nancy Grand Est, Nancy
(2) LORIA, Universit&#233; Nancy 2, Nancy
</p>
<p>Sylvain.Schmitz@loria.fr, Joseph.LeRoux@loria.fr
</p>
<p>R&#233;sum&#233;. Nous d&#233;finissons un formalisme, les grammaires rationnelles d&#8217;arbres avec traits,
et une traduction des grammaires d&#8217;arbres adjoints avec traits vers ce nouveau formalisme. Cette
traduction pr&#233;serve les structures de d&#233;rivation de la grammaire d&#8217;origine en tenant compte de
l&#8217;unification de traits. La construction peut &#234;tre appliqu&#233;e aux r&#233;alisateurs de surface qui se
fondent sur les arbres de d&#233;rivation.
</p>
<p>Abstract. The derivation trees of a tree adjoining grammar provide a first insight into the
sentence semantics, and are thus prime targets for generation systems. We define a formalism,
feature based regular tree grammars, and a translation from feature based tree adjoining gram-
mars into this new formalism. The translation preserves the derivation structures of the original
grammar, and accounts for feature unification.
</p>
<p>Mots-cl&#233;s : Unification, grammaire d&#8217;arbres adjoints, arbre de d&#233;rivation, grammaire
rationnelle d&#8217;arbres.
</p>
<p>Keywords: Unification, tree adjoining grammar, derivation tree, regular tree grammar.
</p>
<p>1 Introduction
</p>
<p>Le processus de d&#233;rivation dans les grammaires d&#8217;arbres adjoints (Joshi &amp; Schabes, 1997, TAG)
produit deux arbres : l&#8217;arbre d&#233;riv&#233; qui correspond &#224; un arbre syntagmatique classique (voir
figure 1b), et l&#8217;arbre de d&#233;rivation, qui pr&#233;sente par quelles op&#233;rations les arbres &#233;l&#233;mentaires
de la grammaire ont &#233;t&#233; combin&#233;s pour obtenir l&#8217;arbre d&#233;riv&#233; (voir figure 1a). Selon la t&#226;che de
traitement de la langue, il sera plus ad&#233;quat de consid&#233;rer l&#8217;un ou l&#8217;autre, l&#8217;arbre d&#233;riv&#233; &#233;tant en
correspondance avec les lex&#232;mes d&#8217;une phrase, tandis que l&#8217;arbre de d&#233;rivation donne une vue
s&#233;mantique primitive de la phrase, comme le montrent par exemple Candito &amp; Kahane (1998).
</p>
<p>De fait, l&#8217;arbre de d&#233;rivation est privil&#233;gi&#233; dans plusieurs approches pour la r&#233;alisation de
surface (Koller &amp; Striegnitz, 2002; Koller &amp; Stone, 2007). Il sert aussi de pivot &#224; partir du-
quel repr&#233;sentation s&#233;mantique et arbre d&#233;riv&#233; peuvent &#234;tre g&#233;n&#233;r&#233;s dans les approches de de
Groote (2002), Pogodalla (2004) et Kanazawa (2007) &#224; base de grammaires cat&#233;gorielles abs-
traites.
</p>
<p>Ces travaux ne sont cependant pas imm&#233;diatement applicables &#224; des grammaires r&#233;alistes qui
emploient une variante des TAG &#224; base de structures de traits (Vijay-Shanker, 1992, voir par
exemple la figure 2). Cette variante munit les n&#339;uds des arbres &#233;l&#233;mentaires de structures de
traits, dont les unifications contraignent les op&#233;rations de substitution ou d&#8217;adjonction du n&#339;ud.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain Schmitz, Joseph Le Roux
</p>
<p>radis
</p>
<p>gris
</p>
<p>le
</p>
<p>creux
</p>
<p>est
</p>
<p>subst
</p>
<p>adj
</p>
<p>adj
</p>
<p>subst
</p>
<p>(a) Arbre de d&#233;rivation.
</p>
<p>S
</p>
<p>N
</p>
<p>AdjN
</p>
<p>N
</p>
<p>radis gris
</p>
<p>D
</p>
<p>le
</p>
<p>Adj
</p>
<p>creuxest
</p>
<p>V
</p>
<p>VP
</p>
<p>[
det : &#8722;
</p>
<p>num : sg
</p>
<p>]
</p>
<p>[num : sg ]
[
</p>
<p>det : &#8722;
</p>
<p>num : sg
</p>
<p>]
</p>
<p>[
det : +
</p>
<p>num : sg
</p>
<p>]
</p>
<p>(b) Arbre d&#233;riv&#233;.
</p>
<p>FIG. 1: D&#233;rivation de la phrase &#171; Le radis gris est creux. &#187; avec la grammaire de la figure 2.
</p>
<p>N&#8727;
</p>
<p>N
r
</p>
<p>D&#8900;
</p>
<p>le
</p>
<p>Adj&#8900;
</p>
<p>gris
</p>
<p>N
r
</p>
<p>N&#8727;radis
</p>
<p>N&#8900;
</p>
<p>VP
</p>
<p>S
</p>
<p>N&#8595;
</p>
<p>Adj&#8900;V&#8595;
</p>
<p>creux
</p>
<p>V&#8900;
</p>
<p>est
</p>
<p>top:
</p>
<p>[
det : +
</p>
<p>num : x
</p>
<p>]
bot:[det : &#8722; ] bot:
</p>
<p>[
det : +
</p>
<p>num : sg
</p>
<p>]
bot:
</p>
<p>[
det : &#8722;
</p>
<p>num : x
</p>
<p>]
</p>
<p>bot:
</p>
<p>[
det : &#8722;
</p>
<p>num : x
</p>
<p>]
bot:
</p>
<p>[
det : &#8722;
</p>
<p>num : sg
</p>
<p>]
</p>
<p>bot:[num : sg ]
top:[num : x ]
</p>
<p>FIG. 2: Exemple de grammaire d&#8217;arbres adjoints avec structures de traits.
</p>
<p>Ces structures ne posent en th&#233;orie aucun probl&#232;me, car les domaines de valeur des diff&#233;rents
traits sont finis et il suffit de d&#233;multiplier le nombre de symboles non-terminaux pour &#233;muler les
diff&#233;rentes structures possibles. Mais le nombre de ces structures s&#8217;accommode mal de cette vi-
sion na&#239;ve : par exemple, les vingt-huit traits syntaxiques utilis&#233;s dans la grammaire SEMFRAG
du fran&#231;ais (Gardent, 2006) d&#233;crivent un domaine, certes fini, mais comprenant plus de 214 mil-
liards d&#8217;&#233;l&#233;ments. Enfin, l&#8217;argument du domaine fini ne tient tout simplement pas pour certains
m&#233;canismes de construction s&#233;mantique fond&#233;s sur l&#8217;unification de traits d&#8217;index s&#233;mantiques
qui ont des domaines de valeur non finis (Gardent &amp; Kallmeyer, 2003; Gardent, 2006).
</p>
<p>Nous &#233;tudions dans cet article la traduction d&#8217;une grammaire d&#8217;arbres adjoints avec structures
de traits en une grammaire rationnelle d&#8217;arbres de d&#233;rivation qui en pr&#233;serve les m&#233;canismes
d&#8217;unification de traits. Plus en d&#233;tail,
&#8211; nous rappelons comment traduire une grammaire TAG en une grammaire rationnelle d&#8217;arbres
(RTG) qui en g&#233;n&#232;re les arbres de d&#233;rivation (section 2.1),
</p>
<p>&#8211; puis nous d&#233;finissons un formalisme de grammaires rationnelles d&#8217;arbres enrichies par des
structures de traits et montrons comment traduire une grammaire TAG dans ce nouveau for-
malisme (section 2.2) ;
</p>
<p>&#8211; enfin, nous proposons une seconde traduction qui am&#233;liore l&#8217;efficacit&#233; de la g&#233;n&#233;ration des
arbres de d&#233;rivation TAG (section 3).
</p>
<p>Nous supposons que le lecteur est familier avec les aspects th&#233;oriques des grammaires d&#8217;arbres
adjoints (Joshi &amp; Schabes, 1997), des grammaires rationnelles d&#8217;arbres (Comon et al., 2007) et
de l&#8217;unification (Robinson, 1965)1.
</p>
<p>1Pour &#233;viter toute confusion avec l&#8217;op&#233;ration de substitution dans les TAG, la notion de substitution que l&#8217;on
trouve associ&#233;e &#224; l&#8217;unification sera appel&#233;e u-substitution dans la suite.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Calculs d&#8217;unification sur les arbres de d&#233;rivation TAG
</p>
<p>2 Arbres de d&#233;rivation et unification
</p>
<p>Un arbre de d&#233;rivation d&#8217;une grammaire d&#8217;arbres adjoints a des n&#339;uds &#233;tiquet&#233;s par des arbres
&#233;l&#233;mentaires de la grammaire et en guise d&#8217;ar&#234;tes les relations d&#8217;adjonctions et substitutions
permises par la grammaire entre arbres &#233;l&#233;mentaires. Dans un premier temps, nous reformulons
la description donn&#233;e par de Groote (2002) des arbres de d&#233;rivation qu&#8217;une grammaire d&#8217;arbres
adjoints peut engendrer, en utilisant explicitement une grammaire rationnelle d&#8217;arbres. Dans
un second temps, nous montrons comment les calculs d&#8217;unification de l&#8217;arbre d&#233;riv&#233; peuvent
s&#8217;int&#233;grer simplement dans cette grammaire rationnelle.
</p>
<p>2.1 Grammaire rationnelle des arbres de d&#233;rivation
</p>
<p>Formellement, une grammaire d&#8217;arbres adjoints &#12296;&#931;, N, I, A, S&#12297; est constitu&#233;e d&#8217;un alphabet
terminal &#931;, d&#8217;un alphabet non-terminal N , d&#8217;un ensemble I d&#8217;arbres initiaux &#945;, d&#8217;un ensemble
A d&#8217;arbres auxiliaires &#946;, et d&#8217;un non-terminal distingu&#233; S deN . Nous d&#233;signons par &#947;r le n&#339;ud
racine de l&#8217;arbre &#233;l&#233;mentaire &#947; et par &#946;f le n&#339;ud pied de l&#8217;arbre auxiliaire &#946;.
</p>
<p>Les n&#339;uds d&#8217;un arbre &#233;l&#233;mentaire &#947; de I &#8746; A qui nous int&#233;ressent sont &#233;tiquet&#233;s par des non-
terminaux, et permettent une op&#233;ration de substitution ou d&#8217;adjonction ; nous consid&#233;rons en
particulier que le pied d&#8217;un arbre auxiliaire ne permet pas d&#8217;adjonction2. Nous num&#233;rotons ces
n&#339;uds par un parcours arbitraire depuis la racine, de sorte que &#947;1 = &#947;r. Nous notons lab(&#947;i)
l&#8217;&#233;tiquette dans N du n&#339;ud &#947;i.
</p>
<p>Pour construire la grammaire rationnelle &#12296;S,N &#8746; NA,F , R&#12297; des arbres de d&#233;rivation, nous
d&#233;finissons :
&#8211; l&#8217;ensemble des arbres &#233;l&#233;mentaires comme notre alphabet ordonn&#233; F = I &#8746; A &#8746; {&#949;}, o&#249; le
rang n = rg(&#947;) d&#8217;un arbre &#233;l&#233;mentaire &#947; est le nombre de ses n&#339;uds o&#249; une substitution ou
une adjonction est possible, et o&#249; &#949;, de rang 0, repr&#233;sente une feuille vide ;
</p>
<p>&#8211; l&#8217;alphabet non-terminal N et un duplicata NA = {XA | X &#8712; N} comme alphabet de la
grammaire rationnelle ; &#224; chaque n&#339;ud non terminal &#947;i d&#8217;un arbre &#233;tiquet&#233; par X = lab(&#947;i),
on associe un non terminal nt(&#947;i) de forme X dans N s&#8217;il permet une substitution ou XA
dans NA s&#8217;il permet une adjonction ;
</p>
<p>&#8211; l&#8217;ensemble de r&#232;gles R d&#233;fini comme l&#8217;union
</p>
<p>{X &#8722;&#8594; &#945;(nt(&#945;1), . . . , nt(&#945;n)) | &#945; &#8712; I, n = rg(&#945;), X = lab(&#945;r)}
&#8746; {XA &#8722;&#8594; &#946;(nt(&#946;1), . . . , nt(&#946;n)) | &#946; &#8712; A, n = rg(&#946;), X = lab(&#946;r)}
&#8746; {XA &#8722;&#8594; &#949; | XA &#8712; NA}
</p>
<p>(1)
</p>
<p>Les arbres initiaux de la grammaire TAG sont ainsi associ&#233;s &#224; des r&#232;gles de la forme
X &#8722;&#8594; &#945;(Y1, . . . , Yn) et les arbres auxiliaires &#224; des r&#232;gles XA &#8722;&#8594; &#946;(Y1, . . . , Yn), o&#249; X est le
non terminal qui &#233;tiquette la racine de l&#8217;arbre &#233;l&#233;mentaire TAG. Enfin, la possibilit&#233; d&#8217;une ad-
jonction non r&#233;alis&#233;e est simul&#233;e par les r&#232;gles XA &#8722;&#8594; &#949;. On peut observer que la taille de la
grammaire RTG obtenue est &#233;quivalente &#224; la taille de la grammaire TAG d&#8217;origine. La traduc-
tion elle-m&#234;me peut &#234;tre calcul&#233;e en temps lin&#233;aire.
</p>
<p>Puisque la grammaire TAG de la figure 2 ne propose pas d&#8217;arbre auxiliaire enracin&#233; par S, VP ,
Adj ouD, on peut simplifier les r&#232;gles en ignorant ces n&#339;uds d&#8217;adjonction. La figure 3a montre
</p>
<p>2Dans un souci de concision, nous ne traitons pas les contraintes d&#8217;adjonction s&#233;lective, qui ne posent aucune
difficult&#233; conceptuelle.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain Schmitz, Joseph Le Roux
</p>
<p>&#12296;S, {S, V, VA, N,NA},
{creux, est, radis, gris, le, &#949;},
{S &#8722;&#8594; creux(N, V ),
V &#8722;&#8594; est(VA),
VA &#8722;&#8594; &#949;,
N &#8722;&#8594; radis(NA),
NA &#8722;&#8594; gris(NA),
NA &#8722;&#8594; le(NA),
NA &#8722;&#8594; &#949;}&#12297;
</p>
<p>(a) Grammaire rationnelle d&#8217;arbres.
</p>
<p>gris
</p>
<p>gris
</p>
<p>&#949;
</p>
<p>radis est
</p>
<p>creux
</p>
<p>radis
</p>
<p>&#949;
</p>
<p>est
</p>
<p>creux
</p>
<p>&#949;
</p>
<p>&#949; &#949; &#949;le
</p>
<p>le
</p>
<p>le
</p>
<p>radis est
</p>
<p>creux
</p>
<p>(b) Exemples d&#8217;arbres g&#233;n&#233;r&#233;s.
</p>
<p>FIG. 3: Grammaire rationnelle correspondant &#224; la grammaire TAG de la figure 2.
</p>
<p>la grammaire simplifi&#233;e pour les arbres de la figure 2. Il est ais&#233; de v&#233;rifier que cette grammaire
rationnelle g&#233;n&#232;re les arbres enracin&#233;s par &#171; creux &#187;, avec &#171; radis &#187; et &#171; est &#187; pour deux fils,
et une combinaison arbitraire de n&#339;uds &#171; le &#187; et &#171; gris &#187; comme descendance de &#171; radis &#187;
(voir figure 3b) : la grammaire rationnelle g&#233;n&#232;re les arbres de d&#233;rivation d&#8217;une version sans
structures de traits de la grammaire TAG d&#8217;origine.
</p>
<p>2.2 Calculs d&#8217;unification
</p>
<p>Grammaire rationnelle d&#8217;arbres avec traits Afin de traduire les restrictions impos&#233;es par
les structures de traits de la grammaire TAG, nous consid&#233;rons dans notre RTG non plus de
simples r&#233;&#233;critures entre termes, mais des surr&#233;ductions (Hanus, 1994), c&#8217;est-&#224;-dire des r&#233;&#233;cri-
tures assorties d&#8217;unifications, avec des variables dans (N &#8746;NA)&#215;D o&#249; D d&#233;signe l&#8217;ensemble
des structures de traits possibles3.
</p>
<p>Definition 1. Une grammaire rationnelle d&#8217;arbres avec traits &#12296;S,N,F ,D, R&#12297; est compos&#233;e
d&#8217;un axiome S, d&#8217;un ensemble de symboles non-terminaux N contenant S, d&#8217;un alphabet or-
donn&#233; de terminaux F , d&#8217;un ensemble de structures de traits D, et d&#8217;un ensemble de r&#232;gles
de forme (A, d) &#8722;&#8594; a((B1, d&#8242;1), . . . , (Bn, d&#8242;n)) avec A,B1, . . . , Bn des non-terminaux de N ,
d, d&#8242;1, . . . , d
</p>
<p>&#8242;
n des structures de traits de D, et a un terminal d&#8217;arit&#233; n de F .
</p>
<p>La relation de d&#233;rivation =&#8658; associ&#233;e &#224; G = &#12296;S,N,F ,D, R&#12297; met en relation des paires asso-
ciant un terme4 de T (F , N &#215; D) et une u-substitution, de telle sorte que (s, e) =&#8658; (t, e&#8242;) si et
seulement s&#8217;il existe un contexte5 C, une r&#232;gle (A, d) &#8722;&#8594; a((B1, d&#8242;1), . . . , (Bn, d&#8242;n)) dans R avec
des variables fra&#238;ches dans les structures d, d&#8242;1, . . . , d
</p>
<p>&#8242;
n et une u-substitution &#963; tels que
</p>
<p>s = C[(A, d&#8242;)], &#963; = mgu(d, e(d&#8242;)), t = C[a((B1, &#963;(d&#8242;1)), . . . , (Bn, &#963;(d
&#8242;
n)))] et e
</p>
<p>&#8242; = &#963; &#9702; e
3&#201;tant donn&#233;es deux structures de traits d et d&#8242; de D, on d&#233;signe par l&#8217;u-substitution &#963; = mgu(d, d&#8242;) leur
</p>
<p>unificateur le plus g&#233;n&#233;ral s&#8217;il existe. Nous notons &gt; l&#8217;&#233;l&#233;ment le plus g&#233;n&#233;ral de D, et id l&#8217;u-substitution identit&#233;.
4L&#8217;ensemble des termes sur l&#8217;alphabet F et l&#8217;ensemble de variables X est not&#233; T (F ,X ) ; en particulier
</p>
<p>T (F , &#8709;) = T (F) est l&#8217;ensemble des arbres sur F .
5Un contexte C de T (F ,X ) est un terme de T (F ,X &#8746; {x}), x 6&#8712; X , qui ne contient qu&#8217;une seule occurrence
</p>
<p>de x, et le terme C[t] pour un terme t de T (F ,X ) est obtenu en rempla&#231;ant cette occurrence par t dans C.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Calculs d&#8217;unification sur les arbres de d&#233;rivation TAG
</p>
<p>Le langage g&#233;n&#233;r&#233; par G est L(G) = {t &#8712; T (F) | &#8707;e, ((S,&gt;), id) =&#8658;&#8727; (t, e)}.
</p>
<p>La propagation des unifications de traits se fait hi&#233;rarchiquement par la recherche de l&#8217;unifi-
cateur le plus g&#233;n&#233;ral mgu &#224; chaque &#233;tape de d&#233;rivation. L&#8217;u-substitution e globale associ&#233;e
comme environnement &#224; notre terme sert &#224; communiquer les r&#233;sultats des unifications dans les
diff&#233;rentes branches du terme.
</p>
<p>Traduction de TAG vers RTG avec traits Munis de cette d&#233;finition op&#233;rationnelle d&#8217;une
RTG avec unification, nous enrichissons notre traduction de TAG vers RTG pour tenir compte
des structures de traits des n&#339;uds des arbres TAG. Nous d&#233;finissons feats(&#947;i) comme la structure
de traits deD associ&#233;e au n&#339;ud &#947;i de l&#8217;arbre &#233;l&#233;mentaire &#947;. Cette structure est compos&#233;e de deux
ensembles hauts et bas de traits atomiques top(&#947;i) et bot(&#947;i).
</p>
<p>La traduction est &#233;tablie sur la notion d&#8217;interface in(&#947;) offerte par chaque arbre &#233;l&#233;mentaire TAG
&#947;, qui servira de structure de traits de la partie gauche des r&#232;gles de la grammaire rationnelle
d&#8217;arbres avec traits. Dans le cas d&#8217;un arbre initial &#945;, la structure [top : top(&#945;r)] doit s&#8217;unifier
avec celle du n&#339;ud de substitution. Dans le cas d&#8217;un arbre auxiliaire &#946;, la structure [top :
top(&#946;r), bot : bot(&#946;f )] doit s&#8217;unifier avec celle du n&#339;ud d&#8217;adjonction. Il reste &#224; coindexer ces
interfaces avec les structures de la partie droite de chaque r&#232;gle ; le seul cas &#224; traiter est celui
de la racine de l&#8217;arbre &#233;l&#233;mentaire, pour laquelle nous d&#233;finissons une fonction featsr. Nous
d&#233;finissons ainsi pour tout &#945; dans I , &#946; dans A et &#947; dans I &#8746; A, &#224; l&#8217;aide d&#8217;une variable fra&#238;che t
</p>
<p>in(&#945;) =
[
top : t
top : top(&#945;r)
</p>
<p>]
(2)
</p>
<p>in(&#946;) =
[
top : t
top : top(&#946;r)
bot : bot(&#946;f )
</p>
<p>]
(3)
</p>
<p>featsr(&#947;1) =
[
top : t
bot : bot(&#947;1)
</p>
<p>]
(4)
</p>
<p>Pour un n&#339;ud &#947;i, nous d&#233;finissons tr(&#947;i) = (nt(&#947;i), feats(&#947;i)) et trr(&#947;1) = (nt(&#947;1), featsr(&#947;1)).
L&#8217;ensemble de r&#232;gles de notre grammaire rationnelle d&#8217;arbres avec traits pour une grammaire
TAG &#12296;&#931;, N, I, A, S&#12297; est alors
</p>
<p>{(X, in(&#945;)) &#8722;&#8594; &#945;(trr(&#945;1), tr(&#945;2), . . . , tr(&#945;n)) | &#945; &#8712; I, n = rg(&#945;), X = lab(&#945;r)}
&#8746; {(XA, in(&#946;)) &#8722;&#8594; &#946;(trr(&#946;1), tr(&#946;2), . . . , tr(&#946;n)) | &#946; &#8712; A, n = rg(&#946;), X = lab(&#946;r)}
&#8746; {XA
</p>
<p>[
top : x
bot : x
</p>
<p>] &#8722;&#8594; &#949; | XA &#8712; NA, x variable de D} (5)
Les r&#232;gles d&#233;rivant la feuille vide &#949; effectuent l&#8217;unification finale entre traits hauts et bas des
n&#339;uds de la grammaire TAG.
</p>
<p>Nous obtenons alors l&#8217;ensemble de r&#232;gles suivant pour la grammaire rationnelle enrichie de
structures de traits correspondant &#224; la grammaire TAG de la figure 2 :
</p>
<p>(S,&gt;) &#8722;&#8594; creux (N [ top : &#187; det : +num : x &#8211;] , V [ top : [num : x ] ])
V [ top : t ] &#8722;&#8594; est (VA [ top : tbot : [num : sg ]])
</p>
<p>VA
[
top : x
bot : x
</p>
<p>] &#8722;&#8594; &#949;
N [ top : t ] &#8722;&#8594; radis (NA [ top : tbot : [det : &#8722; ]])
</p>
<p>NA
</p>
<p>[
top : t
</p>
<p>bot :
</p>
<p>&#187;
det : &#8722;
</p>
<p>num : x
</p>
<p>&#8211;] &#8722;&#8594; gris(NA [ top : tbot : &#187; det : &#8722;
num : x
</p>
<p>&#8211;])
NA
</p>
<p>[
top : t
</p>
<p>bot :
</p>
<p>&#187;
det : &#8722;
</p>
<p>num : sg
</p>
<p>&#8211;] &#8722;&#8594; le(NA [ top : tbot : &#187; det : +
num : sg
</p>
<p>&#8211;])
NA
</p>
<p>[
top : x
bot : x
</p>
<p>] &#8722;&#8594; &#949;
</p>
<p>(6)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain Schmitz, Joseph Le Roux
</p>
<p>0 : ((S,&#8868;), id)
</p>
<p>1 :
(
creux(N
</p>
<p>[
top :
</p>
<p>&#187;
det : +
</p>
<p>num : 0x
</p>
<p>&#8211;]
, V [ top : [num : 0x ] ]), id
</p>
<p>)
</p>
<p>2 :
(
radis
</p>
<p>(
NA
</p>
<p>[
top :
</p>
<p>&#187;
det : +
</p>
<p>num : 0x
</p>
<p>&#8211;
</p>
<p>bot : [ det : &#8722; ]
</p>
<p>])
, {1t 7&#8594;
</p>
<p>[
det : +
</p>
<p>num : 0x
</p>
<p>]
}
)
</p>
<p>4 :
</p>
<p>(
le
</p>
<p>(
NA
</p>
<p>[
top :
</p>
<p>&#187;
det : +
</p>
<p>num : 0x
</p>
<p>&#8211;
</p>
<p>bot :
</p>
<p>&#187;
det : +
</p>
<p>num : sg
</p>
<p>&#8211;
])
</p>
<p>, {111t 7&#8594;
[
</p>
<p>det : +
</p>
<p>num : 0x
</p>
<p>]
, 11x 7&#8594; sg}
</p>
<p>)
</p>
<p>5 : (&#949;, {1111x 7&#8594;
[
</p>
<p>det : +
</p>
<p>num : sg
</p>
<p>]
, 0x 7&#8594; sg})
</p>
<p>6 :
(
est
</p>
<p>(
VA
</p>
<p>[
top : [num : sg ]
bot : [num : sg ]
</p>
<p>])
, {2t 7&#8594; [num : sg ]}
</p>
<p>)
</p>
<p>3 :
</p>
<p>(
gris
</p>
<p>(
NA
</p>
<p>[
top :
</p>
<p>&#187;
det : +
</p>
<p>num : 0x
</p>
<p>&#8211;
</p>
<p>bot :
</p>
<p>&#187;
det : &#8722;
</p>
<p>num : 11x
</p>
<p>&#8211;
])
</p>
<p>, {11t 7&#8594;
[
</p>
<p>det : +
</p>
<p>num : 0x
</p>
<p>]
}
</p>
<p>)
7 : (&#949;, {21x 7&#8594; [num : sg ]})
</p>
<p>FIG. 4: Une d&#233;rivation dans la RTG enrichie pour la phrase &#171; Le radis gris est creux. &#187;
</p>
<p>Exemple de d&#233;rivation Nous reprenons dans la figure 4 le cas de la phrase &#171; Le radis gris
est creux. &#187; en employant les r&#232;gles enrichies de structures de traits de l&#8217;&#233;quation (6). Chaque
n&#339;ud de l&#8217;arbre de la figure est constitu&#233; d&#8217;une &#233;tiquette et d&#8217;un couple form&#233; d&#8217;un terme de
T (F , (N &#8746;NA)&#215;D) et d&#8217;un environnement6. La cr&#233;ation de variables fra&#238;ches utilise l&#8217;adresse
de Gorn du n&#339;ud o&#249; la r&#233;&#233;criture a lieu. Les &#233;tiquettes de chaque n&#339;ud indiquent l&#8217;ordre dans
lequel s&#8217;effectuent les surr&#233;ductions. Enfin, l&#8217;on remplace les variables par leur valeur associ&#233;e
dans l&#8217;environnement d&#232;s que possible.
</p>
<p>On ne peut pas d&#233;river l&#8217;arbre correspondant &#224; &#171; * Le radis gris sont creux. &#187;. La partie gauche
de la tentative de d&#233;rivation aurait &#233;t&#233; similaire. En revanche, dans la partie droite, le trait bot
associ&#233; au n&#339;ud VA de sont aurait eu pour valeur num : pl (pluriel). L&#8217;analyse aurait donc
&#233;chou&#233; &#224; l&#8217;&#233;tape suivante, puisqu&#8217;en atteignant la feuille &#949; il aurait fallu unifier des traits top et
bot avec respectivement sg et pl comme valeurs de num.
</p>
<p>Bien s&#251;r, pour une analyse qui visite d&#8217;abord le sous-arbre droit avant le sous-arbre gauche,
le r&#233;sultat serait le m&#234;me, avec encore pour &#233;tape d&#233;cisive du point de vue de l&#8217;unification la
r&#233;&#233;criture finale &#224; &#949;.
</p>
<p>3 Transformation par coin gauche
</p>
<p>Comme nous venons de le voir, la g&#233;n&#233;ration d&#8217;un arbre de d&#233;rivation TAG &#224; l&#8217;aide d&#8217;une
grammaire RTG avec traits n&#8217;est pas tr&#232;s pr&#233;dictive, dans le sens o&#249; il est n&#233;cessaire de patienter
jusqu&#8217;&#224; la r&#233;&#233;criture &#224; &#949; pour v&#233;rifier si une substitution r&#233;ussit. Dans l&#8217;exemple de la figure 4,
la substitution de &#171; radis &#187; dans &#171; creux &#187; n&#8217;est v&#233;ritablement ent&#233;rin&#233;e qu&#8217;au moment de la
r&#233;&#233;criture &#224; &#949;, et potentiellement toutes les op&#233;rations interm&#233;diaires seraient &#224; d&#233;faire si cette
r&#233;&#233;criture n&#8217;avait pas &#233;t&#233; possible.
</p>
<p>Le seul filtrage imm&#233;diatement exerc&#233; par l&#8217;arbre &#171; radis &#187; lors de sa substitution au n&#339;ud N
de &#171; creux &#187; est l&#8217;unification de sa structure top avec la structure top de N . Or, l&#8217;arbre &#171; radis &#187;
</p>
<p>6Nous ne faisons appara&#238;tre que les parties de l&#8217;environnement calcul&#233;es &#224; ce point de la d&#233;rivation.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Calculs d&#8217;unification sur les arbres de d&#233;rivation TAG
</p>
<p>suit l&#8217;usage dans les grammaires TAG, qui est que sa structure top est vide, et il n&#8217;y a en fait
aucun filtrage par ce biais.
</p>
<p>Nous pr&#233;sentons dans cette section une transformation du langage d&#8217;arbres de d&#233;rivation qui
permet d&#8217;inverser l&#8217;ordre des r&#233;&#233;critures, en commen&#231;ant par &#949;, en op&#233;rant &#224; toutes les adjonc-
tions &#224; la racine, et en finissant par l&#8217;arbre initial. Comme nous avons convenu que la racine d&#8217;un
arbre &#233;l&#233;mentaire TAG apparaissait en fils gauche dans nos arbres de d&#233;rivation, cette transfor-
mation revient &#224; une transformation par coin gauche (Rosenkrantz &amp; Lewis II, 1970) appliqu&#233;e
&#224; nos grammaires rationnelles d&#8217;arbres de d&#233;rivation. Cette transformation est simple, et nous
semble plus naturelle que la transformation correspondante sur les arbres d&#233;riv&#233;s.
</p>
<p>3.1 Grammaire rationnelle transform&#233;e
</p>
<p>Les r&#232;gles que nous souhaitons transformer sont de la formeX &#8722;&#8594; &#945;(XA, . . . ),XA &#8722;&#8594; &#946;(XA, . . . )
ouXA &#8722;&#8594; &#949;. &#192; l&#8217;issue de la transformation, un appel &#224;X devra commencer par invoquer &#949;, puis
les adjonctions &#946; en ordre inverse, et enfin &#945; en dernier lieu, dont l&#8217;arit&#233; est d&#233;cr&#233;ment&#233;e. Pour
notre grammaire (figure 3a), cela revient simplement &#224; utiliser de nouveaux non-terminaux NS
et VS et les r&#232;gles
</p>
<p>S &#8722;&#8594; creux(NS, VS)
NS &#8722;&#8594; &#949;(N)
N &#8722;&#8594; radis | gris(N) | le(N)
VS &#8722;&#8594; &#949;(V )
V &#8722;&#8594; est
</p>
<p>(7)
</p>
<p>Il manque &#224; ces r&#232;gles la possibilit&#233; d&#8217;une adjonction ailleurs qu&#8217;&#224; la racine d&#8217;un arbre initial ;
il suffit alors de conserver les r&#232;gles XA &#8722;&#8594; &#946;(XA, . . . ) et XA &#8722;&#8594; &#949; qui s&#8217;appliqueront comme
auparavant.
</p>
<p>Nous pouvons ensuite &#233;liminer les &#949;-termes ; la grammaire de la figure 3a transform&#233;e est alors :
</p>
<p>S &#8722;&#8594; creux(N, V )
N &#8722;&#8594; radis | gris(N) | le(N)
NA &#8722;&#8594; gris(NA) | le(NA) | &#949;
V &#8722;&#8594; est
</p>
<p>(8)
</p>
<p>Les r&#232;gles de d&#233;rivation de NA sont cependant inutiles puisqu&#8217;il n&#8217;y a jamais d&#8217;adjonction sur
un n&#339;ud de cat&#233;gorie N qui n&#8217;est pas une racine dans notre grammaire d&#8217;arbres adjoints.
</p>
<p>Formellement, &#233;tant donn&#233;e une grammaire d&#8217;arbres adjoints &#12296;&#931;, N, I, A, S&#12297;, sa grammaire ra-
tionnelle d&#8217;arbres de d&#233;rivation transform&#233;e par coin gaucheGlc = &#12296;S,N &#8746;NA,Flc, Rlc&#12297; utilise
un alphabet terminal Flc = I &#8746; A &#8746; {&#949;} mais o&#249; l&#8217;arit&#233; d&#8217;un arbre initial &#945; est rg(&#945;)&#8722; 1, et un
ensemble de r&#232;gles Rlc d&#233;fini comme l&#8217;union
</p>
<p>{X &#8722;&#8594; &#945;(nt(&#945;2), . . . , nt(&#945;n)) | &#945; &#8712; I, n = rg(&#945;), X = lab(&#945;r)}
&#8746; {X &#8722;&#8594; &#946;(X, nt(&#946;2) . . . , nt(&#946;n)) | &#946; &#8712; A, n = rg(&#946;), X = lab(&#946;r)}
&#8746; {XA &#8722;&#8594; &#946;(nt(&#946;1), . . . , nt(&#946;n)) | &#946; &#8712; A, n = rg(&#946;), X = lab(&#946;r)}
</p>
<p>(9)
</p>
<p>La taille de cette grammaire est au pire doubl&#233;e par rapport &#224; la grammaire rationnelle d&#8217;arbres
de d&#233;rivation puisque chaque arbre auxiliaire appara&#238;t maintenant deux fois. En pratique, les
r&#232;gles utiles dans la grammaire obtenue sont probablement moins nombreuses. Par exemple,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain Schmitz, Joseph Le Roux
</p>
<p>dans la grammaire SEMFRAG et en se basant sur l&#8217;existence de n&#339;uds d&#8217;adjonction ailleurs
qu&#8217;&#224; la racine pour chaque cat&#233;gorie syntaxique, seuls un tiers des arbres auxiliaires, soit encore
un dixi&#232;me des arbres &#233;l&#233;mentaires, est concern&#233; par cette duplication.
</p>
<p>Notons enfin que la transformation est ais&#233;ment r&#233;versible. Nous d&#233;finissons pour cela la fonc-
tion lc&#8722;1 de T (Flc) dans T (F) par
</p>
<p>lc&#8722;1(t) = revlc(t, &#949;) (10)
revlc(&#946;(t1, t2, . . . , tn), t) = revlc(t1, &#946;(t, f&#946;2(t2), . . . , f&#946;n(tn))) (11)
</p>
<p>revlc(&#945;(t1, . . . , tn), t) = &#945;(t, f&#945;2(t1), . . . , f&#945;n+1(tn)) (12)
</p>
<p>f&#947;i(t) =
</p>
<p>{
recur(t) si &#947;i est un n&#339;ud d&#8217;adjonction
lc&#8722;1(t) si &#947;i est un n&#339;ud de substitution
</p>
<p>(13)
</p>
<p>recur(&#947;(t1, . . . , tn)) = &#947;(f&#947;1(t1), . . . , f&#947;n(tn)) (14)
</p>
<p>On peut ainsi proc&#233;der &#224; la g&#233;n&#233;ration d&#8217;un arbre d&#233;riv&#233; dans L(Glc) et retrouver l&#8217;arbre corres-
pondant de L(G) en lui appliquant lc&#8722;1.
</p>
<p>3.2 Unification dans la grammaire transform&#233;e
</p>
<p>Nous proc&#233;dons maintenant &#224; la d&#233;finition d&#8217;une grammaire rationnelle d&#8217;arbres de d&#233;rivation
transform&#233;e par coin gauche avec structures de traits. En reprenant les r&#232;gles transform&#233;es (7)
de la section 3.1, nous obtenons dans un premier temps les r&#232;gles transform&#233;es avec structures
de traits
</p>
<p>(S,&gt;) &#8722;&#8594; creux (NS [ top : &#187; det : +num : x &#8211;] , V [ top : [num : x ] ])
NS [ top : t ] &#8722;&#8594; &#949;
</p>
<p>(
N
[
top : t
bot : t
</p>
<p>])
N [ bot : [det : &#8722; ] ] &#8722;&#8594; radis
</p>
<p>N
[
top : t
</p>
<p>bot :
</p>
<p>&#187;
det : &#8722;
</p>
<p>num : x
</p>
<p>&#8211;] &#8722;&#8594; gris(N [ top : tbot : &#187; det : &#8722;
num : x
</p>
<p>&#8211;])
N
[
top : t
</p>
<p>bot :
</p>
<p>&#187;
det : +
</p>
<p>num : sg
</p>
<p>&#8211;] &#8722;&#8594; le(N [ top : tbot : &#187; det : &#8722;
num : sg
</p>
<p>&#8211;])
VS [ top : t ] &#8722;&#8594; &#949;
</p>
<p>(
V
[
top : t
bot : t
</p>
<p>])
V [ bot : [num : sg ] ] &#8722;&#8594; est
</p>
<p>(15)
</p>
<p>Comme la r&#233;cursion au sein des arbres auxiliaires est invers&#233;e, les structures de traits de la
partie gauche de chaque r&#232;gle sont les structures de son n&#339;ud racine dans la grammaire TAG,
et inversement (on observe ce changement pour la r&#232;gle qui d&#233;rive &#171; le &#187;).
</p>
<p>Nous pouvons comme auparavant &#233;liminer les r&#232;gles d&#233;rivant &#949;, ce qui a pour effet de copier la
structure de traits top des n&#339;uds de substitution dans la structure bot . Nous obtenons l&#8217;ensemble
de r&#232;gles suivant pour la grammaire TAG de la figure 2 :
</p>
<p>(S,&gt;) &#8722;&#8594; creux
(
N
</p>
<p>[
top :
</p>
<p>&#187;
det : +
</p>
<p>num : x
</p>
<p>&#8211;
bot :
</p>
<p>&#187;
det : +
</p>
<p>num : x
</p>
<p>&#8211;
]
, V
</p>
<p>[
top : [num : x ]
bot : [num : x ]
</p>
<p>])
N [ bot : [det : &#8722; ] ] &#8722;&#8594; radis
</p>
<p>N
[
top : t
</p>
<p>bot :
</p>
<p>&#187;
det : &#8722;
</p>
<p>num : x
</p>
<p>&#8211;] &#8722;&#8594; gris(N [ top : tbot : &#187; det : &#8722;
num : x
</p>
<p>&#8211;])
N
[
top : t
</p>
<p>bot :
</p>
<p>&#187;
det : +
</p>
<p>num : sg
</p>
<p>&#8211;] &#8722;&#8594; le(N [ top : tbot : &#187; det : &#8722;
num : sg
</p>
<p>&#8211;])
V [ bot : [num : sg ] ] &#8722;&#8594; est
</p>
<p>(16)</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Calculs d&#8217;unification sur les arbres de d&#233;rivation TAG
</p>
<p>Cette grammaire d&#8217;arbres avec traits est bien plus lisible que celle d&#233;crite dans l&#8217;&#233;quation (6) :
le premier fils de &#171; creux &#187; ne peut &#234;tre que &#171; le &#187; de par la pr&#233;sence du trait det = + dans
la structure bot associ&#233;e &#224; N . Les seuls fils de &#171; le &#187; possibles sont &#171; gris &#187; et &#171; radis &#187;, seuls
compatibles avec le trait det = &#8722;. Le filtrage d&#251; aux unifications est maintenant imm&#233;diat.
</p>
<p>Construction de la grammaire rationnelle transform&#233;e Nous d&#233;finissons les variantes sui-
vantes des fonctions de calcul de structures de traits, pour tout arbre auxiliaire &#946; de A et pour
tout n&#339;ud &#947;i d&#8217;un arbre &#233;l&#233;mentaire &#947; de I &#8746; A :
</p>
<p>inlc(&#946;) =
[
top : t
bot : bot(&#946;f )
</p>
<p>]
(17)
</p>
<p>featslc(&#947;i) =
</p>
<p>&#63729;&#63732;&#63732;&#63730;&#63732;&#63732;&#63731;
[
top : top(&#947;i)
bot : top(&#947;i)
</p>
<p>]
si &#947;i est un n&#339;ud de substitution,[
</p>
<p>top : t
top : top(&#947;r)
bot : bot(&#947;r)
</p>
<p>]
si &#947;i = &#947;r,
</p>
<p>feats(&#947;i) sinon.
</p>
<p>(18)
</p>
<p>Pour un n&#339;ud &#947;i, nous notons trlc(&#947;i) la paire (nt(&#947;i), featslc(&#947;i)).
</p>
<p>Formellement, l&#8217;ensemble de r&#232;gles de notre grammaire rationnelle d&#8217;arbres avec traits trans-
form&#233;e pour une grammaire TAG &#12296;&#931;, N, I, A, S&#12297; est alors
</p>
<p>{(X, feats(&#945;1)) &#8722;&#8594; &#945;(trlc(&#945;2), . . . , trlc(&#945;n)) | &#945; &#8712; I, n = rg(&#945;), X = lab(&#945;r)}
&#8746; {(X, featslc(&#946;1)) &#8722;&#8594; &#946;((X, inlc(&#946;)), trlc(&#946;2), . . . , trlc(&#946;n))
</p>
<p>| &#946; &#8712; A, n = rg(&#946;), X = lab(&#946;r)}
&#8746; {(XA, in(&#946;)) &#8722;&#8594; &#946;(trr(&#946;1), trlc(&#946;2), . . . , trlc(&#946;n)) | &#946; &#8712; A, n = rg(&#946;), X = lab(&#946;r)} (19)
</p>
<p>4 Conclusion
</p>
<p>Les grammaires rationnelles d&#8217;arbres avec structures de traits permettent de g&#233;n&#233;rer ais&#233;ment les
arbres de d&#233;rivation d&#8217;une grammaire TAG avec structures de traits. Les grammaires transfor-
m&#233;es par coin gauche permettent de plus de filtrer plus efficacement les op&#233;rations d&#8217;adjonction
et de substitution possibles &#224; partir d&#8217;un arbre &#233;l&#233;mentaire.
</p>
<p>Si des calculs d&#8217;unification sur arbres de d&#233;rivation ont d&#233;j&#224; &#233;t&#233; consid&#233;r&#233;s par le pass&#233; de ma-
ni&#232;re sp&#233;cialis&#233;e (Kallmeyer &amp; Romero, 2004), les m&#233;canismes que nous avons d&#233;finis sont
suffisamment g&#233;n&#233;raux pour traduire fid&#232;lement l&#8217;unification dans les grammaires d&#8217;arbres ad-
joints.
</p>
<p>Parmi les perspectives ouvertes par ce traitement des structures de traits dans les arbres de
d&#233;rivation, on pourra mentionner des calculs d&#8217;accessibilit&#233; plus fins entre les arbres &#233;l&#233;men-
taires, utiles par exemple pour v&#233;rifier qu&#8217;une TAG est dans la classe restreinte des grammaires
d&#8217;arbres par insertion (Schabes &amp; Waters, 1995, TIG) ou sous forme rationnelle (Rogers, 1994,
RFTAG). On pourrait par ailleurs imaginer &#233;tendre notre approche &#224; l&#8217;analyse syntaxique, pour
peu que les informations topologiques d&#8217;ordre entre les ancres soient calcul&#233;es dans nos arbres
de d&#233;rivation (Kuhlmann, 2007).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Sylvain Schmitz, Joseph Le Roux
</p>
<p>R&#233;f&#233;rences
</p>
<p>CANDITO M.-H. &amp; KAHANE S. (1998). Une grammaire TAG vue comme une grammaire
Sens-Texte pr&#233;compil&#233;e. In P. ZWEIGENBAUM, Ed., TALN&#8217;98, p. 102&#8211;111: ATALA.
</p>
<p>COMON H., DAUCHET M., GILLERON R., L&#214;DING C., JACQUEMARD F., LUGIEZ D., TI-
SON S. &amp; TOMMASI M. (2007). Tree Automata Techniques and Applications.
</p>
<p>DE GROOTE P. (2002). Tree-adjoining grammars as abstract categorial grammars. In R.
FRANK, Ed., TAG+6, p. 145&#8211;150.
</p>
<p>GARDENT C. (2006). Int&#233;gration d&#8217;une dimension s&#233;mantique dans les grammaires d&#8217;arbres
adjoints. In P. MERTENS, C. FAIRON, A. DISTER &amp; P. WATRIN, Eds., TALN&#8217;06, p. 149&#8211;158:
Presses universitaires de Louvain.
</p>
<p>GARDENT C. &amp; KALLMEYER L. (2003). Semantic construction in feature-based TAG. In
EACL&#8217;03, p. 123&#8211;130: ACL Press.
</p>
<p>HANUS M. (1994). The integration of functions into logic programming: From theory to
practice. Journal of Logic Programming, 19&#8211;20, 583&#8211;628.
JOSHI A. K. &amp; SCHABES Y. (1997). Tree-adjoining grammars. In G. ROZENBERG &amp; A.
SALOMAA, Eds., Handbook of Formal Languages, volume 3: Beyond Words, chapter 2, p.
69&#8211;124. Springer.
</p>
<p>KALLMEYER L. &amp; ROMERO M. (2004). LTAG semantics with semantic unification. In O.
RAMBOW &amp; M. STONE, Eds., TAG+7, p. 155&#8211;162.
</p>
<p>KANAZAWA M. (2007). Parsing and generation as Datalog queries. In ACL&#8217;07, p. 176&#8211;183:
ACL Press.
</p>
<p>KOLLER A. &amp; STONE M. (2007). Sentence generation as a planning problem. In ACL&#8217;07, p.
336&#8211;343: ACL Press.
</p>
<p>KOLLER A. &amp; STRIEGNITZ K. (2002). Generation as dependency parsing. In ACL&#8217;02, p.
17&#8211;24: ACL Press.
</p>
<p>KUHLMANN M. (2007). Dependency Structures and Lexicalized Grammars. Doctoral disser-
tation, Saarland University, Saarbr&#252;cken, Germany.
</p>
<p>POGODALLA S. (2004). Vers un statut de l&#8217;arbre de d&#233;rivation : exemples de construction
de representations s&#233;mantiques pour les grammaires d&#8217;arbres adjoints. In P. BLACHE, Ed.,
TALN&#8217;04, p. 377&#8211;386: LPL.
</p>
<p>ROBINSON J. A. (1965). A machine-oriented logic based on the resolution principle. Journal
of the ACM, 12(1), 23&#8211;41.
ROGERS J. (1994). Capturing CFLs with tree adjoining grammars. In ACL&#8217;94, p. 155&#8211;162:
ACL Press.
</p>
<p>ROSENKRANTZ D. J. &amp; LEWIS II P. M. (1970). Deterministic left corner parsing. In 11th
Annual Symposium on Switching and Automata Theory, p. 139&#8211;152: IEEE Computer Society.
</p>
<p>SCHABES Y. &amp; WATERS R. C. (1995). Tree insertion grammar: a cubic-time parsable forma-
lism that lexicalizes context-free grammar without changing the trees produced. Computatio-
nal Linguistics, 21(4), 479&#8211;513.
VIJAY-SHANKER K. (1992). Using descriptions of trees in a tree adjoining grammar. Com-
putational Linguistics, 18(4), 481&#8211;517.</p>

</div></div>
</body></html>