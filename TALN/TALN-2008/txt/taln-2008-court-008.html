<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Typage, produit cart&#233;sien et unit&#233;s d&#8217;analyse pour les mod&#232;les &#224; &#233;tats finis</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2008, Avignon, 9&#8211;13 juin 2008
</p>
<p>Typage, produit cart&#233;sien et unit&#233;s d&#8217;analyse pour les mod&#232;les
&#224; &#233;tats finis
</p>
<p>Fran&#231;ois Barth&#233;lemy1, 2
(1) CNAM, C&#233;dric, 292 rue Saint-Martin, 75003 Paris
</p>
<p>(2) INRIA, Alpage, 78153 Le Chesnay cedex
barthe@cnam.fr
</p>
<p>R&#233;sum&#233;. Dans cet article, nous pr&#233;sentons un nouveau langage permettant d&#8217;&#233;crire des
relations rationnelles compil&#233;es en automates finis. Les deux caract&#233;ristiques innovantes de ce
langage sont de pourvoir d&#233;crire des relations &#224; plusieurs niveaux, pas n&#233;cessairement deux et
d&#8217;utiliser diverses unit&#233;s d&#8217;analyse pour exprimer les liens entre niveaux. Cela permet d&#8217;aligner
de fa&#231;on fine des repr&#233;sentations multiples.
</p>
<p>Abstract. In this paper, we present a new language to write rational relations compiled
into finite state automata. There are two main novelties in the language. Firstly, the descriptions
may have more than two levels. Secondly, various units may be used to express the relationships
between the levels. Using these features, it is possible to align finely multiple representations.
</p>
<p>Mots-cl&#233;s : Machine finie &#224; &#233;tats, morphologie &#224; deux niveau.
Keywords: Finite-state machine, two-level morphology.
</p>
<p>1 Introduction
</p>
<p>Les machines &#224; &#233;tats finis, &#224; savoir les automates et transducteurs, ont une place importante dans
plusieurs domaines de la linguistique informatique, notamment la description morphologique,
le traitement des entit&#233;s nomm&#233;es, les approximations de syntaxe, la recherche de motifs.
</p>
<p>Ces machines sont sp&#233;cifi&#233;es au moyen d&#8217;expressions r&#233;guli&#232;res, de r&#232;gles contextuelles ainsi
que par l&#8217;application d&#8217;op&#233;rateurs sur des machines existantes. Les automates impl&#233;mentent des
langages rationnels et les transducteurs des relations rationnelles. Ce sont deux types d&#8217;objets
diff&#233;rents, pouvant &#234;tre convertis l&#8217;un dans l&#8217;autre au moyen d&#8217;op&#233;rations. Une relation peut &#234;tre
obtenue en faisant le produit cart&#233;sien de deux langages et un langage peut &#234;tre obtenu en faisant
une projection d&#8217;une relation sur sa premi&#232;re ou sa seconde composante. Les op&#233;rations ration-
nelles (concat&#233;nation, cl&#244;ture sous concat&#233;nation ou &#233;toile, disjonction) sont d&#233;finies sur les
deux types d&#8217;objets. En revanche, certaines op&#233;rations ensemblistes, notamment l&#8217;intersection
et la diff&#233;rence, ne sont des op&#233;rations internes que pour les langages rationnels. Les relations
pour leur part, sont closes sous composition, une op&#233;ration qui n&#8217;a pas de sens sur les langages.
</p>
<p>Dans cet article, nous proposons une extension aux relations n-aires, c&#8217;est-&#224;-dire pouvant avoir
plus de deux composantes ou niveaux, sp&#233;cialement adapt&#233;e pour des descriptions linguistiques
reliant des repr&#233;sentations diff&#233;rentes de certains objets. Cette extension est un langage qui
s&#8217;inscrit dans la lign&#233;e de langages comme PC-Kimmo (Antworth, 1995) ou Xfst (Beesley &amp;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois Barth&#233;lemy
</p>
<p>Karttunen, 2003). Il autorise aussi bien les descriptions parall&#232;les (intersection de transducteurs)
que s&#233;quentielles (composition de transducteurs). Outre la formalisation de descriptions &#224; plus
de deux niveaux, le second apport du langage est de proposer la notion d&#8217;unit&#233; d&#8217;analyse pour
mettre en correspondance les diff&#233;rents niveaux.
</p>
<p>La premi&#232;re section de cet article motive l&#8217;approche au moyen d&#8217;exemples montrant l&#8217;int&#233;r&#234;t de
repr&#233;sentations multiples et d&#8217;unit&#233;s d&#8217;analyse diverses. La seconde section est une pr&#233;sentation
du langage. La troisi&#232;me situe ce travail par rapport &#224; d&#8217;autres approches repr&#233;sentatives du
domaine.
</p>
<p>2 Int&#233;r&#234;t des niveaux et unit&#233;s multiples
</p>
<p>2.1 Motivation de l&#8217;approche multi-niveaux
</p>
<p>Nous allons motiver l&#8217;utilisation de descriptions linguistiques utilisant plus de deux repr&#233;senta-
tions au moyen de quelques exemples.
</p>
<p>George Anton Kiraz a propos&#233; une description de la morphologie de la langue syriaque utilisant
quatre repr&#233;sentations : une repr&#233;sentation &#233;crite de surface et trois dimensions orthogonales
repr&#233;sentant des unit&#233;s d&#8217;analyse &#233;ventuellement discontigu&#235;s : la racine consonnantique, le
sch&#233;ma vocalique et un motif paradigmatique (Kiraz, 2001). Le tableau suivant offre un exemple
de forme avec les quatre niveaux correspondants.
</p>
<p>racine k t b
sch&#233;ma vocalique a e
motif paradigmatique C V C C V C
forme k a t t e b
</p>
<p>Ce type de description a &#233;t&#233; utilis&#233;e &#233;galement pour la morphologie de l&#8217;arabe. Elle s&#8217;appa-
rente &#224; l&#8217;approche de la morphologie des langues s&#233;mitiques de (McCarthy, 1981). Chacun
des niveaux de description est d&#233;crit au moyen d&#8217;un inventaire exhaustif. La compatibilit&#233; des
diff&#233;rents niveaux est r&#233;gie par des r&#232;gles.
</p>
<p>Prenons un autre exemple : la description des formes morphologiques utilis&#233;es dans des mes-
sages SMS. L&#8217;&#233;criture utilis&#233;e dans ce type de messages (et d&#8217;autres formes de communica-
tion &#233;lectronique) m&#233;lange plusieurs sous-syst&#232;mes, l&#8217;un d&#8217;entre eux &#233;tant l&#8217;&#233;criture habituelle,
d&#8217;autres &#233;tant phon&#233;tiques ou id&#233;ographique. Le passage d&#8217;un sous-syst&#232;me &#224; un autre se fait
parfois au sein d&#8217;une m&#234;me forme. On ne peut pas analyser une telle forme sans recourir &#224; deux
repr&#233;sentations, l&#8217;une graph&#233;mique l&#8217;autre phon&#233;tique, ce qui conduit &#224; une description &#224; trois
niveaux. Nous utilisons un quatri&#232;me niveau d&#8217;analyse qui explicite le sous-syst&#232;me graphique
utilis&#233; par une s&#233;quence de caract&#232;res. Voici un exemple de forme avec les niveaux correspon-
dants. La premi&#232;re lettre est interpr&#233;t&#233;e comme relevant du syst&#232;me phon&#233;tique syllabique o&#249;
un caract&#232;re d&#233;note la syllabe utilis&#233;e comme nom de la lettre, la seconde comme relevant de
l&#8217;&#233;criture habituelle et la troisi&#232;me, d&#8217;une &#233;criture habituelle dans laquelle les accents sont omis.
</p>
<p>forme graphique c a f &#233;
forme phon&#233;tique k a f e
translitt&#233;ration k-syll f-graph e-graph-sa
forme de surface k f e</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Typage, produit cart&#233;sien et unit&#233;s d&#8217;analyse 2.2 Unit&#233;s d&#8217;analyse
</p>
<p>La r&#233;f&#233;rence &#224; deux logiques, l&#8217;une concernant le syst&#232;me graphique, l&#8217;autre le syst&#232;me phon&#233;-
tique concerne &#233;galement l&#8217;&#233;criture habituelle. Par exemple, le choix de la forme in ou im dans
le pr&#233;fixe n&#233;gatif (im+mangeable/in+d&#233;cidable) est surtout graphique, alors que le choix de la
forme d&#8217;une racine verbale peuv ou pouv pour le verbe pouvoir d&#233;pend de crit&#232;res phonolo-
giques, &#224; savoir le caract&#232;re ouvert ou ferm&#233; de la syllabe contenant la voyelle. Dans la plupart
des syst&#232;mes de morphologie &#224; deux niveaux, les deux types de ph&#233;nom&#232;nes sont trait&#233;s par une
unique repr&#233;sentation qui est de nature hybride et utilise des m&#233;ta-caract&#232;res pour capturer l&#8217;une
ou l&#8217;autre (ou les deux) des dimensions &#224; consid&#233;rer. Si l&#8217;on pouvait d&#233;crire chaque logique s&#233;-
par&#233;ment sans tomber dans une formalisation trop lourde, ce serait certainement pr&#233;f&#233;rable.
</p>
<p>Un dernier exemple terminera cette section : celui des nombres en toutes lettres. Lauri Karttu-
nen a publi&#233; un article sur la description des nombres en finnois (Karttunen, 2006) et il met &#224;
disposition sur la toile les fichiers contenant cette description au format des outils Xerox (xfst et
lexc). Cette description relie un niveau de surface o&#249; les nombres sont &#233;crits en toutes lettres &#224;
un niveau abstrait o&#249; une notation en chiffres arabes est concat&#233;n&#233;e &#224; des valeurs de traits (cas,
nombre, caract&#232;re ordinal ou cardinal). Cette concat&#233;nation a un caract&#232;re arbitraire puisque les
deux types d&#8217;informations sont diff&#233;rentes. Nous pr&#233;f&#233;rons pour notre part une repr&#233;sentation
&#224; trois niveaux, avec la repr&#233;sentation en lettres, la repr&#233;sentation en chiffres et les traits. La
repr&#233;sentation en chiffres a un int&#233;r&#234;t propre : elle est d&#8217;usage courant. Par ailleurs, l&#8217;ordre des
chiffres dans un nombre est &#233;minemment significatif alors qu&#8217;il n&#8217;y a pas d&#8217;ordre entre les traits,
au moins d&#8217;un point de vue conceptuel.
</p>
<p>Nous sommes donc partis de la description de Lauri Karttunen pour &#233;crire une description &#224;
trois niveaux pour les nombres en finnois et nous l&#8217;avons ensuite enrichie pour d&#233;crire &#233;gale-
ment les nombres en fran&#231;ais, avec l&#8217;ajout de nouveaux niveaux. D&#8217;une part, nous avons un
niveau pour les nombres &#233;crits en fran&#231;ais. D&#8217;autre part, nous avons scind&#233; les traits en trois
cat&#233;gories, chacune enregistr&#233;e sur un niveau : les traits communs aux deux langues (nombre
et caract&#232;re ordinal/cardinal) et les traits sp&#233;cifiques &#224; une ou l&#8217;autre des langues : cas pour le
finnois, genre pour le fran&#231;ais (utilis&#233; pour un/une, premier/premi&#232;re, second/seconde). Ce qui
fait au total six niveaux : fran&#231;ais, finnois, chiffres, traits communs, traits fran&#231;ais, traits finnois.
Cette description permet de traduire d&#8217;une langue &#224; l&#8217;autre, des chiffres &#224; une langue, de fa-
&#231;on plus ou moins d&#233;terministe en fonction des traits renseign&#233;s. La multiplication des niveaux
pourrait &#234;tre un handicap si l&#8217;on approchait une taille critique pour la machine finie obtenue. Ce
n&#8217;est pas le cas dans cet exemple.
</p>
<p>2.2 Unit&#233;s d&#8217;analyse
</p>
<p>Une description morphologique n&#233;cessite de coordonner une multiplicit&#233; d&#8217;unit&#233;s d&#8217;analyse.
C&#8217;est d&#233;j&#224; le cas pour les descriptions &#224; deux niveaux habituelles. &#199;a l&#8217;est encore davantage
avec les descriptions &#224; multiples niveaux reliant des repr&#233;sentations tr&#232;s diff&#233;rentes.
</p>
<p>La partie de la morphologie qui d&#233;crit la structure des formes fait appel &#224; la notion de morph&#232;me
(ou une autre notion d&#8217;unit&#233; dans le cas de morphologie non concat&#233;native). Cette description
ne prend pas en compte la forme de chaque morph&#232;me. Cette indiff&#233;rence aux contenus des
affixes est particuli&#232;rement visible dans la syntaxe du syst&#232;me PC-Kimmo avec la construction
ALTERNATION, et dans une moindre mesure avec lexc de Xerox.
</p>
<p>Lorsqu&#8217;on multiplie les repr&#233;sentations diff&#233;rentes, les correspondances entre repr&#233;sentations
peuvent mettre en jeu plusieurs types d&#8217;unit&#233;s. Par exemple, entre un nombre en lettres et un</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois Barth&#233;lemy
</p>
<p>nombre en chiffres, la correspondance n&#8217;est pas simple, comme l&#8217;illustrent les quelques cas
suivants.
</p>
<p>3 5 6 2 1 0 6 2 1 3 6 0
trois mille cinq cent trente deux mille trente deux treize-cent trente
</p>
<p>Toujours dans cet exemple des nombres, les structures de traits concernent un nombre dans son
int&#233;gralit&#233;. On a donc deux types d&#8217;unit&#233; en jeu dans les correspondances entre repr&#233;sentations :
la forme compl&#232;te et l&#8217;unit&#233; de correspondance chiffres/lettres. De plus, dans cette derni&#232;re,
on peut distinguer des unit&#233;s plus petites telles que les affixes qui interviennent dans les cas
de flexion. C&#8217;est plus clair dans le cas du finlandais pour lequel une d&#233;clinaison &#224; douze cas
fl&#233;chit chacun des chiffres d&#8217;un nombre. Cela existe en fran&#231;ais surtout sur le dernier mot de la
s&#233;quence, car c&#8217;est l&#224; que se fait l&#8217;accord en genre et nombre. Il y a alors 4 types d&#8217;unit&#233;s, plus
la notion de symbole ou caract&#232;re qui est l&#8217;unit&#233; de base dans la description. Dans cet exemple,
les diff&#233;rentes unit&#233;s sont imbriqu&#233;es les unes dans les autres, ce qui autorise une repr&#233;sentation
arborescente des analyses.
</p>
<p>[type=card,gen=fem]
3 4 1
</p>
<p>trois cent quarante et un e
</p>
<p>Ce n&#8217;est pas toujours le cas : les unit&#233;s d&#8217;analyse peuvent d&#233;couper certaines formes de fa-
&#231;on diff&#233;rentes sans qu&#8217;il n&#8217;y ait imbrication de l&#8217;une dans l&#8217;autre. Beaucoup de ph&#233;nom&#232;nes
de nature phonologique rel&#232;vent d&#8217;une autre organisation que la morpho-syntaxe. Quelques
exemples : la r&#233;alisation du schwa et la prononciation d&#8217;une consonne finale peuvent s&#8217;expli-
quer avec une notion de syllabe qui peut r&#233;unir des fragments de formes fl&#233;chies diff&#233;rentes. A
une autre &#233;chelle, au sein d&#8217;une forme, la syllabification d&#233;termine la forme de certaines racines
verbales comportant des alternances et une m&#234;me syllabe peut regrouper des portions d&#8217;affixes
diff&#233;rents. Les deux notions d&#8217;affixe et de syllabe sont orthogonales, aucune n&#8217;est imbriqu&#233;e
dans l&#8217;autre.
</p>
<p>La notion d&#8217;unit&#233; d&#8217;analyse que nous voyons dans ces diff&#233;rents exemples sert notamment &#224;
exprimer des relations de correspondances entre repr&#233;sentations diff&#233;rentes. Au sein d&#8217;une telle
unit&#233;, les diff&#233;rentes repr&#233;sentations sont soit ind&#233;pendantes (par exemple, cent est en relation
avec 100, mais il n&#8217;y a pas de relation sp&#233;ciale entre quelque sous-cha&#238;ne que ce soit de cent
et une sous-cha&#238;ne de 100), soit coordonn&#233;es au moyen d&#8217;une unit&#233; plus petite enchass&#233;e.
</p>
<p>3 Pr&#233;sentation du langage
</p>
<p>3.1 Types et op&#233;rations sur les relations n-aires
</p>
<p>Les relations rationnelles sont intrins&#232;quement typ&#233;es par leur arit&#233;, c&#8217;est-&#224;-dire leur nombre de
composantes. Par exemple, on ne peut pas concat&#233;ner un ensemble de couples et un ensemble de
triplets1. En pratique, un typage plus fort est int&#233;ressant pour distinguer diff&#233;rentes informations.
Par exemple, si l&#8217;on consid&#232;re une relation &#224; trois composantes entre nombres en toutes lettres,
nombre en chiffres et structures de traits, il y a trois projections diff&#233;rentes qui donnent une
relation binaire. Si l&#8217;on s&#8217;en tient au typage minimal par arit&#233;, on peut op&#233;rer une concat&#233;nation
entre une relation binaire comportant les lettres et les chiffres et une autre entre les lettres et les
</p>
<p>1Sauf &#224; r&#233;aliser une coercition de type implicite qui compl&#232;te les couples pour en faire des triplets.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Typage, produit cart&#233;sien et unit&#233;s d&#8217;analyse 3.2 Expressions rationnelles &#233;tendues
</p>
<p>traits. Nous proposons une discipline diff&#233;rente o&#249; l&#8217;on s&#8217;interdit cela en d&#233;finissant un typage
plus fort.
</p>
<p>Pour ce faire, nous allons utiliser des noms pour identifier chaque composante, comparables
aux noms d&#8217;attributs des bases de donn&#233;es relationnelles. Un type de relation consistera en
un ensemble de noms d&#8217;attributs. Ce proc&#233;d&#233; permet de ne plus utiliser l&#8217;ordre pour identifier
les composantes, apportant plus de souplesse dans les notations. De plus, les noms permettent
de simplifier l&#8217;expression de certaines op&#233;rations. Il n&#8217;y a pas de diff&#233;rences th&#233;oriques entre
relations avec composantes ordonn&#233;es et relations avec composantes nomm&#233;es.
</p>
<p>Une nouvelle op&#233;ration, le renommage, consiste &#224; changer le nom de certaines composantes.
Elle r&#233;alise une conversion de type explicite (cast).
Les op&#233;rations qui changent le type de leurs op&#233;randes sont la projection et la jointure. La
projection consiste &#224; &#233;liminer purement et simplement certaines composantes. Elle admet deux
variantes syntaxiques, l&#8217;une o&#249; on sp&#233;cifie ce que l&#8217;on &#233;limine, l&#8217;autre o&#249; on sp&#233;cifie ce que l&#8217;on
conserve.
</p>
<p>La jointure consiste &#224; fusionner deux relations qui peuvent avoir des composantes en commun,
mais pas n&#233;cessairement toutes (Kempe et al., 2004). Les tuples du r&#233;sultats proviennent de
la fusion de deux tuples venant chacun d&#8217;un des op&#233;randes et qui sont &#233;gaux sur les compo-
santes communes. Le type du r&#233;sultat est l&#8217;union des type des op&#233;randes. Si ces deux types sont
disjoints (il n&#8217;y a aucun niveau commun), la jointure est un produit cart&#233;sien. S&#8217;ils sont &#233;gaux
(tous les niveaux sont communs aux deux machines), la jointure est une intersection. S&#8217;il y a
une composante commune, la jointure s&#8217;apparente &#224; une composition, mais il n&#8217;y a pas d&#8217;&#233;li-
mination de cette composante dans le r&#233;sultat. Cette &#233;limination syst&#233;matique a pour objet de
maintenir &#224; deux le nombre de composantes du r&#233;sultat, ce qui est hors de propos lorsqu&#8217;on
admet des relations n-aires.
</p>
<p>La jointure pose un probl&#232;me : en g&#233;n&#233;ral, la jointure de deux relations rationnelles n&#8217;est pas
une relation rationnelle. C&#8217;est bien connu dans le cas particulier de l&#8217;intersection : l&#8217;intersection
de deux relations rationnelles n&#8217;est pas toujours rationnelle. Face &#224; cette difficult&#233;, il convient
de d&#233;finir quelles jointures sont possibles &#224; r&#233;aliser.
</p>
<p>3.2 Expressions rationnelles &#233;tendues
</p>
<p>Une unit&#233; est repr&#233;sent&#233;e par un tuple typ&#233; qui comporte un certain nombre de composantes
nomm&#233;es. Une composante est soit directement un des niveaux d&#8217;analyse, auquel cas elle
contient une cha&#238;ne de symboles de l&#8217;alphabet, soit une composante est le r&#233;sultat d&#8217;un pro-
duit cart&#233;sien imbriqu&#233;, auquel cas elle contient une cha&#238;ne de tuples ayant le m&#234;me type.
</p>
<p>Chaque expression rationnelle a un type, qui est un ensemble de niveaux. Si cet ensemble est un
singleton, elle est une expression rationnelle ordinaire d&#233;notant un langage. Si le type contient
plus d&#8217;un niveau, l&#8217;expression consiste en une expression rationnelle dont les atomes sont des
tuples ayant ce type. Les composantes des tuples sont des expressions rationnelles sur leurs
types respectifs. Chaque tuple pr&#233;sent dans une description doit &#234;tre une occurrence d&#8217;une unit&#233;
d&#8217;analyse pr&#233;alablement d&#233;clar&#233;e.
</p>
<p>Nous allons pr&#233;senter des fragments d&#8217;une grammaire d&#233;crivant la relation entre mots &#233;crits en
lettres et mots &#233;crits en chiffres. Outre les deux niveaux des chiffres et des lettres, elle comporte
un niveau comportant l&#8217;information de genre qui d&#233;termine les formes en lettres se terminant</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>3.2 Expressions rationnelles &#233;tendues Fran&#231;ois Barth&#233;lemy
</p>
<p>par un/une. Il y a deux unit&#233;s d&#8217;analyse : une unit&#233; de correspondance chiffre/lettre et une unit&#233;
qui est le nombre. Le nombre peut comporter plusieurs unit&#233;s de correspondance chiffre/lettre.
Les noms des deux unit&#233;s sont respectivement c2l et num. La grammaire commence avec les
d&#233;clarations de l&#8217;alphabet divis&#233; en classes de symboles, des types de structures de traits et des
unit&#233;s d&#8217;analyse. Dans les expressions, les symboles comportant plusieurs caract&#232;res ou des
caract&#232;res de ponctuation sont &#233;crits entour&#233;s par les signes &lt; et &gt;. Par exemple, &lt; &gt; d&#233;signe
un espace, &lt;lettre&gt; d&#233;signe la classe de caract&#232;re lettre. La cha&#238;ne vide est not&#233;e &lt;&gt;.
</p>
<p>Le nom d&#8217;unit&#233; d&#8217;analyse est donn&#233; en d&#233;but de chaque tuple. Les composantes des tuples
sont nomm&#233;es, ce qui permet d&#8217;accepter plusieurs syntaxes : avec les noms, l&#8217;ordre n&#8217;&#233;tant
pas significatif, ou sans les noms, l&#8217;ordre &#233;tant celui de la d&#233;claration. De plus, la d&#233;claration
comporte une valeur par d&#233;faut pour chacune des composantes, ce qui permet d&#8217;abbr&#233;ger la
notation.
</p>
<p>La syntaxe exige que les noms de niveaux commencent avec T_ (t pour tape, ruban). Le point
d&#8217;interrogation est l&#8217;op&#233;rateur qui rend optionnelle l&#8217;expression qui pr&#233;c&#232;de. Les points de sus-
pensions sont utilis&#233;s pour raccourcir l&#8217;exemple d&#8217;un point de vue typographique et ne font pas
partie de la syntaxe du langage.
</p>
<p>class genre is masc, fem;
class chiffre is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
class lettre is a, b, ..., &lt;-&gt;, &lt; &gt;;
class sep is &lt; &gt;, &lt;-&gt;;
unit c2l is {T_chif: &lt;chiffre&gt;*, T_let: &lt;lettre&gt;*}
unit num is {T_fs: &lt;genre&gt;, segs: {c2l}* }
regexp zero is {num: segs = {c2l: 0, zero}};
regexp n_1 is {c2l: 1, (&lt; &gt;et&lt; &gt;)?un(e?)};
regexp n_2_6 is {c2l: 2, &lt;-&gt;?deux}|...|{c2l: 6, &lt;-&gt;?six};
Les op&#233;rateurs binaires doivent avoir deux op&#233;randes du m&#234;me type, c&#8217;est-&#224;-dire d&#233;crivant deux
relations ayant les m&#234;mes composantes ou niveaux. Il est ainsi possible de concat&#233;ner deux
occurrences d&#8217;une unit&#233; mais impossible de concat&#233;ner par exemple un num et un c2l.
</p>
<p>La notation par accolades d&#233;note un produit cart&#233;sien avec ajout implicite d&#8217;accolades typ&#233;es
dans les composantes. Par exemple,
{num: segs = {c2l: 0, zero}} d&#233;note le produit cart&#233;sien :
(T_fs= &lt;{num&gt;(&lt;masc&gt;|&lt;fem&gt;)&lt;num}&gt;)&#215;
(T_chif= &lt;{num&gt;&lt;{c2l&gt;0&lt;c2l}&gt;&lt;num}&gt;)&#215;
(T_let= &lt;{num&gt;&lt;{c2l&gt;zero&lt;c2l}&gt;&lt;num}&gt;)
dans lequel &lt;{c2l&gt;, &lt;c2l}&gt;, &lt;{num&gt; et &lt;num}&gt; sont quatre symboles atomiques ordi-
naires. Il y a donc inscription des limites d&#8217;unit&#233;s dans les cha&#238;nes, ce qui a pour cons&#233;quence
que l&#8217;intersection ou la jointure consid&#232;rent comme diff&#233;rents une m&#234;me cha&#238;ne d&#233;coup&#233;e de
deux fa&#231;ons diff&#233;rentes.
</p>
<p>Comme tout produit cart&#233;sien, les unit&#233;s doivent agglom&#233;rer des composantes ind&#233;pendantes.
Cela signifie que les types des diff&#233;rentes composantes de l&#8217;unit&#233; doivent &#234;tre disjoints. Il est par
exemple interdit de d&#233;finir unit faux is {T_let: &lt;lettre&gt;*, suite: {num}+},
car les deux composantes ont le niveau T_let en commun.
</p>
<p>La syntaxe propos&#233;e pour les expressions rationnelles ne permet de d&#233;finir que des structures
arborescentes, dans lesquelles les diff&#233;rentes unit&#233;s sont imbriqu&#233;es.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Typage, produit cart&#233;sien et unit&#233;s d&#8217;analyse 3.3 Autres constructions
</p>
<p>3.3 Autres constructions
</p>
<p>Nous venons de voir comment sont d&#233;finies des relations rationnelles au moyen d&#8217;expressions
rationnelles &#233;tendues avec des accolades. Une autre fa&#231;on de d&#233;finir des relations rationnelles
consiste en un calcul o&#249; des op&#233;rateurs sont appliqu&#233;es &#224; des relations rationnelles pr&#233;alable-
ment d&#233;finies. Ces op&#233;rateurs comportent les op&#233;rateurs utilisables dans les expressions ra-
tionnelles (concat&#233;nation, &#233;toile, diff&#233;rence), plus quelques autres, notamment la projection, la
jointure, le renommage, l&#8217;ajout et l&#8217;&#233;limination d&#8217;unit&#233;s. La syntaxe est la suivante.
</p>
<p>let n_1_9 = union(n_1, n_2_6, n_7_9);
regexp schema is {c2l: T_let= (&lt;letter&gt;-&lt;sep&gt;)*}
</p>
<p>{c2l:T_let= &lt;&gt;|(&lt;sep&gt;(&lt;letter&gt;*))}*;
let n_1_69 = union(n_1_9, n_10_19, n_20_69);
let seq = intersect(n_1_69,schema);
</p>
<p>La jointure n&#8217;est pas toujours possible, puisqu&#8217;en toute g&#233;n&#233;ralit&#233;, le r&#233;sultat n&#8217;est pas rationnel.
Elle est possible dans les cas suivants : il y a au plus un niveau commun aux deux op&#233;randes,
ou alors il y a plusieurs niveaux communs mais tous ces niveaux sont synchronis&#233;s (d&#233;coup&#233;s)
de fa&#231;on identique dans les deux machines. Nous n&#8217;irons pas plus loin dans l&#8217;expression de
la condition exacte. On peut la trouver dans (Barth&#233;lemy, 2007). Dans tous les cas o&#249; elle est
admise, le r&#233;sultat de la jointure est une structure de graphe acyclique.
Cela permet de repr&#233;senter certains d&#233;coupages diff&#233;rents de certains niveaux (par exemple,
syllabes et affixes), mais pas tous. Ces structures plus riches que des arborescences ne peuvent
pas &#234;tre d&#233;crites avec les expressions rationnelles &#233;tendues pour des raisons de lisibilit&#233;.
</p>
<p>L&#8217;&#233;limination d&#8217;une unit&#233; dans une relation n&#8217;est autoris&#233;e que dans le cas o&#249; cette unit&#233; ne
concerne qu&#8217;un des niveaux de cette relation ou si c&#8217;est une unit&#233; englobante d&#8217;une autre unit&#233;
ayant le m&#234;me type. De m&#234;me, l&#8217;ajout d&#8217;une unit&#233; n&#8217;est possible que si elle ne concerne qu&#8217;un
niveau ou si c&#8217;est une unit&#233; englobante d&#8217;une autre unit&#233; ayant le m&#234;me type. La raison de ces
restrictions est discut&#233;e dans la section 3.4.
</p>
<p>La morphologie &#224; deux niveaux utilise des r&#232;gles contextuelles pour sp&#233;cifier des correspon-
dances entre niveaux d&#8217;une relation. Ces r&#232;gles sont de quatre types assez complexes (restriction
de contexte, coercition de surface, etc.) pour les syst&#232;me &#224; la Kimmo et des r&#232;gles de r&#233;&#233;cri-
ture pour les syst&#232;mes &#224; la Xerox. Nous utilisons dans notre langage des r&#232;gles de restriction
g&#233;n&#233;ralis&#233;e de (Yli-Jyr&#228; &amp; Koskenniemi, 2004). Elles sont simples &#224; d&#233;crire et g&#233;n&#233;ralisent
&#233;l&#233;gamment les autres types de r&#232;gles.
</p>
<p>Un r&#232;gle de Restriction G&#233;n&#233;ralis&#233;e se lit comme une implication logique, si pr&#233;condition alors
cons&#233;quence. Les deux termes sont des expressions rationnelles &#233;tendues dans lesquelles deux
occurrences du symbole sp&#233;cial # d&#233;limitent le centre et les contextes gauche et droit. Prenons
un exemple.
</p>
<p>rule accord_cent is pattern: {num};
constraint {num: seg = {c2l}*#{c2l:&lt; &gt;?cents}#{c2l}*}
=&gt; {num: seg = {c2l}*#{c2l: cents}#};
</p>
<p>Une telle r&#232;gle &#233;quivaut &#224; une restriction de contexte. Elle peut se lire : si le mot cents avec un s
appara&#238;t, alors il doit &#234;tre le dernier mot du cardinal. On a d&#233;fini ici le centre comme &#233;tant toute
l&#8217;unit&#233; c2l. On aurait pu dans cet exemple choisir comme centre la seule cha&#238;ne cents.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>3.4 Aspects techniques Fran&#231;ois Barth&#233;lemy
</p>
<p>Une r&#232;gle de restriction g&#233;n&#233;ralis&#233;e est un moyen de d&#233;crire une relation. C&#8217;est la sous-relation
du motif d&#233;clar&#233; par pattern qui respecte la contrainte d&#233;crite par la r&#232;gle. Il ne s&#8217;agit pas de
r&#233;&#233;criture mais d&#8217;exprimer une contrainte pesant &#233;ventuellement sur plusieurs niveaux.
</p>
<p>Une r&#233;&#233;criture consiste &#224; remplacer une cha&#238;ne &#224; un certain niveau par une autre. On peut la
r&#233;aliser au moyen des op&#233;rations suivantes : d&#233;crire une relation rationnelle entre la cha&#238;ne &#224;
r&#233;&#233;crire et sa future valeur. Pour cela, la valeur future sera exprim&#233;e sur un niveau sp&#233;cial que
nous appellerons T_fut. Eventuellement, cette relation peut comprendre d&#8217;autres niveaux, qui
ne changent pas eux-m&#234;mes mais conditionnent la r&#233;&#233;criture. Pour effectuer la r&#233;&#233;criture, on
r&#233;alise la jointure entre la nouvelle relation et la relation &#224; modifier, puis par projection, on
supprime le niveau &#224; r&#233;&#233;crire et finalement, on renomme T_fut pour lui donner le nom de
ce niveau. La r&#233;&#233;criture n&#8217;est pas une op&#233;ration primitive &#224; ajouter dans le langage, mais nous
avons pr&#233;vu une syntaxe pour l&#8217;exprimer simplement. La r&#233;&#233;criture peut se d&#233;finir aussi bien au
moyen d&#8217;une expression rationnelle que d&#8217;une r&#232;gle contextuelle.
</p>
<p>3.4 Aspects techniques
</p>
<p>Le travail pr&#233;sent&#233; ici repose sur l&#8217;insertion dans les diff&#233;rentes cha&#238;nes de symboles sp&#233;-
ciaux, les accolades, marquant le d&#233;but et la fin des unit&#233;s d&#8217;analyse. Ces symboles servent
&#224; la synchronisation des diff&#233;rents niveaux. Aucun produit cart&#233;sien n&#8217;est autoris&#233; sans une
telle synchronisation. Cela introduit une propri&#233;t&#233;, c&#8217;est que pour tout tuple d&#8217;une relation, le
nombre d&#8217;occurrences d&#8217;une unit&#233; donn&#233; est le m&#234;me pour tous les niveaux qu&#8217;elle concerne.
Par exemple, pour toute forme analys&#233;e conform&#233;ment &#224; notre embryon d&#8217;exemple, le nombre
d&#8217;unit&#233;s c2l (resp. de symboles &lt;{c2l&gt;, de symboles &lt;c2l}&gt;) est le m&#234;me dans le niveau
des chiffres (T_chif) et dans celui des lettres (T_let). Cette propri&#233;t&#233; est utilis&#233;e pour garan-
tir une cl&#244;ture sous intersection (et diff&#233;rence ensembliste) des relations en utilisant l&#8217;algorithme
de resynchronisation de (Eilenberg, 1976) sur des unit&#233;s plus longues que des symboles. Les
principes th&#233;oriques de cette approche sont discut&#233;s dans (Barth&#233;lemy, 2007).
La compilation de telles relations a &#233;t&#233; &#233;tudi&#233;e dans (Barth&#233;lemy, 2007). Cette compilation
r&#233;sulte en une machine finie qui peut &#234;tre vue soit comme un automate, soit comme un trans-
ducteur. Dans la vision transducteur, les symboles ordinaires sont reconnus ind&#233;pendamment
alors que les accolades sont lues simultan&#233;ment sur tous les niveaux qu&#8217;elles synchronisent.
Les restrictions apport&#233;es sur la jointure et les suppressions/insertions d&#8217;accolades viennent de
la n&#233;cessit&#233; de repr&#233;senter des structures de graphe acyclique au moyen de cha&#238;nes de caract&#232;res.
Cela suppose que les ordres partiels induits par les diff&#233;rents d&#233;coupages en unit&#233;s sont plon-
geables dans un ordre total et de plus qu&#8217;il est possible de choisir un ordre canonique pr&#233;serv&#233;
par les op&#233;rations rationnelles.
</p>
<p>4 Comparaison avec d&#8217;autres langages
</p>
<p>Comme nous venons de le voir, les relations rationnelles d&#233;crites par notre langage sont compi-
l&#233;es en automates finis. Cela signifie que le pouvoir expressif du syst&#232;me est celui des automates
finis. C&#8217;est une puissance moindre que celle de syst&#232;mes de r&#232;gles de r&#233;&#233;criture tels xfst, qui
ont la puissance des relations rationnelles g&#233;n&#233;rales. Loin d&#8217;&#234;tre un handicap, cette puissance
moindre est la cl&#233; qui permet d&#8217;offrir un jeu d&#8217;op&#233;rations beaucoup plus riche que celles dont
on dispose pour les relations rationnelles.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Typage, produit cart&#233;sien et unit&#233;s d&#8217;analyse
</p>
<p>Outre les trois op&#233;rateurs rationnels et leurs d&#233;riv&#233;s, ces derni&#232;res offrent la composition et les
projections. Toutes ces op&#233;rations sont &#233;galement pr&#233;sentes dans notre langage, mais avec en
plus la jointure naturelle, l&#8217;intersection et la diff&#233;rence.
Au-del&#224; des aspects th&#233;oriques, nous pensons que le surcro&#238;t de puissance des syst&#232;mes de
r&#233;&#233;criture a peu d&#8217;impact en pratique pour les descriptions morphologiques. La plupart des des-
criptions peuvent probablement se traduire relativement facilement d&#8217;un langage vers l&#8217;autre.
C&#8217;est ce qui s&#8217;est pass&#233; pour la description des nombres finnois traduite directement de xfst
dans notre langage.
</p>
<p>Nous pouvons d&#233;tailler ce qui se produit au cours de cette traduction. D&#8217;une part, deux informa-
tions (les chiffres et les traits) concat&#233;n&#233;es sur le niveau lexical de xfst sont s&#233;par&#233;es sur deux
niveaux diff&#233;rents de notre langage. Dans le processus de compilation de notre grammaire, les
deux repr&#233;sentations sont &#233;galement concat&#233;n&#233;es, mais pas n&#233;cessairement dans le m&#234;me ordre.
Par ailleurs, les unit&#233;s vraiment importantes dans la descriptions sont mat&#233;rialis&#233;es en xfst par
des symboles ordinaires. Ainsi, la notion correspondant &#224; l&#8217;unit&#233; c2l de notre exemple est no-
t&#233;e par un # en xfst. La gestion de ce symbole (introduction, &#233;limination) est explicite dans le
code xfst. Un autre type d&#8217;unit&#233;s est cod&#233; par le symbole |.
A un certain niveau d&#8217;analyse, les deux descriptions sont donc relativement proches. Les dif-
f&#233;rences portent sur l&#8217;interface utilisateur et quelques nuances. L&#8217;outil de Xerox tend &#224; d&#233;crire
des fonctions multivalu&#233;es servant &#224; transformer une entr&#233;e en une sortie. Notre outil a une
approche plus relationnelle, o&#249; l&#8217;on met en relation de fa&#231;on structur&#233;e des repr&#233;sentations dif-
f&#233;rentes. Par ailleurs, notre cadre est plus d&#233;claratif avec des notions plus abstraites comme la
s&#233;paration de plus de niveaux ou la notion d&#8217;unit&#233; d&#8217;analyse. Nous pensons que cela contribue
au confort de l&#8217;utilisation. Dans certains cas, la contrepartie peut &#234;tre une moindre efficacit&#233;, le
compilateur optimisant moins bien qu&#8217;un programmeur xfst averti.
</p>
<p>Nous aurons du mal &#224; &#233;tablir une comparaison avec le seul autre syst&#232;me multi-niveaux que nous
connaissions : wfsc de Xerox (Kempe et al., 2003). Cet outil n&#8217;est pas diffus&#233; et les publications
&#224; son sujet ne sont pas tr&#232;s d&#233;taill&#233;es. Il s&#8217;agit d&#8217;une bo&#238;te &#224; outils de transducteurs multi-niveaux
pond&#233;r&#233;s. Il impl&#233;mente la jointure. Les niveaux ne sont pas nomm&#233;s mais identifi&#233;s par leur
rang. Il est plus g&#233;n&#233;ral que notre outil car il impl&#233;mente les relations rationnelles n-aires sans
restrictions. En revanche, il ne propose pas de notion d&#8217;unit&#233; d&#8217;analyse. C&#8217;est un v&#233;ritable outil
avec un travail important sur les structures de donn&#233;es et les algorithmes alors que notre langage
est une sur-couche externe au-dessus d&#8217;une bo&#238;te &#224; outils d&#8217;automates finis.
</p>
<p>5 Conclusion
</p>
<p>Dans cet article, nous avons insist&#233; sur le coeur de notre proposition, &#224; savoir utiliser une notion
d&#8217;unit&#233; d&#8217;analyse pour structurer des descriptions multi-niveaux. Dans sa mise en oeuvre, cette
notion ressemble &#224; celle d&#8217;enregistrement dans les langages de programmation.
</p>
<p>Nous n&#8217;avons pas eu la place de pr&#233;senter d&#8217;autres aspects int&#233;ressants de notre langage. La
notion de sous-unit&#233; permet de simplifier l&#8217;&#233;criture d&#8217;expressions rationnelles au moyen de
d&#233;clarations donnant des valeurs par d&#233;faut &#224; certains membres d&#8217;une unit&#233;. Par ailleurs, les
structures de traits typ&#233;es non r&#233;cursives et &#224; domaines de valeurs finis sont propos&#233;es dans la
syntaxe et compil&#233;es en automates finis.
</p>
<p>Notre mod&#232;le offre quelques sources de complexit&#233; qui risquent d&#8217;aller contre son objectif d&#8217;er-</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Fran&#231;ois Barth&#233;lemy
</p>
<p>gonomie et de d&#233;clarativit&#233;. Par exemple, les conditions d&#8217;emploi de la jointure ne sont pas
simples. Nous esp&#233;rons que beaucoup d&#8217;applications ne sont pas sujettes aux subtilit&#233;s de cette
question. Remarquons au passage que les r&#232;gles contextuelles &#224; la Kimmo et &#224; la xfst ne sont
pas exemptes de complexit&#233; non plus.
</p>
<p>L&#8217;utilisation de structures arborescente a &#233;t&#233; test&#233;e au moyen de multiple exemples de taille
significative. Ce n&#8217;est pas encore le cas des structures de graphes acyclique plus complexes.
Leur int&#233;r&#234;t pratique reste &#224; &#233;valuer.
</p>
<p>Notre mod&#232;le est dans la lign&#233;e de la morphologie &#224; deux niveaux en privil&#233;giant l&#8217;aspect rela-
tionnel et l&#8217;op&#233;ration d&#8217;intersection. Il s&#8217;affranchit des r&#232;gles complexes et g&#233;n&#233;rant des conflit
de cette approche. En revanche, il int&#232;gre des r&#232;gles de r&#233;&#233;criture l&#233;g&#232;res venant du mod&#232;le s&#233;-
quentiel. Il s&#8217;inscrit dans la continuit&#233; de ses devanciers, les diff&#233;rences &#233;tant dans le processus
de compilation pour atteindre un r&#233;sultat voisin. Il apporte un plus grand confort dans le cas o&#249;
les repr&#233;sentations sont multiples et tr&#232;s diff&#233;rentes, les autres mod&#232;les &#233;tant des solutions plus
l&#233;g&#232;res dans le cas o&#249; il s&#8217;agit de relier deux repr&#233;sentations voisines, comme une repr&#233;sentation
canonique des affixes et une r&#233;alisation qui en est une simple alternance.
</p>
<p>R&#233;f&#233;rences
ANTWORTH E. L. (1995). User&#8217;s Guide to PC-Kimmo Version 2. Dallas, Texas : Summer
Institute of Linguistics.
BARTH&#201;LEMY F. (2007). Multi-grain relations. In Implementation and Application of Auto-
mata, 12th International Conference (CIAA), p. 243&#8211;252, Praque, Czech Republic.
BARTH&#201;LEMY F. (2007). Using mazurkiewicz trace languages for partition-based morpho-
logy. In ACL, Prague (Czech Republic).
BEESLEY K. R. &amp; KARTTUNEN L. (2003). Finite State Morphology. CSLI Publications.
EILENBERG S. (1976). Automata, Languages, and Machines. Orlando, FL, USA : Academic
Press, Inc.
KARTTUNEN L. (2006). Numbers and finnish numerals. SKY Journal of Linguistics, 19,
407&#8211;421. Festschrift in Honour of Fred Karlsson on his 60th Birthday.
KEMPE A., BAEIJS C., GA&#193;L T., GUINGNE F. &amp; NICART F. (2003). WFSC &#8211; A new
weighted finite state compiler. In Proc. 8th Int. Conf. on Implementation and Application of
Automata (CIAA&#8217;03), LNCS 2759, p. 108&#8211;119, Santa Barbara, CA, USA : Springer Verlag.
KEMPE A., CHAMPARNAUD J.-M. &amp; EISNER J. (2004). A note on join and auto-intersection
of n-ary rational relations. In B. WATSON &amp; L. CLEOPHAS, Eds., Proc. Eindhoven FASTAR
Days, Eindhoven, Netherlands.
KIRAZ G. A. (2001). Computational Nonlinear Morphology. Cambridge University Press.
MCCARTHY J. J. (1981). A prosodic theory of nonconcatenative morphology. Linguistic
Inquiry, 12, 373&#8211;418.
YLI-JYR&#196; A. M. &amp; KOSKENNIEMI K. (2004). Compiling contextual restrictions on strings
into finite-state automata. In Proceedings of the Eindhoven FASTAR Days 2004 (September
3&#8211;4), Eindhoven, The Netherlands.</p>

</div></div>
</body></html>