TALN 2008, Avignon, 9-13 juin 2008

Typage, produit cartésien et unités d’analyse pour les modéles
51 états ﬁnis

Francois Barthélemy1’2
(1) CNAM, Cedric, 292 rue Saint-Martin, 75003 Paris
(2) INRIA, Alpage, 78153 Le Chesnay cedex
barthe@cnam.fr

Résumé. Dans cet article, nous présentons un nouveau langage permettant d’écrire des
relations rationnelles compilées en automates ﬁnis. Les deux caractéristiques innovantes de ce
langage sont de pourvoir décrire des relations a plusieurs niveaux, pas nécessairement deux et
d’utiliser diverses unités d’analyse pour exprimer les liens entre niveaux. Cela permet d’aligner
de facon ﬁne des représentations multiples.

Abstract. In this paper, we present a new language to write rational relations compiled
into ﬁnite state automata. There are two main novelties in the language. Firstly, the descriptions
may have more than two levels. Secondly, various units may be used to express the relationships
between the levels. Using these features, it is possible to align ﬁnely multiple representations.

M0tS-CléS 2 Machine ﬁnie a états, morphologie a deux niveau.

Keywords: Finite-state machine, two-level morphology.

1 Introduction

Les machines a états ﬁnis, a savoir les automates et transducteurs, ont une place importante dans
plusieurs domaines de la linguistique informatique, notamment la description morphologique,
le traitement des entités nommées, les approximations de syntaxe, la recherche de motifs.

Ces machines sont spéciﬁées au moyen d’expressions régulieres, de regles contextuelles ainsi
que par l’application d’opérateurs sur des machines existantes. Les automates implémentent des
langages rationnels et les transducteurs des relations rationnelles. Ce sont deux types d’objets
différents, pouvant étre convertis l’un dans l’autre au moyen d’opérations. Une relation peut étre
obtenue en faisant le produit cartésien de deux langages et un langage peut étre obtenu en faisant
une projection d’une relation sur sa premiere ou sa seconde composante. Les opérations ration-
nelles (concaténation, cloture sous concaténation ou étoile, disjonction) sont déﬁnies sur les
deux types d’objets. En revanche, certaines opérations ensemblistes, notamment l’intersection
et la différence, ne sont des opérations internes que pour les langages rationnels. Les relations
pour leur part, sont closes sous composition, une opération qui n’a pas de sens sur les langages.

Dans cet article, nous proposons une extension aux relations n-aires, c’est-a-dire pouvant avoir
plus de deux composantes ou niveaux, spécialement adaptée pour des descriptions linguistiques
reliant des représentations différentes de certains objets. Cette extension est un langage qui
s’inscrit dans la lignée de langages comme PC-Kimmo (Antworth, 1995) ou Xfst (Beesley &

Francois Barthélemy

Karttunen, 2003). I1 autorise aussi bien les descriptions paralleles (intersection de transducteurs)
que séquentielles (composition de transducteurs). Outre la formalisation de descriptions a plus
de deux niveaux, le second apport du langage est de proposer la notion d ’um'te’ d ’analyse pour
mettre en correspondance les différents niveaux.

La premiere section de cet article motive l’approche au moyen d’exemples montrant l’intérét de
représentations multiples et d’unités d’analyse diverses. La seconde section est une présentation
du langage. La troisieme situe ce travail par rapport a d’autres approches représentatives du
domaine.

2 Intérét des niveaux et unités multiples

2.1 Motivation de l’approche multi-niveaux

Nous allons motiver l’utilisation de descriptions linguistiques utilisant plus de deux representa-
tions au moyen de quelques exemples.

George Anton Kiraz a proposé une description de la morphologie de la langue syriaque utilisant
quatre représentations : une représentation écrite de surface et trois dimensions orthogonales
représentant des unités d’analyse éventuellement discontigues : la racine consonnantique, le
schéma vocalique et un motif paradigmatique (Kiraz, 2001). Le tableau suivant offre un exemple
de forme avec les quatre niveaux correspondants.

racine k t b
schéma vocalique a e

motif paradigmatique C V C C V C
forme k a t t e b

Ce type de description a été utilisée également pour la morphologie de l’arabe. Elle s’appa-
rente a l’approche de la morphologie des langues sémitiques de (McCarthy, 1981). Chacun
des niveaux de description est décrit au moyen d’un inventaire exhaustif. La compatibilité des
différents niveaux est régie par des regles.

Prenons un autre exemple : la description des formes morphologiques utilisées dans des mes-
sages SMS. L’écriture utilisée dans ce type de messages (et d’autres formes de communica-
tion électronique) mélange plusieurs sous-systemes, l’un d’entre eux étant l’écriture habituelle,
d’autres étant phonétiques ou idéographique. Le passage d’un sous-systeme a un autre se fait
parfois au sein d’une méme forme. On ne peut pas analyser une telle forme sans recourir a deux
représentations, l’une graphémique l’autre phonétique, ce qui conduit a une description a trois
niveaux. Nous utilisons un quatrieme niveau d’analyse qui explicite le sous-systeme graphique
utilisé par une séquence de caracteres. Voici un exemple de forme avec les niveaux correspon-
dants. La premiere lettre est interprétée comme relevant du systeme phonétique syllabique ou
un caractere dénote la syllabe utilisée comme nom de la lettre, la seconde comme relevant de
l’écriture habituelle et la troisieme, d’une écriture habituelle dans laquelle les accents sont omis.

forme graphique c a f e
forme phonétique k a f e
translittération k-syll f-graph e-graph-sa
forme de surface k f e

Typage, produit cartésien et unités d’analyse 2.2 Unités d’analyse

La reference a deux logiques, l’une concernant le systeme graphique, l’autre le systeme phoné-
tique conceme également l’écriture habituelle. Par exemple, le choix de la forme in ou im dans
le préﬁxe négatif (im+mangeable/in+décidable) est surtout graphique, alors que le choix de la
forme d’une racine verbale peuv ou pouv pour le verbe pouvoir dépend de criteres phonolo-
giques, a savoir le caractere ouvert ou fermé de la syllabe contenant la voyelle. Dans la plupart
des systemes de morphologie a deux niveaux, les deux types de phénomenes sont traités par une
unique représentation qui est de nature hybride et utilise des méta-caracteres pour capturer l’une
ou l’autre (ou les deux) des dimensions a considérer. Si l’on pouvait décrire chaque logique se-
parément sans tomber dans une formalisation trop lourde, ce serait certainement préférable.

Un demier exemple terminera cette section : celui des nombres en toutes lettres. Lauri Karttu-
nen a publié un article sur la description des nombres en ﬁnnois (Karttunen, 2006) et il met a
disposition sur la toile les ﬁchiers contenant cette description au format des outils Xerox (xfst et
lexc). Cette description relie un niveau de surface ou les nombres sont écrits en toutes lettres a
un niveau abstrait ou une notation en chiffres arabes est concaténée a des valeurs de traits (cas,
nombre, caractere ordinal ou cardinal). Cette concaténation a un caractere arbitraire puisque les
deux types d’informations sont différentes. Nous préférons pour notre part une representation
a trois niveaux, avec la représentation en lettres, la représentation en chiffres et les traits. La
représentation en chiffres a un intérét propre : elle est d’usage courant. Par ailleurs, l’ordre des
chiffres dans un nombre est éminemment signiﬁcatif alors qu’il n’y a pas d’ordre entre les traits,
au moins d’un point de vue conceptuel.

Nous sommes donc partis de la description de Lauri Karttunen pour écrire une description a
trois niveaux pour les nombres en ﬁnnois et nous l’avons ensuite enrichie pour décrire égale-
ment les nombres en francais, avec l’ajout de nouveaux niveaux. D’une part, nous avons un
niveau pour les nombres écrits en francais. D’autre part, nous avons scindé les traits en trois
categories, chacune enregistrée sur un niveau : les traits communs aux deux langues (nombre
et caractere ordinal/cardinal) et les traits spéciﬁques a une ou l’autre des langues : cas pour le
ﬁnnois, genre pour le francais (utilisé pour un/une, premier/premiere, second/seconde). Ce qui
fait au total six niveaux : francais, ﬁnnois, chiffres, traits communs, traits francais, traits ﬁnnois.
Cette description permet de traduire d’une langue a l’autre, des chiffres a une langue, de fa-
con plus ou moins déterministe en fonction des traits renseignés. La multiplication des niveaux
pourrait étre un handicap si l’on approchait une taille critique pour la machine ﬁnie obtenue. Ce
n’est pas le cas dans cet exemple.

2.2 Unités d’analyse

Une description morphologique nécessite de coordonner une multiplicité d’unités d’analyse.
C’est déja le cas pour les descriptions a deux niveaux habituelles. Ca l’est encore davantage
avec les descriptions a multiples niveaux reliant des représentations tres différentes.

La partie de la morphologie qui décrit la structure des formes fait appel a la notion de morpheme
(ou une autre notion d’unité dans le cas de morphologie non concaténative). Cette description
ne prend pas en compte la forme de chaque morpheme. Cette indifférence aux contenus des
afﬁxes est particulierement visible dans la syntaxe du systeme PC-Kimmo avec la construction
ALTERNATION, et dans une moindre mesure avec lexc de Xerox.

Lorsqu’on multiplie les représentations différentes, les correspondances entre représentations
peuvent mettre en jeu plusieurs types d’unités. Par exemple, entre un nombre en lettres et un

Francois Barthélemy

nombre en chiffres, la correspondance n’est pas simple, comme l’illustrent les quelques cas
suivants.

3 5 6 2 1 | 0 6 2 1 | 3 6 | 0
trois mille cinq cent trente deux mille trente deux treize-cent trente

Toujours dans cet exemple des nombres, les structures de traits concernent un nombre dans son
intégralité. On a donc deux types d’unité en jeu dans les correspondances entre représentations :
la forme complete et l’unité de correspondance chiffres/lettres. De plus, dans cette derniere,
on peut distinguer des unités plus petites telles que les afﬁxes qui interviennent dans les cas
de ﬂexion. C’est plus clair dans le cas du ﬁnlandais pour lequel une déclinaison a douze cas
ﬂéchit chacun des chiffres d’un nombre. Cela existe en francais surtout sur le dernier mot de la
séquence, car c’est la que se fait l’accord en genre et nombre. 11 y a alors 4 types d’unités, plus
la notion de symbole ou caractere qui est l’unité de base dans la description. Dans cet exemple,
les différentes unités sont imbriquées les unes dans les autres, ce qui autorise une représentation
arborescente des analyses.

[type=card,gen=fem]
4 1

3
trois cent quarante E

Ce n’est pas toujours le cas : les unités d’analyse peuvent découper certaines formes de fa-
con différentes sans qu’il n’y ait imbrication de l’une dans l’autre. Beaucoup de phénomenes
de nature phonologique relevent d’une autre organisation que la morpho-syntaxe. Quelques
exemples : la réalisation du schwa et la prononciation d’une consonne ﬁnale peuvent s’expli-
quer avec une notion de syllabe qui peut réunir des fragments de formes ﬂéchies différentes. A
une autre échelle, au sein d’une forme, la syllabiﬁcation détermine la forme de certaines racines
verbales comportant des alternances et une méme syllabe peut regrouper des portions d’afﬁxes
différents. Les deux notions d’afﬁxe et de syllabe sont orthogonales, aucune n’est imbriquée
dans l’autre.

La notion d’unité d’analyse que nous voyons dans ces différents exemples sert notaInment a
exprimer des relations de correspondances entre représentations différentes. Au sein d’une telle
unité, les différentes représentations sont soit indépendantes (par exemple, cent est en relation
avec 100, mais il n’y a pas de relation spéciale entre quelque sous-chaine que ce soit de cent
et une sous-chaine de 100), soit coordonnées au moyen d’une unité plus petite enchassée.

3 Présentation du langage

3.1 Types et opérations sur les relations n-aires

Les relations rationnelles sont intrinsequement typées par leur arité, c’est-a-dire leur nombre de
composantes. Par exemple, on ne peut pas concaténer un ensemble de couples et un ensemble de
tripletsl. En pratique, un typage plus fort est intéressant pour distinguer différentes informations.
Par exemple, si l’on considere une relation a trois composantes entre nombres en toutes lettres,
nombre en chiffres et structures de traits, il y a trois projections différentes qui donnent une
relation binaire. Si l’on s’en tient au typage minimal par arité, on peut opérer une concaténation
entre une relation binaire comportant les lettres et les chiffres et une autre entre les lettres et les

1Sauf a réaliser une coercition de type implicite qui complete les couples pour en faire des triplets.

Typage, produit cartésien et unités d’analyse 3.2 Expressions rationnelles étendues

traits. Nous proposons une discipline différente ou l’on s’interdit cela en déﬁnissant un typage
plus fort.

Pour ce faire, nous allons utiliser des noms pour identiﬁer chaque composante, comparables
aux noms d’attributs des bases de données relationnelles. Un type de relation consistera en
un ensemble de noms d’attributs. Ce procédé permet de ne plus utiliser l’ordre pour identiﬁer
les composantes, apportant plus de souplesse dans les notations. De plus, les noms permettent
de simpliﬁer l’expression de certaines opérations. Il n’y a pas de différences théoriques entre
relations avec composantes ordonnées et relations avec composantes nommées.

Une nouvelle opération, le renommage, consiste a changer le nom de certaines composantes.
Elle réalise une conversion de type explicite (cast).

Les opérations qui changent le type de leurs opérandes sont la projection et la jointure. La
projection consiste a éliminer purement et simplement certaines composantes. Elle admet deux
variantes syntaxiques, l’une ou on spéciﬁe ce que l’on élimine, l’autre ou on spéciﬁe ce que l’on
conserve.

La jointure consiste a fusionner deux relations qui peuvent avoir des composantes en commun,
mais pas nécessairement toutes (Kempe et al., 2004). Les tuples du résultats proviennent de
la fusion de deux tuples venant chacun d’un des opérandes et qui sont égaux sur les compo-
santes communes. Le type du résultat est l’union des type des opérandes. Si ces deux types sont
disjoints (il n’y a aucun niveau commun), la jointure est un produit cartésien. S’ils sont égaux
(tous les niveaux sont communs aux deux machines), la jointure est une intersection. S’il y a
une composante commune, la jointure s’apparente a une composition, mais il n’y a pas d’éli-
mination de cette composante dans le résultat. Cette élimination systématique a pour objet de
maintenir a deux le nombre de composantes du résultat, ce qui est hors de propos lorsqu’on
admet des relations n-aires.

La jointure pose un probleme : en général, la jointure de deux relations rationnelles n’est pas
une relation rationnelle. C’est bien connu dans le cas particulier de l’intersection : l’intersection
de deux relations rationnelles n’est pas toujours rationnelle. Face a cette difﬁculté, il convient
de déﬁnir quelles jointures sont possibles a réaliser.

3.2 Expressions rationnelles étendues

Une unité est représentée par un tuple typé qui comporte un certain nombre de composantes
nommées. Une composante est soit directement un des niveaux d’analyse, auquel cas elle
contient une chaine de symboles de l’alphabet, soit une composante est le résultat d’un pro-
duit cartésien imbriqué, auquel cas elle contient une chaine de tuples ayant le méme type.

Chaque expression rationnelle a un type, qui est un ensemble de niveaux. Si cet ensemble est un
singleton, elle est une expression rationnelle ordinaire dénotant un langage. Si le type contient
plus d’un niveau, l’expression consiste en une expression rationnelle dont les atomes sont des
tuples ayant ce type. Les composantes des tuples sont des expressions rationnelles sur leurs
types respectifs. Chaque tuple présent dans une description doit étre une occurrence d’une unité
d’analyse préalablement déclarée.

Nous allons présenter des fragments d’une grammaire décrivant la relation entre mots écrits en
lettres et mots écrits en chiffres. Outre les deux niveaux des chiffres et des lettres, elle comporte
un niveau comportant l’information de genre qui détermine les formes en lettres se terminant

3.2 Expressions rationnelles etendues Francois Barthelemy

par un/une. 11 y a deux unites d’analyse : une unite de correspondance chiffre/lettre et une unite
qui est le nombre. Le nombre peut comporter plusieurs unites de correspondance chiffre/lettre.
Les noms des deux unites sont respectivement c2 1 et num. La grammaire commence avec les
declarations de l’alphabet divise en classes de symboles, des types de structures de traits et des
unites d’analyse. Dans les expressions, les symboles comportant plusieurs caracteres ou des
caracteres de ponctuation sont ecrits entoures par les signes < et >. Par exemple, < > designe
un espace, <lett re> designe la classe de caractere lett re. La chaine vide est notee <>.

Le nom d’unite d’analyse est donne en debut de chaque tuple. Les composantes des tuples
sont nommees, ce qui permet d’accepter plusieurs syntaxes : avec les noms, l’ordre n’etant
pas signiﬁcatif, ou sans les noms, l’ordre etant celui de la declaration. De plus, la declaration
comporte une valeur par defaut pour chacune des composantes, ce qui permet d’abbreger la
notation.

La syntaxe exige que les noms de niveaux commencent avec T_ (t pour tape, ruban). Le point
d’interrogation est l’operateur qui rend optionnelle l’expression qui precede. Les points de sus-
pensions sont utilises pour raccourcir l’exemple d’un point de vue typographique et ne font pas
partie de la syntaxe du langage.

class genre is masc, fem;

class chiffre is O, l, 2, 3, 4, 5, 6, 7, 8, 9;
class lettre is a, b, ..., <—>, < >;

class sep is < >, <—>;

unit c2l is {T_chif: <chiffre>*, T_let: <lettre>*}
unit num is {T_fs: <genre>, segs: {c2l}* }

regexp zero is {num: segs = {c2l: 0, zero}};
regexp n_l is {c2l: l, (< >et< >)?un(e?)};
regexp n_2_6 is {c2l: 2, <—>?deux}|...|{c2l: 6, <—>?six};

Les operateurs binaires doivent avoir deux operandes du meme type, c’est-a-dire decrivant deux
relations ayant les memes composantes ou niveaux. Il est ainsi possible de concatener deux
occurrences d’une unite mais impossible de concatener par exemple un num et un c2 1.

La notation par accolades denote un produit cartesien avec ajout implicite d’accolades typees
dans les composantes. Par exemple,

{num: segs = {c2l: 0, zero} } denote le produit cartesien:

(T_fs= <{num>(<masc>|<fem>)<num}>)X

(T_chif= <{num><{c2l>O<c2l}><num}>)X

(T_let= <{num><{c2l>zero<c2l}><num}>)

dans lequel < { c2l>, <c2l } >, <{num> et <num} > sont quatre symboles atomiques ordi-
naires. 11 y a donc inscription des limites d’unites dans les chaines, ce qui a pour consequence
que l’intersection ou la jointure considerent comme differents une meme chaine decoupee de
deux facons differentes.

Comme tout produit cartesien, les unites doivent agglomerer des composantes independantes.
Cela signiﬁe que les types des differentes composantes de l’unite doivent etre disjoints. Il est par
exemple interdit de deﬁnir unit faux is {T_let: <lettre>* , suite: {num} + } ,
car les deux composantes ont le niveau T_let en commun.

La syntaxe proposee pour les expressions rationnelles ne permet de deﬁnir que des structures
arborescentes, dans lesquelles les differentes unites sont imbriquees.

Typage, produit cartesien et unites d’analyse 3.3 Autres constructions

3.3 Autres constructions

Nous venons de voir comment sont deﬁnies des relations rationnelles au moyen d’expressions
rationnelles etendues avec des accolades. Une autre facon de deﬁnir des relations rationnelles
consiste en un calcul ou des operateurs sont appliquees a des relations rationnelles prealable-
ment deﬁnies. Ces operateurs comportent les operateurs utilisables dans les expressions ra-
tionnelles (concatenation, etoile, difference), plus quelques autres, notaInment la projection, la
jointure, le renommage, l’aj out et l’elimination d’unites. La syntaxe est la suivante.

let n_l_9 = union(n_l, n_2_6, n_7_9);
regexp schema is {c2l: T_let= (<letter>—<sep>)*}
{c2l:T_let= <>|(<sep>(<letter>*))}*;
let n_l_69 = union(n_l_9, n_lO_l9, n_20_69);
let seq = intersect(n_l_69,schema);

La jointure n’est pas toujours possible, puisqu’en toute generalite, le resultat n’est pas rationnel.
Elle est possible dans les cas suivants : il y a au plus un niveau commun aux deux operandes,
ou alors il y a plusieurs niveaux communs mais tous ces niveaux sont synchronises (decoupes)
de facon identique dans les deux machines. Nous n’irons pas plus loin dans l’expression de
la condition exacte. On peut la trouver dans (Barthelemy, 2007). Dans tous les cas o1‘1 elle est
admise, le resultat de la jointure est une structure de graphe acyclique.

Cela permet de representer certains decoupages differents de certains niveaux (par exemple,
syllabes et afﬁxes), mais pas tous. Ces structures plus riches que des arborescences ne peuvent
pas etre decrites avec les expressions rationnelles etendues pour des raisons de lisibilite.

L’elimination d’une unite dans une relation n’est autorisee que dans le cas o1‘1 cette unite ne
concerne qu’un des niveaux de cette relation ou si c’est une unite englobante d’une autre unite
ayant le meme type. De meme, l’ajout d’une unite n’est possible que si elle ne concerne qu’un
niveau ou si c’est une unite englobante d’une autre unite ayant le meme type. La raison de ces
restrictions est discutee dans la section 3.4.

La morphologie a deux niveaux utilise des regles contextuelles pour speciﬁer des correspon-
dances entre niveaux d’une relation. Ces regles sont de quatre types assez complexes (restriction
de contexte, coercition de surface, etc.) pour les systeme a la Kimmo et des regles de reecri-
ture pour les systemes a la Xerox. Nous utilisons dans notre langage des regles de restriction
generalisee de (Yli-Jyra & Koskenniemi, 2004). Elles sont simples a decrire et generalisent
elegamment les autres types de regles.

Un regle de Restriction Generalisee se lit comme une implication logique, si précondition alors
consequence. Les deux termes sont des expressions rationnelles etendues dans lesquelles deux
occurrences du symbole special # delimitent le centre et les contextes gauche et droit. Prenons
un exemple.

rule accord_cent is pattern: {num};
constraint {num: seg = {c2l}*#{c2l:< >?cents}#{c2l}*}
=> {num: seg = {c2l}*#{c2l: cents}#};

Une telle regle equivaut a une restriction de contexte. Elle peut se lire : si le mot cents avec un s
apparait, alors il doit etre le demier mot du cardinal. On a deﬁni ici le centre comme etant toute
l’unite c2 1. On aurait pu dans cet exemple choisir comme centre la seule chaine cent s.

3.4 Aspects techniques Francois Barthélemy

Une regle de restriction généralisée est un moyen de décrire une relation. C’est la sous-relation
du motif déclaré par patt e rn qui respecte la contrainte décrite par la regle. I1 ne s’agit pas de
réécriture mais d’exprimer une contrainte pesant éventuellement sur plusieurs niveaux.

Une réécriture consiste a remplacer une chaine a un certain niveau par une autre. On peut la
réaliser au moyen des opérations suivantes : décrire une relation rationnelle entre la chaine a
réécrire et sa future valeur. Pour cela, la valeur future sera exprimée sur un niveau spécial que
nous appellerons T_fut. Eventuellement, cette relation peut comprendre d’autres niveaux, qui
ne changent pas eux-mémes mais conditionnent la réécriture. Pour effectuer la réécriture, on
réalise la jointure entre la nouvelle relation et la relation a modiﬁer, puis par projection, on
supprime le niveau a réécrire et ﬁnalement, on renomme T_fut pour lui donner le nom de
ce niveau. La réécriture n’est pas une opération primitive a ajouter dans le langage, mais nous
avons prévu une syntaxe pour l’exprimer simplement. La réécriture peut se déﬁnir aussi bien au
moyen d’une expression rationnelle que d’une regle contextuelle.

3.4 Aspects techniques

Le travail présenté ici repose sur l’insertion dans les différentes chaines de symboles spé-
ciaux, les accolades, marquant le début et la ﬁn des unités d’analyse. Ces symboles servent
a la synchronisation des différents niveaux. Aucun produit cartésien n’est autorisé sans une
telle synchronisation. Cela introduit une propriété, c’est que pour tout tuple d’une relation, le
nombre d’occurrences d’une unité donné est le méme pour tous les niveaux qu’elle conceme.
Par exemple, pour toute forme analysée conformément a notre embryon d’exemple, le nombre
d’unités c2l (resp. de symboles < { c2l>, de symboles <c2l } >) est le méme dans le niveau
des chiffres (T_chi f) et dans celui des lettres (T_let). Cette propriété est utilisée pour garan-
tir une cloture sous intersection (et différence ensembliste) des relations en utilisant l’algorithme
de resynchronisation de (Eilenberg, 1976) sur des unités plus longues que des symboles. Les
principes théoriques de cette approche sont discutés dans (Barthélemy, 2007).

La compilation de telles relations a été étudiée dans (Barthélemy, 2007). Cette compilation
résulte en une machine ﬁnie qui peut étre vue soit comme un automate, soit comme un trans-
ducteur. Dans la vision transducteur, les symboles ordinaires sont reconnus indépendamment
alors que les accolades sont lues simultanément sur tous les niveaux qu’elles synchronisent.
Les restrictions apportées sur la jointure et les suppressions/insertions d’accolades viennent de
la nécessité de représenter des structures de graphe acyclique au moyen de chaines de caracteres.
Cela suppose que les ordres partiels induits par les différents découpages en unités sont plon-
geables dans un ordre total et de plus qu’il est possible de choisir un ordre canonique préservé
par les opérations rationnelles.

4 Comparaison avec d’autres langages

Comme nous venons de le voir, les relations rationnelles décrites par notre langage sont compi-
lées en automates ﬁnis. Cela signiﬁe que le pouvoir expressif du systeme est celui des automates
ﬁnis. C’est une puissance moindre que celle de systemes de regles de réécriture tels Xfst, qui
ont la puissance des relations rationnelles générales. Loin d’étre un handicap, cette puissance
moindre est la clé qui permet d’offrir un jeu d’opérations beaucoup plus riche que celles dont
on dispose pour les relations rationnelles.

Typage, produit cartésien et unités d’analyse

Outre les trois opérateurs rationnels et leurs dérivés, ces demieres offrent la composition et les
projections. Toutes ces opérations sont également présentes dans notre langage, mais avec en
plus la jointure naturelle, l’intersection et la différence.

Au-dela des aspects théoriques, nous pensons que le surcroit de puissance des systemes de
réécriture a peu d’impact en pratique pour les descriptions morphologiques. La plupart des des-
criptions peuvent probablement se traduire relativement facilement d’un langage vers l’autre.
C’est ce qui s’est passé pour la description des nombres ﬁnnois traduite directement de xfst
dans notre langage.

Nous pouvons détailler ce qui se produit au cours de cette traduction. D’une part, deux informa-
tions (les chiffres et les traits) concaténées sur le niveau lexical de xfst sont séparées sur deux
niveaux différents de notre langage. Dans le processus de compilation de notre grammaire, les
deux représentations sont également concaténées, mais pas nécessairement dans le méme ordre.
Par ailleurs, les unités vraiment importantes dans la descriptions sont matérialisées en xfst par
des symboles ordinaires. Ainsi, la notion correspondant a l’unité c2 1 de notre exemple est no-
tée par un # en xfst. La gestion de ce symbole (introduction, élimination) est explicite dans le
code xfst. Un autre type d’unités est codé par le symbole | .

A un certain niveau d’analyse, les deux descriptions sont donc relativement proches. Les dif-
ferences portent sur l’interface utilisateur et quelques nuances. L’ outil de Xerox tend a décrire
des fonctions multivaluées servant a transformer une entrée en une sortie. Notre outil a une
approche plus relationnelle, o1‘1 l’on met en relation de facon structurée des représentations dif-
férentes. Par ailleurs, notre cadre est plus déclaratif avec des notions plus abstraites comme la
séparation de plus de niveaux ou la notion d’unité d’analyse. Nous pensons que cela contribue
au confort de l’utilisation. Dans certains cas, la contrepartie peut étre une moindre efﬁcacité, le
compilateur optiIr1isant moins bien qu’un programmeur xfst averti.

Nous aurons du mal a établir une comparaison avec le seul autre systeme multi-niveaux que nous
connaissions : wfsc de Xerox (Kempe et al., 2003). Cet outil n’est pas diffusé et les publications
a son suj et ne sont pas tres détaillées. 11 s’ agit d’une boite a outils de transducteurs multi-niveaux
pondérés. I1 implémente la jointure. Les niveaux ne sont pas nommés mais identiﬁés par leur
rang. Il est plus général que notre outil car il implémente les relations rationnelles n-aires sans
restrictions. En revanche, il ne propose pas de notion d’unité d’analyse. C’est un véritable outil
avec un travail important sur les structures de données et les algorithmes alors que notre langage
est une sur-couche exteme au-dessus d’une boite a outils d’automates ﬁnis.

5 Conclusion

Dans cet article, nous avons insisté sur le coeur de notre proposition, a savoir utiliser une notion
d’unité d’analyse pour structurer des descriptions multi-niveaux. Dans sa mise en oeuvre, cette
notion ressemble a celle d’enregistrement dans les langages de programmation.

Nous n’avons pas eu la place de présenter d’autres aspects intéressants de notre langage. La
notion de sous-unité permet de simpliﬁer l’écriture d’expressions rationnelles au moyen de
déclarations donnant des valeurs par défaut a certains membres d’une unité. Par ailleurs, les
structures de traits typées non récursives et a domaines de valeurs ﬁnis sont proposées dans la
syntaxe et compilées en automates ﬁnis.

Notre modele offre quelques sources de complexité qui risquent d’aller contre son objectif d’er-

Francois Barthélemy

gonomie et de déclarativité. Par exemple, les conditions d’emploi de la jointure ne sont pas
simples. Nous espérons que beaucoup d’applications ne sont pas sujettes aux subtilités de cette
question. Remarquons au passage que les regles contextuelles a la Kimmo et a la xfst ne sont
pas exemptes de complexité non plus.

L’utilisation de structures arborescente a été testée au moyen de multiple exemples de taille
signiﬁcative. Ce n’est pas encore le cas des structures de graphes acyclique plus complexes.
Leur intérét pratique reste a évaluer.

Notre modele est dans la lignée de la morphologie a deux niveaux en privilégiant l’aspect rela-
tionnel et l’opération d’intersection. Il s’affranchit des regles complexes et générant des conﬂit
de cette approche. En revanche, il integre des regles de réécriture légeres venant du modele se-
quentiel. Il s’inscrit dans la continuité de ses devanciers, les différences étant dans le processus
de compilation pour atteindre un résultat voisin. Il apporte un plus grand confort dans le cas ou
les représentations sont multiples et tres différentes, les autres modeles étant des solutions plus
légeres dans le cas ou il s’agit de relier deux représentations voisines, comme une représentation
canonique des afﬁxes et une réalisation qui en est une simple alternance.

Références

ANTWORTH E. L. (1995). User’s Guide to PC-Kimmo Version 2. Dallas, Texas : Summer
Institute of Linguistics.

BARTHELEMY F. (2007). Multi-grain relations. In Implementation and Application of Auto-
mata, I 2th International Conference (CIAA), p. 243-252, Praque, Czech Republic.

BARTHELEMY F. (2007). Using mazurkiewicz trace languages for partition-based morpho-
logy. In ACL, Prague (Czech Republic).
BEESLEY K. R. & KARTTUNEN L. (2003). Finite State Morphology. CSLI Publications.

EILENBERG S. (1976). Automata, Languages, and Machines. Orlando, FL, USA : Academic
Press, Inc.

KARTTUNEN L. (2006). Numbers and ﬁnnish numerals. SKY Journal of Linguistics, 19,
407-421. Festschrift in Honour of Fred Karlsson on his 60th Birthday.

KEMPE A., BAEIJS C., GAAL T., GUINGNE F. & NICART F. (2003). WFSC — A new
weighted ﬁnite state compiler. In Proc. 8th Int. Conf on Implementation and Application of
Automata (CIAA’03), LNCS 2759, p. 108-119, Santa Barbara, CA, USA : Springer Verlag.

KEMPE A., CHAMPARNAUD J .-M. & EISNER J . (2004). A note on join and auto-intersection
of n-ary rational relations. In B. WATSON & L. CLEOPHAS, Eds., Proc. Eindhoven FASTAR
Days, Eindhoven, Netherlands.

KIRAZ G. A. (2001). Computational Nonlinear Morphology. Cambridge University Press.

MCCARTHY J . J . (1981). A prosodic theory of nonconcatenative morphology. Linguistic
Inquiry, 12, 373-418.

YLI-JYRA A. M. & KOSKENNIEMI K. (2004). Compiling contextual restrictions on strings
into ﬁnite-state automata. In Proceedings of the Eindhoven FASTAR Days 2004 (September
3-4), Eindhoven, The Netherlands.

