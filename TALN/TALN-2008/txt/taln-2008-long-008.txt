TALN 2008, Avignon, 9–13 juin 2008
Contrôle rhétorique de la génération des connecteurs
concessifs en dialogue homme-machine
Vladimir Popescu1, 2 Jean Caelen1
(1) GETALP/LIG, Institut National Polytechnique de Grenoble, France
(2) Université « Politehnica » de Bucarest, Roumanie
{vladimir.popescu, jean.caelen}@imag.fr
Résumé. Les connecteurs discursifs ont on rôle important dans l’interprétation des dis-
cours (dialogiques ou pas), donc lorsqu’il s’agit de produire des énoncés, le choix des mots
qui relient les énoncés (par exemple, en dialogue oral) s’avère essentiel pour assurer la com-
préhension des visées illocutoires des locuteurs. En linguistique computationnelle, le problème
a été abordé surtout au niveau de l’interprétation des discours monologiques, tandis que pour
le dialogue, les recherches se sont limitées en général à établir une correspondance quasiment
biunivoque entre relations rhétoriques et connecteurs. Dans ce papier nous proposons un méca-
nisme pour guider la génération des connecteurs concessifs en dialogue, à la fois du point de vue
discursif et sémantique ; chaque connecteur considéré sera contraint par un ensemble de condi-
tions qui prennent en compte la cohérence du discours et la pertinence sémantique de chaque
mot concerné. Les contraintes discursives, exprimées dans un formalisme dérivé de la SDRT
(« Segmented Discourse Representation Theory ») seront plongées dans des contraintes séman-
tiques sur les connecteurs, proposées par l’école genevoise (Moeschler), pour enfin évaluer la
cohérence du discours résultant de l’emploi de ces connecteurs.
Abstract. Cue words play an important part in discourse interpretation (whether dialogues
are concerned or not), hence when utterances have to be produced, the choice of the words that
connect these utterances (for example, in spoken dialogue) is essential for ensuring the com-
prehension of the illocutionary goals of the speakers. In computational linguistics, the issue
has been mitigated particularly in the context of monologue discourse interpretation, whereas
for dialogues, research is usually limited to establishing an almost one-to-one mapping between
rhetorical relations and cue words. In this paper we propose a mechanism for guiding concessive
connectors in dialogue, at the same time from a discourse and from a semantic point of view ;
each considered connector will be constrained via a set of conditions that take into account dis-
course coherence and the semantic relevance of each word concerned. Discourse constraints,
expressed in a formalism derived from SDRT (“Segmented Discourse Representation Theory”)
will be mapped to semantic constraints on the connectors ; these semantic constraints are pro-
posed by the Geneve linguistics school (Moeschler). Finally, the coherence of the discourse
resulted from the use of these connectors will be assessed.
Mots-clés : Dialogue homme-machine, cohérence discursive, connecteurs concessifs,
sémantique, pragmatique.
Keywords: Human-computer dialogue, discourse coherence, concessive connectors, se-
mantics, pragmatics.
Vladimir Popescu, Jean Caelen
1 Introduction
Les connecteurs discursifs sont importants pour guider la compréhension des messages1 que les
locuteurs transmettent sous forme linguistique en dialoguant. Par conséquent, ils ont reçu relati-
vement beaucoup d’attention dans les recherches en linguistique, surtout lorsque l’interprétation
des énoncés est concernée (Ducrot, 1980), (Moeschler, 1989). En traitement automatique des
langues, les connecteurs sont regardés en général de deux manières différentes, selon les buts
assumés :
– en analyse morpho-syntaxique et sémantique, les connecteurs ont souvent on rôle modéré,
car, d’un côté ils subissent et imposent peu de contraintes aux niveaux morphologique et
syntaxique (voir par exemple, en français, l’emploi du subjonctif du verbe, après bien que)
et, d’un autre côté, ils n’apportent rien à la sémantique des énoncés, considérée de manière
vériconditionnelle et / ou isolée (Jurafsky & Martin, 2000)2 ;
– en interprétation / analyse du discours (qui remonte surtout à la prise en compte des aspects
pragmatiques de la langue), les connecteurs ont une place importante, car leur présence guide
le processus d’analyse (Mann & Thomson, 1986).
En génération du langage naturel, les connecteurs sont en général considérés comme les mani-
festations superficielles (c’est-à-dire, au niveau de la réalisation de surface) des relations rhéto-
riques qui relient des énoncés distincts pour constituer des discours (Reiter & Dale, 2000) ; par
exemple, le connecteur “mais” matérialise une relation de correction par rapport à ce qui avait
été dit auparavant. De toutes façons, cette approche s’avère souvent insuffisante, car, comme
l’a montré Moeschler (Moeschler, 1989), les conditions d’emploi de chaque connecteur im-
pliquent souvent plusieurs énoncés, reliés de manières assez diverses.
De l’autre côté, au niveau computationnel, les propos de Moeschler doivent être développés
sous forme d’algorithmes, où les entrées et les sorties soient clairement précisées. A partir de
ce constat, cet article propose une formalisation computationnelle du choix des connecteurs
concessifs dans le cadre d’un module générique, conçu pour le contrôle pragmatique de la
génération du langage en dialogue oral homme-machine (Popescu et al., 2007).
Au niveau théorique, la nouveauté de l’approche proposée dans cet article réside dans le fait
qu’à la différence de Moeschler, qui, étant donné le connecteur, déduisait le schéma sémantico-
pragmatique le plus pertinent et donc l’emploi du connecteur (causal ou argumentatif) (Moes-
chler, 1989), nous proposons de déduire le schéma sémantico-pragmatique le plus pertinent à
partir de la structure rhétorique (SDRS - « Segmented Discourse Representation Structure ») du
dialogue et, par conséquent, choisir le connecteur qui satisfasse le mieux ce schéma ; ainsi, la
cohérence du discours est également prise en compte.
Du point de vue applicatif, une telle démarche est utile lorsqu’il s’agit, pour la machine, de
produire des répliques, à partir d’expressions figées à trous, ce qui est une approche courante en
dialogue homme-machine finalisé par la tâche, étant données la facilité de l’implémentation et
la vitesse d’exécution ; les expressions figées sont ensuite collées via les connecteurs calculés.
On génère donc un phénomène de surface (les connecteurs discursifs concessifs) de manière
motivée du point de vue pragmatique et sémantique.
1Le mot « message » est pris ici dans un sens élargi, intégrant la portée spécifiée par la théorie de l’information
et les visées illocutoires des sujets parlants.
2Il y a toutefois des exceptions à cette manière de considérer les connecteurs en analyse et en génération,
comme par exemple la théorie « sens-texte » de Mel’cˇuk (Reiter & Dale, 2000).
Génération des connecteurs concessifs en dialogue
Pour un état de l’art concis sur ce sujet, on peut retenir, d’un côté, les démarches convergentes
avec celles deMoeschler, qui concernent seulement l’interprétation des connecteurs du discours
ou, d’un autre côté, l’interprétation des connecteurs surtout en termes de relations de discours,
soit dans la direction fixée par Marcu (Marcu, 2000), soit selon l’approche de Lascarides en
SDRT (Sporelander & Lascarides, 2006). En ce qui concerne le choix des connecteurs en gé-
nération, des travaux représentatifs ont été poursuivis par Marcu, qui reliait les connecteurs
à des relations discursives seulement (Marcu, 2000) ; donc, selon la terminologie de Moes-
chler, seul le « cotexte » était pris en compte, en opposition avec le « contexte » sémantico-
pragmatique, qui légitime ou bloque la production d’un connecteur, surtout lorsque le dialogue
oral est concerné.
Ici, à partir de la structure rhétorique (cotexte), nous calculons un contexte sémantico-pragma-
tique, qu’on filtre ensuite à travers le cotexte du dialogue entier, et qui pilote le choix des
connecteurs. La section suivante constitue le cœur de l’article et présente les sémantiques des
connecteurs pragmatiques considérés, aussi que les détails formels et computationnels du mé-
canisme pilotant le choix des connecteurs en génération ; ce mécanisme sera ensuite évalué de
manière qualitative via un exemple typique de dialogue. La troisième section conclut l’article
et présente des pistes pour continuer cette recherche.
2 Génération des connecteurs concessifs en dialogue
2.1 Aperçus sémantico-pragmatiques des connecteurs
Les connecteurs discursifs marquant la concession ont été bien étudiés, surtout dans l’école
genevoise de linguistique (Moeschler, Roulet, Rubattel, etc.) (Moeschler, 1989) ; ces travaux ont
abouti à des modélisations sémantiques formelles des connecteurs tels que mais, quand même,
pourtant ou bien que. Dans ce paragraphe on donne un bref aperçu d’une telle modélisation, à
partir de la présentation de (Moeschler, 1989).
Pour cela, on considère d’abord un ensemble de notations, utilisées tout au long de cet article :
– ?, ?, ..., ::= étiquettes des énoncés dans le discours ;
– ? ::= marque de connexion entre deux énoncés du discours ;
– TRUE, FALSE ::= les valeurs de vérité « vrai », respectivement « faux » ;
– equals(?, ?) ::= prédicat binaire vrai ssi la variable ? est égale (c’est-à-dire, unifiée) avec la valeur ? ;
– ?, ¬, ?, ? ::= connecteurs logiques ayant leur signification classique en logique (Gallier, 1986) ;
– ?, 3, ?, ? ::= connecteurs ayant leur signification classique en théorie des ensembles ;
– ?, ? ::= quantificateurs logiques existentiel, respectivement universel ;
– K(?) ::= fonction retournant la sémantique (en logique du premier ordre) de l’énoncé ? ;
– ?(?) ::= fonction retournant la valeur de vérité de la formule logique ? ; donc, désignant par ? l’ensemble des
formules logiques définissables pour un alphabet donné, on a que ? : ?? {TRUE,FALSE} ;
– cause(?, ?) ::= prédicat binaire vrai ssi la modification de contexte du discours, déterminée par l’énoncé ?,
est une cause suffisante pour l’ajout du contenu de l’énoncé ? au contexte ;
–  (?, ?) ::= relation argumentative entre les énoncés ? et ?, vraie ssi un locuteur utilise l’énoncé ? pour faire
admettre le contenu propositionnel où les visées illocutoires de l’énoncé ? (Ducrot, 1980) ;
– < ::= relation de force argumentative entre deux énoncés : ? < ? ssi ? est plus pertinent pour son émetteur
(qui tente d’argumenter le contenu d’un autre énoncé, soit-il ?) que ? (Moeschler, 1989) ;
– ?(?, ?) ::= relation de norme, vraie ssi d’ordinaire ? implique ? ; la norme est donc une implication révisable
selon le contexte ;
– smaller(?, ?) ::= prédicat binaire vrai ssi la valeur ? est inférieure à la valeur ? ;
– ClassOf(?,?) ::= prédicat binaire vrai ssi l’élément ? appartient à l’ensemble ? ;
Vladimir Popescu, Jean Caelen
– ?¯ ::= opération logique de « ou exclusif ».
Ainsi, (Moeschler, 1989) définit deux types de concession, causale et argumentative qui se
particularisent pour chacun des connecteurs considérés - mais, quand même, pourtant ou bien
que. Par conséquent, (Moeschler, 1989) propose un ensemble de sémantiques pour ces quatre
connecteurs, dont on ne retient, de toutes façons, que les aspects ’procéduraux’, car le but as-
sumé dans cet article est de proposer un cadre opérationnel pour la génération de ces connec-
teurs en dialogue homme-machine.
Ainsi, mais et quand même se définissent à travers un « carré argumentatif » (délimité par trois
énoncés, ?, ? et ?), formalisable de manière concise comme ci-dessous :
1. mais peut être employé de deux manières, désignées par mais1 (pour l’emploi de relation directe) et mais2
(pour l’emploi de relation indirecte) :
– ? mais1 ¬? ::= ?? : (?, ?) ? (??¯¬?) ? (? < ?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE)? (?,¬?) ;
exemple : Il fait beau mais1 je ne sors pas . – ? est ’il fait beau’, ? est ’je sors’ et ? est par exemple ’je
ne me sens pas bien’.
– ? mais2 ? ::= ?? : (?, ?) ? (??¯¬?)? (?,¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
exemple : Il fait beau mais2 j’ai mal à la tête. – ? est ’il fait beau’, ? est ’j’ai mal à la tête’ et ? est par
exemple ’je sors’.
2. quand même peut être employé en relation directe seulement, ainsi :
? quand même ¬? ::= ?? : ?(?, ?) ? (??¯¬?)? (?,¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
exemple : Il fait beau. Je reste quand même chez moi. – ? est ’il fait beau’, ? est par exemple ’j’ai mal à la
tête’ et ? est ’je sors’ .
D’un autre côté, les connecteurs pourtant et bien que se définissent à travers un « triangle
causal » (délimité par deux énoncés, ? et ?), formalisable ainsi :
1. pourtant peut être employé de deux manières, selon les deux permutations possibles du triangle causal
(Moeschler, 1989) :
– ? pourtant1 ? ::= cause(?,¬?) ? (??¯¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
exemple : Il pleut, pourtant1 je me balade dans le parc. – ? est ’il pleut’ et ?, ’je me balade...’.
– ? pourtant2 ? ::= cause(?,¬?) ? (??¯¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
exemple : Je suis gentil avec lui, pourtant2 il me dit de gros mots toujours. – ? est ’je suis gentil...’ et ?,
’il me dit de gros mots...’.
2. bien que peut également être employé de deux manières, selon les permutations du triangle causal :
– bien que1 ?, ? ::= cause(?,¬?) ? (??¯¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
exemple : Bien qu’1 il fasse mauvais, je sors. – ? est ’il fait mauvais’ et ?, ’je sors’.
– ? bien que2 ? ::= cause(?,¬?) ? (??¯¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
exemple : Je me balade dans le parc, bien qu’2 il pleuve. – ? est ’je me balade...’ et ?, ’il pleut’.
Dans ce paragraphe nous avons présenté les sémantiques de quatre connecteurs concessifs,
mais, quand même, pourtant et bien que, formalisées dans une approche qui s’inspire des tra-
vaux de l’école genevoise (Moeschler, 1989). Pour une spécification algorithmique du proces-
sus de génération de ces connecteurs, à partir de leurs sémantiques, il y a au moins un point
à améliorer dans les sémantiques présentées : on observe qu’au niveau formel il n’y a aucune
différence entre les sémantiques de pourtant et bien que. Comment savoir alors quel connecteur
produire, dans un contexte donné ? Pour l’interprétation, Moeschler précise seulement que bien
que stipule une plus forte détermination causale entre ses arguments, par rapport à pourtant
(Moeschler, 1989) ; donc, il faudra exprimer cette idée de manière formelle, en tant que règle
ou contrainte supplémentaire agissant sur la sémantique de ce connecteur.
Génération des connecteurs concessifs en dialogue
2.2 Structure de discours et sémantique des connecteurs
L’idée fondamentale de cet article est de « calculer » le connecteur le plus approprié en généra-
tion dialogique, par rapport au contexte sémantico-pragmatique de la conversation. Ainsi, pour
cela on part d’une représentation profonde du cotexte associé au dialogue, à laquelle on ajoutera
des contraintes contextuelles.
Nous supposons que le point de départ pour le calcul des connecteurs est une structure segmen-
tée de discours (SDRS), calculé en préalable par un module de structuration rhétorique (Popescu
et al., 2007). Cette structure de discours est calculée dans le cadre d’une version adaptée de la
SDRT, pour la génération en dialogue (Popescu et al., 2007).
Pour qu’on puisse utiliser cette structure rhétorique dans le calcul des connecteurs, nous spé-
cifions une grammaire pour la représenter, utilisant les informations fournies par le module
de structuration rhétorique. Une telle grammaire suppose que les informations sur la SDRS
consistent en (i) le nombreD des énoncés connectés par des relations rhétoriques, (ii) le nombre
R des relations rhétoriques qui relient les énoncés, (iii) l’ensemble? d’étiquettes pi des énoncés,
(iv) l’ensemble P des étiquettes des relations rhétoriques3, (v) les formes logiquesK des énon-
cés dans la structure de discours, (vi) les sémantiques (exprimées dans une logique du premier
ordre (Popescu et al., 2007)) ? des relations rhétoriques dans la structure de discours. Cette
grammaire est présentée de manière détaillée en (Popescu, 2007).
En ce qui concerne l’ensemble possible des relations rhétoriques qui relient des paires d’énon-
cés (ou de sous-structures de discours), nous avons considéré 17 relations (Popescu et al.,
2007), du total de 35, précisées par la SDRT d’origine (Asher & Lascarides, 2003) : (i) re-
lations dialogiques - Q-Elab (« Question Elaboration »), IQAP (« Indirect Question-Answer
Pair »), P-Corr (« Plan Correction »), P-Elab (« Plan Elaboration »), Backgroundq (« Back-
ground Question »), Elabq (« Elaboration Question »), Narrationq (« Narration Question »),
QAP (« Question-Answer Pair »), ACK (« Acknowledgement ») et NEI (« Not Enough Infor-
mation ») ; (ii) relations monologiques - Alternation, Background, Consequence, Elaboration,
Narration, Contrast et Parallel. Les sémantiques de toutes ces relations rhétoriques sont simu-
lées dans une logique du premier ordre, pour plus d’efficacité computationnelle dans le contexte
des dialogues finalisés par la tâche (Popescu et al., 2007) ; cette simulation conserve les sé-
mantiques informelles des relations, en tant que précisées dans la SDRT d’origine (Asher &
Lascarides, 2003).
Pour relier cette structure rhétorique aux spécifications sémantiques des connecteurs concessifs
(présentées dans la section 2.1), on va transposer le carré argumentatif et le triangle causal qui
situent les quatre connecteurs considérés, dans des contraintes de type rhétorique ; pour cela, on
s’appuie sur les sémantiques des relations rhétoriques, en tant que précisées en (Popescu et al.,
2007). Ainsi, nous proposons tout d’abord un ensemble de correspondances entre les relations
sémantiques spécifiant les connecteurs et les relations rhétoriques ; ces correspondances, pré-
sentées dans le tableau 1 sont motivées également par les définitions de (Moeschler, 1989) et
par les spécifications de (Asher & Lascarides, 2003).
S’appuyant sur ces correspondances, nous pourrons spécifier les sémantiques des connecteurs,
en termes des relations de discours (et des connecteurs logiques usuels). Cependant, une obser-
vation préalable s’impose : dans la section 2.1 il n’y avait pas de distinction sémantique formelle
entre pourtant et bien que ; de toutes façons, l’idée d’une plus forte détermination causale agen-
3Les étiquettes des relations rhétoriques sont identiques à leurs noms (Asher & Lascarides, 2003).
Vladimir Popescu, Jean Caelen
TAB. 1 – Relations sémantiques (Moeschler) et relations rhétoriques (Asher & Lascarides)
Relation sémantique Relation rhétorique
?¯(?, ?) Contrast(?, ?) ? (? ? ?)
cause(?, ?) ?? ?
 (?, ?) Consequence(?, ?)
?(?, ?) Background(?, ?)
cée par bien que peut être formalisée via une contrainte supplémentaire sur ce connecteur : que
le temps de l’action décrite par l’énoncé qui succède ce connecteur précède le temps de l’action
décrite par le deuxième énoncé sous l’incidence de ce connecteur. Au niveau logique cela sera
exprimé via la fonction ∆(?) qui précise (retourne) le temps de l’action décrite par l’énoncé
libellé ? ; cette fonction est codée dans une ontologie de discours (Popescu et al., 2007).
Ainsi, les sémantiques des connecteurs concessifs considérés se formalisent, en termes rhéto-
riques, comme ci-dessous :
1. ? mais1 ¬? ::= ?? : Consequence(?, ?)?Contrast(?,¬?)?Consequence(?,¬?)?equals(?(K(?)),TRUE)?equals(?(K(?)),
TRUE) ? equals(?(K(?)),FALSE)? < (?, ?) ;
2. ? mais2 ? ::= ?? : Consequence(?, ?)?Contrast(?,¬?)?Consequence(?,¬?)?equals(?(K(?)),TRUE)?equals(?(K(?)),
TRUE) ? equals(?(K(?)),FALSE) ;
3. ? quand même ¬? ::= ?? : Background(?, ?) ? Contrast(?,¬?) ? Consequence(?,¬?) ? equals(?(K(?)),TRUE) ?
equals(?(K(?)),TRUE) ? equals(?(K(?)),FALSE) ;
4. ? pourtant1 ? ::= (?? ¬?) ? Contrast(?,¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
5. ? pourtant2 ? ::= (? ? ¬?) ? Contrast(?,¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ;
6. bien que1 ?, ? ::= (?? ¬?) ? Contrast(?,¬?) ? equals(?(K(?)),TRUE) ? equals(?(K(?)),TRUE) ? smaller(∆t(?),
∆t(?)) ;
7. ? bien que2 ? ::= (? ? ¬?)?Contrast(?,¬?)?equals(?(K(?)),TRUE)?equals(?(K(?)),TRUE)?smaller(∆t(?),∆t(?)).
Dans ces sémantiques, les énoncés non reliés par les connecteurs, mais intervenant dans les
contraintes sur ces derniers (? ou ?, selon le cas) sont tirés soit du cotexte, soit du contexte :
– si l’énoncé en question est présent dans le discours, dans des tours de parole antérieurs, on
s’appuie sur lui ;
– sinon, on déduit cet énoncé à partir des énoncés antérieurs et de l’ontologie de tâche (Caelen
& Xuereb, 2007) (le contexte), via un processus inférentiel.
Une dernière remarque à l’égard des sémantiques des connecteurs concessifs (et du lien entre
celles-ci et la structure rhétorique) concerne la relation « < /2 », de force argumentative, non
formalisée par Moeschler ou dans les sections antérieures de cet article. Pour cela, on s’appuie
de manière explicite sur le contexte du dialogue, posant qu’on peut avoir deux interlocuteurs,
l’émetteur d’un énoncé courant, désigné comme ci-dessus, par la fonction emitter/1 et l’alocu-
taire, désigné par ¬emitter/1 ; par conséquent, il n’y a pas d’équivalence entre des expressions
du type ?(¬emitter(?), ?) et ¬ ? (emitter(?), ?), où « ? » désigne un prédicat binaire quel-
conque et « ? », un terme quelconque. Ceci étant, nous posons comme hypothèse de travail
qu’un énoncé dont le contenu fait une référence explicite à son émetteur a une force argumenta-
tive plus élevée par rapport à un énoncé qui ne le fait pas, ou qu’un énoncé qui fait une référence
explicite à l’alocutaire (donc, au destinataire) a une force argumentative plus élevée par rapport
à un énoncé dont le contenu ne fait référence ni à cet alocutaire, ni à l’émetteur. Précisant que
deux énoncés dont la force argumentative est à comparer ont le même émetteur, ces consignes
peuvent s’exprimer sous forme logique ainsi :
? < ? ::= (ClassOf(emitter(?),K(?))?¬ClassOf(emitter(?),K(?)))?(ClassOf(¬emitter(?),K(?))?¬ClassOf(¬emitter(?),K(?))
? ¬ClassOf(emitter(?),K(?))) ? equals(emitter(?), emitter(?)) ? equals(¬emitter(?),¬emitter(?)).
Génération des connecteurs concessifs en dialogue
2.3 Choix des connecteurs : algorithme
Le cadre posé dans le paragraphe précedent pour l’expression sémantique, amendée par la struc-
ture rhétorique, des connecteurs concessifs en dialogue sera mis en valeur via une procédure
conçue pour générer les connecteurs appropriés, lorsqu’il s’agit, pour la machine, de produire
un énoncé dialogique.
Les entrées dans cette procedure consistent en (i) la structure rhétorique du dialogue « courant »
(c’est-à-dire, intégrant aussi la sémantique de la réplique censée être générée par la machine et
donc, éventuellement, contenir un ou plusieurs connecteurs concessifs), (ii) les sémantiques
des connecteurs (spécifiées sous forme de règles), (iii) l’ontologie de discours (spécifiée sous
forme d’arbre hiérarchique (Popescu et al., 2007)) et (iv) l’ontologie de tâche pour les dialogues
(spécifiée, à l’instar de l’ontologie de discours, sous forme de hiérarchie de concepts (Caelen &
Xuereb, 2007)).
La sortie de cette procedure consiste en un ensemble de connecteurs qui peuvent relier les
énoncés dans la réplique courante de la machine ; cette liste peut éventuellement être vide, mais
dans le cas contraire, chaque entrée dans cette liste a trois éléments : (i) le connecteur choisi,
(ii) son « argument gauche » et (iii), son argument droit ; donc une entrée type est de la forme :
(?, pii, pij), ce qui correspondra à une forme de surface du type pii ? pij , où ? est le connecteur
et pii et pij , les libellés de deux énoncés. Donc, la procédure est spécifiée ci-dessous :
1. initialiser la liste des connecteurs : ?? ? ;
2. lire la structure de discours courante, S(D,R, P,?) (cf. §2.2) ;
3. lire les étiquettes des énoncés à être générés par la machine, < pi >, avec < pi >? ? et | < pi > | < D ;
4. trier l’ensemble < pi > par rapport à l’ordre d’apparition des énoncés (ordre spécifié par le composant de
structuration rhétorique (Popescu et al., 2007)) ;
5. pour chaque énoncé pi_ dans < pi > :
(a) repérer les relations rhétoriques connectant l’énoncé pi_ à des énoncés dans S ; soient ces relations
spécifiées par l’ensemble < ? >pi_? P , avec | < ? >pi_ | < R ;
(b) repérer les arguments gauches des relations dans l’ensemble < ? >pi_ ; soient ces arguments spéci-
fiés par l’ensemble < ? >pi_? ?, avec | < ? >pi_ | < D ;
(c) pour chaque sémantique ? des connecteurs (? ? ?, avec |?| = 7, car il y a 7 connecteurs possibles) :
i. apparier(?, pi_, (< ? >pi_, < ? >pi_)) ;
ii. si OK, alors ?? ? ? (?, pi?, pi_) ;
iii. sinon, alors ?? ? ? ? ;
6. si |(?, pi?, pi_)| > 1 (la procédure apparier retourne plusieurs connecteurs entre deux énoncés), alors :
(a) s’il existe un connecteur qui a un maximum de contraintes, alors garder celui-ci et enlever le reste
(par exemple, entre pourtant et bien que, garder le dernier et enlever le premier) ;
(b) sinon, s’il existe un connecteur qui assure un nombre maximal de relations rhétoriques, c’est-à-dire,
qui contient un nombre maximal de relations rhétoriques différentes dans ses contraintes, alors :
i. si les sémantiques des connecteurs ne mènent pas à une contradiction logique, alors garder
tous ces connecteurs ;
ii. sinon, alors garder celui-ci et enlever le reste (par exemple, entre mais et quand même, garder
le dernier et enlever le premier, car celui-ci contient deux relations rhétoriques différentes,
Consequence et Contrast, tandis que le dernier en contient trois - les deux qui viennent d’être
précisées, auxquelles Background s’ajoute) ;
(c) sinon, alors choisir de manière aléatoire un des connecteurs (cette situation est peu probable, étant
données les sémantiques des connecteurs et leur utilisation) ;
7. retourner ?.
Vladimir Popescu, Jean Caelen
Le noyau de l’algorithme consiste dans la procédure apparier/3, qui prend en entrée la séman-
tique d’un connecteur, (l’étiquette d’) un énoncé qui constituera l’argument droit du connecteur
et une structure formée de deux ensembles : un ensemble de relations rhétoriques (censées
avoir pi_ en tant qu’argument droit) et, respectivement, un ensemble d’énoncés (censés être les
arguments gauches des relations rhétoriques). La sortie de la procédure apparier est constituée
d’une structure qui contient la sémantique d’un connecteur, son argument gauche et, respecti-
vement, son argument droit (qui est censé être justement l’énoncé pi_ lu en entrée) :
1. initialiser trois listes : ? ? ?, P ? ?, C ? ? ; ces listes contiendront, respectivement, des étiquettes
d’énoncés, des étiquettes de relations rhétoriques, et des connecteurs logiques ;
2. pour chaque terme dans la sémantique ? du connecteur, le classer dans une des catégories suivantes : (i)
étiquettes d’énoncés, (ii) relations de discours, (iii) connecteurs logiques ;
3. par conséquent, actualiser les listes ?, P et C ;
4. si P ?< ? >pi_, alors :
(a) unifier les termes dans ? qui sont les arguments des termes en P , avec les termes en < ? >pi_ qui
sont les arguments des termes en P? < ? >pi_ ;
(b) pour chaque connecteur logique enC, vérifier si celui-ci peut être placé entre des entités en< ? >pi_
?P et < ? >pi_ ??, afin que :
– la succession des termes et connecteurs soit identique à celle spécifiée en ?, à part les unifications
de l’étape 4.(a) ;
– la forme logique résultée (en étendant les énoncés à leurs sémantiques, exprimées via des prédicats
dans l’ontologie de tâche, selon les détails précisés en (Popescu et al., 2007)) ne mène pas à
l’ensemble vide (c’est-à-dire, à une contradiction) ;
cette étape représente en fait la résolution de la formule logique obtenue de ?, en substituant les
énoncés par des énoncés dans la structure de discours en entrée, pourvu qu’on préserve les arguments
des relations rhétoriques ;
(c) si OK, alors retourner OK, (?, pi?, pi_) ;
(d) sinon, alors retourner KO ;
5. sinon, alors retourner KO.
2.4 Traçage sur une situation de dialogue
Nous démontrons l’opération des algorithmes proposés en §2.3 sur un fragment de dialogue
typique entre le système et un client, où la machine est une bibliothécaire virtuelle. Ainsi, dési-
gnant par U le client (l’usager), parM , la machine, et par l’indice supérieur piij , l’étiquette du
j-ème énoncé dans le i-ème tour de parole, le dialogue est montré ci-dessous (les connecteurs
ont été mis en italiques) :
U : Excusez-moipi11 , pourrais-je emprunter ce bouquin ?pi12
M : Monsieur, vous ne pouvez emprunter que trois livres à la foispi21 , mais je ferai quand même une
exception cette fois-ci.pi22
U : Merci beaucoup !pi31 Alors, je vous donne ma carte ?pi32
M : Bonpi41 , bien que vous ayez déjà gardé un livre il y a deux moispi42 , je vous en prête maintenant
quatrepi43 ; pourtant, vous n’avez pas l’air plus attentif en ce moment...pi44
Les énoncés de M sont disponibles sous forme logique, en tant que fournis par le contrô-
leur de dialogue (Caelen & Xuereb, 2007), (Popescu et al., 2007), tandis que ceux de U , sous
forme linguistique ; à partir de ces derniers, l’analyseur sémantique calcule, pour ces énoncés,
les formes logiques correspondantes, auxquelles l’interpréteur pragmatique attache les infor-
mations concernant le type d’acte de langage véhiculé par chaque contribution dialogique de
Génération des connecteurs concessifs en dialogue
l’usager (Caelen & Xuereb, 2007). A partir de ces informations, le composant de structuration
rhétorique dans le module de génération calcule la SDRS qui intègre les formes logiques des
énoncés censés être réalisés sous forme linguistique par M (Popescu et al., 2007). Ainsi, pour
le fragment de dialogue considéré, la SDRS calculée est exprimée, sous forme synthétique,
ci-dessous :
Elaboration(pi11, pi12) ? P-Corr(pi12, pi21) ? Consequence(pi21,¬pi22) ? ACK(pi22, pi31) ? Consequence(pi31, pi32) ? ACK(pi32, pi41) ?
P-Elab(pi22, pi43) ? Consequence(pi42,¬pi43) ? Consequence(pi43,¬pi44) ? Narration(pi42, pi44).
Les relations de discours ont été calculées entre des paires d’énoncés et même entre des paires
dont un élément est un énoncé sous forme niée ; cela est utile pour faire la correspondance
entre des fragments de cette SDRS et les sémantiques des connecteurs. Ainsi, pour la première
réplique de la machine, entre les énoncés pi21 et pi22 la procédure apparier retourne les élé-
ments (mais, pi21, pi22) et (quand même, pi21, pi22), puisque, pour mais on retrouve les contraintes
Consequence(pi21,¬pi22) ? Contrast(pi22,¬pi22) ? equals(?(K(pi21)),TRUE) ?
equals(?(K(¬pi21)),FALSE) et l’énoncé « manquant » ? est retrouvé en tant que ’vous ne
pouvez pas emprunter ce livre’ qui est déduit par modus ponens (Gallier, 1986) à partir de pi21
et du fait (connu par le système à travers son ontologie de tâche) que U a déjà emprunté trois
livres qu’il n’a pas encore rendus ; pour quand même est déduit via les mêmes contraintes que
ci-dessus, auxquelles s’ajoute la contrainte Background(pi21,¬pi22), déduite par modus ponens
du fait que U a déjà emprunté trois livres et que, par défaut, selon le règlement, la bibliothèque
ne prête pas plus de trois livres à la fois. Dans ce contexte, on a trois choix : (i) supprimer mais,
(ii) supprimer quand même, (iii) garder les deux connecteurs ; selon l’algorithme dans §2.3 nous
devrions adopter un des choix (ii) ou (iii). Du fait que (iii) ne mène à aucune contradiction lo-
gique, nous l’adoptons, car ainsi nous augmentons la pertinence illocutoire de la contribution
langagière deM . De toutes façons, pour pouvoir garder mais on doit vérifier la satisfaction de
< (pi21, ?), ce qui est vrai puisque pi21 exprime une vérité générale - ’on peut emprunter au plus
trois livres à la fois’, tandis que ? exprime un fait relié àU , donc :ClassOf(¬emitter(?), K(?)).
La deuxième contribution de la machine est traitée de manière similaire : entre les énoncés
pi42 et pi43 la procédure apparier retourne (bien que, pi42, pi43) et (pourtant, pi42, pi43), puisqu’on
retrouve la contrainte pi42 ? ¬pi43, déduite de la relation Consequence(pi42,¬pi43) et du fait,
présent dans l’ontologie de tâche, que si un client avait perdu un document, la bibliothèque serait
devenue plus stricte avec celui-ci, ce qui n’est pas compatible avec la concession de prêter plus
de documents que le règlement prévoit, à cet usager (quatre livres, au lieu de trois) ; toutefois,
on en retient seulement bien que, car, selon l’algorithme dans §3.2, ce connecteur est défini
par plus de contraintes : à partir de K(pi42) et de K(pi43) (les sémantiques des énoncés pi43 et
pi44) on déduit smaller(∆t(pi42),∆t(pi43)). Par contre, pour les énoncés pi43 et pi44, la procédure
apparier, opérant à l’instar du cas précédent, ne retourne quand même que pourtant, car, du fait
que le temps de ces deux énoncés est le même (le présent), on a que equals(∆t(pi43),∆t(pi44)),
donc les contraintes pour bien que ne sont pas satisfaites.
3 Conclusion
Dans cet article nous avons proposé un cadre pour contrôler la génération des connecteurs
concessifs afin de mieux structurer les répliques de la machine en dialogue avec les utilisa-
teurs. Le mécanisme proposé pour générer mais, quand même, pourtant et bien que s’articule
d’une part autour d’une description sémantique de ces connecteurs, dérivée de celle proposée
Vladimir Popescu, Jean Caelen
par (Moeschler, 1989) et, d’une autre part, autour d’un ensemble de spécifications pragmatiques
dans une procédure computationnelle. Ainsi, l’efficacité de ce cadre a été démontrée sur un frag-
ment typique de dialogue homme-machine autour d’une application particulière - la réservation
de documents dans une bibliothèque. Toutefois, les démarches proposées sont génériques, voire
indépendantes du domaine d’application et paramétrables par rapport à celui-ci.
Cette recherche devrait être continuée à plusieurs niveaux : (i) l’ensemble des connecteurs de-
vrait être étendu à d’autres, comme parce que, puisque, car, d’ailleurs, etc. ; (ii) le mécanisme
devrait être étendu au cas du dialogue à plusieurs locuteurs, ce qui reviendrait dans un premier
temps à la modification de la sémantique de la relation de force argumentative < : les inter-
locuteurs de la machine ne sont plus réduits à ¬emitter() ; du fait que plusieurs interlocuteurs
interviennent, on peut avoir un ensemble plus large de situations concernant la force argumen-
tative : par exemple un énoncé dont l’action implique un locuteur plus haut du point de vue
hiérarchique ou plus actif en conversation peut être plus pertinent du point de vue argumentatif
qu’un autre énoncé impliquant son émetteur... ; (iii) une fois réalisées les extensions au dialogue
à plusieurs, ce mécanisme devra être évalué de manière statistique sur des dialogues réels.
Références
ASHER N. & LASCARIDES A. (2003). Logics of Conversation. United Kingdom : Cambridge
University Press.
CAELEN J. & XUEREB A. (2007). Interaction et pragmatique - jeux de dialogue et de lan-
gage. Paris : Hermès Science.
DUCROT O. (1980). Les mots du discours. Paris : Editions du Minuit.
GALLIER J. (1986). Logic for Computer Science. New York : Wiley.
JURAFSKY D. & MARTIN J. H. (2000). Speech and Language Processing. New Jersey :
Prentice Hall.
MANN W. C. & THOMSON S. A. (1986). Rhetorical Structure Theory : description and
construction of text structures. Nijmegen, The Netherlands : Information Sciences Institute.
MARCU D. (2000). The Rhetorical Parsing, Summarization and Generation of Natural Lan-
guage Texts. Canada : Ph D Thesis, University of Toronto.
MOESCHLER J. (1989). Modélisation du dialogue - représentation de l’inférence argumenta-
tive. Paris : Hermès Science.
POPESCU V. (2007). Pronominal anaphora generation in human-computer dialogue, using
a semantic-pragmatic approach. In Proceedings of the Doctoral Consortium at the FoLLI
Summer School EUROLAN, Iasi, Romania : “Al. I Cuza” University Press.
POPESCU V., CAELEN J. & BURILEANU C. (2007). First-order logic rhetorical structuring
for natural language generation in human-computer dialogue. In Lecture Notes in Computer
Science 4629, Heidelberg : Springer.
REITER E. & DALE R. (2000). Building Natural Language Generation Systems. United
Kingdom : Cambridge University Press.
SPORELANDER C. & LASCARIDES A. (2006). Using automatically labelled examples to
classify rhetorical relations : an assessment. In Journal of Natural Language Engineering,
United Kingdom : Cambridge University Press.
