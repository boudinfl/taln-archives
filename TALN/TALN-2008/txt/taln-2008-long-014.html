<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Convertir des grammaires d&#8217;arbres adjoints &#224; composantes multiples avec tuples d&#8217;arbres (TT-MCTAG) en grammaires &#224; concat&#233;nation d&#8217;intervalles (RCG)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2008, Avignon, 9&#8211;13 juin 2008
</p>
<p>Convertir des grammaires d&#8217;arbres adjoints &#224; composantes
multiples avec tuples d&#8217;arbres (TT-MCTAG) en grammaires &#224;
</p>
<p>concat&#233;nation d&#8217;intervalles (RCG)
</p>
<p>Laura Kallmeyer1 Yannick Parmentier2
(1) SFB 441 / Universit&#233; de T&#252;bingen
</p>
<p>(2) SfS-CL / SFB 441 / Universit&#233; de T&#252;bingen
Nauklerstr. 35, 72074 T&#252;bingen, Allemagne
</p>
<p>lk@sfs.uni-tuebingen.de, parmenti@sfs.uni-tuebingen.de
</p>
<p>R&#233;sum&#233;. Cet article &#233;tudie la relation entre les grammaires d&#8217;arbres adjoints &#224; compo-
santes multiples avec tuples d&#8217;arbres (TT-MCTAG), un formalisme utilis&#233; en linguistique infor-
matique, et les grammaires &#224; concat&#233;nation d&#8217;intervalles (RCG). Les RCGs sont connues pour
d&#233;crire exactement la classe PTIME, il a en outre &#233;t&#233; d&#233;montr&#233; que les RCGs &#171; simples &#187; sont
m&#234;me &#233;quivalentes aux syst&#232;mes de r&#233;&#233;criture hors-contextes lin&#233;aires (LCFRS), en d&#8217;autres
termes, elles sont l&#233;g&#232;rement sensibles au contexte. TT-MCTAG a &#233;t&#233; propos&#233; pour mod&#233;liser
les langages &#224; ordre des mots libre. En g&#233;n&#233;ral ces langages sont NP-complets. Dans cet article,
nous d&#233;finissons une contrainte additionnelle sur les d&#233;rivations autoris&#233;es par le formalisme
TT-MCTAG. Nous montrons ensuite comment cette forme restreinte de TT-MCTAG peut &#234;tre
convertie en une RCG simple &#233;quivalente. Le r&#233;sultat est int&#233;ressant pour des raisons th&#233;oriques
(puisqu&#8217;il montre que la forme restreinte de TT-MCTAG est l&#233;g&#232;rement sensible au contexte),
mais &#233;galement pour des raisons pratiques (la transformation propos&#233;e ici a &#233;t&#233; utilis&#233;e pour
implanter un analyseur pour TT-MCTAG).
</p>
<p>Abstract. This paper investigates the relation between TT-MCTAG, a formalism used in
computational linguistics, and RCG. RCGs are known to describe exactly the class PTIME ;
&#171; simple &#187; RCG even have been shown to be equivalent to linear context-free rewriting sys-
tems, i.e., to be mildly context-sensitive. TT-MCTAG has been proposed to model free word
order languages. In general, it is NP-complete. In this paper, we will put an additional limita-
tion on the derivations licensed in TT-MCTAG. We show that TT-MCTAG with this additional
limitation can be transformed into equivalent simple RCGs. This result is interesting for theo-
retical reasons (since it shows that TT-MCTAG in this limited form is mildly context-sensitive)
and also for practical reasons (the proposed transformation has been used for implementing a
parser for TT-MCTAG).
</p>
<p>Mots-cl&#233;s : Grammaires d&#8217;arbres adjoints &#224; composantes multiples, grammaires &#224; conca-
t&#233;nation d&#8217;intervalles, l&#233;g&#232;re sensibilit&#233; au contexte.
</p>
<p>Keywords: Multicomponent Tree Adjoining Grammars, Range Concatenation Gram-
mars, mild context-sensitivity.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Yannick Parmentier
</p>
<p>1 Introduction
</p>
<p>Il a &#233;t&#233; d&#233;montr&#233; que les grammaires d&#8217;arbres adjoints (TAGs) sont d&#8217;un grand inter&#234;t pour
le traitement automatique des langues naturelles, et pour des raisons linguistiques (domaine
de localit&#233; &#233;tendu), et pour des raisons formelles (complexit&#233; d&#8217;analyse). Pourtant, elles sont
trop limit&#233;es dans leur expressivit&#233; pour traiter certains phenom&#232;nes linguistiques comme par
exemple le brouillage d&#8217;arguments dans des langues dites &#224; ordre des mots libre.
</p>
<p>Cet article consid&#232;re une variante des TAGs, les grammaires d&#8217;arbres adjoints &#224; composantes
multiples avec tuples d&#8217;arbres (TT-MCTAGs), cherchant &#224; r&#233;soudre ce probl&#232;me d&#8217;expressivit&#233;
tout en gardant les propri&#233;t&#233;s principales des TAGs. Dans ce contexte, nous traitons les propri&#233;-
t&#233;s formelles de ce formalisme, en particulier sa relation avec les langages leg&#232;rement sensibles
au contexte. En donnant la construction d&#8217;une grammaire &#224; concat&#233;nation d&#8217;intervalles (RCG)
simple pour une TT-MCTAG qui satisfait une certaine contrainte, nous obtenons deux r&#233;sul-
tats : d&#8217;abord nous prouvons que ces TT-MCTAGs restreintes sont en fait l&#233;g&#232;rement sensibles
au contexte. Ensuite, en combinant cette construction avec un analyseur pour RCG, nous pou-
vons d&#233;velopper un analyseur pour TT-MCTAG. Nous pensons que l&#8217;id&#233;e de passer par les
RCGs pour analyser certains formalismes grammaticaux au lieu de d&#233;velopper un analyseur
diff&#233;rent pour chacun d&#8217;entre eux peut &#234;tre utile d&#8217;une fa&#231;on g&#233;n&#233;rale.
</p>
<p>Le plan de cet article est le suivant. Dans un premier temps, nous d&#233;finissons les formalismes
sur lesquels nous nous basons, &#224; savoir TAG (section 1.1) et RCG (section 1.2), et pr&#233;sentons
bri&#232;vement un algorithme existant de conversion de TAG vers RCG (section 1.3). Ensuite, nous
introduisons le formalisme des TT-MCTAGs (section 2), ainsi que leur forme restreinte. Fina-
lement nous donnons l&#8217;algorithme de conversion de ces grammaires en RCG (section 3).
</p>
<p>1.1 Tree Adjoining Grammars (TAG)
Les TAGs (Joshi &amp; Schabes, 1997) sont des syst&#232;mes de r&#233;&#233;criture d&#8217;arbres. Une TAG est un
ensemble fini d&#8217;arbres (les arbres &#233;l&#233;mentaires) avec des &#233;tiquettes non-terminales et terminales
(les derniers seulement pour des feuilles). Des arbres plus grands sont g&#233;n&#233;r&#233;s par substitu-
tion (remplacement d&#8217;une feuille par un nouvel arbre) et adjonction (remplacement d&#8217;un n&#339;ud
interne par un nouvel arbre). En cas d&#8217;adjonction, l&#8217;arbre que l&#8217;on adjoint a exactement une
feuille marqu&#233;e comme n&#339;ud pied (marqu&#233;e par une &#233;toile). Un tel arbre s&#8217;appelle un arbre
auxiliaire. Si cet arbre est adjoint &#224; un n&#339;ud n, alors dans l&#8217;arbre r&#233;sultat, le sous-arbre de ra-
cine n s&#8217;attache au n&#339;ud pied de l&#8217;arbre auxiliaire. Des arbres non-auxiliaires s&#8217;appellent des
arbres initiaux. Chaque d&#233;rivation commence par un arbre initial. Dans un arbre d&#233;riv&#233; terminal,
toutes les feuilles doivent avoir des &#233;tiquettes terminales. Un exemple est donn&#233; Fig. 1.
</p>
<p>NP
</p>
<p>John
</p>
<p>S
</p>
<p>NP VP
</p>
<p>V
</p>
<p>laughs
</p>
<p>VP
</p>
<p>ADV VP&#8727;
</p>
<p>always
</p>
<p>arbre S
d&#233;riv&#233; : NP VP
</p>
<p>John ADV VP
</p>
<p>always V
</p>
<p>laughs
</p>
<p>arbre de :
d&#233;rivation :
</p>
<p>laugh
1 2
</p>
<p>john always
</p>
<p>FIG. 1 &#8211; D&#233;rivation TAG pour la phrase John always laughs</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>TT-MCTAGs et RCGs
</p>
<p>D&#233;finition 1. Une TAG est un tupleG = &#12296;I, A,N, T &#12297; avec (i)N et T des alphabets disjoints, les
nonterminaux et les terminaux, et (ii) I et A des ensembles finis d&#8217;arbres initiaux et auxiliaires
respectivement avec non-terminaux N et terminaux T . En outre, les n&#339;uds internes dans I &#8746;A
peuvent &#234;tre marqu&#233;s OA (adjonction obligatoire) ou NA (adjonction interdite).
D&#233;finition 2. Soient G = &#12296;I, A,N, T &#12297; une TAG, &#947; et &#947;&#8242; des arbres finis.
&#8211; &#947; &#8658; &#947;&#8242; dans G ssi il existe une adresse de n&#339;ud p et un arbre &#947;&#8242;0 qui est soit un arbre &#233;l&#233;-
</p>
<p>mentaire, soit d&#233;riv&#233; d&#8217;un arbre &#233;l&#233;mentaire tel que &#947;&#8242; = &#947;[p, &#947;&#8242;0]1.
&#8727;
</p>
<p>&#8658; est la cl&#244;ture r&#233;flexive
et transitive de &#8658;.
</p>
<p>&#8211; Le langage d&#8217;arbres de G est LT (G) = {&#947; |&#945;
&#8727;
</p>
<p>&#8658; &#947; pour quelque &#945; &#8712; I , toutes les feuilles
dans &#947; ont une &#233;tiquette terminale et &#947; ne contient pas de n&#339;ud marqu&#233; OA}.
</p>
<p>Les d&#233;rivations en TAG sont repr&#233;sent&#233;es par des arbres de d&#233;rivation (des arbres non-ordonn&#233;s)
qui d&#233;crivent comment les arbres &#233;l&#233;mentaires ont &#233;t&#233; combin&#233;s. L&#8217;arbre d&#233;riv&#233; est alors le
r&#233;sultat de l&#8217;ex&#233;cution de ces combinaisons, i.e., l&#8217;arbre de d&#233;rivation d&#233;crit de fa&#231;on unique
un seul arbre d&#233;riv&#233;. Chaque arc dans un arbre de d&#233;rivation repr&#233;sente une adjonction ou une
substitution. Les arcs sont etiquet&#233;s avec des adresses de n&#339;ud de Gorn2. L&#8217;arbre de d&#233;rivation
de la Fig. 1 par exemple, indique que l&#8217;arbre &#233;l&#233;mentarire de John a &#233;t&#233; substitu&#233; au n&#339;ud
d&#8217;adresse 1 et always a &#233;t&#233; adjoint &#224; l&#8217;adresse 2 (le fait que le premier est une substitution,
le deuxi&#232;me une adjonction peut &#234;tre d&#233;duit du fait que l&#8217;adresse 1 est l&#8217;adresse d&#8217;une feuille
tandis que 2 est l&#8217;adresse d&#8217;un n&#339;ud interne).
D&#233;finition 3. Soit G = &#12296;I, A,N, T &#12297; une TAG, on d&#233;finit &#947; un arbre d&#233;riv&#233; d&#8217;un arbre &#233;l&#233;men-
taire &#947;0 dans G comme suit : &#947; = &#947;0[p1, &#947;1] . . . [pk, &#947;k] tel que les substitutions/adjonctions des
&#947;1, . . . , &#947;k sont les seules substitutions/adjunctions &#224; &#947;0 ex&#233;cut&#233;es lors de la d&#233;rivation de &#947;.
Dans ce cas-l&#224;, l&#8217;arbre de d&#233;rivation correspondant a une racine &#233;tiquet&#233;e &#947;0 qui a k fils. Les
arcs entre &#947;0 et ces fils sont &#233;tiquet&#233;s p1, . . . , pk, et les fils sont les arbres de d&#233;rivation des
d&#233;rivations de &#947;1, . . . , &#947;k.
</p>
<p>1.2 Range Concatenation Grammars (RCG)
D&#233;finition 4. Une RCG positive (Boullier, 1999b; Boullier, 2000) est un tupleG = &#12296;N, T, V, S, P &#12297;
tel que (i) N est un ensemble fini de pr&#233;dicats, chacun d&#8217;arit&#233; fixe, S &#8712; N (d&#8217;arit&#233; 1) le pr&#233;dicat
initial, (ii) T et V sont des alphabets disjoints de terminaux et de variables, et (iii) P est un
ensemble fini de clauses de la forme :
</p>
<p>A0(x01, . . . , x0a0)&#8594; &#491;
ou A0(x01, . . . , x0a0)&#8594; A1(x11, . . . , x1a1) . . .An(xn1, . . . , xnan)
</p>
<p>avec n &#8805; 1, Ai &#8712; N, xij &#8712; (T &#8746; V )
&#8727; et ai l&#8217;arit&#233; d&#8217;Ai.
</p>
<p>Notons qu&#8217;une RCG avec une arit&#233; maximale n s&#8217;appelle une RCG d&#8217;arit&#233; n. Notons &#233;galement
que, dans ce papier nous n&#8217;utilisons que des RCGs positives, ainsi, dans ce qui suit, chaque
mention des RCGs ref&#232;re aux RCGs positives3. Dans un appel de clause par rapport &#224; une
cha&#238;ne w = t1 . . . tn, les arguments des pr&#233;dicats sont instanti&#233;s par des sous-cha&#238;nes de w,
</p>
<p>1Pour des arbres &#947;, &#947;1, . . . , &#947;n et des adresses de n&#339;uds diff&#233;rentes deux &#224; deux p1, . . . , pn dans &#947;,
&#947;[p1, &#947;1] . . . [pn, &#947;n] est le r&#233;sultat des substitutions/adjonctions s&#233;quentielles de &#947;1, . . . , &#947;n respectivement aux
n&#339;uds d&#8217;adresses p1, . . . , pn dans &#947;.
</p>
<p>2L&#8217;adresses de la racine est &#491;, et le n-i&#232;me fils d&#8217;un n&#339;ud avec adresse p a l&#8217;adresse p.j.
3La variante n&#233;gative permet des appels de pr&#233;dicats de la forme A(&#945;1, . . . , &#945;n). Un tel pr&#233;dicat reconna&#238;t le
</p>
<p>compl&#233;ment de A(&#945;1, . . . , &#945;n), voir (Boullier, 2000).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Yannick Parmentier
</p>
<p>plus pr&#233;cisement par les intervalles correpondants. Un intervalle &#12296;i, j&#12297; avec 0 &#8804; i &lt; j &#8804;
n correspond &#224; la cha&#238;ne entre les positions i et j, i.e., la cha&#238;ne ti+1 . . . tj . Si i = j, &#12296;i, j&#12297;
correspond &#224; &#491;. Si i &gt; j, &#12296;i, j&#12297; n&#8217;est pas d&#233;fini.
D&#233;finition 5. Une instantiation d&#8217;une clause C par rapport &#224; une cha&#238;ne w = t1 . . . tn est une
fonction f : {t&#8242; | t&#8242; est l&#8217;occurrence d&#8217;un t &#8712; T dans les arguments de C} &#8746; V &#8594; {&#12296;i, j&#12297; | i &#8804;
j, i, j &#8712; IN} tel que :
a) pour chaque occurrence t&#8242; d&#8217;un t &#8712; T dans C : f(t&#8242;) := &#12296;i, i+ 1&#12297; pour quelque i,
</p>
<p>0 &#8804; i &lt; n tel que ti = t,
b) pour chaque v &#8712; V : f(v) = &#12296;j, k&#12297; pour quelques 0 &#8804; j &#8804; k &#8804; n, et
c) si pour un argument x1 . . . xk d&#8217;un pr&#233;dicat dans C, f(x1) = &#12296;i1, j1&#12297;, . . . , f(xk) =
</p>
<p>&#12296;ik, jk&#12297;, alors jm = im+1 pour 1 &#8804; m &lt; k. Par d&#233;finition, nous disons alors que
f(x1 . . . xk) = &#12296;i1, jk&#12297;.
</p>
<p>La relation de d&#233;rivation pour RCG est d&#233;finie comme suit :
D&#233;finition 6. Pour chaque clause C : s&#8217;il existe une instantiation de cette clause par rapport &#224;
un w &#8712; T &#8727;, on peut alors, dans un pas de d&#233;rivation (. . .&#8658; . . .), remplacer la partie gauche de
cette instantiation par sa partie droite. &#8727;&#8658; est la cl&#244;ture reflexive et transitive de &#8658;. Le langage
des cha&#238;nes d&#8217;une RCG G est L(G) = {w |S(&#12296;0, |w|&#12297;) &#8727;&#8658; &#491; par rapport &#224; w}.
Comme exemple, prenons G = &#12296;{S,A,B}, {a, b}, {X, Y, Z}, S, P &#12297; avec
S(X Y Z)&#8594; A(X,Z)B(Y ), A(aX, a Y ) &#8594; A(X, Y ), B(bX) &#8594; B(X),
A(&#491;, &#491;) &#8594; &#491;, B(&#491;) &#8594; &#491;. L(G) = {anbkan | k, n &#8712; IN}.
</p>
<p>La d&#233;rivation pour w = aabaa est la suivante.
La clause S est instanti&#233;e comme suit : S(&#12296;0, 5&#12297;)&#8658; A(&#12296;0, 2&#12297;, &#12296;3, 5&#12297;)B(&#12296;2, 3&#12297;)
</p>
<p>S(X Y Z) &#8594; A(X , Z) B(Y )
</p>
<p>&#12296;0, 2&#12297; &#12296;2, 3&#12297; &#12296;3, 5&#12297; &#12296;0, 2&#12297; &#12296;3, 5&#12297; &#12296;2, 3&#12297;
aa b aa aa aa b
</p>
<p>Apr&#232;s cela, A(&#12296;0, 2&#12297;, &#12296;3, 5&#12297;)&#8658; A(&#12296;1, 2&#12297;, &#12296;4, 5&#12297;)&#8658; A(&#12296;2, 2&#12297;, &#12296;5, 5&#12297;)&#8658; &#491; :
</p>
<p>A(aXaY )&#8594; A(X,Y ) et A(aXaY )&#8594; A(X,Y ) et A(&#491;, &#491;) &#8594; &#491;
</p>
<p>&#12296;0, 1&#12297;&#12296;1, 2&#12297;&#12296;3, 4&#12297;&#12296;4, 5&#12297;&#12296;1, 2&#12297;&#12296;4, 5&#12297; &#12296;1, 2&#12297;&#12296;2, 2&#12297;&#12296;4, 5&#12297;&#12296;5, 5&#12297;&#12296;2, 2&#12297;&#12296;5, 5&#12297;
a a a a a a a &#491; a &#491; &#491; &#491;
</p>
<p>Pour le second pr&#233;dicat, nous avons B(&#12296;2, 3&#12297;)&#8658; B(&#12296;3, 3&#12297;)&#8658; &#491; :
B(b X) &#8594; B(X)
</p>
<p>&#12296;2, 3&#12297; &#12296;3, 3&#12297; &#12296;3, 3&#12297;
b &#491; &#491;
</p>
<p>et B(&#491;) &#8594; &#491;
</p>
<p>D&#233;finition 7. Une RCG est dite non-combinatoire si chaque argument d&#8217;un pr&#233;dicat d&#8217;une
partie droite de clause consiste en une seule variable. Elle est lin&#233;aire si aucune variable n&#8217;ap-
parait plus d&#8217;une fois dans la partie gauche d&#8217;une clause ou plus d&#8217;une fois dans la partie
droite d&#8217;une clause. Elle est non-effa&#231;ante si pour chaque clause, chaque variable dans la par-
tie gauche se trouve &#233;galement dans la partie droite, et vice versa. Une RCG est simple si elle
est non-combinatoire, lin&#233;aire et non-effa&#231;ante.
</p>
<p>Les RCGs simples sont &#233;quivalentes aux syst&#232;mes de r&#233;&#233;criture hors contextes lin&#233;aires (LC-
FRS, (Weir, 1988)), c.f. (Boullier, 1998). Par cons&#233;quent, les RCGs simples sont l&#233;g&#232;rement
sensibles au contexte (Joshi, 1985).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>TT-MCTAGs et RCGs
</p>
<p>1.3 De TAG &#224; RCG
</p>
<p>L&#8217;id&#233;e g&#233;n&#233;rale de la transformation d&#8217;une TAG en RCG (positive simple) propos&#233;e par (Boul-
lier, 1999b; Boullier, 1999a) est la suivante : la RCG contient des pr&#233;dicats de deux types,
&#12296;&#945;&#12297;(X) et &#12296;&#946;&#12297;(L,R), utilis&#233;s respectivement pour encoder les arbres initiaux et auxiliaires. X
couvre la cha&#238;ne de l&#8217;arbre &#945; en incluant tous les arbres ajout&#233;s &#224; &#945;, tandis que L et R couvrent
les parties de la cha&#238;ne de &#946; (incluant tous les arbres ajout&#233;s) qui se trouvent &#224; gauche et &#224;
droite du n&#339;ud pied. Les clauses de la RCG r&#233;duisent les arguments de ces pr&#233;dicats en identi-
fiant la partie provenant de l&#8217;arbre &#945;/&#946; lui-m&#234;me et les parties provenant des arbres ajout&#233;s par
substitution ou adjonction. Un exemple est donn&#233; Fig. 2.
</p>
<p>TAG :
</p>
<p>&#945;1 SNA
</p>
<p>a S F
</p>
<p>&#491;
</p>
<p>&#945;2
F
</p>
<p>d
</p>
<p>&#945;3
F
</p>
<p>e
</p>
<p>&#946; S
</p>
<p>b S&#8727;NA c
</p>
<p>RCG &#233;quivalente : S(X) &#8594; &#12296;&#945;1&#12297;(X) | &#12296;&#945;2&#12297;(X) | &#12296;&#945;3&#12297;(X) (chaque w est la cha&#238;ne d&#8217;un arbre initial)
&#12296;&#945;1&#12297;(aF ) &#8594; &#12296;&#945;2&#12297;(F ) | &#12296;&#945;3&#12297;(F ) (la cha&#238;ne de &#945;1 est a suivie de la cha&#238;ne de l&#8217;arbre substitu&#233; au n&#339;ud F )
&#12296;&#945;1&#12297;(aB1B2F ) &#8594; &#12296;&#946;&#12297;(B1, B2)&#12296;&#945;2&#12297;(F ) | &#12296;&#946;&#12297;(B1, B2)&#12296;&#945;3&#12297;(F ) (ou &#946; est adjoint &#224; S dans &#945; ;
</p>
<p>la cha&#238;ne est alors a, suivie de la partie gauche de &#946;, la partie droite de &#946; et la cha&#238;ne substitu&#233;e &#224; F )
&#12296;&#946;&#12297;(B1b, cB2) &#8594; &#12296;&#946;&#12297;(B1, B2) (&#946; peut &#234;tre adjoint &#224; sa racine ; alors la partie gauche est la partie gauche du &#946; adjoint
</p>
<p>suivie de b ; la partie droite est c suivie par la partie droite du &#946; adjoint)
&#12296;&#945;2&#12297;(d) &#8594; &#491; &#12296;&#945;3&#12297;(e) &#8594; &#491; &#12296;&#946;&#12297;(b, c) &#8594; &#491; (les cha&#238;nes de &#945;2, &#945;3 et &#946; sont d, e et la paire b (gauche) et c (droite) resp.)
</p>
<p>FIG. 2 &#8211; Une TAG et la RCG &#233;quivalente.
</p>
<p>2 TT-MCTAG
</p>
<p>Pour repr&#233;senter un ensemble de phenom&#232;nes linguistiques, une extension des grammaires
d&#8217;arbres adjoints a &#233;t&#233; propos&#233;e, &#224; savoir les TAGs &#224; composantes multiples (MCTAG, (Weir,
1988)). Leur motivation r&#233;side dans le besoin de r&#233;partir la contribution d&#8217;un seul &#233;l&#233;ment lexi-
cal (par exemple un verbe et ses arguments) sur plusieurs arbres &#233;l&#233;mentaires. Une MCTAG
est donc compos&#233;e d&#8217;ensembles d&#8217;arbres &#233;l&#233;mentaires. Si l&#8217;un de ces ensembles est utilis&#233; lors
d&#8217;une d&#233;rivation, chacun de ses &#233;l&#233;ments doit &#234;tre utilis&#233;.
</p>
<p>D&#233;finition 8. Une MCTAG est un tuple G = &#12296;I, A,N, T,A&#12297; tel que GTAG := &#12296;I, A,N, T &#12297; est
une TAG, et A est une partition de I &#8746; A.
</p>
<p>Le type de MCTAG auquel nous sommes int&#233;ress&#233; est Tree-Tuple MCTAG with Shared Nodes
(TT-MCTAG, (Lichte, 2007)). Les TT-MCTAGs ont &#233;t&#233; introduites afin d&#8217;analyser des ph&#233;no-
m&#232;nes d&#8217;ordre de mots libre dans des langues comme l&#8217;allemand. Un exemple est (1) o&#249; l&#8217;argu-
ment es de reparieren pr&#233;c&#232;de l&#8217;argument der Mechaniker de verspricht et n&#8217;avoisine donc pas
le pr&#233;dicat dont il d&#233;pend.
</p>
<p>(1) ... dass es der Mechaniker zu reparieren verspricht
... que le le m&#233;canicien r&#233;parer promet
&#8216;... que le m&#233;canicien promet de le r&#233;parer&#8217;
</p>
<p>Dans une TT-MCTAG, les ensembles &#233;l&#233;mentaires contiennent (1) un arbre lexicalis&#233; &#947;, l&#8217;unique
arbre t&#234;te, et (2) plusieurs arbres auxiliaires, les arbres arguments. Une liste compos&#233;e d&#8217;une</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Yannick Parmentier
</p>
<p>t&#234;te et d&#8217;arguments s&#8217;appelle un tuple d&#8217;arbres. Lors de la d&#233;rivation, les arguments doivent soit
s&#8217;adjoindre directement &#224; leur t&#234;te, soit &#234;tre li&#233;s par une cha&#238;ne d&#8217;adjonctions &#224; des racines, &#224;
un arbre adjoint &#224; leur t&#234;te. Autrement dit, dans l&#8217;arbre de d&#233;rivation TAG correpondant, la t&#234;te
doit dominer ses arguments de telle mani&#232;re que les adresses des n&#339;uds sur le chemin, sauf la
premi&#232;re, doivent &#234;tre &#491; (i.e. le n&#339;ud racine). Cela traduit la notion d&#8217;adjonction avec partage
de n&#339;uds de (Kallmeyer, 2005).
D&#233;finition 9. 1. Une MCTAG G = &#12296;I, A,N, T,A&#12297; est une TT-MCTAG ssi chaque &#915; &#8712; A
a la forme {&#947;, &#946;1, . . . , &#946;n} ou &#947; (la t&#234;te) a au moins une feuille avec une &#233;tiquette termi-
nale, et &#946;1, . . . , &#946;n sont des arbres auxiliaires, les arguments. Nous &#233;crivons un tel ensemble
&#12296;&#947;, {&#946;1, . . . , &#946;n}&#12297;. 2. Un arbre de d&#233;rivation D dans &#12296;I, A,N, T &#12297; est admis comme arbre de
d&#233;rivation TAG dans G ssi
</p>
<p>(MC) (&#8220;multicomponent condition&#8221;) Il existe k ( k &#8805; 1) instances &#915;1, . . . ,&#915;k de tuples &#233;l&#233;men-
taires, diff&#233;rentes les unes des autres, tel que&#8899;ki=1 &#915;i est l&#8217;ensemble d&#8217;&#233;tiquettes dans D.
(SN-TTL) (&#8220;tree-tuple locality with shared nodes&#8221;) pour tous les n&#339;uds n0, n1, . . . , nm
(m &gt; 1) dansD avec l&#8217;&#233;tiquette du m&#234;me tuple, tel que l&#8217;&#233;tiquette de n0 est la t&#234;te : pour chaque
1 &#8804; i &#8804; m : ou bien &#12296;n0, ni&#12297; &#8712; PD4 ou bien il existe des ni,1, . . . , ni,k &#233;tiquettes d&#8217;arbres
auxiliaires telles que ni = ni,k, &#12296;n0, ni,1&#12297; &#8712; PD et pour 1 &#8804; j &#8804; k &#8722; 1 : &#12296;ni,j, ni,j+1&#12297; &#8712; PD
avec &#491; comme &#233;tiquette d&#8217;arc.
Sur la Fig. 3, l&#8217;arbre auxiliaire NPnom est adjoint directement &#224; verspricht (sa t&#234;te) tandis que
l&#8217;arbre NPacc est adjoint &#224; la racine d&#8217;un arbre qui est adjoint &#224; la racine d&#8217;un arbre qui est
adjoint &#224; reparieren.
</p>
<p>&#9001;
VP
</p>
<p>VP&#8727; verspricht
,
</p>
<p>{
VP
</p>
<p>NPnom VP&#8727;
</p>
<p>} &#9002; &#9001;
NPnom
</p>
<p>der Mech.
, {}
</p>
<p>&#9002;
</p>
<p>&#9001;
VP
</p>
<p>zu reparieren
,
</p>
<p>{
VP
</p>
<p>NPacc VP&#8727;
</p>
<p>} &#9002; &#9001;
NPacc
</p>
<p>es
, {}
</p>
<p>&#9002;
</p>
<p>arbre de d&#233;rivation :
reparieren
</p>
<p>&#491;
</p>
<p>verspricht
&#491;
</p>
<p>NPnom
1 &#491;
</p>
<p>Mechaniker NPacc
1
</p>
<p>es
</p>
<p>FIG. 3 &#8211; D&#233;rivation en TT-MCTAG pour (1)
</p>
<p>Le probl&#232;me de la reconnaissance pour TT-MCTAG est NP-difficile (S&#248;gaard et al., 2007).
Nous introduisons ici une contrainte suppl&#233;mentaire pour les TT-MCTAGs, fond&#233;e sur une id&#233;e
de (S&#248;gaard et al., 2007) : les TT-MCTAGs sont de rang k si, &#224; chaque moment de la d&#233;rivation,
le nombre d&#8217;arguments qui d&#233;pendent de t&#234;tes pr&#233;c&#233;demment utilis&#233;es dans la d&#233;rivation et qui
donc attendent leur adjonction, est limit&#233; &#224; k.5
</p>
<p>D&#233;finition 10. Une TT-MCTAGG = &#12296;I, A,N, T,A&#12297; est de rang k (appel&#233;e aussi k-TT-MCTAG)
ssi pour chaque arbre de d&#233;rivation TAG D admis dans G :
(TT-k) Il n&#8217;existe pas de n&#339;uds n, h0, . . . , hk, a0, . . . , ak dans D tels que l&#8217;&#233;tiquette de ai r&#233;f&#232;re
&#224; un argument de l&#8217;&#233;tiquette de hi et &#12296;hi, n&#12297;, &#12296;n, ai&#12297; &#8712; P+D pour 0 &#8804; i &#8804; k.
</p>
<p>4PD est la relation de parent&#233;, i.e., &#12296;x, y&#12297; &#8712; PD ssi y est n&#339;ud fils de x dans D.
5Une id&#233;e similaire est utilis&#233;e dans V-TAG, (Rambow, 1994), o&#249;, lors de l&#8217;analyse, on doit conna&#238;tre l&#8217;en-
</p>
<p>semble des liens de dominance qui restent encore &#224; satisfaire. En limitant cet ensemble, on obtient une analyse
polynomiale.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>TT-MCTAGs et RCGs
</p>
<p>3 De k-TT-MCTAG &#224; RCG
</p>
<p>Nous construisons une RCG simple &#233;quivalente &#224; une k-TT-MCTAG de mani&#232;re similaire &#224; la
conversion en RCG pour TAG. Nous consid&#233;rons des pr&#233;dicats &#12296;&#947;&#12297; r&#233;f&#233;rant aux contributions
des arbres &#233;l&#233;mentaires (et non des ensembles) utilis&#233;s dans une analyse. Rappelons que chaque
TT-MCTAG est une TAG contrainte, ainsi une d&#233;rivation TT-MCTAG est une d&#233;rivation pour
la TAG sous-jacente. En cons&#233;quence, nous pouvons construire une RCG pour la TAG sous-
jacente, tout en enrichissant les pr&#233;dicats de fa&#231;on &#224; conserver l&#8217;information &#171; doit &#234;tre adjoint &#187;
pour les arbres arguments, information contraignant les clauses instantiables dans la d&#233;rivation
RCG. Dans notre cas, la production d&#8217;un pr&#233;dicat &#12296;&#947;&#12297; contient non seulement la production
de &#947; et de ses arguments, mais &#233;galement celle des arguments des pr&#233;dicats pr&#233;c&#233;demment
instanti&#233;s dans la d&#233;rivation, et &#233;tant adjoints par la suite6. Notre conversion m&#232;ne &#224; une RCG
d&#8217;arit&#233; 2, et dont les noms de pr&#233;dicats sont complexes. Afin de maintenir le nombre de noms
de pr&#233;dicats n&#233;cessaires finis, la limite k est cruciale. Un pr&#233;dicat &#12296;&#947;&#12297; doit encoder l&#8217;ensemble
des arbres arguments d&#233;pendant d&#8217;arbres t&#234;tes pr&#233;c&#233;demment consomm&#233;s dans la d&#233;rivation.
Cette ensemble est appel&#233; liste des arguments en attente (List of Pending Arguments, LPA). Ces
arbres doivent soit &#234;tre adjoints &#224; la racine de &#947; ou &#234;tre pass&#233; &#224; la LPA des arbres adjoints.
Afin de r&#233;duire le nombre de clauses, nous distingons, comme le propose (Boullier, 1999b), les
clauses d&#8217;arbres (pr&#233;dicats &#12296;&#947;...&#12297;), des clauses dites de &#171; branchement &#187; (pr&#233;dicats &#12296;adj . . .&#12297; and
&#12296;sub . . .&#12297;). Nous avons ainsi trois types de pr&#233;dicats :
</p>
<p>1. &#12296;&#947;, LPA&#12297;. Ces pr&#233;dicats ont une arit&#233; 2 si &#947; est un arbre auxiliare (contributions gauche et
droite du n&#339;ud pied), une arit&#233; 1 s&#8217;il s&#8217;agit d&#8217;un arbre initial. Les clauses &#12296;&#947;, LPA&#12297; distribuent
les variables r&#233;f&#233;rant aux productions des arbres substitu&#233;s ou adjoints &#224; &#947; via une partie droite
compos&#233;e de pr&#233;dicats adj et sub. La LPA est pass&#233;e au pr&#233;dicat adj du n&#339;ud racine, et les
arguments de &#947; distribu&#233;s &#224; l&#8217;ensemble des pr&#233;dicats d&#8217;adjonction.
</p>
<p>2. &#12296;adj, &#947;, dot, LPA&#12297; est un pr&#233;dicat de branchement d&#8217;arit&#233; 2. Ici, la LPA contient a) la liste
des arguments des t&#234;tes pr&#233;c&#233;demment consomm&#233;es si dot = &#491; (i.e. n&#339;ud racine), et b) cer-
tains des arguments de &#947; (toutes les distributions des arguments sur les n&#339;uds d&#8217;adjonction
ont &#233;t&#233; calcul&#233;es, en tenant compte des contraintes d&#8217;&#233;tiquette du n&#339;ud dot). Les clauses
&#12296;adj, &#947;, dot, LPA&#12297; adjoignent un arbre &#947;&#8242; sur le n&#339;ud dot de &#947;. Si &#947;&#8242; &#233;tait dans la LPA, le
pr&#233;dicat d&#8217;arbre appel&#233; re&#231;oit LPA \ {&#947;&#8242;}, dans le cas contraire, &#947;&#8242; est une t&#234;te, et la LPA
reste inchang&#233;e.
</p>
<p>3. &#12296;sub, &#947;, dot&#12297; est une clause de branchement d&#8217;arit&#233; 1, repr&#233;sentant les arbres pouvant &#234;tre
substitu&#233;s au n&#339;ud dot de &#947;.
</p>
<p>Plus pr&#233;cis&#233;ment, la conversion se passe comme suit : comme dans (Boullier, 1999b), nous d&#233;-
finissons une cha&#238;ne de d&#233;coration &#963;&#947; pour chaque arbre &#233;l&#233;mentaire &#947;. Les n&#339;uds internes qui
ne sont pas &#233;tiquet&#233;s NA recoivent deux variables L et R repr&#233;sentant les productions provenant
d&#8217;une adjonction au n&#339;ud en question, les n&#339;uds feuilles une variable X repr&#233;sentant la pro-
duction provenant d&#8217;une substitution. Dans un parcours de type depth-first de &#947;, les variables
sont collect&#233;es (les n&#339;uds pieds apportant un caract&#232;re de s&#233;paration &#171; , &#187;), pour cr&#233;er le(s)
argument(s) du pr&#233;dicat &#12296;&#947;&#12297;.
</p>
<p>1. Nous ajoutons un pr&#233;dicat de d&#233;part S et les clauses S(X)&#8594; &#12296;&#945;, &#8709;&#12297;(X) pour l&#8217;ensemble des
arbres initiaux &#945;.
</p>
<p>6Notons qu&#8217;une alternative &#224; ces pr&#233;dicats enrichis serait d&#8217;augmenter l&#8217;arit&#233; des pr&#233;dicats pour contenir les
contributions des arguments restant &#224; adjoindre. La conversion en RCG devient alors bien plus complexe.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Yannick Parmentier
</p>
<p>&#9001;
&#945;v VPOA
</p>
<p>v0
</p>
<p>, {}
</p>
<p>&#9002; &#9001;
&#945;n1 NP1NA
</p>
<p>n1
</p>
<p>, {}
</p>
<p>&#9002; &#9001;
&#945;n2 NP2NA
</p>
<p>n2
</p>
<p>, {}
</p>
<p>&#9002;
</p>
<p>&#9001;
&#946;v1 VPOA
</p>
<p>v1 VP&#8727;NA
,
</p>
<p>&#63729;&#63730;
&#63731;
</p>
<p>&#946;n1 VP
</p>
<p>NP1 VP&#8727;NA
</p>
<p>&#63740;&#63741;
&#63742;
&#9002; &#9001;
</p>
<p>&#946;v2 VPOA
</p>
<p>v2 VP&#8727;NA
,
</p>
<p>&#63729;&#63730;
&#63731;
</p>
<p>&#946;n2 VP
</p>
<p>NP2 VP&#8727;NA
</p>
<p>&#63740;&#63741;
&#63742;
&#9002;
</p>
<p>FIG. 4 &#8211; TT-MCTAG
</p>
<p>2. Pour chaque &#947; &#8712; I &#8746; A, soient Lp, Rp les symboles gauche et droite dans &#963;&#947; pour le n&#339;ud
d&#8217;adresse p, s&#8217;il s&#8217;agit d&#8217;un n&#339;ud d&#8217;adjonction, et Xp s&#8217;il s&#8217;agit d&#8217;un n&#339;ud de substitution.
Soient p1, . . . , pk les n&#339;uds d&#8217;adjonction potentiels, pk+1, . . . , pl les n&#339;uds de substitution
dans &#947;. La RCG produite contient alors toutes les clauses :
&#12296;&#947;, LPA&#12297;(&#963;&#947;) &#8594; &#12296;adj, &#947;, p1, LPAp1&#12297;(Lp1 , Rp1) . . . &#12296;adj, &#947;, pk, LPApk&#12297;(Lpk , Rpk)
&#12296;sub, &#947;, pk+1&#12297;(Xpk+1) . . . &#12296;sub, &#947;, pl&#12297;(Xpl) telles que :
&#8211; si LPA 6= &#8709;, alors &#491; &#8712; {p1, . . . , pk} et LPA &#8838; LPA&#491;,
&#8211;
</p>
<p>&#8899;k
i=0 LPApi = LPA &#8746; &#915;(&#947;) o&#249; &#915;(&#947;) est soit l&#8217;ensemble des arguments de &#947; (si &#947; est un
</p>
<p>arbre t&#234;te), soit &#8709; si &#947; est lui-m&#234;me un argument.
3. Pour tous les pr&#233;dicats &#12296;adj, &#947;, dot, LPA&#12297;, la RCG contient les clauses &#12296;adj, &#947;, dot, LPA&#12297;(L,R)&#8594;
&#12296;&#947;&#8242;, LPA&#8242;&#12297;(L,R) telles que &#947;&#8242; peut &#234;tre adjoint au n&#339;ud dot de &#947; et :
&#8211; soit &#947;&#8242; &#8712; LPA et LPA&#8242; = LPA \ {&#947;&#8242;},
&#8211; soit &#947;&#8242; /&#8712; LPA, &#947;&#8242; est un arbre t&#234;te, et LPA&#8242; = LPA.
</p>
<p>4. Pour tous les pr&#233;dicats &#12296;adj, &#947;, dot, &#8709;&#12297; o&#249; le n&#339;ud dot de &#947; n&#8217;est pas un n&#339;ud &#233;tiquet&#233; OA, la
RCG contient une clause &#12296;adj, &#947;, dot, &#8709;&#12297;(&#491;, &#491;)&#8594; &#491;.
</p>
<p>5. Pour tous les pr&#233;dicats &#12296;sub, &#947;, dot&#12297; et tous les &#947;&#8242; qui peuvent &#234;tre substitu&#233;s au n&#339;ud dot de
&#947;, la RCG contient la clause &#12296;sub, &#947;, dot&#12297;(X)&#8594; &#12296;&#947;&#8242;, &#8709;&#12297;(X).
</p>
<p>Prenons la TT-MCTAG de la Fig. 4. Pour celle-l&#224;, on obtient (entre autres) les clauses RCG
&#8211; &#12296;&#945;v, &#8709;&#12297;(L v0 R)&#8594; &#12296;adj, &#945;v, &#491;, &#8709;&#12297;(L,R) (une seule adjonction sur la racine d&#8217;adresse &#491;)
&#8211; &#12296;adj, &#945;v, &#491;, &#8709;&#12297;(L,R)&#8594; &#12296;&#946;v1 , &#8709;&#12297;(L,R) | &#12296;&#946;v2 , &#8709;&#12297;(L,R) (&#946;v1 ou &#946;v2 peuvent &#234;tre adjoints &#224;
&#491; dans &#945;v, LPA (ici vide) est transmise)
</p>
<p>&#8211; &#12296;&#946;v1 , &#8709;&#12297;(L v1, R) &#8594; &#12296;adj, &#946;v1 , &#491;, {&#946;n1}&#12297;(L,R) (dans &#946;v1 , il y a un unique n&#339;ud d&#8217;adjonc-
tion d&#8217;adresse &#491; ; l&#8217;argument est pass&#233; &#224; la nouvelle LPA)
</p>
<p>&#8211; &#12296;adj, &#946;v1 , &#491;, {&#946;n1}&#12297;(L,R) &#8594; &#12296;&#946;n1, &#8709;&#12297;(L,R) | &#12296;&#946;v1 , {&#946;n1}&#12297;(L,R) | &#12296;&#946;v2 , {&#946;n1}&#12297;(L,R)
(soit &#946;n1 est adjoit et retir&#233; de la LPA ou bien un autre arbre (&#946;v1 ou &#946;v2) est adjoint)
</p>
<p>&#8211; &#12296;&#946;v1 , {&#946;n1}&#12297;(L v1, R) &#8594; &#12296;adj, &#946;v1 , &#491;, {&#946;n1, &#946;n1}&#12297;(L,R) (ici encore, il y a un seul n&#339;ud
d&#8217;adjonction dans &#946;v1 ; l&#8217;argument &#946;n1 est ajout&#233; &#224; la LPA)
</p>
<p>&#8211; &#12296;&#946;n1 , &#8709;&#12297;(L X,R) &#8594; &#12296;adj, &#946;n1 , &#491;, &#8709;&#12297;(L,R) &#12296;sub, &#946;n1, 1, &#12297;(X) (adjonction &#224; la racine et
substitution au n&#339;ud 1 dans &#946;n1)
</p>
<p>&#8211; &#12296;adj, &#946;n1 , &#491;, &#8709;&#12297;(&#491;, &#491;) &#8594; &#491; (l&#8217;adjonction &#224; la racine de &#946;n1 n&#8217;est pas obligatoire tant que la
LPA est vide)
</p>
<p>&#8211; &#12296;sub, &#946;n1, 1, &#12297;(X)&#8594; &#12296;&#945;n1, &#8709;&#12297;(X) (substitution de &#945;n1 au n&#339;ud d&#8217;adresse 1)
&#8211; &#12296;&#945;n1, &#8709;&#12297;(n1) &#8594; &#491; (aucune adjonction ou substitution dans &#945;n1)
La d&#233;rivation RCG pour la cha&#238;ne d&#8217;entr&#233;e n1n2n1v2v1v1v0 proc&#232;de comme suit7 :
</p>
<p>S(n1 n2 n1 v2 v1 v1 v0) &#8658; &#12296;&#945;v, &#8709;&#12297;(n1 n2 n1 v2 v1 v1 v0)
</p>
<p>7Nous rempla&#231;ons les intervalles par les sous-cha&#238;nes correspondantes pour rendre l&#8217;exemple plus lisible.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>TT-MCTAGs et RCGs
</p>
<p>&#8658; &#12296;adj, &#945;v, &#491;, &#8709;&#12297;(n1 n2 n1 v2 v1 v1, &#491;) (adjonction au n&#339;ud &#491;, v0 est consomm&#233;)
</p>
<p>&#8658; &#12296;&#946;v1 , &#8709;&#12297;(n1 n2 n1 v2 v1 v1, &#491;) (&#946;v1 est adjoint)
</p>
<p>&#8658; &#12296;adj, &#946;v1 , &#491;, {&#946;n1}&#12297;(n1 n2 n1 v2 v1, &#491;) (adj. au n&#339;ud &#491;, v1 est consomm&#233;, &#946;n1 est plac&#233; dans la LPA)
</p>
<p>&#8658; &#12296;&#946;v1 , {&#946;n1}&#12297;(n1 n2 n1 v2 v1, &#491;) (&#946;v1 est adjoint)
</p>
<p>&#8658; &#12296;adj, &#946;v1 , &#491;, {&#946;n1, &#946;n1}&#12297;(n1 n2 n1 v2, &#491;) (adj. au n&#339;ud &#491;, v1 est consomm&#233;, &#946;n1 est plac&#233; dans la LPA)
</p>
<p>&#8658; &#12296;&#946;v2 , {&#946;n1, &#946;n1}&#12297;(n1 n2 n1 v2, &#491;) (&#946;v2 est adjoint)
</p>
<p>&#8658; &#12296;adj, &#946;v2 , &#491;, {&#946;n2, &#946;n1, &#946;n1}&#12297;(n1 n2 n1, &#491;) (adj. au n&#339;ud &#491;, v2 est consomm&#233;, &#946;n2 est plac&#233; dans la LPA)
</p>
<p>&#8658; &#12296;&#946;n1 , {&#946;n2, &#946;n1}&#12297;(n1 n2 n1, &#491;) (&#946;n1 issu de la LPA est adjoint)
</p>
<p>&#8658; &#12296;adj, &#946;n1 , &#491;, {&#946;n2, &#946;n1}&#12297;(n1 n2, &#491;) &#12296;sub, &#946;n1, 1, &#12297;(n1) (adj. au n&#339;ud &#491;, subst. au n&#339;ud 1)
</p>
<p>&#8658; &#12296;adj, &#946;n1 , &#491;, {&#946;n2, &#946;n1}&#12297;(n1 n2, &#491;) &#12296;&#945;n1 , &#8709;&#12297;(n1) (subst. de &#945;n1 )
</p>
<p>&#8658; &#12296;adj, &#946;n1 , &#491;, {&#946;n2, &#946;n1}&#12297;(n1 n2, &#491;) &#491;&#8658; &#12296;&#946;n2, {&#946;n1}&#12297;(n1 n2, &#491;) (n1 consomm&#233;, &#946;n2 adjoint)
</p>
<p>&#8658; &#12296;adj, &#946;n2 , &#491;, {&#946;n1}&#12297;(n1, &#491;) &#12296;sub, &#946;n2, 1, &#12297;(n2) (adj. au n&#339;ud &#491;, subst. au n&#339;ud 1)
</p>
<p>&#8658; &#12296;adj, &#946;n2 , &#491;, {&#946;n1}&#12297;(n1, &#491;) &#12296;&#945;n2 , &#8709;&#12297;(n2) (subst. de &#945;n2 )
</p>
<p>&#8658; &#12296;adj, &#946;n2 , &#491;, {&#946;n1}&#12297;(n1, &#491;) &#491;&#8658; &#12296;&#946;n1, &#8709;&#12297;(n1, &#491;) (n2 est consomm&#233;, &#946;n1 adjoint)
&#8727;
</p>
<p>&#8658; &#12296;adj, &#946;n1 , &#491;, &#8709;&#12297;(&#491;, &#491;) &#12296;&#945;n1, &#8709;&#12297;(n1)
&#8727;
</p>
<p>&#8658; &#491; (subst. de &#945;n1 , n1 consomm&#233;)
</p>
<p>Cette exemple n&#233;cessite une LPA de capacit&#233; maximale 3, i.e. une 3-TT-MCTAG. Notons
qu&#8217;avec cette construction, le groupement des arbres en tuples est perdu. Ainsi, dans notre
exemple, nous ne savons plus quel arbre n1 provient de quel ensemble. Cependant, en pratique,
nous cr&#233;ons une RCG pour une sous-grammaire TT-MCTAG s&#233;lectionn&#233;e &#224; partir de la cha&#238;ne
d&#8217;entr&#233;e. Si plusieurs occurrences d&#8217;un tuple donn&#233; sont s&#233;lectionn&#233;es, celles-ci se voient affec-
t&#233;es un identifiant unique.
</p>
<p>Avec cette construction, on peut d&#233;montrer le th&#233;or&#232;me suivant (voir (Kallmeyer &amp; Parmentier,
2008)). Comme corollaire, les k-TT-MCTAGs sont l&#233;g&#232;rement sensibles au contexte.
Th&#233;or&#232;me 1. Pour chaque k-TT-MCTAG G, il existe une RCG G&#8242; simple telle que
L(G) = L(G&#8242;)8.
</p>
<p>Conclusion
</p>
<p>Cet article a mis en relation deux formalismes grammaticaux, &#224; savoir les grammaires TT-
MCTAG et grammaires RCG. TT-MCTAG est un formalisme de r&#233;&#233;criture d&#8217;arbres qui permet
de mod&#233;liser des ph&#233;nom&#232;nes d&#8217;ordre des mots libre (existant par exemple en allemand). Les
RCG, quant &#224; elles, sont connues pour leur propri&#233;t&#233;s formelles avantageuses : les RCG sont
analysables en un temps polynomial, et les RCG simples sont l&#233;g&#232;rement sensibles au contexte.
De plus, des algorithmes d&#8217;analyse pour RCGs simples sont connus.
</p>
<p>8Nous suspectons que l&#8217;inverse ne soit pas toujours vrai. Autrement dit, nous suspectons que les langages k-TT-
MCTAG soient strictement contenus dans l&#8217;ensemble des langages RCG simples. Un exemple de langage qui n&#8217;est
probablement pas dans k-TT-MCTAG est le langage de double copie {www |w &#8712; {a, b}&#8727;}. Si les trois copies d&#8217;un
terminal appartiennent &#224; un m&#234;me tuple, deux d&#8217;entre elles doivent &#234;tre adjointes par partage de n&#339;ud, comment
contraindre alors toutes les d&#233;pendances pour n&#8217;avoir que celles attendues ?</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Yannick Parmentier
</p>
<p>Nous avons montr&#233; comment convertir une TT-MCTAG restreinte (appel&#233;e k-TT-MCTAG) en
une RCG simple &#233;quivalente. Le r&#233;sultat formel de cette conversion est que la classe des lan-
gages de cha&#238;nes g&#233;n&#233;r&#233;s par une k-TT-MCTAG est contenue dans la classe des langages g&#233;n&#233;-
r&#233;s par les RCGs simples. En particulier, k-TT-MCTAG est l&#233;g&#232;rement sensible au contexte.
</p>
<p>Le r&#233;sultat pratique de cette conversion r&#233;side dans l&#8217;implantation d&#8217;un analyseur syntaxique
pour TT-MCTAG utilisant un analyseur RCG comme noyau. Plus pr&#233;cis&#233;ment, la TT-MCTAG
est d&#8217;abord convertie en une RCG &#233;quivalente, utilis&#233;e alors pour l&#8217;analyse. Le r&#233;sultat de l&#8217;ana-
lyse RCG est alors converti en analyse TT-MCTAG par interpr&#233;tation des noms de pr&#233;dicats
des clauses instanci&#233;es. L&#8217;analyseur en question est utilis&#233; pour d&#233;velopper une grammaire TT-
MCTAG de l&#8217;allemand, et est disponible librement sous licence GPL9.
</p>
<p>R&#233;f&#233;rences
BOULLIER P. (1998). A Proposal for a Natural Language Processing Syntactic Backbone.
Rapport interne 3342, INRIA.
BOULLIER P. (1999a). On TAG and Multicomponent TAG Parsing. Rapport interne 3668,
Institut National de Recherche en Informatique et en Automatique (INRIA).
BOULLIER P. (1999b). On TAG Parsing. In TALN 99, 6e conf&#233;rence annuelle sur le Traitement
Automatique des Langues Naturelles, p. 75&#8211;84, Carg&#232;se, Corse.
BOULLIER P. (2000). Range Concatenation Grammars. In Proceedings of the Sixth Interna-
tional Workshop on Parsing Technologies (IWPT2000), p. 53&#8211;64, Trento, Italy.
JOSHI A. K. (1985). Tree adjoining grammars : How much contextsensitivity is required ro
provide reasonable structural descriptions ? In D. DOWTY, L. KARTTUNEN &amp; A. ZWICKY,
Eds., Natural Language Parsing, p. 206&#8211;250. Cambridge University Press.
JOSHI A. K. &amp; SCHABES Y. (1997). Tree-Adjoning Grammars. In G. ROZENBERG &amp; A.
SALOMAA, Eds., Handbook of Formal Languages, p. 69&#8211;123. Berlin : Springer.
KALLMEYER L. (2005). Tree-local multicomponent tree adjoining grammars with shared
nodes. Computational Linguistics, 31(2), 187&#8211;225.
KALLMEYER L. &amp; PARMENTIER Y. (2008). On the relation between Multicomponent Tree
Adjoining Grammars with Tree Tuples (TT-MCTAG) and Range Concatenation Grammars
(RCG). In Proceedings of the 2nd International Conference on Language and Automata
Theory and Applications LATA, Tarragona, Spain.
LICHTE T. (2007). An MCTAG with Tuples for Coherent Constructions in German. In
Proceedings of the 12th Conference on Formal Grammar 2007, Dublin, Ireland.
RAMBOW O. (1994). Formal and Computational Aspects of Natural Language Syntax. PhD
thesis, University of Pennsylvania.
S&#216;GAARD A., LICHTE T. &amp; MAIER W. (2007). The complexity of linguistically motivated
extensions of tree-adjoining grammar. In Recent Advances in Natural Language Processing
2007, Borovets, Bulgaria.
WEIR D. J. (1988). Characterizing mildly context-sensitive grammar formalisms. PhD thesis,
University of Pennsylvania.
</p>
<p>9Voir http://www.sfb441.uni-tuebingen.de/emmy/tulipa</p>

</div></div>
</body></html>