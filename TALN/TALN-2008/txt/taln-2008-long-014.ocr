TALN 2008, Avignon, 9-13 juin 2008

Convertir des grammaires d’arbres adjoints a composantes
multiples avec tuples d’arbres (TT-MCTAG) en grammaires a
concaténation d’intervalles (RCG)

Laura Kallmeyerl Yannick Parmentierz
(1) SFB 441 / Université de Tiibingen
(2) SfS-CL / SFB 441 / Université de Tiibingen
Nauklerstr. 35, 72074 Tiibingen, Allemagne
lk@ sfs.uni-tuebingen.de, parmenti @ sfs.uni-tuebingen.de

Résumé. Cet article etudie la relation entre les grammaires d’arbres adjoints a compo-
santes multiples avec tuples d’arbres (TT-MCTAG), un formalisme utilise en linguistique infor-
matique, et les grammaires a concatenation d’intervalles (RCG). Les RCGS sont connues pour
decrire exactement la classe PTIME, il a en outre ete demontre que les RCGs « simples » sont
meme equivalentes aux systemes de reecriture hors-contextes lineaires (LCFRS), en d’autres
termes, elles sont legerement sensibles au contexte. TT-MCTAG a ete propose pour modeliser
les langages a ordre des mots libre. En general ces langages sont NP-complets. Dans cet article,
nous deﬁnissons une contrainte additionnelle sur les derivations autorisees par le formalisme
TT-MCTAG. Nous montrons ensuite comment cette forme restreinte de TT-MCTAG peut étre
convertie en une RCG simple equivalente. Le resultat est interessant pour des raisons theoriques
(puisqu’il montre que la forme restreinte de TT-MCTAG est legerement sensible au contexte),
mais egalement pour des raisons pratiques (la transformation proposee ici a ete utilisee pour
implanter un analyseur pour TT-MCTAG).

Abstract. This paper investigates the relation between TT-MCTAG, a formalism used in
computational linguistics, and RCG. RCGS are known to describe exactly the class PTIME;
« simple » RCG even have been shown to be equivalent to linear context-free rewriting sys-
tems, i.e., to be mildly context-sensitive. TT-MCTAG has been proposed to model free word
order languages. In general, it is NP-complete. In this paper, we will put an additional limita-
tion on the derivations licensed in TT-MCTAG. We show that TT-MCTAG with this additional
limitation can be transformed into equivalent simple RCGS. This result is interesting for theo-
retical reasons (since it shows that TT-MCTAG in this limited form is mildly context-sensitive)
and also for practical reasons (the proposed transformation has been used for implementing a
parser for TT-MCTAG).

M0tS-CléS I Grammaires d’arbres adjoints a composantes multiples, grammaires a conca-
tenation d’intervalles, legere sensibilite au contexte.

Keywords: Multicomponent Tree Adjoining Grammars, Range Concatenation Gram-
mars, mild context-sensitivity.

Laura Kallmeyer, Yannick Parmentier

1 Introduction

Il a ete demontre que les grammaires d’arbres adjoints (TAGs) sont d’un grand interet pour
le traitement automatique des langues naturelles, et pour des raisons linguistiques (domaine
de localite etendu), et pour des raisons formelles (complexite d’analyse). Pourtant, elles sont
trop limitees dans leur expressivite pour traiter certains phenomenes linguistiques comme par
exemple le brouillage d’arguments dans des langues dites a ordre des mots libre.

Cet article considere une variante des TAGs, les grammaires d’arbres adjoints a composantes
multiples avec tuples d’arbres (TT-MCTAGs), cherchant a resoudre ce probleme d’expressivite
tout en gardant les proprietes principales des TAGS. Dans ce contexte, nous traitons les proprie-
tes formelles de ce formalisme, en particulier sa relation avec les langages legerement sensibles
au contexte. En donnant la construction d’une grammaire a concatenation d’intervalles (RCG)
simple pour une TT-MCTAG qui satisfait une certaine contrainte, nous obtenons deux resul-
tats : d’abord nous prouvons que ces TT-MCTAGs restreintes sont en fait legerement sensibles
au contexte. Ensuite, en combinant cette construction avec un analyseur pour RCG, nous pou-
vons developper un analyseur pour TT-MCTAG. Nous pensons que l’idee de passer par les
RCGs pour analyser certains formalismes grammaticaux au lieu de developper un analyseur
different pour chacun d’entre eux peut étre utile d’une fagon generale.

Le plan de cet article est le suivant. Dans un premier temps, nous deﬁnissons les formalismes
sur lesquels nous nous basons, a savoir TAG (section 1.1) et RCG (section 1.2), et presentons
brievement un algorithme existant de conversion de TAG vers RCG (section 1.3). Ensuite, nous
introduisons le formalisme des TT-MCTAGs (section 2), ainsi que leur forme restreinte. Fina-
lement nous donnons l’algorithme de conversion de ces grammaires en RCG (section 3).

1.1 Tree Adjoining Grammars (TAG)

Les TAGs (Joshi & Schabes, 1997) sont des systemes de reecriture d’arbres. Une TAG est un
ensemble ﬁni d’arbres (les arbres elementaires) avec des etiquettes non-terminales et terminales
(les demiers seulement pour des feuilles). Des arbres plus grands sont generes par substitu-
tion (remplacement d’une feuille par un nouvel arbre) et adj onction (remplacement d’un noeud
interne par un nouvel arbre). En cas d’adjonction, l’arbre que l’on adjoint a exactement une
feuille marquee comme noeud pied (marquee par une etoile). Un tel arbre s’appelle un arbre
auxiliaire. Si cet arbre est adjoint a un noeud n, alors dans l’arbre resultat, le sous-arbre de ra-
cine n s’attache au noeud pied de l’arbre auxiliaire. Des arbres non-auxiliaires s’appellent des
arbres initiaux. Chaque derivation commence par un arbre initial. Dans un arbre derive terminal,
toutes les feuilles doivent avoir des etiquettes terminales. Un exemple est donne Fig. 1.

 

S arbre S arbre de:
NP/\\,P+,--.—«—}IP\ dénvéz Ny /VP\ derivation:
 I Al|)V VP* John A]|)V V|P laugh
N'P V
‘ I always always \|/ W
laughs laughs john always

John

FIG. 1 — Derivation TAG pour la phrase John always laughs

TT-MCTAGs et RCGs

Déﬁnition 1. Une TAG est un tuple G = (I, A, N, T) avec (i) N et T des alphabets disjoints, les
nonterminaux et les terminaux, et (ii) I et A des ensembles ﬁnis d’arbres initiaux et auxiliaires
respectivement avec non-terminaux N et terminaux T. En 0utre, les naeuds internes dans I U A
peuvent etre marques OA (adjonction obligatoire) 0u NA (adjonction interdite).

Déﬁnition 2. Soient G = (I, A, N, T) une TAG, 7 et 7’ des arbresﬁnis.

— 7 => 7’ dans G ssi il existe une adresse de naeud p et un arbre 76 qui est s0it un arbre ele-
mentaire, s0it derive d’un arbre elementaire tel que 7’ = 7[p, 76]1. 5 est la cléture reﬂexive
et transitive de =>.

— Le langage d’arbres de G est LT(G) = {7 | oz 5 7 pour quelque oz 6 I, t0utes lesfeuilles
dans 7 0nt une etiquette terminale et 7 ne contient pas de naeud marque OA}.

Les derivations en TAG sont representees par des arbres de derivation (des arbres non-ordonnes)
qui decrivent comment les arbres elementaires ont ete combines. L’arbre derive est alors 1e
résultat de 1’execution de ces combinaisons, i. e., 1’arbre de derivation décrit de fagon unique
un seul arbre derive. Chaque arc dans un arbre de derivation représente une adjonction ou une
substitution. Les arcs sont etiquetes avec des adresses de noeud de Gornz. L’ arbre de derivation
de la Fig. 1 par exemple, indique que 1’arbre elementarire de John a ete substitué au noeud
d’adresse 1 et always a ete adjoint a 1’adresse 2 (le fait que le premier est une substitution,
1e deuxieme une adjonction peut etre deduit du fait que 1’adresse 1 est 1’adresse d’une feuille
tandis que 2 est 1’adresse d’un noeud interne).

Déﬁnition 3. Soit G = (I, A, N, T) une TAG, on deﬁnit 7 un arbre derive d’un arbre elemen-
taire 70 dans G comme suit .' 7 = 70[p1, 71] . . . [p;,, 71,] tel que les substituti0ns/adj0ncti0ns des
71, . . . , 7;, sont les seules substituti0ns/adjunctions a 70 executees lors de la derivation de 7.
Dans ce cas-la, l’arbre de derivation correspondant a une racine etiquetee 70 qui a k ﬁls. Les
arcs entre 70 et ces ﬁls sont etiquetes p1, . . . , pk, et les ﬁls sont les arbres de derivation des
derivations de 71, . . . ,7;,.

1.2 Range Concatenation Grammars (RCG)

Déﬁnition 4. Une RCG positive (Boullier, 1999b; Boullier, 2000) est un tuple G = (N, T, V, S, P)
tel que (i) N est un ensemble ﬁni de predicats, chacun d’ariteﬁxe, S E N (d’arite 1) le predicat
initial, (ii) T et V sont des alphabets disjoints de terminaux et de variables, et (iii) P est un
ensemble ﬁni de clauses de la forme .-
A0(1:01, . . .,1:0a0) —> 6
0u A0(1:01, . . .,1:0a0) —> A1(1:11, . . .,1:1a1) ...A,,(J:,,1, . . .,1:,,an)
avec n 2 1, A,- E N, 1:,-j E (T U V)* et a,- l’arite d’A,-.

Notons qu’une RCG avec une arite maximale n s’appe1le une RCG d’arite n. Notons egalement
que, dans ce papier nous n’uti1isons que des RCGs positives, ainsi, dans ce qui suit, chaque
mention des RCGs refere aux RCGs positives3. Dans un appel de clause par rapport a une
chaine w = t1 . . .t,,, les arguments des prédicats sont instantiés par des sous-chaines de w,

1Pour des arbres 7,71, . . . ,7” et des adresses de noeuds djfferentes deux a deux p1, . . . , pn dans 7,
7[p1, 71] . . . [pn,7n] est le resultat des substitutions/adjonctions sequentielles de 71, . . . ,7” respectivement aux
noeuds d’adresses p1, . . . , pn dans 7.

2L’adresses de la racine est 6, et le n—ieme ﬁls d’un noeud avec adresse p a 1’adresse p. j .

3La variante negative permet des appels de predicats de la forme A(a1, . . . ,ozn). Un tel predicat reconnait 1e
complement de A(a1, . . . ,o4n), voir (Boullier, 2000).

Laura Kallmeyer, Yannick Parmentier

plus précisement par les intervalles correpondants. Un intervalle (i, j) avec 0 3 i < j 3
n correspond a la chaine entre les positions 1' et j, i.e., la chaine t,-+1 . . .tj. Si 1' = j, (i, j)
correspond a 6. Si 1' > j, (i, j) n’est pas déﬁni.

Déﬁnition 5. Une instantiation d’une clause C par rapport a une chaine w = t1 . . .75” est une
fonction f : {t’ | 75’ est l ’occurrence d’un t E T dans les arguments de C} U V —>  j)  g
j, i,j E IN} tel que .'
a) pour chaque occurrence t’ d’un t E T dans C .' f (t’ ) := (i,i + 1) pour quelque 2',
0 3 2' < ntelquet, :75,
b) pour chaque 11 E V .' f(11) = (j, k) pour quelques 0 gj g k g n, et
c) si pour un argument 1:1...J:;, d’un prédicat dans C, f(.'I31) = (i1,j1), . . .,f(J:,,) =
(ik, jk), alors jm = im+1 pour 1 g m < h. Par deﬁnition, nous disons alors que
f(151---1%): <i1,Jk)-

La relation de dérivation pour RCG est déﬁnie comme suit :

Déﬁnition 6. Pour chaque clause 0 .' s’il existe une instantiation de cette clause par rapport a
un 11) E T*, on peut alors, dans un pas de de’rivation (. . . => . . .), remplacer la partie gauche de
cette instantiation par sa partie droite. 5 est la cloture reﬂexive et transitive de =>. Le langage
des chaines d’une RCG G est L(G) = {w | S((0,  5 6par rapport a 11)}.

Come exemple, prenons G = ({S, A, B}, {a, b}, {X, Y, Z}, S, P) avec
S(XYZ) —> A(X, Z) B(Y), A(aX,aY) —> A(X,Y), B(bX) —> B(X),
A(6, 6) —> 6, B(6) —> 6. L(G) = {anbkan | h, n E N}.

La dérivation pour w = aabaa est la suivante.
La clause S est instantiée comme suit: S((0, 5)) => A((0, 2), (3, 5))B((2, 3))
S(X Y Z) _> A(X, Z) B(Y)
/ i l / ¥ .1
(0,2) (223) (3,5) (0,2) (3, 5) (23)
Apres cela, A((0, 2), (3, 5)) => A((1,2), (4,5)) => A((2,2), (5,5)) => 6:

A(?)(\a‘  et x14}1)§ }{)%‘ et A(6, 6) —> 6
(0, 1)(1, 2)(3,4)(4, 5)(1, 2)(4, 5) (1, 2)(2, 2)(4 5)(5, 5)(2, 2)(5, 5)

Pour le second prédicat, nous avons B((2, 3)) => B ((3, 3)) => 6 :
B(b X) —> B(X)
/ L z ,3
<2, 3> <3, 3> <3, 3> e (6) r 6
b 6 6
Déﬁnition 7. Une RCG est dite non-combinatoire si chaque argument d’un pre’dicat d’une
partie droite de clause consiste en une seule variable. Elle est linéaire si aucune variable n’ap-
parait plus d’une fois dans la partie gauche d’une clause ou plus d’une fois dans la partie
droite d’une clause. Elle est non-effacante si pour chaque clause, chaque variable dans la par-
tie gauche se trouve également dans la partie droite, et vice versa. Une RCG est simple si elle
est non-combinatoire, line’aire et non-eﬁacante.

Les RCGs simples sont équivalentes aux systemes de réécriture hors contextes linéaires (LC-
FRS, (Weir, 1988)), cf (Boullier, 1998). Par conséquent, les RCGs simples sont légerement
sensibles au contexte (Joshi, 1985).

TT-MCTAGs et RCGs

1.3 De TAG £1 RCG

L’ idée générale de la transformation d’une TAG en RCG (positive simple) proposée par (Boul-
lier, 1999b; Boullier, 1999a) est la suivante : la RCG contient des prédicats de deux types,
(a)(X) et (B) (L, R), utilisés respectivement pour encoder les arbres initiaux et auxiliaires. X
couvre la chaine de l’arbre 04 en incluant tous les arbres ajoutés a oz, tandis que L et R couvrent
les parties de la chaine de B (incluant tous les arbres ajoutés) qui se trouvent a gauche et a
droite du noeud pied. Les clauses de la RCG réduisent les arguments de ces prédicats en identi-
ﬁant la partie provenant de l’arbre oz/B lui-méme et les parties provenant des arbres ajoutés par
substitution ou adjonction. Un exemple est donné Fig. 2.

061 SNA 0,2 0,3 ﬂ S
TAG 2 a S F f F /I\
I d I b SEA c
6
RCG équivalente 2 S(X) —> (041)  I <0t2)(X) I (043)  (chaque 11; est la chaine d’un arbre initial)
<0t1)(aF) —> (042)  I <0t3)(F) (la chaine de (11 est a suivie de la chaine de1’arbre substitué au noeud F)
(0z1)(aB1B2F) —> <,6)(B1 , B2) <0t2)(F) I  (B1 , B2) <0t3)(F) (ou ﬂ est adjoint a S dans 04;
la chaine est alors a, suivie de la partie gauche de ﬂ, la partie droite de ﬂ et la chaine substituée a F)
 (B1 b, CB2) —>  (B1 , B2) (ﬂ peut étre adjoint a sa racine ; alors la partie gauche est la partie gauche du ﬂ adjoint

suivie de b; la partie droite est c suivie par la partie droite du ﬂ adjoint)
(042) (d) —> 6 (043) (6) —> 6  (b, C) —> 6 (les chaines de 042, «mg et ﬂ sont d, e et la paire b (gauche) et c (droite) resp.)

FIG. 2 — Une TAG et la RCG équivalente.

2 TT-MCTAG

Pour représenter un ensemble de phenomenes linguistiques, une extension des grammaires
d’arbres adjoints a été proposée, a savoir les TAGs a composantes multiples (MCTAG, (Weir,
1988)). Leur motivation réside dans le besoin de répartir la contribution d’un seul élément lexi-
cal (par exemple un verbe et ses arguments) sur plusieurs arbres élémentaires. Une MCTAG
est donc composée d’ensembles d’arbres élémentaires. Si l’un de ces ensembles est utilisé lors
d’une dérivation, chacun de ses éléments doit étre utilisé.

Déﬁnition 8. Une MCTAG est un tuple G = (I, A, N, T, A) tel que GTAG := (I, A, N, T) est
une TAG, et A est une partition de I U A.

Le type de MCTAG auquel nous sommes intéressé est Tree-Tuple MCTAG with Shared Nodes
(TT-MCTAG, (Lichte, 2007)). Les TT-MCTAGs ont été introduites aﬁn d’analyser des pheno-
menes d’ordre de mots libre dans des langues comme l’allemand. Un exemple est (1) o1‘1l’argu-
ment es de reparieren précede l’argument der Mechaniker de verspricht et n’avoisine donc pas
le prédicat dont il dépend.

(1)  dass es der Mechaniker zu reparieren verspricht
 que 1e 1e mécanicien réparer promet
‘... que le mécanicien promet de le réparer’

Dans une TT-MCTAG, les ensembles élémentaires contiennent (1) un arbre lexicalisé 7, l’unique
arbre téte, et (2) plusieurs arbres auxiliaires, les arbres arguments. Une liste composée d’une

Laura Kallmeyer, Yannick Parmentier

téte et d’arguments s’appel1e un tuple d’arbres. Lors de la dérivation, les arguments doivent soit
s’adjoindre directement a leur téte, soit étre lies par une chaine d’adjonctions a des racines, a
un arbre adj oint a leur tete. Autrement dit, dans 1’arbre de dérivation TAG correpondant, la téte
doit dominer ses arguments de telle maniere que les adresses des noeuds sur le chemin, sauf la
premiere, doivent étre e (i.e. 1e noeud racine). Cela traduit la notion d’adjonction avec partage
de noeuds de (Kallmeyer, 2005).

Déﬁnition 9. I. Une MCTAG G = (I, A, N, T, A) est une TT-MCTAG ssi chaque I‘ E A
a la forme {*y, B1, . . ., Bn} ou 7 (la téte) a au moins une feuille avec une etiquette termi-
nale, et B1, . . . , B,, sont des arbres auxiliaires, les arguments. Nous ecrivons un tel ensemble
(7, {B1, . . . , B,,}). 2. Un arbre de derivation D dans (I, A, N, T) est admis comme arbre de
derivation TAG dans G ssi

(MC) ( “multicomponent condition”) Il existe k ( k 2 1) instances P1, . . . , P], de tuples elemen-
taires, diﬁerentes les unes des autres, tel que U111 I‘, est l’ensemble d’etiquettes dans D.

(SN -TTL) ( “tree-tuple locality with shared nodes”) pour tous les naeuds n0, n1, . . . , nm

(m > 1) dans D avec l ’etiquette du meme tuple, tel que l ’etiquette de no est la tete .' pour chaque
1 g 2' g m .' ou bien (n0,n,-) E 73134 ou bien il existe des n,-,1, . . .,n,-,1, etiquettes d’arbres
auxiliaires telles que n,- = 77/-,;,];;, (n0,n,-,1) E 7313 et pour 1 g j 3 k — 1 .' (n,-,3-,n,-,3-+1) E 7313
avec 6 comme etiquette d’arc.

Sur la Fig. 3, 1’arbre auxiliaire NPn,,m est adjoint directement a verspricht (sa téte) tandis que
1’arbre NPW est adjoint a la racine d’un arbre qui est adjoint a la racine d’un arbre qui est
adj oint a reparieren.

arbre de dérivation 2

  reparieren
,1’ , , ' 1- "’  , ' h
I VP* Verspricht  NPm,m  ’ der Mech. Verspnc t
- .' A\__/_,-—” 6
___,,..v|p   ,.Npr,w {} 1 
Z11 Tepariefen , Nliacc VP* ” x  CS , Mechaniker NPWC

CS
FIG. 3 — Derivation en TT-MCTAG pour (1)

Le probleme de la reconnaissance pour TT-MCTAG est NP-difﬁcile (S¢gaard et al., 2007).
Nous introduisons ici une contrainte supplémentaire pour les TT-MCTAGs, fondée sur une idee
de (S¢gaard et al. , 2007) : les TT-MCTAGs sont de rang ls si, a chaque moment de la dérivation,
1e nombre d’arguments qui dependent de tétes précédemment utilisées dans la dérivation et qui
donc attendent leur adjonction, est limité a k.5

Déﬁnition 10. Une T1"-M CTAG G = (I, A, N, T, A) est de rang k (appelee aussi lc-TT-MCTAG)
ssi pour chaque arbre de derivation TAG D admis dans G .'

(TT-ls) Il n’existe pas de naeuds n, ho, . . . , hk, a0, . . . , ak dans D tels que l ’etiquette de a,- refere
a un argument de l ’etiquette de hi et (h,-, n), (n, a,-) 6 PE pour 0 g i g k.

4730 est la relation de parente, i.e., (1:,y) 6 PD ssi y est noeud ﬁls de :17 dans D.

5Une idee similaire est utilisee dans V—TAG, (Rainbow, 1994), 01), lors de l’analyse, on doit connaitre l’en—
semble des liens de dominance qui restent encore a satisfaire. En limitant cet ensemble, on obtient une analyse
polynomiale.

TT-MCTAGs et RCGs

3 De k:-TT-MCTAG £1 RCG

Nous construisons une RCG simple équivalente a une is-TT-MCTAG de maniere similaire a la
conversion en RCG pour TAG. Nous considérons des prédicats (7) référant aux contributions
des arbres élémentaires (et non des ensembles) utilisés dans une analyse. Rappelons que chaque
TT-MCTAG est une TAG contrainte, ainsi une dérivation TT-MCTAG est une dérivation pour
la TAG sous-jacente. En conséquence, nous pouvons construire une RCG pour la TAG sous-
jacente, tout en enrichissant les prédicats de facon a conserver l’information « doit étre adj oint »
pour les arbres arguments, information contraignant les clauses instantiables dans la dérivation
RCG. Dans notre cas, la production d’un prédicat (7) contient non seulement la production
de 7 et de ses arguments, mais également celle des arguments des prédicats précédemment
instantiés dans la dérivation, et étant adjoints par la suite6. Notre conversion mene a une RCG
d’arité 2, et dont les noms de prédicats sont complexes. Aﬁn de maintenir le nombre de noms
de prédicats nécessaires ﬁnis, la limite k est cruciale. Un prédicat (7) doit encoder l’ensemble
des arbres arguments dépendant d’arbres tétes précédemment consommés dans la dérivation.
Cette ensemble est appelé liste des arguments en attente (List of Pending Arguments, LPA). Ces
arbres doivent soit étre adjoints a la racine de 7 ou étre passé a la LPA des arbres adjoints.
Aﬁn de réduire le nombre de clauses, nous distingons, comme le propose (Boullier, 1999b), les
clauses d’arbres (prédicats (7...)), des clauses dites de « branchement » (prédicats (adj . .  and
(sub . . .)). Nous avons ainsi trois types de prédicats :

1. (7, LPA). Ces prédicats ont une arité 2 si 7 est un arbre auxiliare (contributions gauche et
droite du noeud pied), une arité 1 s’il s’agit d’un arbre initial. Les clauses (7, LPA) distribuent
les variables référant aux productions des arbres substitués ou adjoints a 7 via une partie droite
composée de prédicats adj et sub. La LPA est passée au prédicat adj du noeud racine, et les
arguments de 7 distribués a l’ensemble des prédicats d’adjonction.

2. (adj, 7, dot, LPA) est un prédicat de branchement d’arité 2. Ici, la LPA contient a) la liste
des arguments des tétes précédemment consommées si dot = e (i. e. noeud racine), et b) cer-
tains des arguments de 7 (toutes les distributions des arguments sur les noeuds d’adjonction
ont été calculées, en tenant compte des contraintes d’étiquette du noeud dot). Les clauses
(adj, 7, dot, LPA) adjoignent un arbre 7’ sur le noeud dot de 7. Si 7’ était dans la LPA, le
prédicat d’arbre appelé recoit LPA \ {7’}, dans le cas contraire, 7’ est une téte, et la LPA
reste inchangée.

3. (sub, 7, dot) est une clause de branchement d’arité 1, représentant les arbres pouvant étre
substitués au noeud dot de 7.

Plus précisément, la conversion se passe comme suit : comme dans (Boullier, 1999b), nous de-
ﬁnissons une chaine de décoration av pour chaque arbre élémentaire 7. Les noeuds intemes qui
ne sont pas étiquetés NA recoivent deux variables L et R représentant les productions provenant
d’une adjonction au noeud en question, les noeuds feuilles une variable X représentant la pro-
duction provenant d’une substitution. Dans un parcours de type depth-ﬁrst de 7, les variables
sont collectées (les noeuds pieds apportant un caractere de séparation « , »), pour créer le(s)
argument(s) du prédicat 

1. Nous ajoutons un prédicat de départ S et les clauses S (X ) —> (oz, (Z))(X) pour l’ensemble des
arbres initiaux oz.

5Notons qu’une alternative :21 ces prédicats enrichis serait d’augmenter l’arité des prédicats pour contenir les
contributions des arguments restant a adj oindre. La conversion en RCG devient alors bien plus complexe.

Laura Kallmeyer, Yannick Parmentier

0511 VPOA 0511.1 NPINA 0411.2 NP2NA
< J. 11> < 1. 11> < 1. 11>

 1yP\  1y?\ >
V1 VP}‘vA NP1 VP}‘vA V2 VP}‘vA NP2 VP}‘vA

FIG. 4 — TT—MCTAG

2. Pour chaque 7 E I U A, soient L1,, R1, les symboles gauche et droite dans 0, pour le noeud
d’adresse p, s’il s’agit d’un noeud d’adjonction, et X1, s’il s’agit d’un noeud de substitution.
Soient p1,. . . ,p;, les noeuds d’adjonction potentiels, p;,+1, . . . ,p1 les noeuds de substitution
dans 7. La RCG produite contient alors toutes les clauses :

(7, LPA) (07) —> (adj, 7,p1, LPAp1)(Lp1, Rm) . . . (adj, 7,pk, LPApk)(Lpk, Rpk)

(sub, 7,p,,+1)(Xpk+1) . . . (sub, 7,p1)(Xp,) telles que :
— si LPA 7% (Z), alors 6 6 {p1, . . . ,p1,} et LPA Q LPA€,

— U110 LPAM = LPA U I‘(7) o1‘1 I‘(7) est soit l’ensemble des arguments de 7 (si 7 est un
arbre téte), soit (Z) si 7 est lui-meme un argument.

3. Pour tous les prédicats (adj , 7, dot, LPA), la RCG contient les clauses (adj, 7, dot, LPA) (L, R) —>
(7’ , LPA’) (L, R) telles que 7’ peut étre adjoint au noeud dot de 7 et :
— soit 7’ E LPA et LPA’ = LPA \ {7’},
— soit 7’ ¢ LPA, 7’ est un arbre téte, et LPA’ = LPA.

4. Pour tous les prédicats (adj , 7, dot, (2)) ou le noeud dot de 7 n’est pas un noeud étiqueté OA, la
RCG contient une clause (adj, 7, dot, (Z))(6, 6) —> 6.

5. Pour tous les prédicats (sub, 7, dot) et tous les 7’ qui peuvent étre substitués au noeud dot de
7, la RCG contient la clause (sub, 7, d0t)(X) —> (7’ , (Z))(X

Prenons la TT—MCTAG de la Fig. 4. Pour celle-la, on obtient (entre autres) les clauses RCG

— (011,, (Z))(L 110 R) —> (adj, 041,, 6, (2)) (L, R) (une seule adjonction sur la racine d’adresse 6)

— (adj, 041,, 6, 0)(L, R) —> (BM, (0) (L, R) | (BM, (2)) (L, R) (BM ou BM peuvent étre adjoints a
6 dans 011,, LPA (ici vide) est transmise)

— (BM, (0) (L 111, R) —> (adj, BM, 6, {BM})(L, R) (dans BM, il y a un unique noeud d’adjonc-
tion d’adresse 6 ; l’argument est passé a la nouvelle LPA)

- (adj, B111: 6, {ﬂn1}>(La R) —> <ﬂn170>(L9R) I <ﬂu1,{ﬂm})(L1R) I (@121 {ﬁm})(L, R)
(soit BM est adjoit et retiré de la LPA ou bien un autre arbre (BM ou BM) est adjoint)

— (BM, {BM})(L 111, R) —> (adj, BM, 6, {BM, BM})(L, R) (ici encore, il y a un seul noeud
d’adjonction dans BM ; l’argument BM est ajouté a la LPA)

— (BM, (Z))(L X, R) —> (adj, BM, 6, 0)(L, R) (sub, BM, 1,  (adjonction a la racine et
substitution au noeud 1 dans BM)

— (adj, BM, 6, (Z))(6, 6) —> 6 (l’adjonction a la racine de BM n’est pas obligatoire tant que la
LPA est vide)

— (sub, BM, 1, )(X) —> (am, (2)) (X) (substitution de 04M au noeud d’adresse 1)

— (ozM, (Z))(n1) —> 6 (aucune adjonction ou substitution dans 04M)

La dérivation RCG pour la chaine d’entrée n1n2n1112111111110 procede comme suit’ :

S(n1 n2 n1 112 111 111 110) => (011,, (2)) (n1 n2 121 112 111 111 110)

7Nous remplagons les intervalles par les sous—chaines correspondantes pour rendre l’exemple plus lisible.

TT-MCTAGs et RCGs

adj,3112,6,{3111} (n1,6) (0z112,(Z))(n2) (subst.deo111,)
adj} 51121 61 {3111}

=*> (adj, B111, 6,  (6, 6) (05111,  (T11) =*> 6 (subst. de 04111, 12.1 consommé)

=> (adj, 041,, 6, (2)) (n1 n2 n1 112 111 111,6) (adjonction au noeud e, 1111 est consommé)
=> (31,1, (1)) (n1 n2 n1 112 111 111,6) (ﬁ111 estadjoint)
=> (adj, 31,1, 6, {3111})(n1 n2 n1 112 111,6) (adj.aunoeud6,111 estconsommé, 3111 estplacé dans 1a LPA)
=> (3111, {3111})(n1 n2 111 112 111, 6) (1111 estadjoino
=> (adj, 31,1, 6, {3111, 3111})(n1 n2 n1 112, 6) (adj.aunoeud6,111 estconsommé, 3111 est placé dans 1a LPA)
=> (B1121 {B1111 3111})(n1 n2 n1 112, 6) (1112 estadjoino
=> (adj, 31,2, 6, {3112, 3111, 3111  n2 n1, 6) (adj. au noeud e, 12 est consommé, 3112 est placé dans 1a LPA)
=> (3111, {3112, 3111})(n1 n2 n1, 6) (5111 issudelaLPAestadjoint)
=> (adj, 3111, 6, {3112, 3111})(n1 n2, 6) (sub, 3111, 1, (adj. au noeud 6,subst. au noeud 1)
=> (adj, 3111, 6, «[3112, 3111})(n1 n2, 6) (04111, (Z))(n1) (subst.deoz111)
=> (adj, 3111, 6, {3112, 3111})(n1 n2, 6) 6 => (3112, {3111})(n1 n2, 6) (111 consommé, 3112 adjoint)
=> (adj, 3112, 6, {3111})(n1, 6) (sub, 3112, 1, (adj. au noeud 6,subst au noeud 1)
=> (

=> (

)
)

(711, 6) 6 => (3111,  (711, 6) (12.2 est consommé, 3111 adjoint)

Cette exemple nécessite une LPA de capacité maximale 3, i. e. une 3-TT-MCTAG. Notons
qu’avec cette construction, le groupement des arbres en tuples est perdu. Ainsi, dans notre
exemple, nous ne savons plus quel arbre n1 provient de quel ensemble. Cependant, en pratique,
nous créons une RCG pour une sous-grammaire TT-MCTAG sélectionnée a partir de la chaine
d’entrée. Si plusieurs occurrences d’un tuple donné sont sélectionnées, celles-ci se voient affec-
tées un identiﬁant unique.

Avec cette construction, on peut démontrer le théoreme suivant (voir (Kallmeyer & Parmentier,
2008)). Come corollaire, les I1-TT-MCTAGs sont légerement sensibles au contexte.

Théoréme 1. Pour chaque I1-T1"-MCTAG G, il existe une RCG G’ simple telle que
L(G) = L(G’)8.

Conclusion

Cet article a Inis en relation deux formalismes grammaticaux, a savoir les grammaires TT-
MCTAG et grammaires RCG. TT-MCTAG est un formalisme de réécriture d’arbres qui permet
de modéliser des phénomenes d’ordre des mots libre (existant par exemple en allemand). Les
RCG, quant a elles, sont connues pour leur propriétés formelles avantageuses : les RCG sont
analysables en un temps polynomial, et les RCG simples sont légerement sensibles au contexte.
De plus, des algorithmes d’analyse pour RCGs simples sont connus.

8Nous suspectons que l’inVerse ne soit pas toujours Vrai. Autrement dit, nous suspectons que les langages k—TT—
MCTAG soient strictement contenus dans l’ensemble des langages RCG simples. Un exemple de langage qui n’est
probablement pas dans k—TT—MCTAG est le langage de double copie {www | 111 E {a, b}*}. Si les trois copies d’un
terminal appartiennent a un meme tuple, deux d’entre elles doivent etre adjointes par partage de noeud, comment
contraindre alors toutes les dépendances pour n’aVoir que celles attendues ?

Laura Kallmeyer, Yannick Parmentier

Nous avons montré comment convertir une TT-MCTAG restreinte (appelée lc-TT-MCTAG) en
une RCG simple équivalente. Le résultat formel de cette conversion est que la classe des lan-
gages de chaines générés par une lc-TT-MCTAG est contenue dans la classe des langages géné-
rés par les RCGs simples. En particulier, lc-TT-MCTAG est légerement sensible au contexte.

Le résultat pratique de cette conversion réside dans l’implantation d’un analyseur syntaxique
pour TT-MCTAG utilisant un analyseur RCG comme noyau. Plus précisément, la TT-MCTAG
est d’abord convertie en une RCG équivalente, utilisée alors pour l’analyse. Le résultat de l’ana-
lyse RCG est alors converti en analyse TT-MCTAG par interprétation des noms de prédicats
des clauses instanciées. L’ analyseur en question est utilisé pour développer une grammaire TT-
MCTAG de l’allemand, et est disponible librement sous licence GPL9.

Références

BOULLIER P. (1998). A Proposal for a Natural Language Processing Syntactic Backbone.
Rapport interne 3342, INRIA.

BOULLIER P. (1999a). On TAG and Multicomponent TAG Parsing. Rapport interne 3668,
Institut National de Recherche en Informatique et en Automatique (INRIA).

BOULLIER P. (1999b). On TAG Parsing. In TALN 99, 65 conference annuelle sur le Traitement
Automatique des Langues Naturelles, p. 75-84, Cargese, Corse.

BOULLIER P. (2000). Range Concatenation Grammars. In Proceedings of the Sixth Interna-
tional Workshop on Parsing Technologies (IWPT2000), p. 53-64, Trento, Italy.

J OSHI A. K. (1985). Tree adjoining grammars : How much contextsensitivity is required ro
provide reasonable structural descriptions ? In D. DOWTY, L. KARTTUNEN & A. ZWICKY,
Eds., Natural Language Parsing, p. 206-250. Cambridge University Press.

JOSHI A. K. & SCHABES Y. (1997). Tree-Adjoning Grammars. In G. ROZENBERG & A.
SALOMAA, Eds., Handbook of Formal Languages, p. 69-123. Berlin : Springer.

KALLMEYER L. (2005). Tree-local multicomponent tree adjoining grammars with shared
nodes. Computational Linguistics, 31(2), 187-225.

KALLMEYER L. & PARMENTIER Y. (2008). On the relation between Multicomponent Tree
Adjoining Grammars with Tree Tuples (TT-MCTAG) and Range Concatenation Grammars
(RCG). In Proceedings of the 2nd International Conference on Language and Automata
Theory and Applications LATA, Tarragona, Spain.

LICHTE T. (2007). An MCTAG with Tuples for Coherent Constructions in German. In
Proceedings of the 12th Conference on Formal Grammar 2007, Dublin, Ireland.

RAMBOW O. (1994). Formal and Computational Aspects of Natural Language Syntax. PhD
thesis, University of Pennsylvania.

S¢GAARD A., LICHTE T. & MAIER W. (2007). The complexity of linguistically motivated
extensions of tree-adjoining grammar. In Recent Advances in Natural Language Processing
2007, Borovets, Bulgaria.

WEIR D. J . (1988). Characterizing mildly context-sensitive grammar formalisms. PhD thesis,
University of Pennsylvania.

9Voir http : //www . sfb4 4 1 . uni—tuebingen . de/emmy/tulipa

