<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Grammaires d&#8217;erreur &#8211; correction grammaticale avec analyse profonde et proposition de corrections minimales</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2009 &#8211; Session posters, Senlis, 24&#8211;26 juin 2009
</p>
<p>Grammaires d&#8217;erreur &#8211; correction grammaticale avec analyse
profonde et proposition de corrections minimales
</p>
<p>Lionel Cl&#233;ment1 Kim Gerdes2 Renaud Marlet3
</p>
<p>[1] Universit&#233; Bordeaux 1, LaBRI [2] ILPGA, LPP, Sorbonne Nouvelle [3] INRIA, LaBRI
</p>
<p>R&#233;sum&#233;. Nous pr&#233;sentons un syst&#232;me de correction grammatical ouvert, bas&#233; sur des ana-
lyses syntaxiques profondes. La sp&#233;cification grammaticale est une grammaire hors-contexte
&#233;quip&#233;e de structures de traits plates. Apr&#232;s une analyse en for&#234;t partag&#233;e o&#249; les contraintes
d&#8217;accord de traits sont rel&#226;ch&#233;es, la d&#233;tection d&#8217;erreur minimise globalement les corrections &#224;
effectuer et des phrases alternatives correctes sont automatiquement propos&#233;es.
</p>
<p>Abstract. We present an open system for grammar checking, based on deep parsing. The
grammatical specification is a contex-free grammar with flat feature structures. After a shared-
forest analysis where feature agreement constraints are relaxed, error detection globally mini-
mizes the number of fixes and alternate correct sentences are automatically proposed.
</p>
<p>Mots-cl&#233;s : Correcteur grammatical, analyse syntaxique, for&#234;t partag&#233;e.
Keywords : Grammar checker, parsing, shared forest.
</p>
<p>1 Introduction
La correction grammaticale est une des technologies du TAL les plus utilis&#233;es du grand public.
Pourtant, elle a suscit&#233; comparativement peu de recherches, au moins en nombre de publica-
tions. Il y a sans doute plusieurs raisons &#224; cela.
</p>
<p>Tout d&#8217;abord, d&#8217;un point de vue pratique, les syst&#232;mes semblent relativement d&#233;pendants de
la langue &#224; corriger. En outre, une grande partie du travail de d&#233;finition d&#8217;un correcteur gram-
matical consiste en un recueil patient d&#8217;erreurs idiosyncrasiques, qui peuvent d&#233;pendre de la
langue maternelle du locuteur et de son niveau de connaissance. Cette t&#226;che est difficilement
automatisable faute de larges corpus d&#8217;erreurs disponibles. Enfin, l&#8217;utilit&#233; d&#8217;un tel syst&#232;me re-
pose beaucoup sur son int&#233;gration dans un traitement de texte, et ce n&#8217;est que depuis la mont&#233;e
d&#8217;OpenOffice qu&#8217;un tel travail peut facilement &#234;tre mis &#224; la disposition du public. Il est d&#233;sor-
mais imaginable qu&#8217;une communaut&#233; se cr&#233;e autour de la recherche en correction grammaticale,
qui partage ouvertement ses ressources et r&#233;sultats, comme dans d&#8217;autres domaines du TAL.
</p>
<p>Il existe peut-&#234;tre aussi des raisons plus profondes. La linguistique a pris du temps pour se d&#233;fi-
nir en tant que science de la Langue r&#233;ellement parl&#233;e, et un retour du d&#233;bat sur la normativit&#233;
n&#8217;est pas &#224; l&#8217;ordre du jour, m&#234;me si certaines recherches (en sociolinguistique, en psycholin-
guistique, en recherche sur le FLE ou encore en lexicologie) sur les d&#233;rivations de la norme
peuvent avoir un int&#233;r&#234;t indirect pour le d&#233;veloppement d&#8217;un correcteur grammatical.
</p>
<p>Cet article plaide pour une analyse profonde et compl&#232;te de la phrase, par opposition aux gram-
maires superficielles et locales fr&#233;quemment utilis&#233;es, et pour une minimisation globale des er-
reurs &#224; corriger. Sur la base d&#8217;un analyseur de grammaire de r&#233;&#233;criture am&#233;nag&#233;, nous montrons
comment d&#233;terminer les erreurs et faire des propositions concr&#232;tes de meilleures corrections.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Lionel Cl&#233;ment, Kim Gerdes, Renaud Marlet
</p>
<p>2 Probl&#232;me g&#233;n&#233;ral de la correction grammaticale
Un correcteur grammatical est un outil qui a deux fonctionnalit&#233;s principales :
&#8211; Il signale les phrases ou fragments incorrects (probablement erron&#233;s) dans un document.
&#8211; Il propose des corrections, avec &#233;ventuellement une explication &#171; linguistique &#187; de l&#8217;erreur.
En pratique, on demande des propri&#233;t&#233;s additionnelles &#224; un correcteur grammatical :
&#8211; qu&#8217;il soit rapide : la v&#233;rification doit s&#8217;effectuer &#171; en temps r&#233;el &#187; au cours de la frappe ;
&#8211; qu&#8217;il minimise le bruit : s&#8217;il y a trop de fausses altertes, les utilisateurs le d&#233;brancheront ;
&#8211; qu&#8217;il minimise le silence : il doit laisser passer peu d&#8217;erreurs.
Ce ne sont bien s&#251;r l&#224; que les fonctionnalit&#233;s et exigences principales.
</p>
<p>2.1 Grammaire positive vs grammaire n&#233;gative
</p>
<p>Il y a deux moyens pour d&#233;cider si une phrase est correcte : utiliser une grammaire positive, qui
d&#233;crit toutes les phrases correctes, ou une grammaire n&#233;gative, qui d&#233;crit les phrases incorrectes.
Du fait des r&#233;gularit&#233;s de la langue, il est beaucoup plus facile d&#8217;&#233;crire une grammaire positive.
Une grammaire n&#233;gative n&#8217;est cependant pas inutile. Les deux sont en fait compl&#233;mentaires et
permettent d&#8217;approcher les phrases correctes par un double encadrement. La grammaire positive
peut notamment v&#233;rifier la structure et la coh&#233;rence g&#233;n&#233;rale de la phrase, et la grammaire n&#233;ga-
tive se concentrer sur les erreurs courantes. Cette s&#233;paration des concepts est aussi motiv&#233;e sur
le plan de l&#8217;ing&#233;nierie linguistique : la grammaire positive est propre &#224; la langue, ind&#233;pendante
de l&#8217;&#233;nonciateur, alors que la grammaire n&#233;gative peut &#234;tre choisie en fonction de l&#8217;utilisateur,
par exemple pour signaler des faux amis grammaticaux propres &#224; une autre langue. Contrai-
rement &#224; d&#8217;autres, nous n&#8217;incluons pas dans la grammaire n&#233;gative la v&#233;rification des accords
(trait&#233;e par la grammaire positive), mais des erreurs plus stylistiques, comme les barbarismes
(par ex. l&#8217;anglicisme &#171; faire une d&#233;cision &#187;) ou pl&#233;onasmes (par ex. &#171; danger potentiel &#187;).
</p>
<p>Un locuteur natif commet moins d&#8217;erreurs qu&#8217;un apprenant, et elles ont une r&#233;partition diff&#233;-
rente. On peut penser qu&#8217;employer une forme marqu&#233;e (par ex., en fran&#231;ais, une marque de
f&#233;minin) est plus significatif pour un locuteur natif que pour un apprenant, que la corriger est
donc moins plausible, et ce d&#8217;autant plus que la marque est particuli&#232;rement visible ou audible
(par ex. &#171; actrice / acteur &#187;, par opposition &#224; &#171; jolie / joli &#187;). Des gradations propres &#224; l&#8217;utilisateur
sont donc envisageables. En outre, les possibilit&#233;s d&#8217;&#233;dition locale de la modalit&#233; textuelle, y
compris le &#171; copier / coller &#187;, peuvent conduire du fait de fautes d&#8217;inattention &#224; des incoh&#233;rences
globales. Aucun type d&#8217;erreur ne peut donc &#234;tre exclu, quel que soit l&#8217;utilisateur.
</p>
<p>2.2 Grammaire de surface vs grammaire profonde
</p>
<p>Une panoplie d&#8217;outils sont disponibles pour analyser une phrase afin de pr&#233;parer un jugement
de correction grammaticale : &#233;tiqueteur de parties du discours, chunker, expressions r&#233;guli&#232;res,
grammaires d&#8217;unification, etc. Plus une analyse est superficielle, plus elle est propice au bruit et
au silence. Les grammaires de surface restent de ce fait cantonn&#233;es aux grammaires n&#233;gatives,
o&#249; la localit&#233; des r&#232;gles minimise cet effet, sans l&#8217;annuler. Des attributs pauvres (par ex. de
simples &#233;tiquettes) augmentent aussi le nombre de r&#232;gles &#224; &#233;crire (Souque, 2008). Par ailleurs,
l&#8217;&#233;clatement en r&#232;gles ind&#233;pendantes est source de signalements multiples pour un m&#234;me mot.
</p>
<p>La plupart des correcteurs grammaticaux (par exemple Antidote, Cordial, Microsoft Office et
Prolexis pour le fran&#231;ais) sont des produits commerciaux dont le fonctionnement est opaque. Le
type de donn&#233;es manipul&#233;es est parfois connu, mais pas les calculs faits pour corriger. Langua-
geTool (Naber, 2007) est actuellement un des rares correcteurs grammaticaux libres et ouverts ;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Correction grammaticale avec analyse profonde et proposition de corrections minimales
</p>
<p>il est notamment interfac&#233; &#224; OpenOffice. L&#8217;infrastructure de correction grammaticale est bas&#233;e
sur un &#233;tiqueteur de parties du discours et des r&#232;gles locales construites &#224; l&#8217;aide d&#8217;expressions
r&#233;guli&#232;res. Plus de 1600 r&#232;gles sont disponibles pour le fran&#231;ais. Consid&#233;rons par exemple :
</p>
<p>(1) Le chien de mes voisins mordent.
(2) Les voitures qu&#8217;il a font du bruit.
</p>
<p>Avec des r&#232;gles locales, LanguageTools, &#224; tort, reste silencieux sur (1) et signale deux erreurs
dans (2). Microsoft Office (Fontenelle, 2006), qui semble faire des analyses plus profondes,
signale bien l&#8217;erreur dans (1), mais demande &#224; tort dans (2) &#224; remplacer &#171; font &#187; par &#171; fait &#187;.
</p>
<p>2.3 Nos objectifs
</p>
<p>Pour r&#233;pondre aux questions qui pr&#233;c&#232;dent, nous nous donnons les objectifs suivants.
&#8211; Nous voulons un syst&#232;me ouvert, ind&#233;pendant de la langue, o&#249; l&#8217;on peut sp&#233;cifier facilement
lexiques et grammaires, et les compl&#233;ter incr&#233;mentalement par simple ajout de r&#232;gles.
</p>
<p>&#8211; Nous voulons une analyse profonde, capable de mod&#233;liser des ph&#233;nom&#232;nes complexes comme
des d&#233;pendances &#224; longue distance, inaccessibles &#224; de simples expressions r&#233;guli&#232;res.
</p>
<p>&#8211; Nous voulons pouvoir mod&#233;liser une grammaire positive et une grammaire n&#233;gative, cette
derni&#232;re s&#8217;appuyant sur les analyses profondes de l&#8217;analyseur de grammaire positive.
</p>
<p>&#8211; Nous voulons automatiser la localisation des erreurs, leur hi&#233;rarchisation, et pour certaines les
propositions de correction : le travail principal du linguiste doit &#234;tre de mod&#233;liser la langue.
</p>
<p>&#8211; Nous voulons un correcteur rapide, capable d&#8217;analyser un texte au cours de la frappe.
&#8211; Nous voulons un syst&#232;me librement disponible, facilement int&#233;grable dans un &#233;diteur.
Un correcteur performant pour une langue donn&#233;e n&#233;cessite une &#233;tude de domaine pouss&#233;e et
la sp&#233;cification d&#8217;une large quantit&#233; de r&#232;gles (Fontenelle, 2006). Tel n&#8217;est pas notre propos ici.
</p>
<p>Ce que nous pr&#233;sentons dans cet article sont les principes et le moteur de notre syst&#232;me d&#8217;ana-
lyse de grammaire positive, ind&#233;pendamment de la langue. Le fran&#231;ais sert d&#8217;illustration. En
bref, le processus de correction est le suivant. Une phrase est d&#8217;abord segment&#233;e en un graphe
acyclique orient&#233; qui repr&#233;sente toutes les s&#233;quences possibles des formes lemmatis&#233;es des mots
simples et compos&#233;s, auxquelles s&#8217;ajoutent des lemmes suppl&#233;mentaires (par ex. homophones)
repr&#233;sentant des substitutions plausibles1. L&#8217;analyseur syntaxique construit ensuite une for&#234;t
partag&#233;e d&#8217;analyses en ignorant les ph&#233;nom&#232;nes d&#8217;accord. Puis un parcours montant de la for&#234;t
attribue aux analyses alternatives des co&#251;ts minimums de modification de traits et d&#8217;utilisation
de lemmes substitu&#233;s, afin de satisfaire les accords. Une phrase qui a une analyse de co&#251;t mi-
nimum nul est correcte ; sinon, selon le co&#251;t de correction &#233;tabli au niveau global, un parcours
descendant d&#233;termine les flexions et substitutions qui reconstruisent une phrase correcte.
</p>
<p>3 Correction grammaticale
Un correcteur grammatical localise des erreurs et propose des corrections vraisemblables, sug-
g&#233;rant d&#8217;abord les plus plausibles. Le probl&#232;me est donc de trouver des phrases correctes au
voisinage d&#8217;une phrase incorrecte et de les classer par ordre de proximit&#233;.
</p>
<p>3.1 Le principe du rel&#226;chement de contraintes
</p>
<p>Les notions de voisinage et de proximit&#233; sont subjectives. Les circonscrire et les formaliser
pour une langue demande un travail consid&#233;rable d&#8217;exp&#233;rimentation sur corpus. Nous faisons
</p>
<p>1Le s&#233;quencement en &#171; mots &#187; pour le fran&#231;ais recherche des caract&#232;res s&#233;parateurs. Nous travaillons sur une
m&#233;thode pour traiter de fa&#231;on plus g&#233;n&#233;rale et robuste la composition, l&#8217;agglutination, etc. pour des langues vari&#233;es.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Lionel Cl&#233;ment, Kim Gerdes, Renaud Marlet
</p>
<p>l&#8217;hypoth&#232;se que l&#8217;on peut mod&#233;liser un voisinage avec une grammaire positive dont on rel&#226;che
certaines contraintes afin de construire davantage d&#8217;analyses modulo erreur, et que l&#8217;attribution
d&#8217;un poids aux contraintes insatisfaites renseigne sur la proximit&#233;. La sp&#233;cification du voisinage
est en r&#233;alit&#233; invers&#233;e : on d&#233;crit alors les phrases incorrectes &#224; proximit&#233; des phrases correctes.
</p>
<p>Les grammaires intrins&#232;quement bas&#233;es sur des contraintes, comme les grammaires de pro-
pri&#233;t&#233;s, sont particuli&#232;rement bien adapt&#233;es &#224; cette vision du probl&#232;me (Prost, 2008), mais
elles posent encore des probl&#232;mes de performance et sont moins r&#233;pandues. Le rel&#226;chement
de contraintes a toutefois fait ses preuves pour la robustesse des analyseurs syntaxiques qui
utilisent des syst&#232;mes de traits. Par exemple, (Vogel &amp; Cooper, 1995) appliquent cette id&#233;e &#224;
HPSG, et (Fouvry, 2003) ajoute des pond&#233;rations sur l&#8217;importance des traits. Sur ce principe,
nous avons opt&#233; pour un formalisme connu et &#233;prouv&#233;, qui permet une impl&#233;mentation efficace.
Notre sp&#233;cification grammaticale est une grammaire non contextuelle dont les termes sont &#233;qui-
p&#233;s d&#8217;une structure de traits. Pour un bon compromis efficacit&#233;-expressivit&#233;, nos structures de
trait sont plates et construites sur des ensembles de valeurs finis. En voici un exemple simplifi&#233;.
</p>
<p>gn[nb=N;gen=G;pers=3] -&gt; det[nb=N;gen=G] sadj[nb=N;gen=G;type=ant&#233;]*
</p>
<p>nc[nb=N;gen=G] sadj[nb=N;gen=G;type=post]* gp[]? rel[nb=N;gen=G]? ;
</p>
<p>Nous rel&#226;chons les contraintes d&#8217;accord li&#233;es aux traits. L&#8217;analyse de la structure hors-contexte
reste en revanche rigide. La grammaire peut n&#233;anmoins &#234;tre &#233;crite pour accepter des phrases
incorrectes, par exemple en rendant certains termes optionnels (&#233;valuables par la grammaire
n&#233;gative). Nous conservons la totalit&#233; des ambigu&#239;t&#233;s structurelles d&#8217;analyse : nous construisons
une for&#234;t partag&#233;e sur le squelette hors-contexte de la grammaire (Billot &amp; Lang, 1989). Nous
reposons pour cela sur une variante de l&#8217;algorithme d&#8217;Earley (Earley, 1970) capable de traiter
directement l&#8217;&#233;toile de Kleene et les termes optionnels, de complexit&#233; cubique en la longueur
de la phrase dans le pire cas. Qui plus est, nous consid&#233;rons qu&#8217;un axiome de la grammaire peut
d&#233;buter &#224; chaque mot d&#8217;une phrase. Nous pouvons ainsi construire toutes les analyses partielles
d&#8217;une phrase non couverte par la grammaire et signaler les d&#233;saccords de traits locaux.
</p>
<p>On peut diviser les erreurs grammaticales en erreurs structurelles (pas de structure de consti-
tuants) et erreurs non structurelles (l&#8217;unification &#233;choue) (Bustamante &amp; Le&#243;n, 1996). Pour les
premi&#232;res, on ne peut pas proposer de correction ; on ne peut que signaler la pr&#233;sence d&#8217;une er-
reur. Pour les secondes en revanche, on peut lister des propositions alternatives en jouant sur les
valeurs de traits. Nous &#233;largissons cette notion d&#8217;erreur non structurelle en autorisant des sub-
stitutions lemmatiques plausibles (par ex. des homonophones), qui permettent de proposer des
corrections m&#234;me si la phrase analys&#233;e n&#8217;a pas de structure de constitutants. Certaines erreurs
structurelles, comme l&#8217;ant&#233;position adjectivale, peuvent aussi &#234;tre mod&#233;lis&#233;es avec des traits.
</p>
<p>3.2 Correction minimale
</p>
<p>Uszkoreit, cit&#233; dans (S&#229;gvall Hein, 1998), propose de distinguer 4 niveaux dans la correc-
tion grammaticale : (1) identification de segments possiblement erron&#233;s, (2) identification de
contraintes possiblement viol&#233;es, (3) identification de sources d&#8217;erreur possibles, et (4) construc-
tion et hi&#233;rarchisation d&#8217;alternatives de correction. C&#8217;est sur ce dernier point que nous mettons
l&#8217;accent. Nous mod&#233;lisons la plausibilit&#233; d&#8217;une correction en terme de co&#251;t minimum. Plusieurs
notions de minimalit&#233; sont concevables. L&#8217;exemple suivant illustre la question de la localit&#233;.
</p>
<p>(3) Les cheval blanc sont salissants.
(4) Le cheval blanc est salissant.
(5) Les chevaux blancs sont salissants.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Correction grammaticale avec analyse profonde et proposition de corrections minimales
</p>
<p>Avec une d&#233;cision locale, la meilleure correction de &#171; les cheval blanc &#187; dans (3) est un d&#233;ter-
minant singulier ; puis pour la phrase, 3 mots au singulier et 2 au pluriel font pr&#233;f&#233;rer (4). Mais
en fait, &#224; un niveau global, on recense 5 termes &#224; accorder en nombre ; 3 sont au pluriel, 2 au
singulier. La correction globalement minimale en nombre de modifications est donc (5). Une
d&#233;cision locale est ainsi inexacte, et peut aussi conduire &#224; de mauvais signalements en cascade.
</p>
<p>Deux mod&#232;les de proximit&#233; permettent d&#8217;ordonner les corrections plausibles : l&#8217;un est bas&#233; sur
le nombre de mots &#224; corriger, l&#8217;autre sur le nombre de traits. Bien que souvent en accord, ces
deux mod&#232;les ne sont pas comparables :
</p>
<p>(6) C&#8217;est encore une histoire de cliente arriv&#233;e m&#233;content mais repartis satisfaits.
(7) C&#8217;est encore une histoire de client arriv&#233; m&#233;content mais reparti satisfait.
(8) C&#8217;est encore une histoire de cliente arriv&#233;e m&#233;contente mais repartie satisfaite.
(9) C&#8217;est encore une histoire de clients arriv&#233;s m&#233;contents mais repartis satisfaits.
</p>
<p>Dans (6), le syntagme nominal de &#171; client &#187; est plut&#244;t au masculin, 3 votes contre 2 et plut&#244;t au
singulier, 3 votes contre 2 &#233;galement. Cette minimisation du nombre de traits modifi&#233;s corrige
4 occurrences de traits et 4 mots (7). Mais deux alternatives sont plus &#233;conomiques en nombre
de mots corrig&#233;s : (8) et (9). Elles corrigent 5 occurrences de traits et mais seulement de 3 mots.
Nous optons ici pour la minimisation du nombre de traits &#224; corriger, qui nous semble &#171; cogniti-
vement &#187; plus motiv&#233;e, mais l&#8217;autre choix peut n&#233;anmoins &#234;tre encod&#233; dans notre proposition.
</p>
<p>4 Correction lexicale
Voisinage et proximit&#233; jouent aussi au niveau du mot. Le lexique doit permettre de d&#233;finir
quelles formes peuvent en corriger d&#8217;autres, et &#224; quel co&#251;t. Un premier type de correction cor-
respond &#224; des flexions alternatives d&#8217;un m&#234;me lemme, par ex. &#171; jolie &#187; pour &#171; joli &#187;. Mais tout
trait ne varie pas librement, par ex. rendre &#171; crayon &#187; f&#233;minin a un co&#251;t infini. Un deuxi&#232;me type
de correction correspond &#224; une substitution plausible de lemmes, notamment des homophones :
on / ont, est / ait / ai, &#224; / a, etc. Comme les cat&#233;gories peuvent ici varier, &#224; la diff&#233;rence du cas
pr&#233;c&#233;dent, ces corrections potentielles construisent des analyses alternatives suppl&#233;mentaires.
Cela augmente donc la combinatoire de l&#8217;analyse et il convient d&#8217;en bien mesurer l&#8217;usage.
</p>
<p>La fronti&#232;re entre grammaire positive et grammaire n&#233;gative est ici t&#233;nue car on souhaite inclure
au voisinage des phrases correctes (grammaire positive) un maximum de phrases incorrectes
plausibles. Sans faire appel &#224; une grammaire n&#233;gative, on peut par exemple vouloir corriger un
&#171; que &#187; erron&#233; en &#171; dont &#187;, soit en cr&#233;ant une classe lemmatique pour certains pronoms relatifs,
que l&#8217;on fl&#233;chit avec un trait de cas, soit en les consid&#233;rant explicitement comme substituables
les uns aux autres. On peut faire de m&#234;me pour les pr&#233;positions afin de corriger la rection
verbale. Par ailleurs, le co&#251;t d&#8217;une correction peut d&#233;pendre de l&#8217;utilisateur, du type de lemme,
et de ses formes (cf. &#167;2.1). Le co&#251;t de substitution n&#8217;est donc pas sym&#233;trique, ni fig&#233; dans le
lexique ; une partie doit pouvoir &#234;tre calcul&#233;e dynamiquement. Pour cela, nous d&#233;finissons :
&#8211; un lexique de flexions, qui sp&#233;cifie les lemmes, leur formes et les variations de leurs traits,
&#8211; un lexique de substitutions, qui sp&#233;cifie des substitutions entre formes de lemmes diff&#233;rents,
&#8211; un mod&#232;le de proximit&#233; qui associe des co&#251;ts aux substitutions de traits ou de lemmes.
</p>
<p>Notre lexique de flexions actuel a un format extensionnel :
</p>
<p># Forme Lemme Cat&#233;gorie et traits
</p>
<p>heureux heureux adj[gen=masc; nb=sing|plur]
</p>
<p>portions portion nc[gen=fem!; nb=plur]
</p>
<p>portions porter v[pers=1; nb=plur; mode=ind|subj; tps=imp]</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Lionel Cl&#233;ment, Kim Gerdes, Renaud Marlet
</p>
<p>Si plusieurs lemmes correspondent &#224; une forme, on cr&#233;e autant d&#8217;entr&#233;es. Pour chaque forme,
nous indiquons le lemme correspondant, sa cat&#233;gorie et ses valeurs de traits actuelles. L&#8217;op&#233;ra-
teur &#171; | &#187; permet de sp&#233;cifier un ensemble de valeurs. Par d&#233;faut, toutes les valeurs possibles
d&#8217;un trait sont autoris&#233;es ; la marque &#171; ! &#187; interdit les valeurs autres que celle indiqu&#233;es. Les
traits et valeurs sont pour cela d&#233;clar&#233;s au pr&#233;alable. Peu co&#251;teuse et structurante pour le lin-
guiste, cette d&#233;claration permet aussi de signaler des incoh&#233;rences dans le lexique ou la gram-
maire. Construire un tel lexique (pour une langue peu dot&#233;e) est en grande partie automatisable
(Cl&#233;ment et al., 2004). (De fait, notre lexique pour le fran&#231;ais est d&#233;duit du Lefff.) Quant au
lexique de substitutions, il liste les formes substituables les unes aux autres, par ex., &#171; on|ont &#187;,
&#171; a|&#224; &#187;. Le lexeur introduit syst&#233;matiquement ces formes commes alternatives avant l&#8217;analyse.
(Notre lexique de substitutions du fran&#231;ais provient des homophones de Lexique 3 (New, 2006).)
</p>
<p>Notre intention est d&#8217;offrir des outils pour param&#233;trer facilement un mod&#232;le de co&#251;t, par exemple
une distance de Levenshtein pour pond&#233;rer un co&#251;t par le degr&#233; de marquage des formes. Ac-
tuellement, c&#8217;est un programme ad hoc qui attribue un co&#251;t, selon un sch&#233;ma fixe tr&#232;s simple. &#192;
toute flexion (c.-&#224;-d. assignation d&#8217;une valeur de trait), est associ&#233; le co&#251;t de cette correction :
&#8211; Le co&#251;t de flexion est 1, quel que soit le type de trait, pour toute assignation &#224; une valeur
autre que celles indiqu&#233;es (par ex. 1 pour attribuer fem &#224; &#171; heureux &#187;).
</p>
<p>&#8211; L&#8217;assignation d&#8217;un trait &#224; une valeur interdite a un co&#251;t infini (par ex. fem pour &#171; crayon &#187;).
&#8211; Une substitution a un co&#251;t (arbitraire) de 1. Elle est mod&#233;lis&#233;e par un trait implicite addition-
nel, not&#233; &#171; $ &#187;, et qui ne peut avoir qu&#8217;une valeur : son assignation est donc obligatoire.
</p>
<p>On peut aussi coupler ici le correcteur orthographique au correcteur grammatical en incluant des
substitutions propos&#233;es pour des mots hors lexique. Cela permet de traiter &#224; un m&#234;me niveau
les corrections grammaticales et les flexions erron&#233;es comme &#171; chevals &#187; ou &#171; faisez &#187;. (Une
simplification consiste &#224; laisser l&#8217;utilisateur corriger d&#8217;abord l&#8217;orthographe, puis la grammaire.)
</p>
<p>5 Signalement d&#8217;erreur
Supposons le texte segment&#233; en phrases2. Toute phrase est d&#8217;abord elle-m&#234;me segment&#233;e par un
lexeur qui construit un graphe orient&#233; acyclique (DAG) de lemmes alternatifs (dus aux ambigu&#239;-
t&#233;s lexicales et aux substitutions plausibles), auxquels sont ajout&#233;es des informations morpho-
syntaxiques (notamment les cat&#233;gories flexionnelles).
</p>
<p>L&#8217;analyse syntaxique structurelle de ce DAG construit ensuite un graphe et/ou qui repr&#233;sente
une for&#234;t partag&#233;e d&#8217;arbres d&#8217;analyse (cf. fig. 1). Les traits sont totalement ignor&#233;s &#224; ce stade ;
seule est prise en compte et conserv&#233;e la structure syntagmatique de la phrase (arbres de d&#233;ri-
vation du squelette non contextuel de la grammaire). Le nombre d&#8217;analyses diff&#233;rentes dans le
pire cas est exponentiel en la taille de la phrase. Les diff&#233;rents arbres d&#8217;analyse ne sont toutefois
pas &#233;num&#233;r&#233;s ici. C&#8217;est la for&#234;t partag&#233;e qui les repr&#233;sente qui est construite, en un temps au
plus cubique en la taille de la phrase. Le parseur s&#8217;accomode aussi d&#8217;analyses infinies, comme
il peut s&#8217;en produire (g&#233;n&#233;ralement involontairement) avec des r&#232;gles comme np -&gt; np pp ?.
Il g&#233;n&#232;re dans ce cas des cycles dans la for&#234;t, qui peuvent ais&#233;ment &#234;tre &#233;limin&#233;s.
</p>
<p>Faute de place, nous ne d&#233;taillons pas ici l&#8217;algorithme complet de d&#233;termination des corrections
de co&#251;t global minimum (soumis pour publication) ; nous en pr&#233;sentons juste l&#8217;id&#233;e intuitive,
informellement. Nous n&#8217;explicitons pas non plus l&#8217;ensemble des constructions grammaticales
disponibles ; nous nous concentrons sur la construction principale.
</p>
<p>2Des heuristiques de d&#233;coupage bas&#233;es sur la ponctuation fournissent une segmentation raisonnable. Nous
travaillons n&#233;anmoins sur une technique plus robuste qui exploite la capacit&#233; de notre analyseur &#224; travailler en flux.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Correction grammaticale avec analyse profonde et proposition de corrections minimales
</p>
<p>Phrase
</p>
<p>ET
</p>
<p>GN GV
</p>
<p>ET
</p>
<p>pronom
</p>
<p>je
</p>
<p>OU
</p>
<p>ET ET
</p>
<p>verbeGN
</p>
<p>voisET
</p>
<p>d&#233;terminantN
</p>
<p>unET
</p>
<p>N GP
</p>
<p>ET
</p>
<p>nom
</p>
<p>homme
</p>
<p>ET
</p>
<p>pr&#233;position GN
</p>
<p>avec ET
</p>
<p>d&#233;terminant N
</p>
<p>des ET
</p>
<p>nom
lunettes
</p>
<p>GN
</p>
<p>ET
</p>
<p>FIG. 1 &#8211; graphe et-ou de la for&#234;t partag&#233;e pour &#171; je vois un homme avec des lunettes &#187;
</p>
<p>5.1 Recherche d&#8217;erreur
</p>
<p>La recherche d&#8217;erreur est un parcours de la for&#234;t d&#8217;analyse pour d&#233;terminer les co&#251;ts de correc-
tion minimums des diff&#233;rentes analyses alternatives. &#192; la racine, une for&#234;t qui contient un arbre
de co&#251;t de correction nul est consid&#233;r&#233;e sans erreur &#8212; au risque d&#8217;&#234;tre parfois silencieux du fait
de possibilit&#233;s de rattachement erron&#233;es, et en l&#8217;absence, pour le moment dans notre syst&#232;me,
d&#8217;un jugement de plausibilit&#233; syntaxico-s&#233;mantique des analyses. Sinon, les co&#251;ts de correction
des alternatives permettent d&#8217;ordonner les propositions de correction par ordre de plausibilit&#233;.
</p>
<p>Une correction est repr&#233;sent&#233;e par une assignation de traits, c&#8217;est-&#224;-dire un choix de valeur pour
un ensemble de traits. Par exemple, pour un syntagme nominal : (genre 7&#8594; masc, nombre 7&#8594; pl).
Par ailleurs, un co&#251;t d&#8217;assignation de traits associe &#224; toute valeur possible d&#8217;un trait un co&#251;t qui
repr&#233;sente la plausibilit&#233; de modifier ce trait pour qu&#8217;il prenne la valeur en question dans une
correction &#233;ventuelle (plus le co&#251;t est faible, plus la plausibilit&#233; est grande). Par exemple, pour
un adjectif masculin singulier : (genre 7&#8594; (masc 7&#8594; 0, fem 7&#8594; 1), nombre 7&#8594; (sg 7&#8594; 0, pl 7&#8594; 1)).
Un co&#251;t infini correspond &#224; une affectation de trait impossible, comme d&#8217;imposer le trait f&#233;minin
&#224; nom commun exclusivement masculin (par ex. &#171; crayon &#187;).
</p>
<p>Enfin, effectuer une assignation de traits, sur la base d&#8217;un certain co&#251;t d&#8217;assignation de traits, a
un co&#251;t global qui est la somme des co&#251;ts des valeurs de traits assign&#233;es. Par exemple, effectuer
l&#8217;assignation de traits (genre 7&#8594; masc, nombre 7&#8594; pl) sur la base du co&#251;t d&#8217;assignation de traits
(genre 7&#8594; (masc 7&#8594; 0, fem 7&#8594; 1), nombre 7&#8594; (sg 7&#8594; 0, pl 7&#8594; 1)) a un co&#251;t global de 0 + 1 = 1 :
le co&#251;t de la modification du genre (ici nul) ajout&#233; au co&#251;t de modification du nombre (ici 1).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Lionel Cl&#233;ment, Kim Gerdes, Renaud Marlet
</p>
<p>Pour rechercher et ordonner les corrections, nous examinons les co&#251;ts d&#8217;assignation de traits des
analyses alternatives. L&#8217;absence de monotonie des co&#251;ts minimums de correction et la recherche
d&#8217;un optimum global obligent a priori &#224; examiner toutes les alternatives. Dans le pire cas, elles
peuvent &#234;tre en nombre exponentiel en la longueur de la phrase. Dans cette sous-section, nous
consid&#233;rons que nous les examinons effectivement toutes ; nous verrons &#224; la &#167;5.2 comment r&#233;-
duire et contr&#244;ler cette combinatoire. Dans tous les cas, nous exploitons n&#233;anmoins la structure
de partage syntaxique pour factoriser le calcul des co&#251;ts d&#8217;assignation de traits alternatifs.
</p>
<p>Pour tout n&#339;ud du graphe et/ou de la for&#234;t d&#8217;analyse, on calcule un ensemble de co&#251;ts alter-
natifs d&#8217;assignation de traits qui repr&#233;sentent l&#8217;ensemble des co&#251;ts minimums d&#8217;utilisation de
ce noeud dans une alternative d&#8217;analyse, et pour les diff&#233;rentes affectations de traits. Le calcul
op&#232;re &#171; de bas en haut &#187; (des feuilles vers les racines), de la mani&#232;re suivante3.
</p>
<p>(a) Une feuille de la for&#234;t est un item lexical, qui ne repr&#233;sente qu&#8217;une alternative. Son co&#251;t
d&#8217;assignation de traits est d&#233;fini par le mod&#232;le de co&#251;t pour les corrections lexicales (cf. &#167;4).
</p>
<p>(b) Un n&#339;ud-ou repr&#233;sente un ensemble de sous-arbres alternatifs (dont la t&#234;te est associ&#233;e &#224;
un m&#234;me non-terminal de la grammaire). L&#8217;ensemble des co&#251;ts d&#8217;assignation de traits pour
un n&#339;ud-ou est la r&#233;union de tous les co&#251;ts alternatifs de ses n&#339;uds fils.
</p>
<p>(c) Un noeud-et repr&#233;sente la t&#234;te d&#8217;un sous-arbre. Il correspond &#224; l&#8217;application d&#8217;une r&#232;gle
de grammaire, r&#232;gle de la forme A &#8594; B1B2 . . . Bn, o&#249; chaque &#233;l&#233;ment Bi = bi[. . .] (et de
m&#234;me pour A = a[. . .]) est un non-terminal bi (resp. a) associ&#233; &#224; un ensemble d&#8217;&#233;quations de
traits de la forme &#171; trait = variable &#187;. La t&#234;te du sous-arbre que repr&#233;sente un tel noeud-et est
associ&#233;e au non-terminal a ; ses fils sont des n&#339;uds-ou associ&#233;s aux non-terminaux bi.
L&#8217;id&#233;e intuitive est que le co&#251;t de correction d&#8217;un syntagme, c&#8217;est-&#224;-dire le co&#251;t d&#8217;assignation
de certains traits &#224; des valeurs choisies, est la somme des co&#251;ts de correction de chaque
&#233;l&#233;ment de ce syntagme. En l&#8217;occurrence, le co&#251;t de correction du syntagme associ&#233; &#224; A est
la somme des co&#251;ts de correction desBi. En pratique, il faut tenir compte des points suivants :
</p>
<p>1. &#192; chaque Bi est associ&#233; non pas un unique co&#251;t d&#8217;assignation de traits, mais un en-
semble Ki de tel co&#251;ts, correspondant &#224; des analyses alternatives du n&#339;ud-ou associ&#233;.
L&#8217;ensemble des co&#251;ts d&#8217;assignation de traits du noeud-et est bas&#233; sur l&#8217;ensemble des
combinaisons possibles de choix d&#8217;un n-uplet de co&#251;ts dans K1 &#215; &#183; &#183; &#183; &#215;Kn. (C&#8217;est la
source de l&#8217;explosion combinatoire, que nous montrons comment contr&#244;ler en &#167;5.2.)
</p>
<p>2. Les co&#251;ts d&#8217;assignation de traits &#224; additionner sont ceux pour lesquels un trait appara&#238;t
plusieurs fois avec une m&#234;me variable dans la partie droite de la r&#232;gle, comme par
exemple le trait nb dans la r&#232;gle de la section &#167;3.1, associ&#233; &#224; la variable N. Ce traitement
remplace en quelque sorte l&#8217;op&#233;ration d&#8217;unification d&#8217;une analyse syntaxique ordinaire :
au lieu de v&#233;rifier que les valeurs associ&#233;es aux diff&#233;rentes occurrences de N sont &#233;gales,
on calcule pour chaque valeur possible (ici sg ou pl) le co&#251;t de l&#8217;affecter &#224; N dans la partie
droite de la r&#232;gle. Et ce co&#251;t, qui peut &#234;tre non nul pour une valeur de trait donn&#233;e, est la
somme des co&#251;ts correspondants d&#233;j&#224; calcul&#233;s pour les &#233;l&#233;ments de cette partie droite.
</p>
<p>3. On peut noter que les &#233;quations de traits associ&#233;es &#224; un Bi, de la forme &#171; trait = va-
riable &#187;, ne couvrent pas n&#233;cessairement tous les traits qui figurent dans l&#8217;ensemble des
co&#251;ts d&#8217;assignation calcul&#233;s pour Bi. Certains traits, en quelque sorte, ne sont donc pas
propag&#233;s au niveau de la r&#232;gle. Nous pouvons statuer sur eux localement, d&#232;s ce ni-
</p>
<p>3Nous ne d&#233;crivons pas ici le traitement d&#8217;un certain nombre de constructions : filtrage (&#233;quivalent du =c de
LFG), contrainte par des constantes (&#171; trait = valeurs &#187; en partie gauche ou droite de r&#232;gle), idem avec variable
(not&#233; &#171; trait = variable &amp; valeurs) &#187;. Le cas &#171; trait = variable &#187;, que nous d&#233;crivons ici, est le c&#339;ur de l&#8217;algorithme.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Correction grammaticale avec analyse profonde et proposition de corrections minimales
</p>
<p>veau. En revanche, on ne peut pas encore statuer sur les traits qui sont propag&#233;s, car des
contraintes additionnelles peuvent ult&#233;rieurement en modifier les co&#251;ts d&#8217;assignation.
</p>
<p>Pour garder la trace des traits non propag&#233;s sur lesquels on a statu&#233;, nous nous repo-
sons sur le trait sp&#233;cial $ (aussi utilis&#233; dans le lexique de substitution, cf. &#167;4), que l&#8217;on
propage syst&#233;matiquement jusqu&#8217;en haut de la for&#234;t. Pour effectuer cette propagation
syst&#233;matique, le trait $ est implicitement consid&#233;r&#233; comme pr&#233;sent dans chaque non-
terminal, associ&#233; &#224; une m&#234;me variable de trait x$. Autrement dit, toute r&#232;gle d&#233;finie
comme a[...] &#8594; b1[...] . . . bn[...] repr&#233;sente en fait la r&#232;gle a[...; $ = x$] &#8594; b1[...; $ =
x$] . . . bn[...; $ = x$]. Statuer sur les traits non propag&#233;s consiste &#224; int&#233;grer (additionner)
leur co&#251;t d&#8217;assignation minimum dans le trait sp&#233;cial $. Ils pourront ainsi contribuer au
co&#251;t global lorsque l&#8217;on statuera sur l&#8217;ensemble des traits, &#224; la racine de la for&#234;t.
</p>
<p>4. Il faut &#233;galement prendre en compte le fait que certaines variables peuvent n&#8217;appara&#238;tre
qu&#8217;en partie droite de la r&#232;gle, et non en partie gauche. En ce cas, on peut &#233;galement
statuer localement sur les traits auxquelles elles sont associ&#233;es. Les co&#251;ts minimums
d&#8217;assignation de traits correspondant sont alors aussi cumul&#233;s dans le trait sp&#233;cial $.
</p>
<p>Arriv&#233; &#224; la racine, on dispose d&#8217;un ensemble de co&#251;ts d&#8217;assignation de traits alternatifs, dont
on calcule le minimum. Une fois choisie une assignation de valeur de traits de co&#251;t minimum,
un parcours inverse de haut en bas (de la racine vers les feuilles) &#233;num&#232;re les alternatives de
correction effectives qui ont ce co&#251;t minimum, afin de les pr&#233;senter &#224; l&#8217;utilisateur. S&#8217;il y a de trop
nombreuses alternatives de correction de co&#251;t minimum, on peut aussi en seuiller le nombre.
</p>
<p>5.2 R&#233;duction et contr&#244;le de la combinatoire
</p>
<p>Gr&#226;ce &#224; la for&#234;t partag&#233;e, l&#8217;algorithme en &#167;5.1 partage des calculs et structures de donn&#233;es. Il
n&#8217;en &#233;num&#232;re pas moins toutes les alternatives d&#8217;analyse, potentiellement en nombre exponen-
tiel. Il est capital de r&#233;duire cette combinatoire, sans alt&#233;rer l&#8217;optimum ou via des heuristiques.
</p>
<p>On peut tout d&#8217;abord &#233;liminer les co&#251;ts d&#8217;assignation de traits dont on sait qu&#8217;ils seront de toute
fa&#231;on plus mauvais que tout autre co&#251;t d&#8217;assignation de traits dans d&#8217;un m&#234;me ensemble d&#8217;al-
ternatives : soit parce que leurs co&#251;ts individuels (pour toute valeur de trait) sont uniform&#233;ment
plus &#233;l&#233;v&#233;s, soit parce que leur co&#251;t minimum (sur l&#8217;ensemble des traits) est sup&#233;rieur au co&#251;t
maximum de chaque autre alternative. La combinatoire est r&#233;duite sans modifier l&#8217;optimum.
</p>
<p>Bien qu&#8217;exp&#233;rimentalement efficace sur le type de phrases et de grammaire utilis&#233;es, cette r&#233;-
duction du nombre d&#8217;alternatives &#224; consid&#233;rer ne garantit toutefois pas un temps de correction
polynomial. Pour se pr&#233;munir d&#8217;une explosion combinatoire en toute circonstance, on peut en
outre (ou alternativement) appliquer une ou plusieurs des heuristiques suivantes :
&#8211; &#233;liminer toute alternative dont le co&#251;t minimum est au dessus d&#8217;un certain seuil,
&#8211; &#233;liminer toute alternative dont le co&#251;t maximum est au dessus d&#8217;un certain seuil,
&#8211; borner la taille des ensembles d&#8217;alternatives. (Dans le cas particulier o&#249; cette borne est 1, on
retrouve comme cas particulier le calcul d&#8217;un optimum purement local.)
</p>
<p>L&#8217;optimum n&#8217;est alors plus n&#233;cessairement global, mais la complexit&#233; devient polynomiale en
la taille de la phrase. Seule la derni&#232;re heuristique garantit qu&#8217;une solution est toujours trouv&#233;e.
</p>
<p>6 Conclusion
Nous avons pos&#233; le probl&#232;me central de la correction grammaticale et argument&#233; en faveur
d&#8217;une correction globale, bas&#233;e sur l&#8217;accord des traits syntaxiques. Nous avons pr&#233;sent&#233; pour
cela un formalisme grammatical simple mais expressif, et appliqu&#233; un principe d&#8217;analyse en</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Lionel Cl&#233;ment, Kim Gerdes, Renaud Marlet
</p>
<p>structure rigide (mais ambigu&#235;) avec rel&#226;chement des contraintes d&#8217;accord. Nous avons d&#233;taill&#233;
l&#8217;algorithme qui calcule une correction optimale, ainsi que des propri&#233;t&#233;s et heuristiques qui
permettent de r&#233;duire et de contr&#244;ler sa combinatoire. Au final, des alternatives de correction de
co&#251;ts minimal sont automatiquement propos&#233;es, en une seule passe sur la structure d&#8217;analyse.
Le syst&#232;me et la grammaire actuellement impl&#233;ment&#233;s corrigent par exemple (10) en (11) :
(10) Les enfants ont mang&#233; ces cerise rouge qui &#233;taient juteuses et sucr&#233;es et qu&#8217;ils ont vu que
</p>
<p>j&#8217;avais cueillis.
(11) Les enfants ont mang&#233; ces cerises rouges qui &#233;taient juteuses et sucr&#233;es et qu&#8217;ils ont vu
</p>
<p>que j&#8217;avais cueillies.
(12) Les enfants ont mang&#233; cette cerise rouge qui &#233;tait juteuse et sucr&#233;e et qu&#8217;ils ont vu que
</p>
<p>j&#8217;avais cueilli.
Cette correction minimale (3 traits) n&#233;cessite une analyse &#224; la fois globale et profonde. La for&#234;t
est ici assez peu ambigu&#235;, gr&#226;ce &#224; l&#8217;usage massif de l&#8217;&#233;toile de Kleene et des termes optionnels.
La correction, analyses syntaxiques partielles comprises, s&#8217;effectue en moins de 300 ms. Par
comparaison, Microsoft Office, qui pourtant semble avoir une certaine vision globale, fait des
erreurs en cascade et corrige (10) en (12), ce qui n&#8217;est pas minimal (5 traits modifi&#233;s) et m&#234;me
faux (mauvais accord du participe pass&#233; de la relative). LanguageTool reste silencieux.
</p>
<p>Des exp&#233;riences sont en cours pour mettre le syst&#232;me &#224; l&#8217;&#233;preuve, &#224; la fois en termes de per-
formance et de facilit&#233; d&#8217;&#233;criture de grammaire. Nous voulons aussi exp&#233;rimenter avec d&#8217;autres
langues, et impl&#233;menter une int&#233;gration dans OpenOffice.
</p>
<p>R&#233;f&#233;rences
BILLOT S. &amp; LANG B. (1989). The structure of shared forests in ambiguous parsing. In 27th
annual meeting on Association for Computational Linguistics (ACL), p. 143&#8211;151 : ACL.
BUSTAMANTE F. R. &amp; LE&#211;N F. S. (1996). Gramcheck : A grammar and style checker. In
COLING, p. 175&#8211;181.
CL&#201;MENT L., SAGOT B. &amp; LANG B. (2004). Morphology based automatic acquisition of
large-coverage lexica. In LREC &#8217;04. Voir http://alpage.inria.fr/~sagot/lefff.html.
EARLEY J. (1970). An efficient context-free parsing algorithm. Comm. of the ACM, 13(2).
FONTENELLE T. (2006). Les nouveaux outils de correction linguistique de Microsoft. In
Conf&#233;rence sur le Traitement Automatique des Langues Naturelles (TALN), p. 3&#8211;19, Louvain.
FOUVRY F. (2003). Constraint relaxation with weighted feature structures. In 8th Internatio-
nal Workshop on Parsing Technologies.
NABER D. (2007). Integrated tools for spelling, style, and grammar checking. OpenOffice.org
Conference, Barcelona. Outil disponible &#224; l&#8217;URL http://www.languagetool.org.
NEW B. (2006). Lexique 3 : une nouvelle base de donn&#233;es lexicales. In TALN &#8217;06, p. 892&#8211;900.
PROST J.-P. (2008). Mod&#233;lisation de la gradience syntaxique par analyse rel&#226;ch&#233;e &#224; base de
contraintes. Th&#232;se de doctorat, Universit&#233; de Provence et Macquarie University.
SOUQUE A. (2008). Vers une nouvelle approche de la correction grammaticale automatique.
In Rencontre des &#201;tudiants Chercheurs en Informatique pour le TAL, p. 121&#8211;130, Avignon.
S&#197;GVALL HEIN A. (1998). A chart-based framework for grammar checking &#8211; initial studies.
In 11th Nordic Conference in Computational Linguistic, p. 68&#8211;80.
VOGEL C. &amp; COOPER R. (1995). Robust chart parsing with mildly inconsistent feature struc-
tures. Edinburh Working Papers in Cognitive Science : Nonclassical Feature Systems, 10.</p>

</div></div>
</body></html>