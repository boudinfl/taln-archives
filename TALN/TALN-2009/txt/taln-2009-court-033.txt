TALN 2009 â€“ Session posters , Senlis, 24â€“26 juin 2009
Recto / Verso
Un systÃ¨me de conversion automatique ancienne / nouvelle
orthographe Ã  visÃ©e linguistique et didactique
Richard Beaufort Anne Dister Hubert Naets KÃ©vin MacÃ©
CÃ©drick Fairon
CENTAL / UniversitÃ© Catholique de Louvain, 1 Place Blaise Pascal, B-1348
Louvain-la-Neuve, Belgique
{richard.beaufort, anne.dister, hubert.naets, kevin.mace,
cedrick.fairon}@uclouvain.be
RÃ©sumÃ©. Cet article prÃ©sente Recto / Verso, un systÃ¨me de traitement automatique du lan-
gage dÃ©diÃ© Ã  lâ€™application des rectifications orthographiques de 1990. Ce systÃ¨me a Ã©tÃ© dÃ©ve-
loppÃ© dans le cadre de la campagne de sensibilisation rÃ©alisÃ©e en mars dernier par le Service et
le Conseil de la langue franÃ§aise et de la politique linguistique de la CommunautÃ© franÃ§aise de
Belgique. Nous commenÃ§ons par rappeler les motivations et le contenu de la rÃ©forme proposÃ©e,
et faisons le point sur les principes didactiques retenus dans le cadre de la campagne. La plus
grande partie de lâ€™article est ensuite consacrÃ©e Ã  lâ€™implÃ©mentation du systÃ¨me. Nous terminons
enfin par une premiÃ¨re analyse de lâ€™impact de la campagne sur les utilisateurs.
Abstract. This paper presents Recto / Verso, a natural language processing system dedi-
cated to the application of the 1990 French spelling rectifications. This system was developed
for supporting the awareness-raising campaign promoted last March by the Superior council of
the French language in Belgium. We first remind the motivations and the content of the reform,
and we draw up the didactic principles followed during the campaign. The most important part
of this paper is then focused on the systemâ€™s implementation. We finally end by a short analysis
of the campaignâ€™s impact on the users.
Mots-clÃ©s : Rectifications orthographiques de 1990, conversion ancienne / nouvelle or-
thographe, objectifs didactiques, machines Ã  Ã©tats finis.
Keywords: 1990 French spelling rectifications, ancient / new spelling conversion, di-
dactic purposes, finite-state machines.
1 Introduction
En 1990, le Conseil supÃ©rieur de la langue franÃ§aise, prÃ©sidÃ© par Michel Rocard, et rÃ©unissant
des personnalitÃ©s et des experts franÃ§ais, belge et quÃ©bÃ©cois, proposait un ensemble de recti-
fications orthographiques, connues sous le nom de Â« nouvelle orthographe Â» (Goosse, 1991),
et approuvÃ©es par toutes les instances francophones compÃ©tentes en matiÃ¨re de langue (en ce
compris lâ€™AcadÃ©mie franÃ§aise). Ces modifications, proposÃ©es aux usagers sans leur Ãªtre impo-
sÃ©es, entrent peu Ã  peu dans lâ€™usage, mais sans que leur emploi ne soit systÃ©matique. Ainsi,
R. Beaufort, A. Dister, H. Naets, K. MacÃ©, C. Fairon
on constate que ces nouvelles graphies, bien quâ€™intÃ©grÃ©es dans les correcteurs orthographiques
actuels (Fontenelle, 2006) et prÃ©conisÃ©es dans lâ€™enseignement, sont encore parfois sanction-
nÃ©es chez les Ã©lÃ¨ves, tant en France quâ€™en Belgique. Fort de ce constat, le Conseil de la langue
franÃ§aise et de la politique linguistique de la CommunautÃ© franÃ§aise de Belgique a rÃ©alisÃ© en
mars dernier une vaste campagne de promotion des rectifications auprÃ¨s des usagers, action de
sensibilisation Ã  laquelle la presse francophone belge a participÃ© en Â« passant Ã  la nouvelle or-
thographe Â» pour la version en ligne des quotidiens. Ce Â« passage Â» a Ã©tÃ© rendu possible grÃ¢ce au
dÃ©veloppement dâ€™un systÃ¨me de traitement automatique du langage spÃ©cialement dÃ©diÃ© Ã  cette
tÃ¢che : Recto / Verso. Câ€™est ce systÃ¨me que nous prÃ©sentons ici.
2 La campagne de sensibilisation
En CommunautÃ© franÃ§aise de Belgique, un dÃ©pliant reprenant Â« 7 rÃ¨gles pour nous simplifier
lâ€™orthographe Â» a Ã©tÃ© diffusÃ© Ã  300 000 exemplaires, conjointement Ã  la publication en octobre
2008 de quatre circulaires ministÃ©rielles officialisant le choix de la Â« nouvelle orthographe Â»
pour lâ€™enseignement du franÃ§ais en Belgique.
Sâ€™en est suivie une vaste campagne de sensibilisation au travers de la presse en ligne : quatre
des plus grands groupes de la presse francophone belge (soit un peu plus de 90 % de la presse
en ligne) ont fait le pas de passer Ã  la nouvelle orthographe.1
Cette campagne a Ã©tÃ© menÃ©e durant la Â« Semaine de la langue Â» de mars 2009. Les Ã©ditions Ã©lec-
troniques des journaux ont alors Ã©tÃ© proposÃ©es au lecteur dans deux versions : en orthographe
Â« standard Â», comme dâ€™habitude, et en orthographe rectifiÃ©e. Dans le principe, un bouton nommÃ©
Â« RECTO/VERSO Â» (RECTifications Orthographiques / VERSion Originale) permettait de bas-
culer dâ€™une version Ã  lâ€™autre.
Cette action poursuivait deux objectifs complÃ©mentaires. PremiÃ¨rement, elle voulait sensibi-
liser les grands Ã©diteurs Ã  la question de la nouvelle orthographe, parce quâ€™il est aujourdâ€™hui
Ã©vident que la nouvelle orthographe ne pourra se diffuser dans le public que si les grands Ã©di-
teurs lâ€™adoptent au prÃ©alable. Le passage temporaire de la presse Ã  la nouvelle orthographe, dans
le cadre de la campagne, est certainement un signe encourageant dans ce sens.
DeuxiÃ¨mement, la campagne avait une dimension pÃ©dagogique. Lâ€™idÃ©e Ã©tait dâ€™une part de per-
mettre au public de dÃ©couvrir la nouvelle orthographe au travers de cas concrets dans des articles
rÃ©els, et dâ€™autre part de guider cette dÃ©couverte, au travers de notes explicatives prÃ©sentant les
rectifications introduites dans le texte.
Les versions en ligne des quotidiens se prÃ©sentent classiquement sous la forme de pages HTML.
Dans le cadre de la campagne, nous devions donc gÃ©nÃ©rer des pages HTML en orthographe
rectifiÃ©e au dÃ©part de textes en orthographe traditionnelle.
2.1 Les contraintes pÃ©dagogiques
Afin de donner une dimension pÃ©dagogique aux pages en nouvelle orthographe, il fallait que
les formes rectifiÃ©es soient mises en Ã©vidence par rapport au reste du texte de la page, et soient
expliquÃ©es Ã  lâ€™utilisateur.
1Voir www.lesoir.be ; www.lalibre.be ; www.dhnet.be ; www.sudpresse.be
Recto / Verso
Des formes rectifiÃ©es visibles. Nous avons dÃ©cidÃ© dâ€™utiliser des couleurs, rÃ©parties en deux ni-
veaux complÃ©mentaires : dâ€™une part, une couleur pour lâ€™ensemble du mot concernÃ©, de maniÃ¨re
Ã  faciliter sa localisation dans la page, et dâ€™autre part, une couleur pour la partie du mot touchÃ©e
par la rectification, de maniÃ¨re Ã  accÃ©lÃ©rer lâ€™identification visuelle des modifications rÃ©alisÃ©es.
Pour ce faire, nous avons utilisÃ© une feuille de style CSS, qui autorise entre autres lâ€™utilisa-
tion de balises <span> pour formater un texte. Nous avons donc dÃ©fini deux niveaux de balises
<span> : le premier, "recto..", correspond au mot rectifiÃ© dans sa globalitÃ© et indique si la
forme a Ã©tÃ© modifiÃ©e ("recto") ou est une exception ("recto_ex") ; le second, "rule..", en-
toure la partie du mot concernÃ©e par une rÃ¨gle, et indique par un chiffre de 1 Ã  9 le numÃ©ro de
la rÃ¨gle concernÃ©e. Par exemple, la phrase
le bÃ»cher est lÃ  (1)
deviendra, aprÃ¨s rectification,
le <span class="recto">b<span class="rule4">u</span>cher</span> est lÃ  (2)
oÃ¹ "recto" et "rule4" indiquent conjointement que la rÃ¨gle relative Ã  la suppression de lâ€™ac-
cent circonflexe sur i et u a bien Ã©tÃ© appliquÃ©e. Le CSS dÃ©finit la couleur Ã  appliquer pour chaque
classe "recto.." et pour chaque classe "rule..". En lâ€™occurrence, nous avons dÃ©cidÃ© dâ€™uti-
liser lâ€™orange foncÃ© pour "recto", le vert pour "recto_ex" et le bleu pour toutes les classes
"rule..", afin de ne pas entrainer de surcharge cognitive.
Des rectifications expliquÃ©es. AprÃ¨s analyse, et afin de modifier le moins possible lâ€™apparence
de la page rectifiÃ©e, nous avons dÃ©cidÃ© dâ€™opter pour lâ€™affichage dâ€™infobulles, nâ€™apparaissant que
lorsque lâ€™utilisateur passe la souris sur une rectification donnÃ©e.
Pour ce faire, nous avons exploitÃ© la prÃ©sence des balises <span> Ã  lâ€™aide de la librairie JavaS-
cript jQuery.2 Le fonctionnement de jQuery tient dans la dÃ©finition de la fonction JavaScript
"ready()" qui exÃ©cute au chargement de la page les instructions qui y sont contenues. Dans le
cas prÃ©sent, il y est dÃ©crit que lorsque le curseur de la souris passe au-dessus de lâ€™une des balises
ajoutÃ©es, une infobulle doit sâ€™afficher avec un texte. Ce texte, qui diffÃ¨re selon la combinaison
"recto.." / "rule.." rencontrÃ©e, est conservÃ© dans un tableau JavaScript, ce qui permet de
dissocier le comportement des infobulles de leur contenu.
2.2 Un service accessible en ligne
Afin de faciliter lâ€™accÃ¨s au systÃ¨me par les journaux en ligne et dans le but de simplifier les
opÃ©rations de mise Ã  jour, Recto / Verso a Ã©tÃ© conÃ§u sous la forme dâ€™un service web de type
SOAP. Les quotidiens en ligne ont pu transmettre ainsi leurs articles Ã  un serveur distant, Ã 
lâ€™aide dâ€™une API trÃ¨s simple, et recevoir en retour ces mÃªmes textes rectifiÃ©s et ponctuÃ©s des
balises indiquant lâ€™emplacement et la nature des rectifications.
Les articles de presse nâ€™ont toutefois pas Ã©tÃ© les seuls textes concernÃ©s par la campagne, puis-
quâ€™une interface web accessible au grand public a Ã©galement Ã©tÃ© mise en place. AccÃ©dant elle
aussi au service web, elle a permis Ã  chacun dâ€™employer le systÃ¨me de rectifications.
Du cÃ´tÃ© serveur, lâ€™architecture reste simple : le service web reÃ§oit le texte Ã  rectifier ; il y ap-
plique une sÃ©rie de prÃ©traitements visant Ã  normaliser lâ€™encodage du document ; le texte est
ensuite transmis au moteur de rectifications, et, une fois traitÃ©, renvoyÃ© au client par le service
web.
2Voir http://jquery.com
R. Beaufort, A. Dister, H. Naets, K. MacÃ©, C. Fairon
3 ImplÃ©mentation
3.1 Outils utilisÃ©s
Lâ€™ensemble des traitements linguistiques dÃ©crits dans cet article ont Ã©tÃ© implementÃ©s sous la
forme de machines Ã  Ã©tats finis. Selon les besoins, il sâ€™agit dâ€™automates ou de transducteurs,
pondÃ©rÃ©s ou non (Mohri, 1996; Roche & Schabes, 1997).
Nous avons utilisÃ© la bibliothÃ¨que de machines Ã  Ã©tats finis et le compilateur prÃ©sentÃ©s dans
(Beaufort, 2008). La bibliothÃ¨que propose la plupart des algorithmes standard de la littÃ©rature
dans leur version pondÃ©rÃ©e. Elle autorise la crÃ©ation et la sauvegarde de machines dynamiques
(construites au vol), et permet la sauvegarde et le chargement de machines binaires (complÃ¨te-
ment prÃ©calculÃ©es), plus compactes et plus rapides Ã  charger. Le compilateur, dÃ©veloppÃ© autour
de la bibliothÃ¨que, convertit en machines Ã  Ã©tas finis des rÃ¨gles de rÃ©Ã©criture pondÃ©rÃ©es, des lan-
gages rÃ©guliers, des dictionnaires et des n-grammes. Les rÃ¨gles de rÃ©Ã©criture autorisÃ©es prennent
la forme gÃ©nÃ©rale
Ï†â†’ Ïˆ : : Î» _ Ï / Ï‰ (3)
oÃ¹ Ï†, lorsquâ€™il est entourÃ© par Î» et Ï, se rÃ©Ã©crit Ïˆ et se voit attribuer le poids Ï‰. Dans cette
formulation, Ï†, Ïˆ, Î» et Ï sont des expressions rÃ©guliÃ¨res (McNaughton & Yamada, 1960) et Ï‰
est dÃ©fini sur le semi-anneau tropical (Kuich & Salomaa, 1986). Dans tous les cas, le rÃ©sultat de
la compilation est une machine Ã  Ã©tats finis au format binaire de la bibliothÃ¨que.
3.2 Architecture gÃ©nÃ©rale du systÃ¨me
Les rÃ©flexions prÃ©liminaires au dÃ©veloppement de Recto / Verso ont Ã©tÃ© les suivantes :
1. Certaines rÃ¨gles de la rÃ©forme ne sont pas purement lexicales. Câ€™est le cas, par exemple,
du pluriel des noms composÃ©s ou de lâ€™accord du participe passÃ© laissÃ© devant infinitif.
Recto / Verso devait donc inclure un moteur dâ€™analyse linguistique.
2. Dans le cadre de la campagne de sensibilisation, Recto / Verso devait traiter des pages
HTML et donc Ãªtre capable de masquer les Ã©lÃ©ments non linguistiques le temps du traite-
ment, et de les rÃ©introduire ensuite dans la version rÃ©formÃ©e, afin de respecter lâ€™affichage
prÃ©vu par le crÃ©ateur de la page.
Sur la base de ces considÃ©rations, Recto / Verso a Ã©tÃ© pourvu des modules suivants :
1. Un module de prÃ©traitement HTML, qui cache le contenu non linguistique du texte Ã 
traiter ;
2. Un module de dÃ©sambigÃ¼isation linguistique, qui analyse le contenu linguistique du texte ;
3. Un module de conversion, qui applique la rÃ©forme sur le rÃ©sultat de lâ€™analyse ;
4. Un module de post-traitement HTML, qui rÃ©insÃ¨re les Ã©lÃ©ments non linguistiques dans le
texte rÃ©formÃ©.
Nous commenÃ§ons en 3.3 par dÃ©crire le moteur dâ€™analyse linguistique, qui constitue le cÅ“ur
du systÃ¨me. Nous dÃ©taillons ensuite en 3.4 les modules de prÃ©- et post-traitement HTML, qui
travaillent de pair. Ces modules font toute lâ€™originalitÃ© et la robustesse de lâ€™application. Nous
terminons enfin en 3.5 par le module de conversion, qui est la raison dâ€™Ãªtre de Recto / Verso.
Recto / Verso
3.3 Le module de dÃ©sambigÃ¼isation linguistique
Ce module est fortement inspirÃ© de (Beaufort, 2008), auquel nous renvoyons le lecteur pour une
description dÃ©taillÃ©e. Dans ce systÃ¨me, la phase de dÃ©sambigÃ¼isation linguistique se limite Ã  la
suite dâ€™Ã©tapes nÃ©cessaires Ã  segmenter un texte en unitÃ©s de sens (dates, tÃ©lÃ©phones, URLs, . . .,
nombres, formes lexicales), et Ã  attribuer Ã  chaque unitÃ© et Ã  chacune de ses parties une et une
seule analyse morphologique possible : catÃ©gorie, genre, nombre et personne. Aucune structure
syntaxique nâ€™est construite, et aucune analyse sÃ©mantique nâ€™est entreprise. Le systÃ¨me est or-
ganisÃ© en trois couches : un prÃ©traitement, une analyse morphologique et une dÃ©sambigÃ¼isation
syntaxique.
1. Le prÃ©traitement est rÃ©alisÃ© par un transducteur Pre obtenu par compilation de rÃ¨gles
de rÃ©Ã©criture qui dÃ©crivent les unitÃ©s de sens Ã  dÃ©tecter. En cours de processus, un texte
W est donc composÃ© avec le transducteur Pre, ce qui produit un transducteur W â€², dont
lâ€™entrÃ©e contient le texte et la sortie contient uniquement les unitÃ©s dÃ©tectÃ©es, chaque
unitÃ© Ã©tant systÃ©matiquement situÃ©e en face du premier caractÃ¨re qui lui appartient. La
figure 3.3 en donne une illustration. A partir de ce rÃ©sultat et en appliquant lâ€™algorithme
de segmentation de machines Ã  Ã©tats finis proposÃ© par (Beaufort, 2008), W â€² est segmentÃ©
en un vecteur de machines Ã  Ã©tats finis VW â€² , oÃ¹ chaque machine correspond Ã  une seule
unitÃ©. Ce sont les machines mÃ©morisÃ©es dans ce vecteur qui subiront les Ã©tapes suivantes
du traitement.
2. Lâ€™analyse morphologique repose principalement sur deux transducteurs pondÃ©rÃ©s. Le pre-
mier, dÃ©diÃ© aux formes connues, reprÃ©sente un simple lexique de formes flÃ©chies. Le se-
cond, dÃ©diÃ© aux formes hors vocabulaire, permet de choisir les catÃ©gories Ã  attribuer aux
formes en fonction de leur terminaison (il correspond Ã  lâ€™expression rÃ©guliÃ¨re Â« .+ {suf} Â»
oÃ¹ Â« .+ Â» est une suite non nulle de caractÃ¨res, et Â« {suf} Â» est lâ€™ensemble des suffixes
du franÃ§ais, complÃ©tÃ© de la chaine vide ). Les deux transducteurs sont pondÃ©rÃ©s par des
modÃ¨les de mot distincts, de la forme âˆ’ log p(wi|ti).
3. Lâ€™analyse syntaxique, enfin, sâ€™organise en deux niveaux. Le premier, reprÃ©sentÃ© sous la
forme dâ€™un automate pondÃ©rÃ©, implÃ©mente un n-gramme âˆ’ log p(ti|tiâˆ’2, tiâˆ’1) lissÃ© par
interpolation linÃ©aire (Beaufort et al., 2002). Le second est un transducteur qui regroupe
des suites de catÃ©gories susceptibles de constituer des formes composÃ©es de diffÃ©rents
types : mots composÃ©s (e.g. nom, tiret, nom â†’ nom), formes verbales composÃ©es plus
ou moins complexes (e.g. auxiliaire, participe passÃ©â†’ verbe), etc. On retiendra que les
deux niveaux dâ€™analyse sont conservÃ©s dans des transducteurs distincts mais alignÃ©s, de
maniÃ¨re Ã  donner aux traitements suivants la possibilitÃ© dâ€™un accÃ¨s Ã  une information
macro- ou micro-scopique.
On notera que la composition de lâ€™analyse morphologie et de lâ€™analyse syntaxique permet la
reconstitution dâ€™un modÃ¨le de langue complet sous la forme de Bayes :
âˆ‘
P (T |W ) = arg min âˆ’ log p(wi|ti) â—¦
âˆ‘âˆ’ log p(ti|tiâˆ’2, tiâˆ’1) (4)
T i i
AprÃ¨s dÃ©sambigÃ¼isation, le texte se prÃ©sente sous la forme de plusieurs machines Ã  Ã©tats finis
alignÃ©es. Leur parcours en parallÃ¨le permet de remplir une structure de donnÃ©es, que nous avons
baptisÃ©e OrthoML et qui prÃ©sente les niveaux dâ€™inclusion suivants :
paragrapheâ†’ phraseâ†’ unitÃ© de sensâ†’ forme composÃ©eâ†’ forme simple
R. Beaufort, A. Dister, H. Naets, K. MacÃ©, C. Fairon
A:Alpha h:! ,:Punct " ":! u:Alpha n:! " ":! a:! s:! !:Endpunct
FIG. 1 â€“ Application du prÃ©traitement sur le texte Â« Ah, un as ! Â»
3.4 Les modules de prÃ©- et post-traitement HTML
Une page HTML contient deux types dâ€™Ã©lÃ©ments non linguistiques :
1. Des Ã©lÃ©ments structurants. Il sâ€™agit exclusivement des balises HTML (ouvrantes et fer-
mantes) permettant de dÃ©limiter des portions cohÃ©rentes de texte : une phrase (<BR>), un
paragraphe (<P>), une liste (<UL, <OL>, <LI>) ou un titre (<H1>, <H2>, etc.). Dans
une page HTML, ces balises sont parfois le seul indice dâ€™une ponctuation forte, absente
du texte lui-mÃªme.
2. Du bruit. Il sâ€™agit de tout le reste. Dans ce reste, nous avons dÃ©cidÃ© de placer les balises
de formatage des polices (<B>, <I>, <U>, etc.), qui peuvent faire irruption nâ€™importe oÃ¹
dans le texte, que ce soit entre deux mots dâ€™une mÃªme phrase ou dans un mot lui-mÃªme.
Pour chaque type, nous avons construit un nouveau transducteur de prÃ©traitement :
1. Tag, qui identifie les Ã©lÃ©ments structurants du texte et leur attribue une nouvelle unitÃ©, le
Tag. Ce transducteur est obtenu et fonctionne de maniÃ¨re similaire Ã  Pre.
2. Hid, qui identifie le bruit prÃ©sent dans le texte et le cache Ã  lâ€™analyse. Dans ce cas-ci,
les rÃ¨gles de rÃ©Ã©criture ne projettent plus les Ã©lÃ©ments dÃ©tectÃ©s sur une unitÃ©, mais sur la
chaine vide . Dans le rÃ©sultat de la compositionW â—¦Hid, le bruit est prÃ©sent sur lâ€™entrÃ©e,
mais est absent de la sortie du transducteur.
IdÃ©alement, nettoyer le texte, identifier les Ã©lÃ©ments structurants et dÃ©tecter les unitÃ©s classiques
devraient Ãªtre rÃ©alisÃ©s comme suit :
W â€² = pi2(W â—¦Hid) â—¦ Tag â—¦ Pre (5)
oÃ¹ pi2(Â·) note la projection du langage de sortie de (Â·).
Cependant, la projection fait disparaitre le bruit de la page, de maniÃ¨re irrÃ©cupÃ©rable. Or, lâ€™ob-
jectif est dâ€™appliquer la rÃ©forme sur le texte, tout en conservant lâ€™intÃ©gralitÃ© de la page dâ€™origine.
Pour ce faire, nous avons procÃ©dÃ© comme suit :
1. Le prÃ©traitement est rÃ©alisÃ© sans projection : W â€² = W â—¦Hid â—¦ Tag â—¦ Pre.
2. Le rÃ©sultat du prÃ©traitement est dupliquÃ©, et la projection est appliquÃ©e sur la copie uni-
quement : W â€²pi = pi2(W
â€²).
3. Lâ€™Ã©tape de segmentation du texte en unitÃ©s, sous la forme de machines Ã  Ã©tats finis conser-
vÃ©es dans un vecteur, est appliquÃ©e aux deux versions, la bruitÃ©e et la projetÃ©e.
4. La dÃ©sambigÃ¼isation morphosyntaxique et lâ€™application des rectifications orthographiques
sont rÃ©alisÃ©es sur le vecteur correspondant Ã  la version projetÃ©e, W â€²pi.
5. A la fin du traitement, un alignement entre les deux versions du texte est rÃ©alisÃ©, de ma-
niÃ¨re Ã  contenir Ã  la fois la totalitÃ© de la page initiale, et les rectifications introduites dans
le texte. Dans le principe, cet alignement est obtenu comme suit entre les deux versions
du texte :
W â€²â€² = Best(W â€² â—¦W â€²pi) (6)
si ce nâ€™est quâ€™il est rÃ©alisÃ© au niveau des deux vecteurs dâ€™unitÃ©s :
W â€²â€² = Best(VW â€² [1] â—¦ VW â€² [1]) Â· . . . Â·Best(Vpi W â€² [n] â—¦ VW â€² [n]) (7)pi
Recto / Verso
3.5 Le module de conversion
3.5.1 Description de lâ€™algorithme
Lâ€™algorithme consiste en un parcours rÃ©cursif des diffÃ©rentes couches de la structure de donnÃ©es
remplie par le module de dÃ©sambigÃ¼isation. Toutes les opÃ©rations sont rÃ©alisÃ©es au travers de
machines Ã  Ã©tats finis, par composition avec des modÃ¨les prÃ©compilÃ©s. Le niveau oÃ¹ tout com-
mence est en fait celui des unitÃ©s. Le processus de rectification nâ€™y est cependant dÃ©clenchÃ©
quâ€™en prÃ©sence dâ€™une unitÃ© alphabÃ©tique, et se dÃ©roule en deux Ã©tapes.
La premiÃ¨re Ã©tape traite successivement les diffÃ©rentes formes composÃ©es (Comp) de lâ€™unitÃ©.
Pour rappel, Ã  ce stade de lâ€™analyse, une forme composÃ©e est un niveau de la structure de
donnÃ©es, mais peut en rÃ©alitÃ© ne contenir quâ€™une forme simple. Le traitement rÃ©alisÃ© Ã  ce niveau
diffÃ¨re en fonction de la catÃ©gorie de la forme, et seuls les dÃ©terminants et les substantifs sont
concernÃ©s. Sâ€™il sâ€™agit dâ€™un dÃ©terminant, son nombre (Number) est conservÃ© pour un emploi
ultÃ©rieur. Sâ€™il sâ€™agit dâ€™un substantif, le systÃ¨me tente de lui appliquer les rÃ¨gles de rectification,
relatives aux mots composÃ©s et aux mots Ã©trangers, qui sont contenues dans un lexique :
(Fsm(Comp) . Fsm(Number)) â—¦ fsmRectoLexicon (8)
Câ€™est ici que le nombre du dernier dÃ©terminant rencontrÃ© intervient, puisquâ€™il est utilisÃ© pour
prÃ©ciser au lexique si la forme traitÃ©e est au singulier ou au pluriel. Quâ€™il y ait eu rectification
ou pas, cette Ã©tape se termine par la concatÃ©nation de la forme composÃ©e Ã  la machine Ã  Ã©tats
finis reprÃ©sentant lâ€™unitÃ© complÃ¨te.
La seconde Ã©tape concerne lâ€™unitÃ© complÃ¨te (fsmUnit) et est rÃ©alisÃ©e sous la forme dâ€™une cas-
cade de deux compositions :
fsmUnit â—¦ fsmRectoRule â—¦ fsmMarkRule (9)
A ce stade, les mots Ã©trangers et les mots composÃ©s concernÃ©s par la rÃ©forme ont dÃ©jÃ  Ã©tÃ©
traitÃ©s. Toutes les autres rectifications sont encore Ã  appliquer, ce qui est fait dans la premiÃ¨re
composition de la cascade. La deuxiÃ¨me composition de la cascade nâ€™applique plus de rÃ¨gles
de rectification, mais insÃ¨re, autour des formes modifiÃ©es, les balises <span> qui permettront le
formatage du texte et lâ€™affichage des bulles informatives lors de la lecture de la page dans un
navigateur. Ces balises sâ€™insÃ¨rent autour de toutes les rectifications, y compris celles rÃ©alisÃ©es
sur les mots Ã©trangers et les mots composÃ©s.
Lâ€™algorithme se termine par la crÃ©ation et lâ€™impression (dans un fichier de sortie) de la chaine de
caractÃ¨res correspondant Ã  lâ€™unitÃ©. Câ€™est Ã  ce moment quâ€™est rÃ©alisÃ© le post-traitement HTML
dÃ©crit en 3.4, oÃ¹ un alignement permet de combiner dans le texte de sortie Ã  la fois les rectifica-
tions rÃ©alisÃ©es et les informations non linguistiques qui appartenaient Ã  la page initiale.
3.5.2 Deux modes de gestion des rectifications
On le constate dans lâ€™algorithme, les mots composÃ©s et les mots Ã©trangers Ã  rectifier sont gÃ©rÃ©s
Ã  lâ€™aide dâ€™un lexique, alors que les autres rectifications sont gÃ©rÃ©es par des rÃ¨gles de rÃ©Ã©criture.
Voici les justifications de ce choix.
Utilisation dâ€™un lexique. Quâ€™il sâ€™agisse des mots Ã©trangers ou des mots composÃ©s, il est pos-
sible dâ€™en dresser une liste exhaustive. En ce qui concerne les mots Ã©trangers, il est bien Ã©vident
R. Beaufort, A. Dister, H. Naets, K. MacÃ©, C. Fairon
que leur nombre est a priori infini. Cependant, les seuls mots Ã©trangers qui seront reconnus
comme tels et sans erreur sont ceux recensÃ©s dans les lexiques utilisÃ©s. Dans le cadre de la cam-
pagne, ces lexiques ont bien sÃ»r Ã©tÃ© complÃ©tÃ©s.
En ce qui concerne les mots composÃ©s, ceux concernÃ©s par les rectifications sont de la forme
Â« porte-avion Â» (verbe + nom) et Â« sans-papier Â» (prÃ©position + nom). Il est de ce fait possible
dâ€™exprimer lâ€™ensemble des mots composÃ©s que le systÃ¨me peut rencontrer, sous la forme de
lâ€™expression rÃ©guliÃ¨re suivante :
({PREP}|{VERBE}) Â· "-" Â· {NOM} (10)
oÃ¹ {PREP} reprÃ©sente lâ€™ensemble des prÃ©positions du lexique, {VERBE} correspond aux formes
verbales qui peuvent participer Ã  la crÃ©ation dâ€™un mot composÃ©, et {NOM} fait rÃ©fÃ©rence Ã  lâ€™en-
semble des substantifs du lexique. GrÃ¢ce au compilateur utilisÃ©, il est possible de dÃ©crire des
lexiques dont les formes acceptÃ©es en entrÃ©e sont rÃ©Ã©crites en sortie. En voici un exemple :
garde-chasses<SG>â†’ garde-chasse
(11)
garde-chasse<PL>â†’ garde-chasses
oÃ¹ <SG> et <PL> indiquent respectivement que le mot est singulier ou pluriel. Ceci permet dâ€™Ã©vi-
ter de devoir dÃ©crire des rÃ¨gles de rÃ©Ã©criture plus ou moins lourdes, dont chacune ne sâ€™applique-
rait, au final, quâ€™Ã  une forme du lexique. Les diffÃ©rentes combinaisons possibles autorisent plus
de 3 millions de mots composÃ©s potentiels (354 verbes / prÃ©positionsÃ— 92 778 noms), compilÃ©s
en 25,7s et reprÃ©sentÃ©s sous une machine Ã  Ã©tats finis compacte de 466 Ko.
Utilisation de rÃ¨gles. Les autres rectifications nÃ©cessitent des rÃ¨gles de rÃ©Ã©criture pour lâ€™une des
deux raisons suivantes. Soit le nombre de formes concernÃ©es est potentiellement infini. Câ€™est
le cas des rÃ¨gles concernant lâ€™accent circonflexe. Soit la rÃ¨gle nÃ©cessite la connaissance dâ€™un
contexte postÃ©rieur Ã  la forme Ã  modifier, et indescriptible sous la forme dâ€™un lexique. Câ€™est
le cas, par exemple, de la rÃ¨gle Â« laissÃ© + infinitif Â», qui implique de repÃ©rer, Ã  lâ€™aide dâ€™une
expression rÃ©guliÃ¨re, lâ€™infinitif qui serait prÃ©sent dans le contexte droit du participe.
3.5.3 Insertion des balises <span>
Si les machines Ã  Ã©tats finis ont de nombreux avantages, elles prÃ©sentent cependant un incon-
vÃ©nient majeur : elles ne facilitent pas lâ€™identification dâ€™un symbole de lâ€™alphabet qui aurait Ã©tÃ©
rÃ©Ã©crit par lâ€™un ou lâ€™autre rÃ¨gle. Dans une machine, tous les symboles sont Ã©gaux. Il est dÃ¨s lors
difficile de repÃ©rer quâ€™une rÃ¨gle de rÃ©Ã©criture a Ã©tÃ© appliquÃ©e.
Le compilateur que nous avons utilisÃ© (cf. point 3.1) propose un mÃ©canisme permettant de
rÃ©soudre cette difficultÃ©. Il autorise lâ€™utilisation de marqueurs, symboles extÃ©rieurs Ã  lâ€™alphabet
utilisÃ©, que lâ€™on peut insÃ©rer dans une rÃ¨gle de rÃ©Ã©criture afin dâ€™identifier un phÃ©nomÃ¨ne et dâ€™en
suivre lâ€™Ã©volution.
Dans notre cas, les marqueurs ont Ã©tÃ© exploitÃ©s comme suit. Nous avons dÃ©fini un couple de
marqueurs par rÃ¨gle de rectification. Par exemple, [RU1] et [RU1END] pour la rÃ¨gle concernant
le pluriel des mots composÃ©s, le premier indiquant le dÃ©but dâ€™une rectification, et le second en
indiquant la fin. Ceci Ã©tant fait, voici comment se rÃ©Ã©crit une ligne du lexique :
garde-chasse<PL>â†’ garde-chasse[RU1]s[RU1END] (12)
GrÃ¢ce Ã  la prÃ©sence de ces marqueurs, lâ€™insertion des balises <span> a Ã©tÃ© fortement simplifiÃ©e.
En effet, les rÃ¨gles prÃ©cisent maintenant quâ€™en prÃ©sence de marqueurs de ce type, il faut dâ€™une
Recto / Verso
part introduire une balise globale autour de la forme complÃ¨te :
<span class="recto">garde-chasse[RU1]s[RU1END]</span> (13)
et dâ€™autre part rÃ©Ã©crire les marqueurs, en les replaÃ§ant par le nom de la rÃ¨gle correspondante :
<span class="recto">garde-chasse<span class="rule1">s</span></span> (14)
4 Evaluation du systÃ¨me
Robustesse et nombre dâ€™articles traitÃ©s. Lors du lancement de lâ€™application, quelques bugs
ont causÃ© plusieurs fois lâ€™arrÃªt brutal du systÃ¨me. Une rapide analyse nous a permis de les trou-
ver et de les corriger, de sorte que lâ€™application a traitÃ©, sans arrÃªt du systÃ¨me, plus de 1 000 000
de textes au cours de la Semaine de la langue franÃ§aise en fÃªte (mi-mars 2009). Lâ€™action, de-
puis, continue. En effet, la presse partenaire, convaincue par la stabilitÃ© de lâ€™application et ayant
surtout constatÃ© une augmentation de la consultation des articles en ligne, a souhaitÃ© conti-
nuer de proposer ce service Ã  ses lecteurs. Câ€™est ainsi quâ€™Ã  lâ€™heure oÃ¹ ces lignes sont Ã©crites,
Recto / Verso a traitÃ© plus de 7 000 000 dâ€™articles, soit environ 3,2 articles/seconde.
Performances et taille des articles traitÃ©s. Lâ€™application a Ã©tÃ© installÃ©e sur 4 serveurs pourvus
dâ€™une distribution Ubuntu Server JeOS 8.04.1, dâ€™un processeur 3 GHz et de 2 048 Mo de RAM.
Elle traite 20 000 caractÃ¨res/seconde lorsque le traitement peut rester dÃ©terministe (absence ou
faible prÃ©sence dâ€™Ã©lÃ©ments non linguistiques), et tombe au minimum Ã  10 000 caractÃ¨res/se-
conde en cas dâ€™indÃ©terminisme fort (forte prÃ©sence dâ€™Ã©lÃ©ments non linguistiques).
Les articles traitÃ©s ont une taille moyenne de 3 500 caractÃ¨res, ce qui nous donne un traitement
moyen de 170 ms. La plupart des textes oscillent entre 200 et 4 500 caractÃ¨res, 2% des textes
se situent entre 15 000 et 30 000 caractÃ¨res, et 1 texte sur 50 000 environ dÃ©passe les 60 000
caractÃ¨res.
QualitÃ© de lâ€™analyse. Toutes les formes concernÃ©es par les Rectifications publiÃ©es au Journal
officiel sont traitÃ©es par notre logiciel, hormis punch (la boisson) qui sâ€™Ã©crit dÃ©sormais ponch
conformÃ©ment Ã  la prononciation. En effet, notre systÃ¨me ne propose pas de dÃ©sambigÃ¼isation
sÃ©mantique, et il ne nous Ã©tait pas possible de distinguer la boisson de son homonyme (au sens
de Â« dynamisme Â»).
Lors dâ€™une rÃ©vision manuelle de 1 000 articles, nous avons constatÃ© Ã  deux reprises que les noms
propres (Nivelles, Capelle), homographes de formes concernÃ©es par la rÃ©forme (tu nivelles, il
capelle), avaient Ã©tÃ© mal analysÃ©s et modifiÃ©s Ã  tort. Ce sont les seules erreurs que nous ayons
eu lâ€™occasion dâ€™observer.
5 Conclusions
Dans cet article, nous avons prÃ©sentÃ© Recto / Verso, un systÃ¨me dÃ©diÃ© Ã  lâ€™application de la nou-
velle orthographe, spÃ©cialement dÃ©veloppÃ© dans le cadre de la Semaine de la langue franÃ§aise
en Belgique. Pour Ãªtre acceptÃ©e par la presse et bien accueillie par le public, lâ€™application devait
Ãªtre rapide, simple et intÃ©grer une dimension pÃ©dagogique. Nos dÃ©veloppements ont tÃ¢chÃ© dâ€™at-
teindre ces objectifs. Lâ€™application, rÃ©alisÃ©e Ã  lâ€™aide de machines Ã  Ã©tats finis, traite entre 10 000
R. Beaufort, A. Dister, H. Naets, K. MacÃ©, C. Fairon
et 20 000 caractÃ¨res/seconde selon le taux dâ€™Ã©lÃ©ments non linguistiques contenus dans le texte.
Le service web, de type SOAP, accepte des pages HTML complexes et y modifie les formes
concernÃ©es par la rÃ©forme, sans altÃ©rer le reste de la page. Les feuilles de style et les scripts
Javascript, enfin, facilitent lâ€™identification des rectifications rÃ©alisÃ©es et permettent lâ€™affichage
dâ€™infobulles explicatives.
Ceci ayant Ã©tÃ© mis en place, il restait Ã  attendre le retour du public, dans le cadre de la campagne
de sensibilisation. Recto / Verso a intÃ©ressÃ© les lecteurs des quotidiens en ligne, qui lâ€™ont testÃ©
massivement. La demande des journaux de maintenir le systÃ¨me sur leur site est dâ€™ailleurs la
preuve la plus tangible de cet intÃ©rÃªt du public pour la Â« nouvelle orthographe Â».
Remerciements
Cette recherche a Ã©tÃ© partiellement financÃ©e par le projet Â« Vocalise Â», dans le cadre du pro-
gramme FIRST Post-Doc de la RÃ©gion wallonne (convention 716619), ainsi que par le Service
de la langue de la CommunautÃ© franÃ§aise de Belgique.
Nous remercions NoÃ©mi Boubel, Bernadette Dehottay et Sophie Roekhaut, pour leur interven-
tion dans la constitution de certaines ressources linguistiques, et Olivier Blanc, pour les conseils
quâ€™il nous a donnÃ©s lors de lâ€™Ã©tablissement des principes de lâ€™architecture client / serveur.
RÃ©fÃ©rences
BEAUFORT R. (2008). Application des Machines Ã  Etats Finis en SynthÃ¨se de la Parole. SÃ©lec-
tion dâ€™unitÃ©s non uniformes et Correction orthographique. PhD thesis, FacultÃ© dâ€™Informatique,
FacultÃ©s Universitaires Notre-Dame de la Paix, Namur, Belgique. 605 pages.
BEAUFORT R., DUTOIT T. & PAGEL V. (2002). Analyse syntaxique du franÃ§ais. PondÃ©ration
par trigrammes lissÃ©s et classes dâ€™ambiguÃ¯tÃ©s lexicales. In Actes des XXIVe JournÃ©es dâ€™Etudes
sur la Parole (JEPâ€™02), p. 133â€“136.
FONTENELLE T. (2006). Les nouveaux outils de correction linguistique de microsoft. In P.
MERTENS, C. FAIRON, A. DISTER & G. PURNELLE, Eds., Actes de la 13e confÃ©rence sur
le traitement automatique des langues naturelles (TALNâ€™06), volume 1, p. 3â€“19, Louvain-la-
Neuve : Presses Universitaires de Louvain.
GOOSSE A. (1991). La Â« nouvelle Â» orthographe, ExposÃ© et commentaires. Louvain-la-
Neuve : Duculot.
KUICH W. & SALOMAA A. (1986). Semirings, Automata, Languages, volume 5 of EATCS
Monographs on Theoretical Computer Science. Berlin, Germany : Springer-Verlag.
MCNAUGHTON R. & YAMADA H. (1960). Regular expressions and state graphs for automata.
IRE Transactions on Electronic Computers EC, 9(1), 39â€“47.
MOHRI M. (1996). On some applications of finite-state automata theory to natural language
processing. Journal of Natural Language Engineering, 2, 1â€“20.
E. ROCHE & Y. SCHABES, Eds. (1997). Finite-State Language Processing. Cambridge,
Massachusetts : MIT Press.
