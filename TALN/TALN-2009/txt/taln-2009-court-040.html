<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Un Algorithme d&#8217;Analyse de Type Earley pour Grammaires &#224; Concat&#233;nation d&#8217;Intervalles</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2009 &#8211; Session posters , Senlis, 24&#8211;26 juin 2009
</p>
<p>Un Algorithme d&#8217;Analyse de Type Earley pour Grammaires &#224;
Concat&#233;nation d&#8217;Intervalles
</p>
<p>Laura Kallmeyer1 Wolfgang Maier1 Yannick Parmentier2
</p>
<p>(1) SFB 441 / Universit&#228;t T&#252;bingen, Nauklerstr. 35, D-72074 T&#252;bingen
(2) LORIA / Nancy Universit&#233;, Campus Scientifique, BP 239,
</p>
<p>F-54506 Vand&#339;uvre-L&#232;s-Nancy Cedex
</p>
<p>lk@sfs.uni-tuebingen.de wo.maier@uni-tuebingen.de parmenti@loria.fr
</p>
<p>R&#233;sum&#233;. Nous pr&#233;sentons ici diff&#233;rents algorithmes d&#8217;analyse pour grammaires &#224; conca-
t&#233;nation d&#8217;intervalles (Range Concatenation Grammar, RCG), dont un nouvel algorithme de
type Earley, dans le paradigme de l&#8217;analyse d&#233;ductive. Notre travail est motiv&#233; par l&#8217;int&#233;r&#234;t
port&#233; r&#233;cemment &#224; ce type de grammaire, et comble un manque dans la litt&#233;rature existante.
</p>
<p>Abstract. We present several different parsing algorithms for Range Concatenation Gram-
mar (RCG), inter alia an entirely novel Earley-style algorithm, using the deductive parsing fra-
mework. Our work is motivated by recent interest in range concatenation grammar in general
and fills a gap in the existing literature.
</p>
<p>Mots-cl&#233;s : Analyse syntaxique d&#233;ductive, grammaires &#224; concat&#233;nation d&#8217;intervalles.
Keywords: Deductive parsing, range concatenation grammar.
</p>
<p>1 Introduction
</p>
<p>Les grammaires &#224; concat&#233;nation d&#8217;intervalles (RCG) (Boullier, 2000) ont r&#233;cemment re&#231;u une
attention particuli&#232;re dans diff&#233;rents contextes de travail. Ceux-ci incluent la traduction auto-
matique dirig&#233;e par la syntaxe (S&#248;gaard, 2008), le d&#233;veloppement de grammaires (Sagot, 2005)
ou encore l&#8217;extraction de grammaires &#224; partir de treebanks (Maier &amp; S&#248;gaard, 2008).
En outre, d&#8217;un point de vue formel, les RCGs sont int&#233;ressantes car elles g&#233;n&#232;rent exactement
la classe des langages analysables en un temps polyn&#244;mial (Bertsch &amp; Nederhof, 2001). En
particulier, elles sont plus puissantes que la classe des RCGs &#171; simples &#187;, une sous-classe de
RCG qui est &#233;quivalente aux syst&#232;mes de r&#233;&#233;criture hors-contexte lin&#233;aires (Linear Context-
Free rewriting Systems, LCFRS), aux grammaires d&#8217;arbres adjoints multi-composantes locales
aux arbres (Set-Local Multi-Component Tree-Adjoining Grammars, SL-MCTAG) (Weir, 1988)
et aux grammaires hors-contexte multiples (Multiple Context-Free Grammars, MCFG) (Seki
et al., 1991) (les preuves sont donn&#233;es par Boullier (1998)). Or, il a &#233;t&#233; d&#233;montr&#233; que cette
derni&#232;re classe des RCGs simples est incapable de traiter certains ph&#233;nom&#232;nes de la langue
naturelle, comme par exemple la permutation d&#8217;arguments dans le &#171; brouillage &#187; (scrambling)
des langues dites &#224; ordre des mots libres (Becker et al., 1992), ou encore les constructions non</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Wolfgang Maier et Yannick Parmentier
</p>
<p>semi-lin&#233;aires telles que l&#8217;empilement de cas en g&#233;orgien ancien (Michaelis &amp; Kracht, 1996),
et les nombres chinois (Radzinski, 1991), ph&#233;nom&#232;nes que les RCGs peuvent traiter (Boullier,
1999).
Aussi, des algorithmes d&#8217;analyse pour RCG ont &#233;t&#233; pr&#233;sent&#233;s par (i) Boullier (2000), qui d&#233;finit
un algorithme d&#8217;analyse descendante directionnelle, et (ii) Barth&#233;lemy et al. (2001), qui ajoutent
un oracle &#224; l&#8217;algorithme de Boullier afin de limiter l&#8217;espace de recherche. La classe des RCGs
simples a re&#231;u une plus grande attention, comme en t&#233;moignent les travaux sur l&#8217;analyse &#224; base
d&#8217;automates de De La Clergerie (2002), ceux sur l&#8217;analyse d&#233;ductive de LCFRS de Burden et
Ljungl&#246;f (2005), ou encore l&#8217;approche de Kanazawa (2008) pour l&#8217;analyse de MCFG au moyen
de Datalog.
</p>
<p>Dans cet article, nous ne pr&#233;tendons pas motiver l&#8217;utilisation des RCGs (pour cela, se r&#233;f&#233;rer aux
articles sus-cit&#233;s), mais cherchons plut&#244;t &#224; combler un manque dans la litt&#233;rature sur les algo-
rithmes d&#8217;analyse pour RCG non-simples. Plus pr&#233;cis&#233;ment, nous fournissons une formulation
de l&#8217;analyse de la classe enti&#232;re des RCGs dans le cadre de l&#8217;analyse par d&#233;duction. Nous pr&#233;-
sentons dans un m&#234;me cadre des algorithmes descendants, des algorithmes de type CYK, et un
algorithme de type Earley, facilitant ainsi une comparaison des diff&#233;rentes strat&#233;gies d&#8217;analyse.
Pour profiter pleinement de cette comparaison, il est utile d&#8217;avoir des connaissances en analyse
d&#233;ductive, et notamment des r&#232;gles de d&#233;duction du type de celles pr&#233;sent&#233;es par Shieber et
al. (1995). L&#8217;article est structur&#233; comme suit. En Section 2, nous introduisons les notions pr&#233;li-
minaires n&#233;cessaires. En Section 3, nous introduisons les algorithmes descendants, en Section 4
les algorithmes de type CYK et en Section 5 un algorithme de type Earley. Nous terminons en
donnant quelques chiffres sur l&#8217;efficacit&#233; relative des ces algorithmes.
</p>
<p>2 Notions pr&#233;liminaires
</p>
<p>Les RCGs sont des grammaires dont les productions (appel&#233;es clauses) r&#233;&#233;crivent des pr&#233;dicats
couvrant certaines parties de la phrase en d&#8217;autres pr&#233;dicats. Par exemple, une clause de la forme
S(aXb) &#8594; S(X) indique qu&#8217;un pr&#233;dicat S est vrai pour une partie de la phrase si cette partie
commence par un a et finit par un b, et si, de plus, S est &#233;galement vrai pour la portion de phrase
comprise entre a et b. Une clause S(c) &#8594; &#491; indique que S est vrai pour tout terminal c, sans
autre condition. La RCG ayant les deux clauses S(aXb) &#8594; S(X), S(c)&#8594; &#491; g&#233;n&#232;re le langage
{ancbn |n &#8805; 0}.
</p>
<p>Dans cet article, nous nous int&#233;ressons uniquement aux RCG positives car elles correspondent
&#224; la variante utilis&#233;e dans les travaux sus-mentionn&#233;s. Les RCG non-positives, appel&#233;es RCG
n&#233;gatives, permettent l&#8217;utilisation de pr&#233;dicats n&#233;gatifs de la forme A(&#945;1, . . . , &#945;n). De tels pr&#233;-
dicats permettent de reconna&#238;tre le langage compl&#233;mentaire de celui g&#233;n&#233;r&#233; au moyen des pr&#233;-
dicats positifs correspondants (voir Boullier (2000) pour plus de d&#233;tails).
D&#233;finition 1 (Grammaire &#224; concat&#233;nation d&#8217;intervalle). Une grammaire &#224; concat&#233;nation d&#8217;in-
tervalle (RCG) est un 5-uplet G = &#12296;N, T, V, P, S&#12297;. N est un ensemble fini de noms de pr&#233;dicats,
avec une fonction d&#8217;arit&#233; d&#233;finie comme suit : dim: N &#8594; N \ {0}, T et V sont des ensembles
finis de symboles terminaux et de variables respectivement. P est un ensemble fini de clauses de
la forme &#968;0 &#8594; &#968;1 . . . &#968;m, o&#249; m &#8805; 0 et chacun des &#968;i, 0 &#8804; i &#8804; m, est un pr&#233;dicat de la forme
Ai(&#945;1, . . . , &#945;dim(Ai)) avec Ai &#8712; N et &#945;j &#8712; (T &#8746; V )
</p>
<p>&#8727; pour 1 &#8804; j &#8804; dim(Ai). Comme raccourci
de notation pour Ai(&#945;1, . . . , &#945;dim(Ai)), nous utilisons Ai(~&#945;). S &#8712; N est le nom du pr&#233;dicat de
d&#233;part, tel que dim(S) = 1.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Un Algorithme d&#8217;Analyse de Type Earley pour Grammaires &#224; Concat&#233;nation d&#8217;Intervalles
</p>
<p>Le concept d&#8217;intervalle est primordial pour les RCG. Nous d&#233;finissons ce concept et celui de
vecteur d&#8217;intervalle ci-dessous.
</p>
<p>D&#233;finition 2 (Intervalle). Pour tout w &#8712; T &#8727;, o&#249; w = w1 . . . wn avec wi &#8712; T pour 1 &#8804; i &#8804; n,
nous d&#233;finissons :
&#8211; Pos(w) := {0, . . . , n}.
&#8211; Une paire &#12296;l, r&#12297; &#8712; Pos(w) &#215; Pos(w) avec l &#8804; r est un intervalle dans w. Sa production
&#12296;l, r&#12297;(w) est la sous-cha&#238;ne wl+1 . . . wr.
</p>
<p>&#8211; Pour deux intervalles &#961;1 = &#12296;l1, r1&#12297;, &#961;2 = &#12296;l2, r2&#12297; : si r1 = l2, alors &#961;1 &#183; &#961;2 = &#12296;l1, r2&#12297; ; sinon
&#961;1 &#183; &#961;2 n&#8217;est pas d&#233;fini.
</p>
<p>D&#233;finition 3 (Vecteur d&#8217;intervalles). Pour un w &#8712; T &#8727; donn&#233;, nous appelons un vecteur &#966; =
(&#12296;x1, y1&#12297;, . . . , &#12296;xk, yk&#12297;) vecteur d&#8217;intervalles de dimension k dans w si &#12296;xi, yi&#12297; est un intervalle
dans w pour 1 &#8804; i &#8804; k. &#966;(i).l (resp. &#966;(i).r) d&#233;note alors le premier (resp. second) composant
du ie &#233;l&#233;ment de &#966;, c&#8217;est-&#224;-dire xi (resp. yi).
</p>
<p>Afin d&#8217;instancier une clause de la grammaire, nous avons besoin de d&#233;terminer les intervalles
couverts par toutes les variables dans la clause, et de toutes les occurrences de symboles ter-
minaux. Par souci de clart&#233;, nous supposons que les variables d&#8217;une clause et les occurrences
de symboles terminaux sont &#233;quip&#233;es d&#8217;indices distincts, commen&#231;ant &#224; 1, ordonn&#233;s de gauche
&#224; droite, et tels que, pour les variables, seule la premi&#232;re occurrence donne lieu &#224; un nouvel
indice. Nous introduisons alors une fonction &#933; : P &#8594; N retournant l&#8217;indice maximal dans une
clause. De plus, nous d&#233;finissons &#933;(c, x) pour une clause c et une variable ou une occurrence
d&#8217;un terminal x donn&#233;s comme &#233;tant l&#8217;indice de x dans c.
</p>
<p>D&#233;finition 4 (Instanciation de clause). Une instanciation d&#8217;une clause c &#8712; P avec &#933;(c) =
j par rapport &#224; une cha&#238;ne w est donn&#233;e par le vecteur d&#8217;intervalles &#966; avec dim(&#966;) = j.
L&#8217;application de &#966; &#224; un pr&#233;dicat A(~&#945;) dans c associe toutes les occurrences de x &#8712; (T &#8746; V )
avec &#933;(c, x) = i dans ~&#945; &#224; &#966;(i). Si le r&#233;sultat est d&#233;fini (c&#8217;est-&#224;-dire, les images de variables
adjacentes peuvent &#234;tre concat&#233;n&#233;es), celui-ci est appel&#233; un pr&#233;dicat instanci&#233; et le r&#233;sultat de
l&#8217;application de &#966; &#224; tous les pr&#233;dicats dans c, s&#8217;il est d&#233;fini, est appel&#233; une clause instanci&#233;e.
</p>
<p>En plus des vecteurs d&#8217;intervalles, nous introduisons &#233;galement des vecteurs de contraintes
d&#8217;intervalle. Ceux-ci sont des vecteurs contenant des paires compos&#233;es de variables d&#8217;extr&#233;mit&#233;
d&#8217;intervalle, et un ensemble de contraintes sur ces variables.
</p>
<p>D&#233;finition 5 (Vecteur de contraintes d&#8217;intervalles). Soit Vr = {r1, r2, . . .} un ensemble de va-
riables d&#8217;extr&#233;mit&#233; d&#8217;intervalle.
</p>
<p>Un vecteur de contraintes d&#8217;intervalles de dimension k est une paire &#12296;~&#961;, C&#12297; o&#249;
&#8211; &#961; &#8712; (V 2r )
</p>
<p>k ; nous d&#233;finissons Vr(&#961;) comme l&#8217;ensemble des variables d&#8217;extr&#233;mit&#233; d&#8217;intervalle
apparaissant dans ~&#961;.
</p>
<p>&#8211; C est un ensemble de contraintes cr ayant l&#8217;une des formes suivantes :
r1 = r2, k = r1, r1 + k = r2, k &#8804; r1, r1 &#8804; k, r1 &#8804; r2 ou r1 + k &#8804; r2
pour r1, r2 &#8712; Vr(&#961;) et k &#8712; N.
</p>
<p>Nous disons qu&#8217;un vecteur d&#8217;intervalles &#966; satisfait un vecteur de contraintes d&#8217;intervalles &#12296;&#961;, C&#12297;
ssi &#966; et &#961; ont la m&#234;me dimension k et qu&#8217;il existe une fonction f : Vr &#8594; N associant &#961;(i).l
&#224; &#966;(i).l et &#961;(i).r &#224; &#966;(i).r pour tout 1 &#8804; i &#8804; k telle que toutes les contraintes dans C soient
satisfaites. De plus, nous disons qu&#8217;un vecteur de contraintes d&#8217;intervalles &#12296;&#961;, C&#12297; est satisfiable
ssi il existe un vecteur d&#8217;intervalles &#966; qui le satisfait.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Wolfgang Maier et Yannick Parmentier
</p>
<p>D&#233;finition 6 (Vecteur de contraintes d&#8217;intervalles d&#8217;une clause). Pour toute clause c, nous d&#233;fi-
nissons son vecteur de contraintes d&#8217;intervalles &#12296;&#961;, C&#12297; par rapport &#224; une cha&#238;ne w avec |w| = n
comme suit :
&#8211; &#961; a pour dimension &#933;(c), et toutes les variables d&#8217;extr&#233;mit&#233; d&#8217;intervalle dans &#961; sont diff&#233;-
</p>
<p>rentes deux &#224; deux.
&#8211; Pour tout &#12296;r1, r2&#12297; &#8712; &#961; : 0 &#8804; r1, r1 &#8804; r2, r2 &#8804; n &#8712; C.
</p>
<p>Pour toutes les occurrences x de terminaux dans c avec i = &#933;(c, x) : &#961;(i).l+1 = &#961;(i).r &#8712; C.
Pour toutes x, y qui sont des variables ou des occurrences de terminaux dans c telles que xy
est une sous-cha&#238;ne d&#8217;un des arguments de c : &#961;(&#933;(c, x)).r = &#961;(&#933;(c, y)).l &#8712; C.
Ce sont toutes les contraintes dans C.
</p>
<p>Intuitivement, un vecteur de contraintes d&#8217;intervalles d&#8217;une clause capture toute l&#8217;information
sur les extr&#233;mit&#233;s formant un intervalle, sur les intervalles contenant un unique terminal, et sur
les occurrences de variables / terminaux adjacentes dans la clause.
Une d&#233;rivation RCG consiste en la r&#233;&#233;criture de pr&#233;dicats instanci&#233;s :
D&#233;finition 7 (D&#233;rivation). &#201;tant donn&#233; une RCG G et une cha&#238;ne d&#8217;entr&#233;e w, nous d&#233;finissons
la relation &#8658;G,w (appel&#233;e d&#233;rive) sur les cha&#238;nes des pr&#233;dicats instanci&#233;s de la mani&#232;re sui-
vante. Soient &#915;1,&#915;2 des cha&#238;nes de pr&#233;dicats instanci&#233;s. Si A0( ~&#945;0) &#8594; A1( ~&#945;1) . . . Am( ~&#945;m) est
l&#8217;instanciation d&#8217;une clause c &#8712; PG, alors &#915;1A0( ~&#945;0)&#915;2 &#8658;G,w &#915;1A1( ~&#945;1) . . . Am( ~&#945;m)&#915;2.
</p>
<p>Intuitivement, si le membre de gauche d&#8217;une clause instanci&#233;e appara&#238;t dans la cha&#238;ne de pr&#233;di-
cats instanci&#233;s, il peut &#234;tre remplac&#233; par son membre de droite.
D&#233;finition 8 (Langage). Le langage d&#8217;une RCG G est l&#8217;ensemble des cha&#238;nes qui peuvent &#234;tre
r&#233;duites au mot vide : L(G) = {w | S(&#12296;0, |w|&#12297;) +&#8658;G,w &#491;}.
</p>
<p>La capacit&#233; g&#233;n&#233;rative des RCGs d&#233;passe celle des formalismes l&#233;g&#232;rement sensibles au contexte.
Par exemple, on peut consid&#233;rer la RCG G = &#12296;{S, eq}, {a}, {X, Y }, P, S&#12297; avecP = {S(XY ) &#8594;
S(X)eq(X, Y ), S(a) &#8594; &#491;, eq(aX, aY ) &#8594; eq(X, Y ), eq(a, a) &#8594; &#491;}. Il est facile de constater
que L(G) = {a2n | n &#8805; 0}. Ce langage n&#8217;est pas l&#233;g&#232;rement sensible au contexte car il n&#8217;a pas
la propri&#233;t&#233; de croissance constante.
</p>
<p>Par souci de clart&#233;, nous supposons dans ce qui suit, sans perte de g&#233;n&#233;ralit&#233;, que les arguments
vides (&#491;) apparaissent uniquement dans les clauses dont les membres de droite sont vides.1
</p>
<p>3 Analyse descendante
</p>
<p>Analyse descendante non-directionnelle L&#8217;id&#233;e de l&#8217;analyse descendante est d&#8217;instancier le
pr&#233;dicat de d&#233;part par rapport &#224; la cha&#238;ne d&#8217;entr&#233;e toute enti&#232;re et de v&#233;rifier r&#233;cursivement s&#8217;il
existe un moyen de r&#233;duire tous les pr&#233;dicats des membres de droite &#224; &#491;.
</p>
<p>Les items ont la forme [A, &#966;,flag ], o&#249; A est un pr&#233;dicat, &#966; est un vecteur d&#8217;intervalles de di-
mension dim(A) (contenant les intervalles avec lesquels sont instanci&#233;s les arguments de A) et
flag &#8712; {c, p} indique si l&#8217;item a &#233;t&#233; compl&#233;t&#233; ou pr&#233;dit.
</p>
<p>1Toute RCG peut &#234;tre transform&#233;e en une RCG satisfaisant cette condition : pour cela, il suffit d&#8217;introduire un
nouveau pr&#233;dicat unaire Eps et une clause Eps(&#491;) &#8594; &#491;, puis, pour chaque clause x dont le membre de droite n&#8217;est
pas &#491;, de remplacer chaque argument &#491; qui appara&#238;t dans c par une nouvelle variable X&#491; et d&#8217;ajouter le pr&#233;dicat
Eps(X&#491;) au membre de droite de c.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Un Algorithme d&#8217;Analyse de Type Earley pour Grammaires &#224; Concat&#233;nation d&#8217;Intervalles
</p>
<p>Comme axiome, nous pr&#233;disons S couvrant toute la cha&#238;ne d&#8217;entr&#233;e. Ainsi, la r&#232;gle initialisa-
tion est la suivante :
</p>
<p>[S, (&#12296;0, n&#12297;), p]
</p>
<p>L&#8217;op&#233;ration pr&#233;diction pr&#233;dit de nouveaux items &#224; partir des items pr&#233;c&#233;demment pr&#233;dits :
[A0, &#966;, p]
</p>
<p>[A1, &#966;1, p] . . . [Ak, &#966;k, p]
</p>
<p>s&#8217;il existe une clause A0(~x0) &#8594; A1(~x1) . . . Ak(~xk) avec une instanciation &#968; telle que &#968;(c) =
A(&#966;)&#8594; A1(&#966;1) . . . Ak(&#966;k).
</p>
<p>Puisque, &#224; la diff&#233;rence de l&#8217;analyse descendante standard pour grammaires hors-contexte, nous
commen&#231;ons avec l&#8217;int&#233;gralit&#233; de la cha&#238;ne d&#8217;entr&#233;e &#224; l&#8217;initialisation, nous avons besoin d&#8217;un
moyen pour propager l&#8217;information sur les pr&#233;dicats instanci&#233;s. Ceci se fait via un flag p/c, dont
la valeur est donn&#233;e par les op&#233;rations de lecture et de compl&#233;tion. L&#8217;op&#233;ration de lecture met
la valeur du flag &#224; c pour un item d&#233;crivant un pr&#233;dicat pr&#233;alablement pr&#233;dit :
</p>
<p>[A, &#966;, p]
[A, &#966;, c]
</p>
<p>s&#8217;il existe une clause c = A(~x) &#8594; &#491; avec une instanciation &#968; telle que &#968;(A(~x)) = A(&#966;). La
r&#232;gle de compl&#233;tion met le flag &#224; c pour un pr&#233;dicat d&#8217;un membre de droite compl&#233;t&#233; :
</p>
<p>[A0, &#966;, p], [A1, &#966;1, c] . . . [Ak, &#966;k, c]
[A0, &#966;, c]
</p>
<p>La reconnaissance r&#233;ussit s&#8217;il existe un moyen de d&#233;clarer que le pr&#233;dicat de d&#233;part est compl&#233;t&#233;.
Pour cela, nous utilisons un item but : [S, (&#12296;0, n&#12297;), c].
</p>
<p>Analyse descendante directionnelle L&#8217;algorithme ci-dessus peut &#234;tre am&#233;lior&#233; en &#233;valuant les
pr&#233;dicats d&#8217;un membre de droite de mani&#232;re ordonn&#233;e (de gauche &#224; droite), et en interrompant
l&#8217;&#233;valuation d&#232;s qu&#8217;une instanciation de pr&#233;dicat &#233;choue. Cette variante correspond &#224; l&#8217;algo-
rithme pr&#233;sent&#233; dans Boullier (2000).2 Aussi, nous devons distinguer les items passifs des items
actifs. Les items passifs ont les m&#234;mes forme et signification que les items de l&#8217;algorithme non-
directionnel pr&#233;sent&#233; pr&#233;c&#233;demment. Les items actifs permettent de d&#233;placer un signet (appel&#233;
dot) le long d&#8217;un membre de droite d&#8217;une clause : [A(~x) &#8594; &#934; &#8226; &#936;, &#966;] o&#249; A(~x) &#8594; &#934;&#936; est
une clause et &#966; est un vecteur d&#8217;intervalles de dimension j = &#933;(A(~x) &#8594; &#934;&#936;) qui fournit
l&#8217;instanciation de la clause.
</p>
<p>L&#8217;axiome est la pr&#233;diction du pr&#233;dicat de d&#233;part couvrant toute la cha&#238;ne d&#8217;entr&#233;e. Ainsi la r&#232;gle
initialisation est la m&#234;me que celle de l&#8217;algorithme non-directionnel. L&#8217;item but ne change pas
non plus. Nous avons &#224; pr&#233;sent deux op&#233;rations de pr&#233;diction. La premi&#232;re, pr&#233;diction-r&#232;gle,
pr&#233;dit des items actifs avec leur dot au d&#233;but de leur membre de droite, pour un item passif
pr&#233;dit donn&#233; :
</p>
<p>[A,&#968;, p]
[A(~x) &#8594; &#8226;&#936;, &#966;]
</p>
<p>avec &#966;(A(~x)) = A(&#968;)
</p>
<p>La seconde, pr&#233;diction-pr&#233;d, pr&#233;dit un item passif pour un pr&#233;dicat suivant le dot dans un item
actif :
</p>
<p>[A(~x)&#8594; &#934; &#8226;B(~y)&#936;, &#966;]
[B,&#968;, p]
</p>
<p>avec &#966;(B(~y)) = B(&#968;)
</p>
<p>2Notons que cet algorithme n&#8217;est pas celui implant&#233; dans le syst&#232;me SYNTAX d&#233;velopp&#233; par Boullier et al.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Wolfgang Maier et Yannick Parmentier
</p>
<p>L&#8217;op&#233;ration de lecture est la m&#234;me que dans le cas non-directionnel. L&#8217;op&#233;ration de compl&#233;tion
d&#233;place le dot au-dessus d&#8217;un pr&#233;dicat dans le membre de droite d&#8217;un item actif si l&#8217;item passif
correspondant a &#233;t&#233; compl&#233;t&#233; :
</p>
<p>[B, &#966;B, c], [A(~x) &#8594; &#934; &#8226;B(~y)&#936;, &#966;]
[A(~x) &#8594; &#934;B(~y) &#8226;&#936;, &#966;]
</p>
<p>avec &#966;(B(~y)) = B(&#966;B)
</p>
<p>Une fois que le dot a atteint la fin du membre de droite, nous pouvons effectuer une conversion
de l&#8217;item actif en un item passif compl&#233;t&#233; :
</p>
<p>[A(~x)&#8594; &#934;&#8226;, &#966;]
[A,&#968;, c]
</p>
<p>avec &#966;(A(~x)) = A(&#968;)
</p>
<p>Un probl&#232;me &#233;vident de cet algorithme est que la r&#232;gle pr&#233;diction-r&#232;gle doit calculer toutes les
instanciations possibles des clauses correspondant &#224; un pr&#233;dicat instanci&#233; donn&#233;. Prenons par
exemple la RCG pour {a2n |n &#8805; 0} de la Section 2. Si w = aaaa, &#224; partir de [S, (&#12296;0, 4&#12297;), p]
pr&#233;diction-r&#232;gle pr&#233;dirait (entre autres) tous les items actifs [S(X1Y2) &#8594; &#8226;S(X1)eq(X1, Y2),
(&#12296;0, r&#12297;, &#12296;r, 4&#12297;)] avec r &#8712; {0, 1, 2, 3, 4}. Le calcul de toutes les instanciations possibles est tr&#232;s
co&#251;teux, et va &#234;tre &#233;vit&#233; dans l&#8217;algorithme de type Earley pr&#233;sent&#233; en Section 5. En effet, dans
ce dernier, nous utiliserons des vecteurs de contraintes d&#8217;intervalles (au lieu de vecteurs d&#8217;inter-
valles) pour ne pr&#233;dire qu&#8217;un seul item actif :
</p>
<p>[S(X1Y2)&#8594; &#8226;S(X1)eq(X1, Y2), &#12296;&#12296;(r1, r2), (r3, r4)&#12297;, {0 = r1, r1 &#8804; r2, r2 = r3, r3 &#8804; r4, 4 = r4}&#12297;]
</p>
<p>4 Analyse ascendante
</p>
<p>Analyse CYK L&#8217;analyse CYK (Cocke, Younger, Kasami) est une technique d&#8217;analyse ascen-
dante non-directionnelle. Les items ont la forme [A, &#966;] o&#249; A est un pr&#233;dicat et &#966; un vecteur
d&#8217;intervalles de dimension dim(A).
R&#232;gle de lecture:
</p>
<p>[A, &#966;]
</p>
<p>s&#8217;il existe une clause c = A(~x) &#8594; &#491; avec une instanciation &#968; telle que &#968;(A(~x)) = A(&#966;).
R&#232;gle de compl&#233;tion:
</p>
<p>[A1, &#966;1] . . . [Ak, &#966;k]
[A, &#966;]
</p>
<p>o&#249; A(&#966;)&#8594; A1(&#966;1) . . . Ak(&#966;k) est une clause instanci&#233;e.
</p>
<p>L&#8217;item but est : [S, (&#12296;0, n&#12297;)].
</p>
<p>Analyse ascendante directionnelle Un d&#233;savantage &#233;vident de l&#8217;algorithme CYK est que, afin
de r&#233;aliser une op&#233;ration de compl&#233;tion, tous les A1, . . . , Ak du membre de droite doivent &#234;tre
v&#233;rifi&#233;s pour les items correspondants. Ce qui m&#232;ne &#224; un grand nombre d&#8217;indices qui doivent
&#234;tre v&#233;rifi&#233;s en m&#234;me temps. Pour &#233;viter cela, nous pouvons &#224; nouveau d&#233;placer un signet le
long du membre de droite d&#8217;une clause. Comme dans le cas descendant directionnel, en plus
des items ci-dessus (appel&#233;s items passifs), nous ajoutons des items actifs. Dans les items actifs,
nous gardons une trace des positions d&#233;j&#224; d&#233;termin&#233;es pour les extr&#233;mit&#233;s gauche et droite des
occurrences de variables et terminaux. Ceci est r&#233;alis&#233; par l&#8217;enrichissement des items li&#233;s &#224; la</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Un Algorithme d&#8217;Analyse de Type Earley pour Grammaires &#224; Concat&#233;nation d&#8217;Intervalles
</p>
<p>Grammaire G : S(XY ) &#8594; S(X)eq(X,Y ), S(a1) &#8594; &#491;, eq(a1X, a2Y ) &#8594; eq(X,Y ), eq(a1, a2) &#8594; &#491;
Items g&#233;n&#233;r&#233;s pour la cha&#238;ne w = aa (les contraintes 0 &#8804; r1, r2 &#8804; n pour un intervalle &#12296;r1, r2&#12297; sont omises) :
</p>
<p>Item Op&#233;ration
1. [S, (&#12296;0, 1&#12297;)] lecture S(a1) &#8594; &#491;
2. [S, (&#12296;1, 2&#12297;)] lecture S(a1) &#8594; &#491;
3. [eq, (&#12296;0, 1&#12297;, &#12296;0, 1&#12297;)] lecture eq(a1, a2) &#8594; &#491;
4. [eq, (&#12296;0, 1&#12297;, &#12296;1, 2&#12297;)] lecture eq(a1, a2) &#8594; &#491;
5. [eq, (&#12296;1, 2&#12297;, &#12296;0, 1&#12297;)] lecture eq(a1, a2) &#8594; &#491;
6. [eq, (&#12296;1, 2&#12297;, &#12296;1, 2&#12297;)] lecture eq(a1, a2) &#8594; &#491;
7. [S(XY ) &#8594; &#8226;S(X)eq(X,Y ), {X.l &#8804; X.r,X.r = Y.l, Y.l &#8804; Y.r}] initialisation,
8. [eq(a1X, a2Y ) &#8594; &#8226;eq(X,Y ),
</p>
<p>{a1.l + 1 = a1.r, a1.r = X.l,X.l &#8804; X.r, a2.l + 1 = a2.r, a2.r = Y.l, Y.l &#8804; Y.r}]initialisation
9. [S(XY ) &#8594; S(X) &#8226; eq(X,Y ), &#12296;{. . . , 0 = X.l, 1 = X.r}] compl&#233;tion 7. avec 1.
10. [S(XY ) &#8594; S(X) &#8226; eq(X,Y ), {. . . , 1 = X.l, 2 = X.r}] compl&#233;tion 7. avec 2.
11. [eq(a1X, a2Y ) &#8594; eq(X,Y )&#8226;, {. . . , 1 = X.l, 2 = X.r, 1 = Y.l, 2 = Y.r}] compl&#233;tion 8. avec 6.
12. [S(XY ) &#8594; S(X)eq(X,Y )&#8226;, {. . . , 0 = X.l, 1 = X.r, 1 = Y.l, 2 = Y.r}] compl&#233;tion 9. avec 4.
13. [eq, (&#12296;0, 2&#12297;, &#12296;0, 2&#12297;)] conversion 11.
14. [S, (&#12296;0, 1&#12297;, &#12296;1, 2&#12297;)] conversion 12.
</p>
<p>FIG. 1 &#8211; Trace d&#8217;une analyse CYK directionnelle.
</p>
<p>clause. Les items actifs ont la forme [A(~x) &#8594; &#934; &#8226; &#936;, &#12296;&#961;, C&#12297;] avec A(~x) &#8594; &#934;&#936; une clause,
&#934;&#936; 6= &#491;, &#933;(A(~x &#8594; &#934;&#936;)) = j et &#12296;&#961;, C&#12297; un vecteur de contraintes d&#8217;intervalles de dimension
j. Nous imposons que &#12296;&#961;, C&#12297; doit &#234;tre satisfiable. Les items qui diff&#232;rent uniquement par une
bijection des variables d&#8217;intervalles sont consid&#233;r&#233;s comme &#233;quivalents.
La r&#232;gle de lecture et celle de but sont les m&#234;mes que dans le cas non-directionnel. En outre,
la r&#232;gle initialisation introduit des clauses dont le dot est au d&#233;but du membre de droite :
</p>
<p>[A(~x) &#8594; &#8226;&#934;, &#12296;&#961;, C&#12297;]
</p>
<p>A(~x) &#8594; &#934; &#233;tant une clause avec pour vecteur de contraintes d&#8217;intervalles &#12296;&#961;, C&#12297;,&#934; 6= &#491;.
</p>
<p>La r&#232;gle de compl&#233;tion d&#233;place le dot au-dessus d&#8217;un pr&#233;dicat dans le membre de droite d&#8217;un
item actif si l&#8217;item passif correspondant a &#233;t&#233; compl&#233;t&#233; :
</p>
<p>[B, &#966;B],
[A(~x)&#8594; &#934; &#8226;B(x1...y1, ..., xk...yk)&#936;, &#12296;&#961;, C&#12297;]
[A(~x) &#8594; &#934;B(x1...y1, ..., xk...yk) &#8226;&#936;, &#12296;&#961;, C
</p>
<p>&#8242;&#12297;]
</p>
<p>o&#249; C &#8242; = C &#8746; {&#966;B(j).l = &#961;(&#933;(xj)).l, &#966;B(j).r = &#961;(&#933;(yj)).r | 1 &#8804; j &#8804; k}. Notons que les
conditions sur les items n&#233;cessitent que le nouvel ensemble de contraintes pour &#961; soit satisfiable.
</p>
<p>La r&#232;gle de conversion convertit un item actif dont le dot est &#224; la fin du membre de droite en un
item passif compl&#233;t&#233; :
</p>
<p>[A(~x) &#8594; &#936;&#8226;, &#12296;&#961;, C&#12297;]
[A, &#966;]
</p>
<p>s&#8217;il existe une instanciation &#968; de A(~x)&#8594; &#936; qui satisfasse &#12296;&#961;, C&#12297; tel que &#968;(A(~x)) = A(&#966;).
</p>
<p>Un exemple de trace d&#8217;ex&#233;cution est donn&#233; en Fig. 1. Par souci de clart&#233;, au lieu de variables
d&#8217;intervalles, nous utilisons X.l (resp. X.r) pour l&#8217;extr&#233;mit&#233; gauche (resp. droite) de l&#8217;intervalle
associ&#233; &#224; X .</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Wolfgang Maier et Yannick Parmentier
</p>
<p>5 Algorithme de type Earley
</p>
<p>R&#232;gles de d&#233;duction Nous ajoutons &#224; pr&#233;sent une op&#233;ration de pr&#233;diction &#224; l&#8217;algorithme CYK
avec items actifs, ce qui conduit &#224; un algorithme de type Earley. Les items passifs sont enrichis
avec un flag additionnel qui peut prendre les valeur p ou c selon que l&#8217;item est pr&#233;dit ou com-
pl&#233;t&#233;. De plus, ils contiennent un vecteur de contraintes d&#8217;intervalles puisque, lorsqu&#8217;on pr&#233;dit
un pr&#233;dicat, les extr&#233;mit&#233;s gauche et droite de ses arguments peuvent ne pas &#234;tre connues.
</p>
<p>Les items passifs ont soit la forme [A, &#12296;&#961;, C&#12297;, p] pour les items pr&#233;dits, o&#249; &#12296;&#961;, C&#12297; est un vecteur
de contraintes d&#8217;intervalles de dimension dim(A), soit la forme [A, &#966;, c] pour les items com-
pl&#233;t&#233;s o&#249; &#966; est un vecteur d&#8217;intervalles de dimension dim(A). Les items actifs sont les m&#234;mes
que dans le cas CYK. L&#8217;axiome est la pr&#233;diction d&#8217;un pr&#233;dicat S couvrant la cha&#238;ne d&#8217;entr&#233;e,
c&#8217;est-&#224;-dire, la r&#232;gle initialisation est la suivante :
</p>
<p>[S, &#12296;(&#12296;r1, r2&#12297;), {0 = r1, n = r2}&#12297;, p]
</p>
<p>Nous avons deux op&#233;rations de pr&#233;diction. La premi&#232;re, pr&#233;diction-r&#232;gle, pr&#233;dit des items
actifs avec le dot au d&#233;but de leur membre de droite, pour un item passif pr&#233;dit donn&#233; :
</p>
<p>[A, &#12296;&#961;, C&#12297;, p]
[A(x1 . . . y1, . . . , xk . . . yk) &#8594; &#8226;&#936;, &#12296;&#961;
</p>
<p>&#8242;, C &#8242;&#12297;]
</p>
<p>o&#249; &#12296;&#961;&#8242;, C &#8242;&#12297; est obtenu &#224; partir du vecteur de contraintes d&#8217;intervalles de la clause
A(x1 . . . y1, . . . , xk . . . yk) &#8594; &#936; en prenant toutes les contraintes de C, en associant tous les
&#961;(i).l &#224; &#961;&#8242;(&#933;(xi)).l et tous les &#961;(i).r &#224; &#961;&#8242;(&#933;(yi)).r, et en ajoutant les contraintes r&#233;sultant au
vecteur de contraintes de la clause. La seconde op&#233;ration, pr&#233;diction-pred, pr&#233;dit un item passif
pour le pr&#233;dicat suivant le dot dans un item actif :
</p>
<p>[A(...) &#8594; &#934; &#8226;B(x1...y1, ..., xk...yk)&#936;, &#12296;&#961;, C&#12297;]
[B, &#12296;&#961;&#8242;, C &#8242;&#12297;, p]
</p>
<p>o&#249; &#961;&#8242;(i).l = &#961;(&#933;(xi)).l, &#961;&#8242;(i).r = &#961;(&#933;(yi)).r pour tout 1 &#8804; i &#8804; k et C &#8242; = {c | c &#8712; C, c ne
contient que des variables d&#8217;intervalles de &#961;&#8242;}. L&#8217;op&#233;ration lecture peut &#234;tre appliqu&#233;e si un
pr&#233;dicat pr&#233;dit peut &#234;tre d&#233;riv&#233; par une &#491;-clause :
</p>
<p>[A, &#12296;&#961;, C&#12297;, p]
[A, &#966;, c]
</p>
<p>s&#8217;il existe une clause A(~x)&#8594; &#491; avec une instanciation possible &#968; qui satisfasse &#12296;&#961;, C&#12297; telle que
&#968;(A(~x)) = A(&#966;).
</p>
<p>Finalement, les r&#232;gles de compl&#233;tion, de conversion sont celles de l&#8217;algorithme CYK avec
items actifs &#224; ceci pr&#232;s que nous ajoutons des flags c aux items passifs apparaissant dans ces
r&#232;gles. L&#8217;item but est le m&#234;me que pr&#233;c&#233;demment. La Fig. 2 illustre cet algorithme avec la RCG
et la cha&#238;ne d&#8217;entr&#233;e d&#233;finies dans l&#8217;exemple de la Fig. 1.
</p>
<p>Correction et compl&#233;tude Il est ais&#233; de constater que l&#8217;algorithme de type Earley est &#224; la fois
correct et complet. Plus pr&#233;cis&#233;ment, si un item compl&#233;t&#233; est g&#233;n&#233;r&#233;, alors le pr&#233;dicat corres-
pondant peut &#234;tre d&#233;riv&#233; : [A,&#968;, c] &#8658; A(&#968;). De plus, si on peut d&#233;river un constituant A(&#968;),
alors on peut &#233;galement g&#233;n&#233;rer l&#8217;item correspondant. Soit &#915; une cha&#238;ne de pr&#233;dicats instan-
ci&#233;s. Alors S(&#12296;0, n&#12297;) &#8727;&#8658;l A(&#968;)&#915;
</p>
<p>&#8727;
</p>
<p>&#8658;l &#915; ssi [A,&#968;, c] o&#249;
&#8727;
</p>
<p>&#8658;l signifie &#8220;d&#233;rivation plus &#224; gauche&#8221;.
En particulier, [S, (&#12296;0, n&#12297;), c] ssi S(&#12296;0, n&#12297;) &#8727;&#8658; &#491;.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Un Algorithme d&#8217;Analyse de Type Earley pour Grammaires &#224; Concat&#233;nation d&#8217;Intervalles
</p>
<p>Item Op&#233;ration
1 [S, &#12296;(&#12296;r1, r2&#12297;), {0 = r1, r1 &#8804; r2, 2 = r2}&#12297;, p] initialisation
2 [S(XY ) &#8594; &#8226;S(X)eq(X,Y ), {X.l &#8804; X.r,X.r = Y.l, Y.l &#8804; Y.r, 0 = X.l, 2 = Y.r}] pr&#233;diction-r&#232;gle de 1
3 [S, &#12296;(&#12296;r1, r2&#12297;), {0 = r1, r1 &#8804; r2}&#12297;, p] pr&#233;diction-pred de 2
4 [S, (&#12296;0, 1&#12297;), c] lecture de 3
5 [S(XY ) &#8594; &#8226;S(X)eq(X,Y ), {X.l &#8804; X.r,X.r = Y.l, Y.l &#8804; Y.r, 0 = X.l, }] pr&#233;diction-r&#232;gle de 3
6 [S(XY ) &#8594; S(X) &#8226; eq(X,Y ), {. . . , 0 = X.l, 2 = Y.r, 1 = X.r}] compl&#233;t. de 2 avec 4
7 [S(XY ) &#8594; S(X) &#8226; eq(X,Y ), {X.l &#8804; X.r,X.r = Y.l, Y.l &#8804; Y.r, 0 = X.l, 1 = X.r}]compl&#233;t. de 5 avec 4
8 [eq, &#12296;(&#12296;r1, r2&#12297;, &#12296;r3, r4&#12297;), {r1 &#8804; r2, r2 = r3, r3 &#8804; r4, 0 = r1, 2 = r4, 1 = r2}&#12297;] pr&#233;diction-pred de 6
9 [eq(a1X, a2Y ) &#8594; &#8226;eq(X,Y ), {a1.l + 1 = a1.r, a1.r = X.l,X.l &#8804; X.r,
</p>
<p>a2.l + 1 = a2.r, a2.r = Y.l, Y.l &#8804; Y.r,X.r = a2.l, 0 = a1.l, 1 = X.r, 2 = Y.r}] pr&#233;diction-r&#232;gle de 8
. . .
</p>
<p>10 [eq, (&#12296;0, 1&#12297;, &#12296;1, 2&#12297;), c] lecture 8
11 [S(XY ) &#8594; S(X)eq(X,Y )&#8226;, {. . . , 0 = X.l, 2 = Y.r, 1 = X.r, 1 = Y.l}] compl&#233;t. de 6 avec 10
12 [S, (&#12296;0, 2&#12297;), c] conversion 11
</p>
<p>FIG. 2 &#8211; Trace d&#8217;une analyse de type Earley pour la cha&#238;ne aa.
</p>
<p>Obtenir une for&#234;t d&#8217;analyse Jusqu&#8217;ici, nous avons d&#233;crit des reconnaisseurs et non des ana-
lyseurs. Cependant, chaque fois qu&#8217;une conversion est r&#233;alis&#233;e, une clause compl&#232;tement ins-
tanci&#233;e a &#233;t&#233; trouv&#233;e. En collectant ces clauses, nous obtenons une repr&#233;sentation compacte de
la for&#234;t. En partant d&#8217;un pr&#233;dicat S couvrant toute la cha&#238;ne d&#8217;entr&#233;e, nous pouvons extraire
directement les analyses de cette repr&#233;sentation.
</p>
<p>Complexit&#233; Il est clair que tous les algorithmes pr&#233;sent&#233;s ici sont polyn&#244;miaux par rapport &#224;
la taille de la cha&#238;ne d&#8217;entr&#233;e. Un grand facteur de complexit&#233; avec RCG, comme l&#8217;a montr&#233;
Boullier (2000), est le nombre maximal de variables d&#8217;intervalles apparaissant dans un argument
d&#8217;un pr&#233;dicat. Dans notre approche &#224; la Earley, nous essayons de retarder au maximum le calcul
des valeurs que ces intervalles peuvent prendre, afin de r&#233;duire l&#8217;espace de recherche. Afin
d&#8217;avoir une id&#233;e de l&#8217;efficacit&#233; de notre approche, nous donnons une &#233;valuation du co&#251;t relatif
des algorithmes directionnel descendant et de type Earley. Ces algorithmes ont &#233;t&#233; test&#233;s sur
diff&#233;rents mots du langage L = {a2n |n &#8804; 0}. La table ci-dessous donne le nombre d&#8217;items
g&#233;n&#233;r&#233;s. Nous constatons que la propagation de contraintes d&#8217;intervalles augmente la quantit&#233;
d&#8217;information transport&#233;e dans un item, et ainsi diminue grandement le nombre d&#8217;items.3
</p>
<p>Mots Earley Descendant Mots Earley Descendant
a2 15 21 a16 100 539
a8 55 164 a32 185 1894
</p>
<p>6 Conclusion
</p>
<p>Nous avons pr&#233;sent&#233; diff&#233;rents algorithmes d&#8217;analyse pour la classe enti&#232;re des RCGs, au moyen
du paradigme de l&#8217;analyse par d&#233;duction. Seul l&#8217;algorithme descendant directionnel avait &#233;t&#233;
pr&#233;sent&#233; jusqu&#8217;alors. La diff&#233;rence cruciale entre cet algorithme et notre algorithme de type
Earley est que, alors que le premier calcule toutes les instanciations de clause lors des op&#233;rations
de pr&#233;diction, le second &#233;vite cela en utilisant une technique de mise &#224; jour dynamique d&#8217;un
ensemble de contraintes sur les extr&#233;mit&#233;s des intervalles. Les exp&#233;riences men&#233;es montrent
que l&#8217;algorithme de type Earley g&#233;n&#232;re bien moins d&#8217;items, ce qui confirme que la propagation
de contraintes d&#8217;intervalles est une m&#233;thode viable pour un calcul paresseux des intervalles.
</p>
<p>3Bien entendu, la pr&#233;sence de contraintes rend la comparaison entre items plus complexe, n&#233;cessitant ainsi
l&#8217;utilisation de repr&#233;sentations de bas niveau et de techniques efficaces de r&#233;solution de contraintes.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Laura Kallmeyer, Wolfgang Maier et Yannick Parmentier
</p>
<p>R&#233;f&#233;rences
BARTH&#201;LEMY F., BOULLIER P., DESCHAMP P. &amp; DE LA CLERGERIE &#201;. (2001). Guided
parsing of Range Concatenation Languages. In Proceedings of the 39th Annual Meeting on
Association for Computational Linguistics, p. 42&#8211;49.
BECKER T., RAMBOW O. &amp; NIV M. (1992). The Derivationel Generative Power of For-
mal Systems or Scrambling is Beyond LCFRS. Technical Report IRCS-92-38, Institute for
Research in Cognitive Science, University of Pennsylvania.
BERTSCH E. &amp; NEDERHOF M.-J. (2001). On the complexity of some extensions of RCG
parsing. In Proceedings of the Seventh International Workshop on Parsing Technologies, p.
66&#8211;77, Beijing, China.
BOULLIER P. (1998). Proposal for a Natural Language Processing Syntactic Backbone. Rap-
port de Recherche RR-3342, Institut National de Recherche en Informatique et en Automa-
tique, Le Chesnay, France.
BOULLIER P. (1999). Chinese numbers, mix, scrambling, and range concatenation grammars.
In Proceedings of the 9th Conference of the European Chapter of the Association for Compu-
tational Linguistics (EACL&#8217;99), p. 53&#8211;60, Bergen, Norway.
BOULLIER P. (2000). Range concatenation grammars. In Proceedings of the Sixth Internatio-
nal Workshop on Parsing Technologies (IWPT 2000), p. 53&#8211;64, Trento, Italy.
BURDEN H. &amp; LJUNGL&#214;F P. (2005). Parsing linear context-free rewriting systems. In Pro-
ceedings of the Ninth International Workshop on Parsing Technology, p. 11&#8211;17, Vancouver,
British Columbia.
KANAZAWA M. (2008). A prefix-correct earley recognizer for multiple context-free gram-
mars. In Proceedings of the Ninth International Workshop on Tree Adjoining Grammars and
Related Formalisms (TAG+9), p. 49&#8211;56, T&#252;bingen, Germany.
MAIER W. &amp; S&#216;GAARD A. (2008). Treebanks and mild context-sensitivity. In Proceedings
of the 13th Conference on Formal Grammar 2008, Hamburg, Germany.
MICHAELIS J. &amp; KRACHT M. (1996). Semilinearity as a Syntactic Invariant. In Logical
Aspects of Computational Linguistics, Nancy.
RADZINSKI D. (1991). Chinese number-names, tree adjoining languages, and mild context-
sensitivity. Computational Linguistics, 17, 277&#8211;299.
SAGOT B. (2005). Linguistic facts as predicates over ranges of the sentence. In Proceedings of
LACL 05, number 3492 in Lecture Notes in Computer Science, p. 271&#8211;286, Bordeaux, France.
SEKI H., MATSUMURA T., FUJII M. &amp; KASAMI T. (1991). On multiple context-free gram-
mars. Theoretical Computer Science, 88, 191&#8211;229.
SHIEBER S. M., SCHABES Y. &amp; PEREIRA F. C. N. (1995). Principles and implementation
of deductive parsing. Journal of Logic Programming, 24(1&amp; 2), 3&#8211;36.
S&#216;GAARD A. (2008). Range concatenation grammars for translation. In Proceedings of the
22nd International Conference on Computational Linguistics, Manchester, England.
VILLEMONTE DE LA CLERGERIE E. (2002). Parsing mildly context-sensitive languages with
thread automata. In Proceedings of the 19th International Conference on Computational Lin-
guistics, p. 1&#8211;7, Taipei, Taiwan.
WEIR D. J. (1988). Characterizing mildly context-sensitive grammar formalisms. PhD thesis,
University of Pennsylvania, Philadelphia, PA.</p>

</div></div>
</body></html>