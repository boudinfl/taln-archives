<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>&lt;TextCoop&gt;: un analyseur de discours bas&#233; sur les grammaires logiques</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>TALN 2011, Montpellier, 27 juin &#8211; 1er juillet 2011
</p>
<p>&lt;TextCoop&gt;: un analyseur de discours bas&#233; sur les grammaires logiques
</p>
<p>Patrick Saint-Dizier
IRIT-CNRS, Toulouse
</p>
<p>stdizier@irit.fr
</p>
<p>R&#233;sum&#233;. Dans ce document, nous pr&#233;sentons les principales caract&#233;ristiques de &lt;TextCoop&gt;, un environ-
nement bas&#233; sur les grammaires logiques d&#233;di&#233; &#224; l&#8217;analyse de structures discursives. Nous &#233;tudions en particulier
le langage DisLog qui fixe la structure des r&#232;gles et des sp&#233;cifications qui les accompagnent. Nous pr&#233;sentons la
structure du moteur de &lt;TextCoop&gt; en indiquant au fur et &#224; mesure du texte l&#8217;&#233;tat du travail, les performances
et les orientations en particulier en mati&#232;re d&#8217;environnement, d&#8217;aide &#224; l&#8217;&#233;criture de r&#232;gles et de d&#233;veloppement
applicatif.
</p>
<p>Abstract. In this paper, we introduce the main features of &lt;TextCoop&gt;, an environment dedicated to
discourse analysis within a logic-based grammar framework. We focus on the structure of discourse rules (DisLog
language) and on the features of the engine, while outlining the results, the performances and the orientations for
future work.
</p>
<p>Mots-cl&#233;s : grammaire du discours, programmation en logique, grammaires logiques.
Keywords: discourse structure, logic programming, logic-based grammars.
</p>
<p>1 Analyser quelles structures discursives ?
</p>
<p>Lorsque l&#8217;on pense &#224; l&#8217;analyse de structures discursives, il vient d&#8217;abord &#224; l&#8217;esprit l&#8217;analyse des structures rh&#233;to-
riques qui, d&#8217;une fa&#231;on ou d&#8217;une autre, sont cens&#233;es permettre de rendre compte de fa&#231;on compl&#232;te des diverses
articulations discursives d&#8217;un texte (Marcu 97, 02). L&#8217;objectif est de relier tous les &#233;l&#233;ments d&#8217;un texte par le biais
de ces relations, ce qui rend alors compte de la structure s&#233;mantico-pragmatique de ce texte. Outre le fait que ces
relations existent en grand nombre et avec parfois des d&#233;finitions un peu vagues et difficilement op&#233;rationalisables,
il existe en fait, pour le besoin des applications, un grand nombre d&#8217;autres structures qui rentrent plus ou moins
facilement dans le paradigme rh&#233;torique.
</p>
<p>C&#8217;est ainsi le cas des cadres du discours, initi&#233; en France par M. Charolles, pour lesquels les relations rh&#233;toriques
&#8217;frame&#8217; ou &#8217;background&#8217; ne sont pas tout &#224; fait satisfaisantes. C&#8217;est aussi le cas de nombreux types de structures
&#8217;d&#233;di&#233;es&#8217;, comme par exemple les instructions dans le discours proc&#233;dural. Enfin, notons toutes les structures qui
rel&#232;vent de la typographie et qui ont un lien avec le contenu du texte (titres, notes, paragraphes, listes, etc.). Enfin,
notons la complexit&#233; sous-jacente de certaines repr&#233;sentations qui forment des r&#233;seaux complexes de liens entre
structures.
</p>
<p>Dans la suite de ce document, nous proposons un environnement,&lt;TextCoop&gt;, d&#233;di&#233; &#224; l&#8217;analyse des structures
discursives, bas&#233; sur la notion de grammaire logique. Nos exp&#233;rimentations ayant largement tourn&#233; autour de
l&#8217;analyse des diverses structures rencontr&#233;es dans les textes proc&#233;duraux, nombre d&#8217;exemples sont emprunt&#233;s &#224; ce
cadre (Delpech et al 07, 08) (Aouladomar et al. 05), voir aussi (Delin 94) ou (Takechi 03). &lt;TextCoop&gt; d&#233;signe
l&#8217;ensemble de l&#8217;architecture du syst&#232;me, y compris les outils d&#8217;aide &#224; la mise au point et les ressouces linguistiques
associ&#233;es. DisLog (pour &#8217;Dicourse in Logic&#8217; ou &#8217;Discontinuities in Logic&#8217;) d&#233;signe le langage qui d&#233;crit les r&#232;gles
d&#8217;analyse et les contraintes que l&#8217;on peut y associer.
</p>
<p>Notre mod&#233;lisation n&#8217;est pas d&#233;di&#233;e &#224; un cadre applicatif particulier ou &#224; un genre textuel. Apr&#232;s un bref posi-
tionnement, nous pr&#233;sentons la syntaxe des r&#232;gles de DisLog ainsi que des outils associ&#233;s. Contrairement &#224; une
approche bas&#233;e sur l&#8217;apprentissage (Marcu 02), l&#8217;ensemble de notre travail est positionn&#233; dans une mod&#233;lisation
linguistique et d&#233;clarative, typique des grammaires logiques, qui autorise le raisonnement. Notre approche est
quelque peu bas&#233; sur une vision g&#233;n&#233;rative &#224; base de principes. Nous pr&#233;sentons ensuite les fonctionalit&#233;s du</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>PATRICK SAINT-DIZIER
</p>
<p>moteur ainsi que son environnement actuel. Le d&#233;veloppement de &lt;TextCoop&gt; est encore dans un stade exp&#233;ri-
mental : un travail est toujours en cours sur les propri&#233;t&#233;s de son environnement et des fonctions qu&#8217;il peut offir. Par
contre, ses fondements sont globalement fix&#233;s, et ont &#233;t&#233; test&#233;s dans plusieurs cadres linguistiques et applicatifs.
</p>
<p>Historiquement,&lt;TextCoop&gt; a initialement fait l&#8217;objet d&#8217;une &#233;tude d&#233;di&#233;e aux proc&#233;dures grand-public (Delpech
et al 08) avec une impl&#233;mentation simple en Perl de l&#8217;ensemble des fonctions. Toutefois, la rigidit&#233;, le peu de
portabilit&#233; et les limites expressives de Perl nous ont pouss&#233; &#224; refaire une impl&#233;mentation en Java, &#224; base de
g&#233;n&#233;rateurs d&#8217;automates, utilisant JCUP. Cette approche a d&#251; &#234;tre abondonn&#233;e apr&#232;s 10 mois de programmation
infructueuse. Voulant augmenter les possibilit&#233;s expressives du syst&#232;me, en particulier au niveau raisonnement, et
avoir un d&#233;veloppement fiable et rapide, nous avons finalement opt&#233; pour une version en Prolog que nous pouvons
facilement faire &#233;voluer et maintenir. Via une collaboration avec une soci&#233;t&#233;, les aspects interfaces et aide &#224; la
mise au point seront d&#233;velopp&#233;s d&#232;s que pertinent pour en faire une plateforme op&#233;rationelle. Une licence de type
GPL est pr&#233;vue au moins pour la partie noyau.
</p>
<p>1.1 Le positionnement de &lt;TextCoop&gt;
</p>
<p>La plateforme &lt;TextCoop&gt;, d&#233;di&#233;e &#224; l&#8217;analyse de structures du discours, doit permettre de pouvoir reconna&#238;tre
une grande diversit&#233; de structures, g&#233;n&#233;riques ou d&#233;di&#233;es &#224; des applications ou &#224; des genres textuels.&lt;TextCoop&gt;
vise &#224; la fois le traitement de structures discursives g&#233;n&#233;riques, dans des textes quelconques, et le traitement de
structures plus sp&#233;cifiques, &#8217;m&#233;tier&#8217;, dans des textes plus sp&#233;cialis&#233;s.
</p>
<p>Consid&#233;rant la complexit&#233; de la description des structures du discours, nous d&#233;veloppons une vision qui s&#8217;appuie
sur quelques consid&#233;rations simples de la grammaire g&#233;n&#233;rative &#224; savoir d&#233;velopper :
&#8211; des principes productifs, qui ont un bon niveau d&#8217;abstraction, linguistiquement ad&#233;quat, mais qui sur-reconnaissent
</p>
<p>dans certains cas,
&#8211; et des principes restrictifs qui viennent limiter la puissance des premiers, sur la base de contraintes de bonne
</p>
<p>formation, qui peuvent &#234;tre g&#233;n&#233;raux ou sp&#233;cifiques.
Cette approche modulaire permet une meilleure mod&#233;lisation des ph&#233;nom&#232;nes, plus compartiment&#233;e, et un meilleur
contr&#244;le sur le r&#233;sultat. Elle permet aussi une mise au point des r&#232;gles et une &#233;volutivit&#233; plus simple. Ces principes
sont g&#233;r&#233;s par un traitement en cascade des r&#232;gles, y compris de liage et de correction.
</p>
<p>Par le biais des diff&#233;rentes contraintes introduites dans DisLog, il est possible de produire des repr&#233;sentations
&#233;tiquet&#233;es complexes, sous forme d&#8217;arbres, de graphe ou de d&#233;pendances. DisLog permet d&#8217;introduire des relations
de un vers plusieurs ou de plusieurs vers un, permettant ainsi qu&#8217;une structure soit en relation avec plusieurs autres
structures de natures diff&#233;rentes. Cependant, dans la plupart des textes &#233;tudi&#233;s, ces relations sont relativement
simples, le souci &#233;tant en g&#233;n&#233;ral de pr&#233;server l&#8217;intelligibilit&#233; des documents.
</p>
<p>Le formalisme des r&#232;gles, DisLog, permet d&#8217;introduire tout type de forme de raisonnement a priori. Ceci est un
point original et crucial en analyse du discours, facilit&#233; par l&#8217;impl&#233;mentation r&#233;alis&#233;e en Prolog. Ces formes de rai-
sonnements permettent entre autres (1) de r&#233;aliser des calculs, report&#233;s dans les annotations produites, (2) de lever
des ambigu&#239;t&#233;s d&#8217;analyse, (3) de compl&#233;ter l&#8217;analyse grammaticale par l&#8217;appel par exemple &#224; des connaissances
(pour inclure des donn&#233;es pragmatiques). Si une requ&#234;te de raisonnement &#233;choue, alors la r&#232;gle &#233;choue.
La litt&#233;rature est particuli&#232;rement abondante s&#8217;agissant de l&#8217;analyse du discours. On y trouve plusieurs directions.
Un mouvement th&#233;orique assez important s&#8217;est d&#233;velopp&#233; depuis 20 ans environ, autour de plusieurs cadres dont
la DRT et ses extensions. Ce cadre demeure essentiellement abstrait et orient&#233; vers des modes de repr&#233;sentations
peu expressifs. Notre orientation &#233;tant &#224; la fois plus empirique et li&#233;e &#224; une s&#233;mantique conceptuelle plut&#244;t que
formelle, ce cadre n&#8217;est a priori pas pertinent pour nos travaux et ne sera pas &#233;voqu&#233; ici. Plusieurs approches
empiriques sont par contre d&#8217;un int&#233;r&#234;t marqu&#233;. Il y a tout d&#8217;abord les travaux qui caract&#233;risent la nature et la
forme des relations rh&#233;toriques. (Mann et al 88) ont propos&#233; une formulation contemporaine de ce cadre. De
nombreux travaux ont suivi dont (Delin 94), (Kosseim et al 00), (Rossner et al 92), (Saito et al 06), (Vander
Linden 93), etc. qui affinent ces relations ou les &#233;tudient dans des cadres sp&#233;cialis&#233;s. cependant, on assiste alors &#224;
une prolif&#233;ration de ces relations, o&#249; les d&#233;finitions deviennent parfois vagues.
</p>
<p>Un courant plus profond se pr&#233;occupe du sens v&#233;hicul&#233; par ces relations, dans une perspective cognitive, de
leur aspects pragmatiques ainsi que des intentions de communication sous-jacentes (Wright 04), (Moschler 85)
(Davidson 63) (Anscrombre et al 81). Ceci est particuli&#232;rement int&#233;ressant dans diff&#233;rents cadres tels que le
dialogue, l&#8217;argumentation et la n&#233;gociation (Amgoud et al. 01, 05), et la g&#233;n&#233;ration de langue naturelle (Rosner et</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&lt;TEXTCOOP&gt;: UN ANALYSEUR DE DISCOURS BAS&#201; SUR LES GRAMMAIRES LOGIQUES
</p>
<p>al. 92) qui, au niveau de son composant de planification, s&#8217;appuie en particulier sur des sch&#233;mas rh&#233;toriques.
Une interrogation toujours d&#8217;actualit&#233; concerne la caract&#233;risation en langue des relations de discours afin de pou-
voir les identifier automatiquement. C&#8217;est de toute &#233;vidence un d&#233;fi ouvert, o&#249; des solutions parfois parall&#232;les
ont &#233;t&#233; tent&#233;es, car ces relations n&#8217;ont pas syst&#233;matiquement des marques qui les identifient. Notons par exemple
(Mann et al. 88), (Saito et al. 06), (Takechi et al 03) (Di Eugenio et al 96) qui soulignent bien les r&#233;sultats que
l&#8217;on peut escompter. R&#233;cemment, par exemple via le projet ANR Annodis, une approche &#224; base d&#8217;apprentissage &#224;
partir d&#8217;annotations manuelles s&#8217;est d&#233;velopp&#233;e. Une telle entreprise se heurte &#224; deux difficult&#233;s : les d&#233;saccords
importants (mais in&#233;vitables) entre annotateurs et la difficult&#233; de d&#233;velopper de l&#8217;apprentissage sur des segments
textuels importants o&#249; peu d&#8217;information est en fait pertinente. Enfin, notons les travaux qui d&#233;veloppement des
grammaires pour le texte par exemple &#224; partir de TAGs (Gardent 97) (Webber 04).
Au niveau des environnements, GATE (http ://gate.ac.uk/) est une plateforme tr&#232;s r&#233;pandue et qui intervient dans
de nombreux projets. Elle est essentiellement d&#233;di&#233;e &#224; l&#8217;analyse de phrases ou de courts fragments de textes. Par
ailleurs, Linguastream
(http ://www.linguastream.org/home.html) est une plateforme ouverte pour l&#8217;analyse du langage qui peut accepter
en entr&#233;e tout type de texte XML. Il est bas&#233; sur une architecture en composants et offre plusieurs API Java
utiles pour l&#8217;int&#233;gration. C&#8217;est un syst&#232;me largement ouvert qui laisse une grande libert&#233; &#224; l&#8217;utilisateur tout en lui
proposant un ensemble d&#8217;outils d&#8217;aide et d&#8217;interfaces tr&#232;s pertinents. Linguastream est d&#8217;abord d&#233;di&#233; &#224; l&#8217;analyse
de la phrase au sein de textes. Cette plateforme ne permet pas d&#8217;inclure de modules de raisonnement comme cela
est tr&#232;s utile en analyse de structures discursives, par exemple pour lever des ambiguit&#233;s ou pour introduire des
consid&#233;rations pragmatiques. Il serait toutefois int&#233;ressant de voir avec ces plateformes comment on peut &#233;crire
des analyseurs de structures de discours.
</p>
<p>Au niveau des grammaires de discours, nous pensons qu&#8217;il est n&#233;cessaire de pr&#233;server une analyse linguistique
pr&#233;cise, qui permet de d&#233;crire les ph&#233;nom&#232;nes &#224; un bon niveau d&#8217;abstraction, en pr&#233;servant une certaine pr&#233;dic-
tibilit&#233;. Nous nous attacherons donc &#224; un travail essentiellement manuel, m&#234;me si des traitements automatiques
sur corpus sont utilis&#233;s pour explorer les constructions (par exemple par bootstrapping). Ce texte &#233;tant d&#233;di&#233; &#224; la
partie grammaire, cet aspect m&#233;thodologique est trait&#233; ailleurs.
</p>
<p>1.2 Le langage des structures du discours
</p>
<p>Il n&#8217;est pas dans notre objectif d&#8217;argumenter pour les diff&#233;rents aspects un langage &#233;largi qui rende compte de
l&#8217;ensemble des formes que peuvent prendre les structures qui rel&#232;vent du discours. Nous nous contenterons d&#8217;en
observer un certain nombre, fortement r&#233;currentes dans les situations que nous avons examin&#233;es, et qui sont &#224; la
base du langage de description DisLog introduit dans &lt;TextCoop&gt;. Ce langage est con&#231;u de fa&#231;on assez ouverte
pour pouvoir permettre de coder de nombreuses configurations.
</p>
<p>Les relations rh&#233;toriques (Mann et al 88) sont structur&#233;es sous forme de deux types de relations :
&#8211; une relation hi&#233;rarchique dite de noyau vers satellite. Ainsi dans ins&#233;rez verticalement la carte m&#232;re sinon vous
</p>
<p>risquez d&#8217;endommager les connecteurs&#8217;, la premi&#232;re partie de l&#8217;&#233;nonc&#233; est habituellement appel&#233;e conclusion
d&#8217;argument (ici de type avertissement) tandis que la seconde partie, qui explique les risques encourus, est
appel&#233;e support de l&#8217;argument. La conclusion peut apparaitre seule, avec un support vide, mais le support n&#8217;a
de sens que s&#8217;il est reli&#233; &#224; au moins une conclusion.
</p>
<p>&#8211; une relation non hi&#233;rarchique de noyau vers noyau. Ainsi la relation &#8217;parall&#232;le&#8217; associe-t-elle deux structures de
m&#234;me niveau, comme dans l&#8217;ellipse : Jean est re&#231;u &#224; son permis, Marie aussi.
</p>
<p>L&#8217;analyse discursive des textes s&#8217;applique souvent sur ces deux types de sch&#233;mas. Cette structure est bien entendu
r&#233;cursive ou emboit&#233;e : un satellite peut &#234;tre lui m&#234;me une structure composite complexe.
</p>
<p>On observe cependant des situations plus complexes. Ainsi un noyau peut-il gouverner plusieurs satellites, &#233;ven-
tuellement de statuts diff&#233;rents (une d&#233;finition suivie d&#8217;un conseil, un avertissement au milieu d&#8217;instructions). Un
cas courant de multiplicit&#233; de satellites dans les textes proc&#233;duraux est celui d&#8217;un titre (&#233;nonc&#233; d&#8217;un but) et des
instructions qui permettent de r&#233;aliser ce but. Dans un texte, le r&#233;seau de relations devient alors tr&#232;s complexe,
suivant une structure de graphe orient&#233;. de plus, les relations noyau-satellite(s) sont souvent floues et ambigues et
varient selon le point de vue. Enfin, le caract&#232;re hi&#233;rarchique de certaines relations est difficile &#224; &#233;tablir et peut
d&#233;pendre du contexte.
</p>
<p>Comme cela est souvent indiqu&#233; dans la litt&#233;rature sur les relations du discours, celles-ci peuvent &#234;tre en tr&#232;s</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>PATRICK SAINT-DIZIER
</p>
<p>grand nombre, et de d&#233;finitions variables selon les auteurs ou les annotateurs. Cette situation est nettement plus
complexe, pour faire un parall&#232;le, que dans le cas de la relation pr&#233;dicat arguments ou ajouts, o&#249; des relations
th&#233;matiques sont souvent employ&#233;es et relativement bien maitris&#233;es. Si l&#8217;on consid&#232;re par exemple des textes
techniques, on observe que chaque genre peut avoir quelques structures sp&#233;cifiques. C&#8217;est le cas par exemple des
instructions, du sommaire et des pr&#233;-requis dans les proc&#233;dures.
</p>
<p>1.3 Caract&#233;riser les structures discursives
</p>
<p>De nombreux auteurs se sont attaqu&#233;s au probl&#232;me difficile qui consiste &#224; d&#233;finir un formalisme grammatical pour
reconnaitre les structures discursives. Nous faisons ici en quelque sorte une synth&#232;se des principales difficult&#233;s. Si
l&#8217;on veut caract&#233;riser la structure grammaticale d&#8217;une structure discursive, il convient de d&#233;finir avec pr&#233;cision :
&#8211; Comment identifier un objet discursif, sur quelles bases linguistiques, pragmatiques, typographiques, etc. (DiEu-
</p>
<p>genio et al. 96). Certaines relations sont relativement bien marqu&#233;es dans la plupart des cas, alors que d&#8217;autres
sont rarement marqu&#233;es ou ne s&#8217;y pr&#234;tent pas. Les discours en langue contr&#244;l&#233;e ou &#224; vis&#233;e finalis&#233;e, visant l&#8217;ef-
ficacit&#233; et la clart&#233;, d&#233;veloppent en g&#233;n&#233;ral des marques nettement plus &#233;videntes, comme, par exemple, dans
le discours proc&#233;dural ou didactique. Les marques peuvent de surcroit &#234;tre ambigu&#235;s entre plusieurs relations.
Assez souvent, enfin, on remarque qu&#8217;un noyau se trouve identifi&#233; parce qu&#8217;un satellite a &#233;t&#233; identifi&#233; et peut
lui &#234;tre associ&#233; : les satellites sont souvent mieux marqu&#233;s que leur noyau.
</p>
<p>&#8211; Comment d&#233;limiter l&#8217;objet discursif une fois identifi&#233; ? D&#8217;autres marques (ponctuation, typographie, connec-
teurs, etc.) peuvent &#234;tre consid&#233;r&#233;es en compl&#233;ment des marques identifiantes indiqu&#233;es ci-dessus. Une ap-
proche int&#233;ressante vise &#224; d&#233;velopper la notion de structure de discours &#233;l&#233;mentaire (EDU (Schauer 06)), com-
parable, dans la phrase, &#224; la proposition. Il convient d&#8217;en &#233;valuer l&#8217;utilisabilit&#233;. Des groupes d&#8217;EDUs peuvent
parfois consid&#233;r&#233;es et &#233;valu&#233;es comme &#233;tant une structure discursive autonome (par exemple sur la base de la
th&#233;orie du centrage).
</p>
<p>&#8211; Comment, une fois une structure discursive identifi&#233;e, la relier &#224; une ou plusieurs autres structures ? La difficult&#233;
est ici d&#8217;identifier les structures exactes &#224; mettre en relation, par exemple une &#233;num&#233;ration (satellite) doit &#234;tre
li&#233;e exactement &#224; l&#8217;&#233;l&#233;ment initiateur de cette &#233;num&#233;ration, comme par exemple un terme ou une expression plus
g&#233;n&#233;rique (un titre). Les composants sont souvent contig&#252;s, mais leur d&#233;limitation peut s&#8217;av&#233;rer tr&#232;s difficile.
</p>
<p>On se trouve donc devant une triade : identification, d&#233;limitation, liage (des diff&#233;rents protagonistes de la rela-
tion).
</p>
<p>2 Le formalisme grammatical de &lt;TextCoop&gt;
</p>
<p>Le formalisme grammatical de &lt;TextCoop&gt;, DisLog, &#233;tend les possibilit&#233;s expressives des approches &#224; base
d&#8217;expressions r&#233;guli&#232;res et les adapte aux besoins de l&#8217;analyse de discours, en y int&#233;grant un composant de raison-
nement souvent utile dans l&#8217;analyse de telles structures. Notre approche s&#8217;appuie aussi sur les travaux, maintenant
assez anciens, mais toujours actuels, des grammaires logiques (DCGs, XGs, MGs, etc.), qui s&#8217;appuient sur des
mod&#232;les d&#8217;ex&#233;cution inspir&#233;s des programmes logiques, dont Prolog. D&#8217;autres sch&#233;mas de strat&#233;gie, par exemple
&#224; base de contraintes ou utilisant du parall&#233;lisme ET-OU sont possibles. Cette approche nous parait int&#233;ressante
pour l&#8217;analyse du discours en raison de son caract&#232;re d&#233;claratif marqu&#233;, de son ind&#233;pendance relative aux strat&#233;-
gies de traitement, et aussi de son aptitude &#224; int&#233;grer naturellement des modules de raisonnement et des structures
de contraintes puissantes (par exemple des structures de traits typ&#233;s, des contraintes d&#8217;arbres).
Le formalisme que nous proposons ici peut aussi bien permettre de coder des r&#232;gles d&#8217;analyse de structures dis-
cursives con&#231;ues par des linguistes et cod&#233;es manuellement que des r&#232;gles issues de m&#233;canismes d&#8217;apprentissage
&#224; partir de textes annot&#233;s, qui produisent en sortie des formes contraintes. Il est aussi possible de coder globale-
ment une forme noyau-satellite que ces m&#234;mes formes s&#233;paremment. Ce dernier choix est n&#233;cessaire lorsque la
combinatoire entre noyau et satellite est &#233;lev&#233;e, ou que ces constituants sont discontinus, ce qui est assez fr&#233;quent.
</p>
<p>2.1 DisLog : le formalisme grammatical
</p>
<p>Le langage DisLog offert par &lt;TextCoop&gt; comprend les symboles suivants, ils suivent en g&#233;n&#233;ral la syntaxe de
Prolog et des DCGs (grammaires &#224; clauses d&#233;finies) :</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&lt;TEXTCOOP&gt;: UN ANALYSEUR DE DISCOURS BAS&#201; SUR LES GRAMMAIRES LOGIQUES
</p>
<p>&#8211; des symboles pr&#233;-terminaux et non terminaux. Les pr&#233;-terminaux se d&#233;rivent directement en des entr&#233;es
lexicales ou des expressions (caract&#233;ristiques de structures rh&#233;toriques ou de domaines, par exemple) ou bien
encore en des marques typographiques ou des marques d&#8217;annotations (html, XML, ...). Ces marques d&#8217;anno-
tations peuvent faire r&#233;f&#233;rence &#224; des structures d&#233;j&#224; identifi&#233;es. Les symboles non terminaux font appel &#224; des
grammaires, essentiellement &#224; caract&#232;re local (par exemple grammaire des expressions temporelles) ou, plus ra-
rement, des constructions standard de la langue (SN, SV, etc.). Les r&#232;gles ne s&#8217;appellent pas entre-elles. Les liens
entre structures sont r&#233;alis&#233;s par des op&#233;rations de liage s&#233;lectif (voir ci-dessous). Les symboles non terminaux
et pr&#233;terminaux peuvent &#234;tre associ&#233;s &#224; des structures de traits attribut-valeur, ceci ne sera pas d&#233;velopp&#233; ici,
tant bien connu. Enfin, ces symboles sont utilis&#233;s soit pour identifier un type de structure discursive soit comme
&#233;l&#233;ment de d&#233;limitation (inclus ou exclu). Lorsqu&#8217;ils sont exclus, ils apparaissent dans un pr&#233;dicat &#8217;borne&#8217;.
</p>
<p>&#8211; des symboles terminaux indiqu&#233;s entre crochets, cette possibilit&#233; est utile lorsqu&#8217;il y a peu de choix sur ces
terminaux au sein d&#8217;une r&#232;gle, dans le cas contraire, il est p&#233;f&#233;rable de faire appel &#224; un pr&#233;terminal,
</p>
<p>&#8211; des indications d&#8217;optionalit&#233; ou d&#8217;it&#233;rativit&#233; sur les symboles pr&#233;terminaux et non terminaux,
&#8211; des symboles permettant d&#8217;exprimer la pr&#233;c&#233;dence lin&#233;aire (la &#8217;,&#8217;), ainsi que la co-occurence de symboles (le
</p>
<p>&#8217; ;&#8217;) si l&#8217;on veut utiliser la forme abr&#233;g&#233;e des r&#232;gles (non d&#233;velopp&#233;e ici),
&#8211; des &#8217;gaps&#8217; qui repr&#233;sentent des s&#233;quences finies de mots qui ne pr&#233;sentent pas d&#8217;int&#233;r&#234;t pour la r&#232;gle en cours de
</p>
<p>description. La condition d&#8217;arr&#234;t est constitu&#233;e par le symbole explicite qui suit le gap. D&#232;s qu&#8217;un tel symbole
est rencontr&#233;, le gap s&#8217;arr&#232;te. Les gaps peuvent &#234;tre associ&#233;s &#224; des contraintes, en particulier des symboles ter-
minaux ou non-terminaux qui ne doivent pas &#234;tre ignor&#233;s. Si un gap rencontre un tel symbole avant d&#8217;atteindre
sa condition d&#8217;arr&#234;t alors il y a &#233;chec de la r&#232;gle &#224; reconnaitre la structure. Un gap ne peut ni commencer ni
terminer une r&#232;gle, il doit toujours &#234;tre born&#233; explicitement par un symbole ou un terminal.
</p>
<p>&#8211; des appels &#224; des pr&#233;dicats qui introduisent des contraintes, des connaissances &#224; int&#233;grer ou des calculs divers.
Ceux-ci sont repr&#233;sent&#233;s entre accolades comme dans les DCGs.
</p>
<p>&#8211; des fonctions d&#8217;assignation, explicites ou par d&#233;faut, d&#8217;&#233;tiquettes d&#233;di&#233;es permettant d&#8217;&#233;tiqueter les structures
reconnues avec d&#8217;&#233;ventuels attributs, calcul&#233;s par les pr&#233;dicats ci-dessus.
</p>
<p>A priori, les r&#232;gles sont de type 2, avec la syntaxe des DCGs. Toutefois des r&#232;gles de type 1 peuvent aussi &#234;tre
construites. Le symbole en partie gauche de r&#232;gle contient une variable qui repr&#233;sente le r&#233;sultat : en g&#233;n&#233;ral il
s&#8217;agit de la structure compl&#232;te telle que lue avec des marques d&#8217;annotation, &#233;ventuellement avec des attributs, au
d&#233;but et &#224; la fin correspondant &#224; la structure reconnue. Il est aussi possible de repositionner des composants du
texte lus en entr&#233;e.
</p>
<p>A titre d&#8217;exemple, des expressions d&#8217;avertissement du type il est conseill&#233; de ne jamais ACTION parce que....
se repr&#233;sentent simplement (i.e. sans faire de g&#233;n&#233;ralisation) comme ci-dessous (Fontan et al. 08). On consid&#232;re
ici que la structure commen&#231;ant par parce que ne fait pas partie de l&#8217;avertissement (en fait c&#8217;est un support de
l&#8217;avertissement selon les th&#233;ories de l&#8217;argumentation, celui-ci est reconnu s&#233;paremment) :
avertissement(R) &#8211;&gt; [il, est], expr([type :conseil]), [de], negation, gap([connecteur([type :cause])), borne([parce,
que]).
Cette r&#232;gle d&#233;bute par la mention de deux terminaux, qui font partie de la structure &#224; reconnaitre, suivie d&#8217;un
pr&#233;-terminal de type conseil (indiqu&#233; ici par la structure attribut valeur dans l&#8217;argument). Elle se poursuit par un
autre terminal, un non terminal qui reconnait la n&#233;gation, puis un gap dont on indique qu&#8217;il ne doit pas ignorer les
connecteurs de cause sur son parcours qui se termine sur la borne (une marque externe &#224; la r&#232;gle, voir ci-dessous)
qui est le terminal [parce,que]. La variable R repr&#233;sente la structure &#233;tiquet&#233;e, qui est ici de la forme :
&lt;avertissement&gt; ... texte lu ... &lt; /avertissement&gt;.
</p>
<p>2.2 L&#8217;insertion d&#8217;&#233;tiquettes XML
</p>
<p>DisLog pr&#233;voit la possibilit&#233; (1) de sp&#233;cifier d&#8217;autres types d&#8217;&#233;tiquettes que celles li&#233;es au symbole en partie
gauche, (2) d&#8217;inclure des attributs, et (3) d&#8217;ins&#233;rer &#224; tout endroit du segment de texte lu tout autre type d&#8217;&#233;tiquette.
Consid&#233;rons :
</p>
<p>&lt;avertissement&gt; il est &lt;exp-conseil force=&quot;mod&#233;r&#233;&quot;&gt; recommand&#233; &lt; /exp-conseil&gt; de ne jamais ouvrir la
boite &lt; /avertissement&gt;
</p>
<p>Dans cet exemple, on a ins&#233;r&#233; une balise &lt;exp-conseil&gt; avec un attribut (d&#233;duit de propri&#233;t&#233;s lexicales) qui</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>PATRICK SAINT-DIZIER
</p>
<p>indique la force du conseil, ici &#8217;mod&#233;r&#233;&#8217;.
</p>
<p>L&#8217;insertion d&#8217;&#233;tiquettes XML se fait comme suit :
&#8211; par d&#233;faut en d&#233;but et fin de s&#233;quence reconnue, en utilisant le non terminal donn&#233; en partie gauche de r&#232;gle,
&#8211; si l&#8217;on veut ins&#233;rer une autre &#233;tiquette, alors celle-ci est sp&#233;cifi&#233;e explicitement par une variable d&#8217;insertion.
</p>
<p>Ceci vaut aussi si on veut ajouter un ou plusieurs attributs.
&#8211; si l&#8217;on veut ins&#233;rer des &#233;tiquettes compl&#233;mentaires dans la s&#233;quence reconnue, celles-ci sont aussi sp&#233;cifi&#233;es
</p>
<p>par des variables d&#8217;insertion dans la partie droite de r&#232;gle.
&#8211; si, d&#8217;aventure, on ne veut rien ins&#233;rer en d&#233;but et fin de s&#233;quence, on emploie la notation $noinsert.
Les variables d&#8217;insertion sont repr&#233;sent&#233;es par : $insert1, $insert2, qui sont instanci&#233;es explicitement en fin de
r&#232;gle dans une section &#8217;calculs&#8217; entre accolades. On peut employer des variables qui proviennent soit de d&#233;duc-
tions soit de caract&#233;ristiques h&#233;rit&#233;es de donn&#233;es lexicales. Pour l&#8217;exemple ci-dessus, on doit ajouter dans la r&#232;gle :
avertissement(R) &#8211;&gt; [il, est], $insert1, expr([type :conseil, force :F]), $insert2, [de], negation,
gap([connecteur([type :cause])), borne([parce, que]), { $insert1= &lt;exp-conseil, force :F&gt;, $insert2=&lt; /exp-
conseil&gt; }.
avec la donn&#233;e lexicale : expr([type :conseil, force :mod&#233;r&#233;]) &#8211;&gt; [recommand&#233;].
</p>
<p>2.3 Les r&#232;gles de liage s&#233;lectif
</p>
<p>Les r&#232;gles de liage s&#233;lectif permettent de lier deux structures ou plus comme &#233;voqu&#233; dans l&#8217;introduction. L&#8217;objectif
est de lier noyau et satellite(s), ou tout autre lien que l&#8217;on souhaite &#233;tablir (par exemple, connecteur - EDU, etc.).
Les r&#232;gles de liage ont donc un statut de non-terminaux : elle lient entre-elles des r&#232;gles, permettant de construire
des arbres partiels dans un texte, indiquant les structures discursives qui sont en relation. Par exemple si l&#8217;on veut
lier les structures discursives a et b pour former c, on peut d&#233;finir une r&#232;gle de liage comme suit :
c(R) &#8211;&gt; [&lt;a&gt;], gap, [&lt; /a&gt;], gap, [&lt;b&gt;], gap, [&lt; /b&gt;].
ce qui produira : &lt;c&gt; &lt;a&gt;, ... &lt; /a&gt;, ... &lt;b&gt;, ... &lt; /b&gt; &lt; /c&gt;.
o&#249; les structures a et b sont reproduites telles quelles.
</p>
<p>De fa&#231;on plus concr&#232;te, si l&#8217;on consid&#232;re la structure duale des arguments : conclusion-support, comme dans :
Il est capital d&#8217;ins&#233;rer verticalement la carte m&#232;re car vous riquez d&#8217;endommager les connecteurs.,
on aurait la r&#232;gle de liage s&#233;lectif :
argument(R) &#8211;&gt; [&lt;conclusion&gt;], gap, [&lt; /conclusion&gt;], connecteur([type :cause]), [&lt;support&gt;], gap, [&lt; /support&gt;].
et la structure r&#233;sultante est :
&lt;argument&gt; &lt;conclusion&gt; Il est capital d&#8217;ins&#233;rer verticalement la carte m&#232;re &lt; /conclusion&gt;, car &lt;support&gt;
vous riquez d&#8217;endommager les connecteurs&lt; /support&gt;&lt; /argument&gt;.
</p>
<p>2.4 Les r&#232;gles de correction
</p>
<p>&lt;TextCoop&gt; permet la d&#233;finition de r&#232;gles de r&#233;&#233;criture sur les balises permettant de repositionner certaines
balises qui pourraient ne pas &#234;tre positionn&#233;es correctement.
</p>
<p>Un emploi imm&#233;diat est li&#233; au r&#233;-&#233;quilibrage des balises qui peuvent se chevaucher, en particulier lorsque les
conditions de d&#233;limitation d&#8217;une r&#232;gle sont trop peu contraintes. Typiquement, ces r&#232;gles permettent de corriger
une situation telle que :
&lt;a&gt;, ...&lt;b&gt;&lt; /a&gt;, ... &lt; /b&gt; en &lt;a&gt;, ... &lt; /a&gt;, ... &lt;b&gt;, ... &lt; /b&gt; .
</p>
<p>Les r&#232;gles de correction ont la m&#234;me forme que celle ci-dessus, la variable R contenant la structure corrig&#233;e :
corriger([&lt;A&gt;], gap, [&lt; /A&gt;], gap, [&lt;B&gt;], gap, [&lt; /B&gt;]) &#8211;&gt; [&lt;A&gt;], gap,[&lt;B&gt;],gap, [&lt; /A&gt;], gap, [&lt;
/B&gt;].
On notera qu&#8217;ici A et B sont des variables repr&#233;sentant a priori n&#8217;importe quel identifiant de balise.
</p>
<p>2.5 L&#8217;art d&#8217;&#233;crire des r&#232;gles
</p>
<p>Dans notre approche, les r&#232;gles sont &#233;crites pour l&#8217;instant totalement de fa&#231;on manuelle, &#224; partir d&#8217;analyse de
documents et de rep&#233;rage de marques. Toutefois, le formalisme a &#233;t&#233; con&#231;u pour accueillir les sp&#233;cifications,</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&lt;TEXTCOOP&gt;: UN ANALYSEUR DE DISCOURS BAS&#201; SUR LES GRAMMAIRES LOGIQUES
</p>
<p>relativement ouvertes, de syst&#232;mes bas&#233;s sur l&#8217;apprentissage. Nous souhaitons aussi introduire des outils d&#8217;aide &#224;
l&#8217;&#233;criture de r&#232;gles, par exemple bas&#233;s sur des techniques de bootstrapping. Ceci reste toutefois &#224; approfondir car
l&#8217;analyse de discours a des caract&#233;ristiques tr&#232;s diff&#233;rentes de celle de la phrase o&#249; bootstrapping et apprentissage
ont &#233;t&#233; largement test&#233;s. Notre exp&#233;rience est que l&#8217;&#233;criture de r&#232;gles qui reconnaissent des structures de discours
et les lient sont complexes : elles pr&#233;sentent peu de marques explicites, ce qui les rend ambigu&#235;s, elles couvrent
aussi tr&#232;s souvent des fragments de texte cons&#233;quents. Ces raisons font que nous avons privil&#233;gi&#233; dans notre
approche une &#233;criture manuelle des r&#232;gles que nous associerons &#224; un ensemble d&#8217;outils de visualisation de fa&#231;on
&#224; guider les auteurs. Cette &#233;criture, nous pensons, permet d&#8217;acc&#233;der &#224; une meilleure ad&#233;quation linguistique et un
meilleur niveau de g&#233;n&#233;ralisation.
</p>
<p>Par exemple, c&#8217;est &#224; ce niveau que des m&#233;canismes de raisonnement peuvent &#234;tre introduits. Dans le cas ci-
dessous :
La confiture se pr&#233;pare avec des fruits rouges (cassis, fraises, framboises) afin de ...
pour identifier que la structure entre parenth&#232;ses est une illustration, faute de marques explicites, via le contr&#244;le :
cassis est_un &#8217;fruit rouge&#8217;, etc. une terminologie simple est n&#233;cessaire. La r&#232;gle suivante int&#232;gre noyau et satellite
et s&#8217;&#233;crit, par exemple :
illustration(R) &#8211;&gt; Nom(Type), [&#8217;(&#8217;], liste_Noms(Type1), [&#8217;)&#8217;], { subsume(Type,Type1) }.
Enfin, l&#8217;analyse de structures du discours m&#232;ne &#224; de nombreuses ambiguit&#233;s. Les r&#232;gles d&#233;crites par les auteurs
refl&#232;tent ces ambiguit&#233;s. Notre syst&#232;me est con&#231;u soit pour refl&#233;ter toutes les analyses possibles (mode mise au
point) soit pour privil&#233;gier un choix a priori (via le m&#233;canismes de cascades de r&#232;gles ou des heuristiques). Toute-
fois, les techniques d&#8217;interpr&#233;tation des programmes logiques pourraient permettre des modes interm&#233;diaires, ainsi
qu&#8217;une interpr&#233;tation &#224; base de contraintes &#8217;actives&#8217; permettant de produire l&#8217;ensemble des analyses possibles.
</p>
<p>2.6 Gestion de la concurrence entre r&#232;gles
</p>
<p>Nous proposons ici quelques contraintes qui g&#232;rent la concurrence entre r&#232;gles. Les r&#232;gles &#233;tant parfois trop
permissives (ou pourrait parler de principe productif comme pour la syntaxe X-bar), il est n&#233;cessaire d&#8217;ajouter
des contraintes qui en limitent la puissance (on pourrait parler de principes restrictifs). Notre syst&#232;me fonctionne
par segments appel&#233;s unit&#233;s textuelles. Celles-ci peuvent &#234;tre des paragraphes, des sections, des arbres (pour des
documents semi-structur&#233;s, etc.). Nous ferons une pr&#233;sentation ici illustr&#233;e de ces contraintes.
Certaines structures discursives ont des formes tr&#232;s proches, difficiles &#224; distinguer. &lt;TextCoop&gt; offre actuel-
lement deux possibilit&#233;s pour g&#233;rer la concurrence au niveau de la reconnaissance de structures. Le moteur de
&lt;TextCoop&gt;, pr&#233;sent&#233; ci-dessous, ex&#233;cute les r&#232;gles en cascades. Le langage de &lt;TextCoop&gt; permet de sp&#233;ci-
fier l&#8217;ordre dans lesquels les r&#232;gles sont ex&#233;cut&#233;es.
</p>
<p>Nous appellerons ci-dessous paquet de r&#232;gles l&#8217;ensemble des r&#232;gles qui sont li&#233;es &#224; la reconnaissance d&#8217;une struc-
ture donn&#233;e (par exemple, support d&#8217;argument, illustration, reformulation) identifi&#233;e par l&#8217;emploi d&#8217;un symbole
identique en partie gauche de r&#232;gle. L&#8217;analogie avec les paquets de clauses en Prolog est imm&#233;diate.&lt;TextCoop&gt;
permet de sp&#233;cifier une structure d&#8217;ordre (&#233;ventuellement partiel) qui indique dans quel ordre les paquets de r&#232;gles
doivent &#234;tre ex&#233;cut&#233;s. Ainsi dans :
titre &lt; pr&#233;requis&lt; sommaire.
les r&#232;gles reconnaissant les titres seront ex&#233;cut&#233;es d&#8217;abord puis celles li&#233;es aux pr&#233;-requis, etc. sans possibilit&#233; de
retour arri&#232;re.
</p>
<p>Associ&#233; &#224; ce m&#233;canisme de cascades, il est possible de d&#233;finir des zones ferm&#233;es o&#249; une fois une zone reconnue,
aucune r&#232;gle ne pourra &#234;tre appliqu&#233;e sur cette zone. Une zone ferm&#233;e est d&#233;finie sur un segment de texte inclus
dans une balise ouvrante et fermante du m&#234;me type. Lorsque la zone est identifi&#233;e, il n&#8217;est pas possible de tenter
d&#8217;appliquer d&#8217;autres r&#232;gles &#224; l&#8217;int&#233;rieur de cette zone. Par exemple, la balise&lt;titre&gt; d&#233;finie dans le traitement des
proc&#233;dures introduit une telle zone :
zone_fermee([titre]).
Un titre ressemble en effet, quant &#224; sa structure, &#224; une instruction : monter votre mezzanine, on ne veut pas, une
fois un titre reconnu, l&#8217;&#233;tiqueter aussi comme une instruction. &lt;TextCoop&gt; permet de d&#233;finir une liste de zones
ferm&#233;es. Cette liste comprend des structures de deux types : (1) des structures qui peuvent &#234;tre reconnues par
plusieurs paquets de r&#232;gles, mais o&#249; l&#8217;on veut privil&#233;gier un choix et ne pas provoquer de double &#233;tiquetage, afin
de limiter les probl&#232;mes d&#8217;ambiguit&#233;s (cut &#8217;rouge&#8217; en Prolog), (2) des structures discursives &#8217;terminales&#8217;, c&#8217;est &#224;</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>PATRICK SAINT-DIZIER
</p>
<p>dire qui ne doivent pas &#234;tre davantage d&#233;compos&#233;es, tout au moins par rapport &#224; la grammaire de discours telle
qu&#8217;elle est &#233;crite. Par exemple, la structure de pr&#233;-requis (liste d&#8217;ingr&#233;dients ou d&#8217;&#233;quipements) est analys&#233;e dans
les proc&#233;dures comme une structure terminale (mais elle pourrait &#234;tre plus finement analys&#233;e dans un autre cadre).
Ce second cas est d&#233;fini d&#8217;abord pour des raisons d&#8217;efficacit&#233; (comme un cut &#8217;vert&#8217; en Prolog).
Outre la possibilit&#233; de zones ferm&#233;es, DisLog offre la possibilit&#233; de sp&#233;cifier d&#8217;autres types de contraintes. Tout
d&#8217;abord on peut indiquer si une structure doit en dominer une autre :
dom(instruction,but).
indique que toute structure de type but est domin&#233;e par une instruction. De la m&#234;me fa&#231;on, on peut indiquer
que deux structures doivent &#234;tre dans deux branches diff&#233;rentes de la structure reconnue, sans aucune dominance
possible :
not_dom(instruction,avertissement).
Une instruction ne peut contenir un avertissement. Enfin, nous permettons de sp&#233;cifier directement une relation
rh&#233;torique :
rel_rhetorique(noyau,satellite,structure_englobante)., comme dans :
rel_rhetorique(conclusion_avt,support_avt,avertissement).
comme d&#233;crit ci-dessus. A ce stade aucune contrainte de pr&#233;c&#233;dence n&#8217;est donn&#233;e. Si l&#8217;on veut que le noyau soit
toujours avant le satellite, il faut ajouter :
prec(conclusion_avt,support_avt). La contraite rel_rhetorique inclut donc la contrainte &#8217;sister&#8217; et un liage s&#233;lectif
des deux premiers &#233;l&#233;ments sp&#233;cifi&#233;s.
</p>
<p>3 Le moteur de &lt;TextCoop&gt;
</p>
<p>Nous d&#233;crivons ici le fonctionnement du moteur &lt;TextCoop&gt; qui est, pour l&#8217;heure, un interpr&#233;teur. Nous in-
diquons d&#8217;abord la forme des r&#232;gles telles que trait&#233;es par cet interpr&#233;teur puis le fonctionnement du moteur
lui-m&#234;me. D&#8217;autres fonctionnements peuvent &#234;tre envisag&#233;s, sur le m&#234;me sch&#233;ma que celui des DCGs qu&#8217;il ne
fait que g&#233;n&#233;raliser. Nous ne nous &#233;tendrons pas ici sur les aspects th&#233;oriques du syst&#232;me. Les textes analys&#233;s
&#233;tant compos&#233;s de phrases &#224; nombre de mot finis, les gaps ignorant eux aussi des suites finies de mots, on peut,
via &#233;num&#233;rabilit&#233; r&#233;cursive, appliquer le th&#233;or&#232;me du point fixe pour donner une s&#233;mantique d&#233;clarative &#8217;simple&#8217;,
comme dans les programmes logiques en g&#233;n&#233;ral.
</p>
<p>3.1 Traduction des r&#232;gles
</p>
<p>Le moteur fonctionne comme un interpr&#233;teur, les r&#232;gles ainsi que les divers dispositifs pr&#233;sent&#233;s ci-dessus sont
donc traduits sous forme de structures de donn&#233;es directement utilisables par le moteur. Pour les r&#232;gles, cette
structure est proche de celle d&#233;finie pour les DCGs dans un mode interpr&#233;t&#233;, elle a la forme suivante :
forme(Identifiant,Entr&#233;e,Sortie,Partie_droite,R&#233;sultat).
o&#249; :
&#8211; Identifiant est le nom du symbole en partie gauche de r&#232;gle,
&#8211; Entr&#233;e et Sortie contiennent le texte en cours de traitement, ceci traduit la technique des listes de diff&#233;rences
</p>
<p>des DCGs, dont nous avons un besoin explicite ici pour reconstruire le texte &#233;tiquet&#233;,
&#8211; Partie_droite est la partie droite de r&#232;gle, d&#233;velopp&#233;e ci-dessous,
&#8211; R&#233;sultat est la variable R, r&#233;sultat de l&#8217;analyse (avec &#233;tiquetage) comme pr&#233;sent&#233; ci-dessus.
Les symboles en partie droite sont repr&#233;sent&#233;s sous forme de liste, apr&#232;s d&#233;veloppement complet de la r&#232;gle lorsque
la forme abr&#233;g&#233;e est utilis&#233;e. Les symboles terminaux et non terminaux sont augment&#233;s de trois arguments :
&#8211; un argument qui repr&#233;sente la chaine de mots couverte par ce symbole,
&#8211; les deux variables qui repr&#233;sentent la liste de diff&#233;rence propre &#224; ce symbole lorsqu&#8217;il est d&#233;velopp&#233;.
Ainsi, le symbole pr&#233;terminal : expr([type :conseil]) qui repr&#233;sente une expression (terminale) de type conseil est-
il traduit en : expr(EXPR, [type :conseil],E0,E1). En ce qui concerne le symbole gap, les trois m&#234;mes variables
sont ajout&#233;es ainsi qu&#8217;une marque qui indique le symbole d&#8217;arr&#234;t du gap, cette marque est l&#8217;identifiant du symbole
qui suit le gap dans la r&#232;gle et ses contraintes.
Plus globalement, la r&#232;gle suivante, qui traite de la structure d&#8217;une conclusion de conseil :
concl_conseil &#8211;&gt; pro(_), aux([ty :etre]), gap([supconseil]), expr([type :conseil]), gap([supconseil]), mfin(_).</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&lt;TEXTCOOP&gt;: UN ANALYSEUR DE DISCOURS BAS&#201; SUR LES GRAMMAIRES LOGIQUES
</p>
<p>est traduite de la fa&#231;on suivante :
</p>
<p>forme(c-cons-fr, E, S, [ pro(PRO,_,E,E2), aux(AUX,etre,E2,E3),
gap(supconseil, [expr,conseil], E3,E4,Saute1),expr(EXPR,conseil,E4,E5),
gap(supconseil, [mfin,_], E5,E6,Saute2), mfin(MFIN,_,E6,S)], [], % no reasoning
[ &#8217;&lt;concl-cons&gt;&#8217; ,PRO, AUX, Saute1, EXPR, Saute2, &#8217;&lt;/concl-cons&gt;&#8217;, MFIN ]).
</p>
<p>&#8217;aux&#8217; demande l&#8217;auxiliaire &#234;tre, &#8217;mfin&#8217; est une marque de fin, r&#233;pertori&#233;e dans le lexique. Les deux symboles gap
contiennent les variables Saute1 et Saute2 qui indiquent la chaine de mots qu&#8217;ils ont parcourue, et qui sera ignor&#233;e,
jusqu&#8217;&#224; rencontrer le symbole suivant dans la r&#232;gle. L&#8217;argument qui contient les restrictions (le seul pr&#233;sent dans
la structure initiale) peut &#234;tre soit une constante Prolog, dont l&#8217;interpr&#233;tation est directe soit une structure de traits,
qui est interpr&#233;t&#233;e de fa&#231;on standard, avec la subsomption sur les traits s&#233;mantiques.
</p>
<p>3.2 Le fonctionnement global du moteur
</p>
<p>Le moteur de &lt;TextCoop&gt; est &#233;crit en Prolog SWI, et tous les composants linguistiques attach&#233;s sont aussi
impl&#233;ment&#233;s dans ce cadre. Nous avons cherch&#233; &#224; optimiser les traitements sans que ceci soit la priorit&#233; : l&#8217;objectif
sont les traitements de structures du discours en mode batch.
</p>
<p>Comme indiqu&#233; ci-dessus, le moteur fonctionne par cascades de r&#232;gles, suivant les priorit&#233;s &#233;nonc&#233;es. Il n&#8217;y a
pas de retour arri&#232;re sur les &#233;tapes pr&#233;c&#233;dentes d&#8217;une cascade. Une &#233;tape de cascade est identifi&#233;e par le ou les
symboles en partie droite de r&#232;gle : des paquets de r&#232;gles sont donc ex&#233;cut&#233;s &#224; chaque &#233;tape. Au sein d&#8217;une &#233;tape,
les r&#232;gles dans un paquet sont ex&#233;cut&#233;es dans l&#8217;ordre dans lequel elle sont &#233;crites. Une option du moteur permet
d&#8217;&#233;viter les retours arri&#232;re (couteux) sur ces r&#232;gles. Cette option est d&#233;sactiv&#233;e en phase de mise au point. les
contraints &#233;nonc&#233;es sont v&#233;rifi&#233;es &#224; chaque &#233;tape de l&#8217;ex&#233;cution des r&#232;gles.
</p>
<p>A titre exp&#233;rimental, l&#8217;interpr&#233;teur est pourvu, outre la strat&#233;gie de traitement de la gauche vers la droite, d&#8217;une
strat&#233;gie inverse, de la droite vers la gauche. Celle-ci est utilis&#233;e lorsque les marques identifiantes d&#8217;une relation
rh&#233;torique sont plac&#233;es &#224; la fin de la structure, alors que la structure ne d&#233;bute que par une marque de d&#233;limitation.
C&#8217;est le cas, par exemple des structures d&#8217;illustration du type : (a,b,c,.., par exemple), ou la parenth&#232;se ouvrante
sert de d&#233;limiteur (elle est peu discriminante de la relation) et o&#249; la marque &#8217;par exemple&#8217; est situ&#233;e en fin de
chaine. Les r&#233;sultats que nous obtenons indiquent un meilleur taux de reconnaissance et une meilleure efficacit&#233;.
Cette strat&#233;gie sera automatis&#233;e, &#224; partir de l&#8217;analyse de la position des marques identifiantes.
</p>
<p>Le r&#233;sultat final de l&#8217;analyse est le texte donn&#233; en entr&#233;e augment&#233; de balises XML qui d&#233;limitent et caract&#233;risent
les structures analys&#233;es.
</p>
<p>3.3 Evaluation
</p>
<p>La premi&#232;re version du moteur est &#224; pr&#233;sent disponible avec son environnement. Celle-ci a &#233;t&#233; r&#233;alis&#233;e dans
l&#8217;objectif de valider les id&#233;es et de d&#233;finir pr&#233;cis&#233;mment les fonctionnalit&#233;s internes et externes utiles en analyse
discursive. L&#8217;optimisation du code n&#8217;y est que partielle. Les performances du syst&#232;me actuel sont les suivantes, sur
la base de 30 patrons (li&#233;s au traitement des proc&#233;dures), avec un lexique de 1300 mots ou expressions et un acc&#232;s
&#224; un analyseur morphologique, lui aussi en Prolog. Le calcul se fait sur un PC standard. Nous traitons 60 Mo de
texte (hors balises) par heure. La taille du lexique dans cette exp&#233;rience est assez importante pour le traitement du
discours. Dans de nombreuses applications, le lexique utile peut &#234;tre nettement plus r&#233;duit. Ceci a un impact im-
portant sur les performances. Le lexique qui a servi &#224; l&#8217;exp&#233;rimentation contient 800 verbes, cependant, dans une
application d&#8217;analyse de proc&#233;dures, ce nombre descend &#224; environ 150 verbes, et &#224; des variations morphologiques
tr&#232;s r&#233;duites. On peut alors traiter jusqu&#8217;&#224; 200 Mo de texte par heure. Bien entendu la complexit&#233; des patrons
a aussi une influence sur les performances : les gaps, la longueur des r&#232;gles, les restrictions mais aussi le non
d&#233;terminisme introduit par les r&#232;gles d&#8217;un m&#234;me paquet sont des facteurs importants, mais qui restent difficiles &#224;
analyser finement.
</p>
<p>Il est nettement plus difficile d&#8217;&#233;valuer la qualit&#233; de reconnaissance des r&#232;gles. Cela d&#233;pend beaucoup des types
de textes trait&#233;s et de la qualit&#233; de conception des r&#232;gles, comme dans tout type de programmation. En ce qui
concerne les proc&#233;dures, des r&#233;sultats d&#233;taill&#233;s sont donn&#233;s dans (Fontan et al. 08). Les textes professionnels</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>PATRICK SAINT-DIZIER
</p>
<p>donnent des r&#233;sultats tr&#232;s bons, du fait de leur qualit&#233; de r&#233;daction et de leur r&#233;gularit&#233;, aussi bien au niveau de
l&#8217;&#233;criture des instructions que de celle des conseils, avertissements, d&#233;finitions, commentaires ou illustrations.
Nous travaillons actuellement au d&#233;velopement de techniques bas&#233;es sur le bootstrapping, mais adapt&#233;es &#224; la
probl&#232;matique du discours, visant &#224; am&#233;liorer la d&#233;finition des r&#232;gles pour un type de ph&#233;nom&#232;ne donn&#233;. Cela
inclut les aspects structurels aussi bien que les aspects lexicaux, en particulier la caract&#233;risation fine des marques.
Ces marques sont de types tr&#232;s diversifi&#233;s. Pour bien organiser nos ressources lexicales, il convient d&#8217;&#233;laborer, au
sein du syst&#232;me, une architecture souple et modulaire, mais non redondante, des ressources lexicales (marqueurs,
classes s&#233;mantiques de verbes, expressions d&#233;di&#233;es, etc.).
</p>
<p>4 L&#8217;environnement linguistique de &lt;TextCoop&gt;
</p>
<p>Nous avons pr&#233;sent&#233; essentiellement dans ce document le moteur de &lt;TextCoop&gt; ainsi que le formalisme des
r&#232;gles. Il est clair qu&#8217;un tel syst&#232;me ne peut fonctionner qu&#8217;en s&#8217;appuyant sur un ensemble de ressources lexicales,
et ne peut &#234;tre v&#233;ritablement int&#233;gr&#233; dans des traitements de grande &#233;chelle que si, outre ses performances, ses
modules de ressources (lexique, grammaires locales, ontologies et terminologies, etc.) et formats d&#8217;entr&#233;e sortie
des documents suivent des formats normalis&#233;s. Il est essentiel aussi qu&#8217;il dispose d&#8217;un module de mise au point
des r&#232;gles, de visualisation des r&#233;sultats et des recommandations et une m&#233;thode pour son int&#233;gration dans des
applications.
</p>
<p>Pour l&#8217;heure, nous avons d&#233;velopp&#233; et int&#233;gr&#233; diff&#233;rents modules de ressources qui sont plus particuli&#232;rement
pertinents pour l&#8217;analyse du discours que l&#8217;on peut utiliser tels quels dans les r&#232;gles, comme par exemple :
&#8211; des listes de connecteurs typ&#233;s : de cause, concession, temps, etc.
&#8211; des listes de termes sp&#233;cifiques pouvant &#234;tre utilis&#233;s comme marques : marques de l&#8217;illustration, de la reformu-
</p>
<p>lation, du d&#233;veloppement, etc.
&#8211; des listes de verbes par classes et sous-classes s&#233;mantiques, inspir&#233;es des classes de WordNet,
&#8211; des listes de termes avec polarit&#233; n&#233;gative ou positive, ceci est utile en argumentation et en analyse d&#8217;opinions.
&#8211; des grammaires locales : expression du temps, de la quantit&#233;, expressions &#233;valuatives simples, etc.
&#8211; enfin, des modules qui contiennent quelques r&#232;gles simples pour reconnaitre des structures telles que : illustra-
</p>
<p>tion, reformulation, but, condition, d&#233;finition et &#233;laboration (une relation nettement plus complexe et compo-
site). De fa&#231;on plus g&#233;n&#233;rale, nous souhaitons &#233;tudier comment on peut greffer un analyseur de phrases au sein
de &lt;TextCoop&gt; pour le compl&#233;ter.
</p>
<p>En mati&#232;re de visualisation des r&#233;sultats, nous avons conduit une exp&#233;rimentation tr&#232;s concluante en utilisant
NAVITEXTE (http ://panini.u-paris10.fr/jlm/?Start :projets :NaviTexte), m&#234;me si cette interface est un peu trop
&#233;labor&#233;e pour nos besoins. Nous envisageons &#224; pr&#233;sent une visualisation qui soit davantage sous forme d&#8217;abre,
tout en pr&#233;servant la structure du document original. En mati&#232;re de normalisation des donn&#233;es et de certains
traitements, nous &#233;tudions le cadre de UIMA (http ://www.uima-fr.org/) qui est certainement une direction forte.
L&#8217;aide &#224; la mise au point des r&#232;gles est difficile &#224; concevoir dans le cadre du discours. Dans notre cadre, elle se
limite actuellement &#224; quelques recommandations sur leur forme et la fa&#231;on de les simplifier ou de les g&#233;n&#233;raliser.
Nous envisageons de d&#233;velopper un analyseur qui d&#233;tecterait certains types d&#8217;erreurs ou d&#8217;incompatibilit&#233;s entre
r&#232;gles, comme cela existe dans certains compilateurs de r&#232;gles. Etant dans une &#233;tape qui demeure exp&#233;rimentale,
il nous faut bien identifier les besoins &#8217;raisonnables&#8217; en mati&#232;re de mise au point de r&#232;gles et de ressources avant
d&#8217;en r&#233;aliser une impl&#233;mentation. L&#8217;architecture des ressources linguistiques utilis&#233;es dans les r&#232;gles, pour &#233;viter
les doubles et les incoh&#233;rences est aussi un sujet d&#8217;&#233;tude actuel.
</p>
<p>5 Les applications
</p>
<p>Le projet &lt;TextCoop&gt; est &#224; l&#8217;origine d&#233;di&#233; &#224; l&#8217;analyse des proc&#233;dures (Delpech et al. 2008). Nous avons donc
conduit nos premi&#232;res exp&#233;rimentations sur les structures li&#233;es aux proc&#233;dures, qui ont des caract&#233;ristiques assez
diversifi&#233;es et qui permettent de bien tester &#224; la fois le moteur et l&#8217;&#233;criture des r&#232;gles. Un &#233;l&#233;ment int&#233;ressant est
que, dans ce projet, nous avons analys&#233; &#224; la fois des structures linguistiques connues et des structures d&#233;di&#233;es
(titres, instructions, etc.). Les caract&#233;ristiques globales de ces structures sont les suivantes :
&#8211; titres : ressemblent &#224; des instructions, bien que souvent tr&#232;s elliptiques (verbe ou objet sous-entendu), les r&#232;gles
</p>
<p>de reconnaissance s&#8217;appuient sur de nombreuses consid&#233;rations typographiques.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>&lt;TEXTCOOP&gt;: UN ANALYSEUR DE DISCOURS BAS&#201; SUR LES GRAMMAIRES LOGIQUES
</p>
<p>&#8211; instructions : nous traitons ici en fait de compos&#233;s instructionnels qui peuvent contenir plusieurs instructions
&#233;l&#233;mentaires. Dans ces r&#232;gles, les difficult&#233;s sont la d&#233;limitation des instructions ainsi que le grand nombre de
symboles gaps introduits. L&#8217;identification des instructions se fait simplement sur la base de verbes et d&#8217;indica-
tions morphosyntaxiques.
</p>
<p>&#8211; pr&#233;requis : longue structure sous forme de liste, pauvre en verbes (les gaps excluent les verbes), elle se situe en
g&#233;n&#233;ral au d&#233;but du document, elle est parfois difficile &#224; identifier &#224; cause de conflits avec des sommaires ou de
la publicit&#233;. La structure typographique, cod&#233;e dans les r&#232;gles, est un &#233;l&#233;ment essentiel.
</p>
<p>&#8211; conseils et avertissements, ont la forme d&#8217;arguments : s&#233;quence d&#8217;une conclusion (une instruction particuli&#232;re)
suivie d&#8217;un ou plusieurs supports (les difficult&#233;s &#224; pr&#233;voir si on ne fait pas ce qui est demand&#233;). Ces deux
structures sont li&#233;es et demandent un traitement conjoint via deux paquets de r&#232;gles. Des r&#232;gles de liage lient
les deux composants. Conseils et avertissements ressemblent &#224; la structure des instructions, mais sont pourvus
de marqueurs sp&#233;cifiques (Fontan et al. 2009) riches et diversifi&#233;s. Ces structures sont trait&#233;es dans une &#233;tape
de cascade qui pr&#233;c&#232;de celle des instructions. Des zones ferm&#233;es &#233;vitent les doubles analyses.
</p>
<p>Par ailleurs, selon le m&#234;me sch&#233;ma, nous avons d&#233;velopp&#233; une analyse d&#8217;avis consommateurs o&#249; nous faisons res-
sortir la structure du discours, globalement : type de produit, circonstances d&#8217;achat, liste d&#8217;arguments (propri&#233;t&#233;s
avec des avis positifs et n&#233;gatifs), recommandation, commentaires. Bien que ce travail soit encore dans un stade
exp&#233;rimental,&lt;TextCoop&gt; est bien adapt&#233; pour rendre compte de la structure globale de ce type de texte.
</p>
<p>Enfin, &lt;TextCoop&gt; a &#233;t&#233; utilis&#233; ponctuellement comme outil d&#8217;exploration &#224; l&#8217;enrichissement de documents
semi-structur&#233;s, comme par exemple l&#8217;ajout d&#8217;une zone de pr&#233;-requis dans les proc&#233;dures qui n&#8217;en ont pas.
En perspective, via un projet ANR, LELIE, qui d&#233;bute, &lt;TextCoop&gt; sera utilis&#233; pour l&#8217;analyse et la pr&#233;vention
des risques industriels tels qu&#8217;ils peuvent apparaitre dans les proc&#233;dures (mauvaise r&#233;daction, non suivi d&#8217;exi-
gences r&#233;glementaires ou m&#233;tier). Dans ce cadre pr&#233;-industriel, &lt;TextCoop&gt; recevra un environnement plus
professionnel.
</p>
<p>6 Conclusion
</p>
<p>Dans ce document, nous avons pr&#233;sent&#233; les principales caract&#233;ristiques de &lt;TextCoop&gt;, un environnement bas&#233;
sur les grammaires logiques d&#233;di&#233; &#224; l&#8217;analyse de structures discursives via le langage offert par DisLog. Nous
avons d&#233;taill&#233; en particulier la structure des r&#232;gles et du moteur. Nous avons indiqu&#233; au fur et &#224; mesure du texte
l&#8217;&#233;tat du travail, les performances et les orientations en particulier en mati&#232;re d&#8217;environnement, d&#8217;aide &#224; l&#8217;&#233;criture
de r&#232;gles et de d&#233;veloppement applicatif.
</p>
<p>S&#8217;il existe plusieurs plateformes tr&#232;s &#233;labor&#233;es pour l&#8217;analyse de la phrase et de structures plus petites, il y a peu
de plateformes qui soient d&#233;di&#233;es &#224; l&#8217;analyse de structures du discours, qu&#8217;elles soient rh&#233;toriques ou d&#233;di&#233;es &#224; des
applications. Outre cette originalit&#233; relative, un &#233;l&#233;ment important dans sa viabilit&#233; est le d&#233;veloppement d&#8217;aide &#224;
l&#8217;&#233;criture de r&#232;gles et des &#233;l&#233;ments du langage qui y sont associ&#233;s.
</p>
<p>Le code&lt;TextCoop&gt; et des donn&#233;es linguistiques associ&#233;es seront prochainement mis &#224; disposition sous licence
GPL.
</p>
<p>Remerciements
</p>
<p>Ce projet est soutenu par un projet de coop&#233;ration franco-indien (IFCPAR) ainsi que par l&#8217;ANR (projet termin&#233;
TextCoop, et projet actuel LELIE).
</p>
<p>R&#233;f&#233;rences
</p>
<p>Amgoud, L., Bonnefon, J.F., Prade, H., An Argumentation-based Approach to Multiple Criteria Decision, in
8th European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty, ECSQA-
RU&#8217;2005, Barcelona, 2005.</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>PATRICK SAINT-DIZIER
</p>
<p>Amgoud, L., Parsons, S., Maudet, N., Arguments, Dialogue, and Negotiation, in : 14th European Conference on
Artificial Intelligence, Berlin, 2001.
</p>
<p>Anscombre, J.-Cl. Ducrot, O., Interrogation et Argumentation, in Langue francaise, no 52, L&#8217;interrogation, 5 - 22,
1981.
</p>
<p>Aouladomar, F., Saint-Dizier, P., An Exploration of the Diversity of Natural Argumentation in Instructional Texts,
5th International Workshop on Computational Models of Natural Argument, IJCAI, Edinburgh, 2005.
</p>
<p>Bouffier, A., Poibeau, T., Re-engineering free texts to obtain XML documents : a discourse based approach,
RANLP 2007. Carberry, S., Plan Recognition in natural language dialogue, Cambridge university Press, MIT
Press, 1990.
</p>
<p>Cruse, A., Lexical Semantics, Cambridge Univ. Press, 1986.
</p>
<p>Delin, J., Hartley, A., Paris, C., Scott, D., Vander Linden, K., Expressing Procedural Relationships in Multilingual
Instructions, Proceedings of the Seventh International Workshop on Natural Language Generation, pp. 61-70,
Maine, USA, 1994.
</p>
<p>Delpech, E., Saint-Dizier, P., Investigating the Structure of Procedural Texts for Answering How-to Questions,
LREC 2008, Marrakech.
</p>
<p>Davidson, D., Actions, Reasons, and Causes, Journal of Philosophy, 60, 1963
</p>
<p>Di Eugenio, B. and Webber, B.L., Pragmatic Overloading in Natural Language Instructions, International Journal
of Expert Systems, 1996.
</p>
<p>Lionel Fontan, Patrick Saint-Dizier. Constructing a Know-How Repository of Advices and Warnings from Pro-
cedural Texts. Dans ACM International Conference on Document Engineering, Sao Paolo, Dick Bulterman, Luiz
Soares (Eds.), ACM, p. 234-240, september 2008.
Gardent, C., Discourse tree adjoining grammars, report nb. 89, Univ. Saarlandes, Saarbrucken, 1997.
Kosseim, L., Lapalme, G., Choosing Rhetorical Structures to Plan Instructional Texts, Computational Intelligence,
Blackwell, Boston, 2000.
</p>
<p>Mann, W., Thompson, S., Rhetorical Structure Theory : Towards a Functional Theory of Text Organisation, TEXT
8 (3) pp. 243-281, 1988.
Marcu, D., The Rhetorical Parsing of Natural Language Texts, ACL 1997.
</p>
<p>Marcu, D., Au unsupervised approach to recognizing Discourse relations, ACL 2002.
</p>
<p>Moschler, J., Argumentation et Conversation, El&#233;ments pour une Analyse Pragmatique du Discours, Hatier -
Cr&#233;dif, 1985.
</p>
<p>Rosner, D., Stede, M., Customizing RST for the Automatic Production of Technical Manuals, in R. Dale, E. Hovy,
D. Rosner and O. Stock eds., Aspects of Automated Natural Language Generation, Lecture Notes in Artificial
Intelligence, pp. 199-214, Springler-Verlag, 1992.
</p>
<p>Saito, M., Yamamoto, K., Sekine, S., Using Phrasal Patterns to Identify Discourse Relations, ACL, 2006.
</p>
<p>Schauer, H., From Elementary Discourse Units to Complex Ones, ACL 2006.
</p>
<p>Takechi, M., Tokunaga, T., Matsumoto, Y., Tanaka, H., Feature Selection in Categorizing Procedural Expressions,
The Sixth International Workshop on Information Retrieval with Asian Languages (IRAL2003), pp.49-56, 2003.
Vander Linden, K., Speaking of Actions Choosing Rhetorical Status and Grammatical Form in Instructional Text
Generation Thesis, University of Colorado, 1993.
</p>
<p>Webber, B., D-LTAG : extending lexicalized TAGs to Discourse, Cognitive Science 28, pp. 751-779, Elsevier,
2004.
</p>
<p>Wright, von G.H., Explanation and understanding, Cornell university Press, 2004.</p>

</div></div>
</body></html>