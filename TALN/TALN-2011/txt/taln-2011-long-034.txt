TALN 2011, Montpellier, 27juin — 1°’ju1'11et 2011

<TextCoop>: un analyseur de discours basé sur les grammaires logiques

Patrick Saint-Dizier
IRIT-CNRS, Toulouse
stdizier@irit.fr

Résllnlé. Dans ce document, nous presentons les principales caracteristiques de <TextCoop>, un environ-
nement base sur les grammaires logiques dedie a l’analyse de structures discursives. Nous etudions en particulier
le langage DisLog qui ﬁxe la structure des regles et des speciﬁcations qui les accompagnent. Nous presentons la
structure du moteur de <TextCoop> en indiquant au fur et a mesure du texte l’etat du travail, les performances
et les orientations en particulier en matiere d’environnement, d’aide a l’ecriture de regles et de developpement
applicatif.

Abstract. In this paper, we introduce the main features of <TextCoop>, an environment dedicated to
discourse analysis within a logic—based grammar framework. We focus on the structure of discourse rules (DisLog
language) and on the features of the engine, while outlining the results, the performances and the orientations for
future work.

M0tS-CléS 3 grammaire du discours, programmation en logique, grammaires logiques.

Keywords: discourse structure, logic programming, logic—based grammars.

1 Analyser quelles structures discursives ?

Lorsque l’on pense a l’analyse de structures discursives, il vient d’abord a l’esprit l’analyse des structures rheto-
riques qui, d’une fagon ou d’une autre, sont censees permettre de rendre compte de fagon complete des diverses
articulations discursives d’un texte (Marcu 97, 02). L’ objectif est de relier tous les elements d’un texte par le biais
de ces relations, ce qui rend alors compte de la structure semantico—pragmatique de ce texte. Outre le fait que ces
relations existent en grand nombre et avec parfois des deﬁnitions un peu vagues et difﬁcilement operationalisables,
il existe en fait, pour le besoin des applications, un grand nombre d’autres structures qui rentrent plus ou moins
facilement dans le paradigme rhetorique.

C’est ainsi le cas des cadres du discours, initie en France par M. Charolles, pour lesquels les relations rhetoriques
’frame’ ou ’background’ ne sont pas tout a fait satisfaisantes. C’est aussi le cas de nombreux types de structures
’dediees’, comme par exemple les instructions dans le discours procedural. Enﬁn, notons toutes les structures qui
relevent de la typographie et qui ont un lien avec le contenu du texte (titres, notes, paragraphes, listes, etc.). Enﬁn,
notons la complexite sous—jacente de certaines representations qui forment des reseaux complexes de liens entre
structures.

Dans la suite de ce document, nous proposons un environnement, <TextCoop>, dedie a l’analyse des structures
discursives, base sur la notion de grammaire logique. Nos experimentations ayant largement toume autour de
l’analyse des diverses structures rencontrees dans les textes proceduraux, nombre d’exemples sont empruntes :21 Ce
cadre (Delpech et al 07, 08) (Aouladomar et al. 05), voir aussi (Delin 94) ou (Takechi 03). <TextCoop> designe
l’ ensemble de 1’ architecture du systeme, y compris les outils d’ aide a la Inise au point et les ressouces linguistiques
associees. DisLog (pour ’Dicourse in Logic’ ou ’Discontinuities in Logic’) designe le langage qui decrit les regles
d’analyse et les contraintes que l’on peut y associer.

Notre modelisation n’est pas dediee a un cadre applicatif particulier ou a un genre textuel. Apres un bref posi-
tionnement, nous presentons la syntaxe des regles de DisLog ainsi que des outils associes. Contrairement a une
approche basee sur l’apprentissage (Marcu 02), l’ensemble de notre travail est positionne dans une modelisation
linguistique et declarative, typique des grammaires logiques, qui autorise le raisonnement. Notre approche est
quelque peu base sur une vision generative a base de principes. Nous presentons ensuite les fonctionalites du

PATRICK SAINT-DIZIER

moteur ainsi que son environnement actuel. Le développement de <TextCoop> est encore dans un stade experi-
mental : un travail est touj ours en cours sur les propriétés de son environnement et des fonctions qu’il peut ofﬁr. Par
contre, ses fondements sont globalement ﬁxes, et ont ete testes dans plusieurs cadres linguistiques et applicatifs.

Historiquement, <TextCoop> a initialement fait 1’ obj et d’une etude dediée aux procedures grand—public (Delpech
et al 08) avec une implementation simple en Perl de l’ensemble des fonctions. Toutefois, la rigidite, le peu de
portabilite et les limites expressives de Perl nous ont pousse a refaire une implementation en Java, a base de
génerateurs d’automates, utilisant J CUP. Cette approche a dﬁ etre abondonnee apres 10 mois de programmation
infructueuse. Voulant augmenter les possibilités expressives du systeme, en particulier au niveau raisonnement, et
avoir un développement ﬁable et rapide, nous avons ﬁnalement opté pour une version en Prolog que nous pouvons
facilement faire evoluer et maintenir. Via une collaboration avec une société, les aspects interfaces et aide a la
mise au point seront développés des que pertinent pour en faire une plateforme operationelle. Une licence de type
GPL est prevue au moins pour la partie noyau.

1.1 Le positionnement de <TextC00p>

La plateforme <TextCoop>, dédiée a l’analyse de structures du discours, doit permettre de pouvoir reconnaitre
une grande diversité de structures, genériques ou dediées a des applications ou a des genres textuels. <TextCoop>
vise a la fois le traitement de structures discursives generiques, dans des textes quelconques, et le traitement de
structures plus speciﬁques, ’metier’, dans des textes plus specialises.

Considerant la complexité de la description des structures du discours, nous developpons une vision qui s’appuie
sur quelques considerations simples de la grammaire generative a savoir developper :
— des principes productifs, qui ont un bon niveau d’ abstraction, linguistiquement adequat, mais qui sur—reconnaissent
dans certains cas,
— et des principes restrictifs qui viennent limiter la puissance des premiers, sur la base de contraintes de bonne
formation, qui peuvent etre géneraux ou spéciﬁques.
Cette approche modulaire permet une meilleure modélisation des phenomenes, plus compartimentee, et un meilleur
controle sur le resultat. Elle permet aussi une Inise au point des regles et une évolutivité plus simple. Ces principes
sont gérés par un traitement en cascade des regles, y compris de liage et de correction.

Par le biais des differentes contraintes introduites dans DisLog, il est possible de produire des representations
étiquetées complexes, sous forme d’ arbres, de graphe ou de dependances. DisLog permet d’introduire des relations
de un vers plusieurs ou de plusieurs vers un, permettant ainsi qu’une structure soit en relation avec plusieurs autres
structures de natures différentes. Cependant, dans la plupart des textes étudiés, ces relations sont relativement
simples, le souci etant en general de préserver l’intelligibilité des documents.

Le formalisme des regles, DisLog, permet d’introduire tout type de forme de raisonnement a priori. Ceci est un
point original et crucial en analyse du discours, facilité par l’implementation realisée en Prolog. Ces formes de rai-
sonnements permettent entre autres (1) de réaliser des calculs, reportés dans les annotations produites, (2) de lever
des ambigu'1'tés d’analyse, (3) de compléter l’analyse grammaticale par l’appel par exemple a des connaissances
(pour inclure des données pragmatiques). Si une requete de raisonnement echoue, alors la regle echoue.

La litterature est particulierement abondante s’agissant de l’analyse du discours. On y trouve plusieurs directions.
Un mouvement theorique assez important s’est développé depuis 20 ans environ, autour de plusieurs cadres dont
la DRT et ses extensions. Ce cadre demeure essentiellement abstrait et orienté vers des modes de representations
peu expressifs. Notre orientation etant a la fois plus empirique et liée a une sémantique conceptuelle plutot que
formelle, ce cadre n’est a priori pas pertinent pour nos travaux et ne sera pas evoqué ici. Plusieurs approches
empiriques sont par contre d’un interet marque. Il y a tout d’abord les travaux qui caractérisent la nature et la
forme des relations rhétoriques. (Mann et al 88) ont propose une formulation contemporaine de ce cadre. De
nombreux travaux ont suivi dont (Delin 94), (Kosseim et al 00), (Rossner et al 92), (Saito et al 06), (Vander
Linden 93), etc. qui afﬁnent ces relations ou les étudient dans des cadres specialises. cependant, on assiste alors a
une proliferation de ces relations, ou les deﬁnitions deviennent parfois vagues.

Un courant plus profond se preoccupe du sens vehiculé par ces relations, dans une perspective cognitive, de
leur aspects pragmatiques ainsi que des intentions de communication sous—jacentes (Wright 04), (Moschler 85)
(Davidson 63) (Anscrombre et al 81). Ceci est particulierement interessant dans différents cadres tels que le
dialogue, l’argumentation et la négociation (Amgoud et al. 01, 05), et la generation de langue naturelle (Rosner et

<TEXTCOOP>Z UN ANALYSEUR DE DISCOURS BASE SUR LES GRAMMAIRES LOGIQUES

— instructions : nous traitons ici en fait de composes instructionnels qui peuvent contenir plusieurs instructions
elementaires. Dans ces regles, les difﬁcultés sont la delimitation des instructions ainsi que le grand nombre de
symboles gaps introduits. L’identiﬁcation des instructions se fait simplement sur la base de verbes et d’indica—
tions morphosyntaxiques.

— prerequis : longue structure sous forme de liste, pauvre en verbes (les gaps excluent les verbes), elle se situe en
general au debut du document, elle est parfois difﬁcile a identiﬁer a cause de conﬂits avec des sommaires ou de
la publicité. La structure typographique, codee dans les regles, est un element essentiel.

— conseils et avertissements, ont la forme d’arguments : sequence d’une conclusion (une instruction particuliere)
suivie d’un ou plusieurs supports (les difﬁcultés a prévoir si on ne fait pas ce qui est demandé). Ces deux
structures sont liees et demandent un traitement conjoint via deux paquets de regles. Des regles de liage lient
les deux composants. Conseils et avertissements ressemblent a la structure des instructions, mais sont pourvus
de marqueurs speciﬁques (Fontan et al. 2009) riches et diversiﬁés. Ces structures sont traitées dans une etape
de cascade qui precede celle des instructions. Des zones fermees évitent les doubles analyses.

Par ailleurs, selon le meme schema, nous avons développé une analyse d’avis consommateurs ou nous faisons res-

sortir la structure du discours, globalement : type de produit, circonstances d’achat, liste d’arguments (proprietes

avec des avis positifs et negatifs), recommandation, commentaires. Bien que ce travail soit encore dans un stade
experimental, <TextCoop> est bien adapte pour rendre compte de la structure globale de ce type de texte.

Enﬁn, <TextCoop> a été utilise ponctuellement comme outil d’exploration a l’enrichissement de documents
semi—structurés, comme par exemple l’aj out d’une zone de pre-requis dans les procedures qui n’en ont pas.

En perspective, via un proj et ANR, LELIE, qui débute, <TextCoop> sera utilise pour l’analyse et la prevention
des risques industriels tels qu’ils peuvent apparaitre dans les procedures (mauvaise redaction, non suivi d’exi—
gences réglementaires ou metier). Dans ce cadre pré-industriel, <TextCoop> recevra un environnement plus
professionnel.

6 Conclusion

Dans ce document, nous avons presenté les principales caractéristiques de <TextCoop>, un environnement base
sur les grammaires logiques dedié a l’analyse de structures discursives via le langage offert par DisLog. Nous
avons detaille en particulier la structure des regles et du moteur. Nous avons indiqué au fur et a mesure du texte
l’état du travail, les performances et les orientations en particulier en matiere d’environnement, d’aide a l’écriture
de regles et de développement applicatif.

S’il existe plusieurs plateformes tres elaborees pour l’analyse de la phrase et de structures plus petites, il y a peu
de plateformes qui soient dediées a l’analyse de structures du discours, qu’elles soient rhétoriques ou dediées a des
applications. Outre cette originalité relative, un element important dans sa viabilite est le développement d’aide a
l’écriture de regles et des elements du langage qui y sont associés.

Le code <TextCoop> et des donnees linguistiques associées seront prochainement mis a disposition sous licence
GPL.

Remerciements

Ce projet est soutenu par un projet de cooperation franco—indien (IFCPAR) ainsi que par l’ANR (projet termine
TextCoop, et projet actuel LELIE).

Références

Amgoud, L., Bonnefon, J .F., Prade, H., An Argumentation-based Approach to Multiple Criteria Decision, in
8th European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty, ECSQA—
RU’ 2005, Barcelona, 2005.

PATRICK SAINT-DIZIER

Amgoud, L., Parsons, S., Maudet, N., Arguments, Dialogue, and Negotiation, in : 14th European Conference on
Artiﬁcial Intelligence, Berlin, 2001.

Anscombre, J .-Cl. Ducrot, 0., Interrogation et Argumentation, in Langue francaise, no 52, L’ interrogation, 5 - 22,
1981.

Aouladomar, F., Saint—Dizier, P., An Exploration of the Diversity of Natural Argumentation in Instructional Texts,
5th International Workshop on Computational Models of Natural Argument, IJCAI, Edinburgh, 2005.

Boufﬁer, A., Poibeau, T., Re—engineering free texts to obtain XML documents : a discourse based approach,
RANLP 2007. Carberry, S., Plan Recognition in natural language dialogue, Cambridge university Press, MIT
Press, 1990.

Cruse, A., lexical Semantics, Cambridge Univ. Press, 1986.

Delin, J ., Hartley, A., Paris, C., Scott, D., Vander Linden, K., Expressing Procedural Relationships in Multilingual
Instructions, Proceedings of the Seventh International Workshop on Natural Language Generation, pp. 61-70,
Maine, USA, 1994.

Delpech, E., Saint—Dizier, P., Investigating the Structure of Procedural Texts for Answering How-to Questions,
LREC 2008, Marrakech.

Davidson, D., Actions, Reasons, and Causes, Journal of Philosophy, 60, 1963

Di Eugenio, B. and Webber, B.L., Pragmatic Overloading in Natural Language Instructions, International Journal
of Expert Systems, 1996.

Lionel Fontan, Patrick Saint—Dizier. Constructing a Know—How Repository of Advices and Warnings from Pro-
cedural Texts. Dans ACM International Conference on Document Engineering, Sao Paolo, Dick Bulterman, Luiz
Soares (Eds.), ACM, p. 234-240, september 2008.

Gardent, C., Discourse tree adjoining grammars, report nb. 89, Univ. Saarlandes, Saarbrucken, 1997.

Kosseim, L., Lapalme, G., Choosing Rhetorical Structures to Plan Instructional Texts, Computational Intelligence,
Blackwell, Boston, 2000.

Mann, W., Thompson, S., Rhetorical Structure Theory : Towards a Functional Theory of Text Organisation, TEXT
8 (3) pp. 243-281, 1988.

Marcu, D., The Rhetorical Parsing of Natural Language Texts, ACL 1997.
Marcu, D., Au unsupervised approach to recognizing Discourse relations, ACL 2002.

Moschler, J ., Argumentation et Conversation, Ele’ments pour une Analyse Pragmatique du Discours, Hatier -
Credif, 1985.

Rosner, D., Stede, M., Customizing RST for the Automatic Production of Technical Manuals, in R. Dale, E. Hovy,
D. Rosner and O. Stock eds., Aspects of Automated Natural Language Generation, Lecture Notes in Artiﬁcial
Intelligence, pp. 199-214, Springler—Verlag, 1992.

Saito, M., Yamamoto, K., Sekine, S., Using Phrasal Patterns to Identify Discourse Relations, ACL, 2006.
Schauer, H., From Elementary Discourse Units to Complex Ones, ACL 2006.

Takechi, M., Tokunaga, T., Matsumoto, Y., Tanaka, H., Feature Selection in Categorizing Procedural Expressions,
The Sixth International Workshop on Information Retrieval with Asian Languages (IRAL2003), pp.49-56, 2003.

Vander Linden, K., Speaking of Actions Choosing Rhetorical Status and Grammatical Form in Instructional Text
Generation Thesis, University of Colorado, 1993.

Webber, B., D—LTAG : extending lexicalized TAGs to Discourse, Cognitive Science 28, pp. 751-779, Elsevier,
2004.

Wright, von G.H., Explanation and understanding, Cornell university Press, 2004.

<TEXTCOOP>Z UN ANALYSEUR DE DISCOURS BASE SUR LES GRAMMAIRES LOGIQUES

al. 92) qui, au niveau de son composant de planiﬁcation, s’appuie en particulier sur des schemas rhetoriques.

Une interrogation touj ours d’actualite conceme la caracterisation en langue des relations de discours aﬁn de pou-
voir les identiﬁer automatiquement. C’est de toute evidence un deﬁ ouvert, ou des solutions parfois paralleles
ont ete tentees, car ces relations n’ont pas systematiquement des marques qui les identiﬁent. Notons par exemple
(Mann et al. 88), (Saito et al. 06), (Takechi et al 03) (Di Eugenio et al 96) qui soulignent bien les resultats que
l’on peut escompter. Recemment, par exemple via le projet ANR Annodis, une approche a base d’apprentissage a
partir d’annotations manuelles s’est developpee. Une telle entreprise se heurte a deux difﬁcultes : les desaccords
importants (mais inevitables) entre annotateurs et la difﬁculte de developper de l’apprentissage sur des segments
textuels importants ou peu d’information est en fait pertinente. Enﬁn, notons les travaux qui developpement des
grammaires pour le texte par exemple a partir de TAGs (Gardent 97) (Webber 04).

Au niveau des environnements, GATE (http ://gate.ac.uk/) est une plateforme tres repandue et qui intervient dans
de nombreux proj ets. Elle est essentiellement dediee a l’analyse de phrases ou de courts fragments de textes. Par
ailleurs, Linguastream

(http ://www.linguastream.org/l1ome.ht1nl) est une plateforme ouverte pour l’analyse du langage qui peut accepter
en entree tout type de texte XML. Il est base sur une architecture en composants et offre plusieurs API Java
utiles pour l’integration. C’est un systeme largement ouvert qui laisse une grande liberte a l’utilisateur tout en lui
proposant un ensemble d’outils d’aide et d’interfaces tres pertinents. Linguastream est d’abord dedie a l’analyse
de la phrase au sein de textes. Cette plateforme ne permet pas d’inclure de modules de raisonnement comme cela
est tres utile en analyse de structures discursives, par exemple pour lever des ambiguites ou pour introduire des
considerations pragmatiques. Il serait toutefois interessant de voir avec ces plateformes comment on peut ecrire
des analyseurs de structures de discours.

Au niveau des grammaires de discours, nous pensons qu’il est necessaire de preserver une analyse linguistique
precise, qui permet de decrire les phenomenes a un bon niveau d’abstraction, en preservant une certaine predic-
tibilite. Nous nous attacherons donc a un travail essentiellement manuel, meme si des traitements automatiques
sur corpus sont utilises pour explorer les constructions (par exemple par bootstrapping). Ce texte etant dedie a la
partie grammaire, cet aspect methodologique est traite ailleurs.

1.2 Le langage des structures du discours

Il n’est pas dans notre objectif d’argumenter pour les differents aspects un langage elargi qui rende compte de
l’ensemble des formes que peuvent prendre les structures qui relevent du discours. Nous nous contenterons d’en
observer un certain nombre, fortement recurrentes dans les situations que nous avons examinees, et qui sont a la
base du langage de description DisLog introduit dans <TextCoop>. Ce langage est concu de fagon assez ouverte
pour pouvoir permettre de coder de nombreuses conﬁgurations.

Les relations rhetoriques (Mann et al 88) sont structurees sous forme de deux types de relations :

— une relation hierarchique dite de noyau vers satellite. Ainsi dans insérez verticalement la carte mére sinon vous
risquez d ’endommager les cormecteurs’, la premiere partie de l’enonce est habituellement appelee conclusion
d’argument (ici de type avertissement) tandis que la seconde partie, qui explique les risques encourus, est
appelee support de l’argument. La conclusion peut apparaitre seule, avec un support vide, mais le support n’a
de sens que s’il est relie a au moins une conclusion.

— une relation non hierarchique de noyau vers noyau. Ainsi la relation ’parallele’ associe—t—elle deux structures de
meme niveau, comme dans l’ellipse : Jean est regu ti son permis, Marie aussi.

L’ analyse discursive des textes s’applique souvent sur ces deux types de schemas. Cette structure est bien entendu

recursive ou emboitee : un satellite peut etre lui meme une structure composite complexe.

On observe cependant des situations plus complexes. Ainsi un noyau peut-il gouvemer plusieurs satellites, even-
tuellement de statuts differents (une deﬁnition suivie d’un conseil, un avertissement au milieu d’instructions). Un
cas courant de multiplicite de satellites dans les textes proceduraux est celui d’un titre (enonce d’un but) et des
instructions qui permettent de realiser ce but. Dans un texte, le reseau de relations devient alors tres complexe,
suivant une structure de graphe oriente. de plus, les relations noyau—satellite(s) sont souvent ﬂoues et ambigues et
varient selon le point de vue. Enﬁn, le caractere hierarchique de certaines relations est difﬁcile a etablir et peut
dependre du contexte.

Comme cela est souvent indique dans la litterature sur les relations du discours, celles—ci peuvent etre en tres

PATRICK SAINT-DIZIER

grand nombre, et de deﬁnitions variables selon les auteurs ou les annotateurs. Cette situation est nettement plus
complexe, pour faire un parallele, que dans le cas de la relation prédicat arguments ou ajouts, ou des relations
thématiques sont souvent employees et relativement bien maitrisées. Si l’on considere par exemple des textes
techniques, on observe que chaque genre peut avoir quelques structures spéciﬁques. C’est le cas par exemple des
instructions, du sommaire et des pre—requis dans les procedures.

1.3 Caractériser les structures discursives

De nombreux auteurs se sont attaqués au probleme difﬁcile qui consiste a deﬁnir un formalisme grammatical pour

reconnaitre les structures discursives. Nous faisons ici en quelque sorte une synthese des principales difﬁcultés. Si

l’on veut caracteriser la structure grammaticale d’une structure discursive, il convient de deﬁnir avec precision :

— Comment identiﬁer un objet discursif, sur quelles bases linguistiques, pragmatiques, typographiques, etc. (DiEu—
genio et al. 96). Certaines relations sont relativement bien marquees dans la plupart des cas, alors que d’autres
sont rarement marquees ou ne s’y pretent pas. Les discours en langue controlee ou a visée ﬁnalisée, visant l’ef—
ﬁcacite et la clarte, developpent en general des marques nettement plus évidentes, comme, par exemple, dans
le discours procedural ou didactique. Les marques peuvent de surcroit etre ambigues e11tre plusieurs relations.
Assez souvent, enﬁn, on remarque qu’un noyau se trouve identiﬁe parce qu’un satellite a eté identiﬁé et peut
lui etre associe : les satellites sont souvent mieux marques que leur noyau.

— Comment delimiter l’objet discursif une fois identiﬁé ‘.7 D’autres marques (ponctuation, typographie, connec-
teurs, etc.) peuvent etre considérées en complement des marques identiﬁantes indiquees ci-dessus. Une ap-
proche intéressante vise a developper la notion de structure de discours élémentaire (EDU (Schauer 06)), com-
parable, dans la phrase, a la proposition. Il convient d’en evaluer l’utilisabilité. Des groupes d’EDUs peuvent
parfois considérées et evaluees comme étant une structure discursive autonome (par exemple sur la base de la
théorie du centrage).

— Comment, une fois une structure discursive identiﬁée, la relier a une ou plusieurs autres structures ? La difﬁculte
est ici d’identiﬁer les structures exactes a mettre en relation, par exemple une enumeration (satellite) doit etre
liee exactement a 1’ element initiateur de cette enumeration, comme par exemple un terme ou une expression plus
generique (un titre). Les composants sont souvent contigiis, mais leur delimitation peut s’averer tres difﬁcile.

On se trouve donc devant une triade : identiﬁcation, déli1nitation,liage (des djfférents protagonistes de la rela-

tion).

2 Le formalisme grammatical de <TextCoop>

Le formalisme grammatical de <TextCoop>, DisLog, étend les possibilités expressives des approches a base
d’expressions régulieres et les adapte aux besoins de l’analyse de discours, en y intégrant un composant de raison—
nement souvent utile dans l’analyse de telles structures. Notre approche s’appuie aussi sur les travaux, maintenant
assez anciens, mais toujours actuels, des grammaires logiques (DCGs, XGs, MGs, etc.), qui s’appuient sur des
modeles d’exécution inspires des programmes logiques, dont Prolog. D’autres schémas de stratégie, par exemple
a base de contraintes ou utilisant du parallelisme ET—OU sont possibles. Cette approche nous parait intéressante
pour l’analyse du discours en raison de son caractere declaratif marque, de son independance relative aux strate-
gies de traitement, et aussi de son aptitude a intégrer naturellement des modules de raisonnement et des structures
de contraintes puissantes (par exemple des structures de traits types, des contraintes d’arbres).

Le formalisme que nous proposons ici peut aussi bien permettre de coder des regles d’analyse de structures dis-
cursives concues par des linguistes et codees manuellement que des regles issues de mécanismes d’apprentissage
a partir de textes annotes, qui produisent en sortie des formes contraintes. Il est aussi possible de coder globale—
ment une forme noyau—satellite que ces memes formes separemment. Ce demier choix est nécessaire lorsque la
combinatoire entre noyau et satellite est élevée, ou que ces constituants sont discontinus, ce qui est assez frequent.

2.1 DisLog : le formalisme grammatical

Le langage DisLog offert par <TextCoop> comprend les symboles suivants, ils suivent en general la syntaxe de
Prolog et des DCGs (grammaires a clauses déﬁnies) :

<TEXTCOOP>Z UN ANALYSEUR DE DISCOURS BASE SUR LES GRAMMAIRES LOGIQUES

— des symboles pré-terminaux et non terminaux. Les pre—terminaux se derivent directement en des entrees
lexicales ou des expressions (caractéristiques de structures rhétoriques ou de domaines, par exemple) ou bien
encore en des marques typographiques ou des marques d’annotations (html, XML, ...). Ces marques d’anno—
tations peuvent faire reference a des structures déja identiﬁées. Les symboles non terminaux font appel a des
grammaires, essentiellement a caractere local (par exemple grammaire des expressions temporelles) ou, plus ra-
rement, des constructions standard de la langue (SN, SV, etc.). Les regles ne s’appellent pas entre-elles. Les liens
entre structures sont realises par des operations de liage sélectif (Voir ci—dessous). Les symboles non terminaux
et préterminaux peuvent etre associés a des structures de traits attribut—Valeur, ceci ne sera pas développé ici,
tant bien connu. Enﬁn, ces symboles sont utilises soit pour identiﬁer un type de structure discursive soit comme
element de delimitation (inclus ou exclu). Lorsqu’ils sont exclus, ils apparaissent dans un prédicat ’bome’.

— des symboles terminaux indiqués entre crochets, cette possibilité est utile lorsqu’il y a peu de choix sur ces
terminaux au sein d’une regle, dans le cas contraire, il est péférable de faire appel a un préterminal,

— des indications d’optionalité ou d’itératiVité sur les symboles préterminaux et non terminaux,

— des symboles permettant d’exprimer la precedence linéaire (la ’,’), ainsi que la co—occurence de symboles (le
’ ;’) si l’on Veut utiliser la forme abrégée des regles (non développée ici),

— des ’ gaps’ qui représentent des sequences ﬁnies de mots qui ne présentent pas d’intéret pour la regle en cours de
description. La condition d’arret est constituée par le symbole explicite qui suit le gap. Des qu’un tel symbole
est rencontre, le gap s’arrete. Les gaps peuvent etre associés a des contraintes, en particulier des symboles ter-
minaux ou non—terminaux qui ne doivent pas etre ignores. Si un gap rencontre un tel symbole avant d’atteindre
sa condition d’arret alors il y a échec de la regle a reconnaitre la structure. Un gap ne peut ni commencer ni
terminer une regle, il doit toujours etre borne explicitement par un symbole ou un terminal.

— des appels a des prédicats qui introduisent des contraintes, des connaissances a intégrer ou des calculs divers.
Ceux—ci sont représentés entre accolades comme dans les DCGs.

— des fonctions d’assignation, explicites ou par défaut, d’étiquettes dédiées permettant d’étiqueter les structures
reconnues avec d’éVentuels attributs, calculés par les prédicats ci—dessus.

A priori, les regles sont de type 2, avec la syntaxe des DCGs. Toutefois des regles de type 1 peuvent aussi etre

construites. Le symbole en partie gauche de regle contient une Variable qui représente le résultat : en général il

s’agit de la structure complete telle que lue avec des marques d’annotation, éventuellement avec des attributs, au

debut et a la ﬁn correspondant a la structure reconnue. Il est aussi possible de repositionner des composants du
texte lus en entree.

A titre d’exemple, des expressions d’aVertissement du type il est conseille’ de ne jamais ACTION parce que....
se représentent simplement (i.e. sans faire de generalisation) comme ci—dessous (Fontan et al. 08). On considere
ici que la structure commengant par parce que ne fait pas partie de l’aVertissement (en fait c’est un support de
l’aVertissement selon les theories de l’argumentation, celui—ci est reconnu séparemment) :

aVertissement(R) —> [il, est], expr([type :conseil]), [de], negation, gap([connecteur([type :cause])), bome([parce,
que]).

Cette regle débute par la mention de deux terminaux, qui font partie de la structure a reconnaitre, suivie d’un
pré—terminal de type conseil (indique ici par la structure attribut Valeur dans l’argument). Elle se poursuit par un
autre terminal, un non terminal qui reconnait la negation, puis un gap dont on indique qu’il ne doit pas ignorer les
connecteurs de cause sur son parcours qui se termine sur la borne (une marque exteme a la regle, Voir ci—dessous)
qui est le terminal [parce,que]. La Variable R représente la structure étiquetée, qui est ici de la forme :
<aVertissement>  texte lu  < /aVertissement>.

2.2 L’insertion d’étiquettes XML

DisLog prévoit la possibilité (1) de speciﬁer d’autres types d’étiquettes que celles liées au symbole en partie
gauche, (2) d’inclure des attributs, et (3) d’insérer a tout endroit du segment de texte lu tout autre type d’étiquette.
Considérons :

<aVertissement> il est <exp-conseil force="modéré"> recommandé < /exp-conseil> de ne jamais ouvrir la
boite < /aVertissement>

Dans cet exemple, on a inséré une balise <exp—conseil> avec un attribut (déduit de propriétés lexicales) qui

PATRICK SAINT-DIZIER

indique la force du conseil, ici ’modére’.

L’insertion d’étiquettes XML se fait comme suit :

— par defaut en debut et ﬁn de sequence reconnue, en utilisant le non terminal donné en partie gauche de regle,

— si l’on Veut insérer une autre etiquette, alors celle—ci est speciﬁee explicitement par une Variable d’insertion.

Ceci Vaut aussi si on Veut aj outer un ou plusieurs attributs.
— si l’on Veut insérer des étiquettes complémentaires dans la sequence reconnue, celles—ci sont aussi speciﬁées
par des Variables d’insertion dans la partie droite de regle.

— si, d’aVenture, on ne Veut rien insérer en debut et ﬁn de sequence, on emploie la notation $noinsert.

Les Variables d’insertion sont représentées par : $insertl, $insert2, qui sont instanciées explicitement en ﬁn de
regle dans une section ’calculs’ entre accolades. On peut employer des Variables qui proviennent soit de deduc-
tions soit de caractéristiques heritees de données lexicales. Pour l’exemple ci—dessus, on doit ajouter dans la regle :
aVertissement(R) —> [il, est], $insertl, expr([type :conseil, force :F]), $insert2, [de], negation,
gap([connecteur([type :cause])), bome([parce, que]), { $insertl= <exp—conseil, force :F>, $insert2=< /exp-
conseil> }.

avec la donnée lexicale : expr([type :conseil, force :modéré]) —> [recommandé].

2.3 Les regles de liage sélectif

Les regles de liage sélectif permettent de lier deux structures ou plus comme évoque dans l’introduction. L’ objectif
est de lier noyau et satellite(s), ou tout autre lien que l’on souhaite établir (par exemple, connecteur — EDU, etc.).
Les regles de liage ont donc un statut de non-terminaux : elle lient entre—elles des regles, permettant de construire
des arbres partiels dans un texte, indiquant les structures discursives qui sont en relation. Par exemple si l’on Veut
lier les structures discursives a et b pour former c, on peut deﬁnir une regle de liage comme suit :

c(R) —> [<a>], gap, [< /a>], gap, [<b>], gap, [< /b>].

ce qui produira: <c> <a>,  < /a>,  <b>,  < /b> < /c>.

ou les structures a et b sont reproduites telles quelles.

De fagon plus concrete, si l’on considere la structure duale des arguments : conclusion—support, comme dans :
Il est capital d ’inse’rer verticalement la carte mére car vous riquez d ’endommager les cormecteurs.,
on aurait la regle de liage sélectif :

argument(R) —>[<conclusion>],gap, [< /conclusion>],connecteur([type:cause]), [<support>],gap, [< /support>].

et la structure resultante est :
<argument> <conclusion> Il est capital d’inserer Verticalement la carte mere < /conclusion>, car <support>
Vous riquez d’endommager les connecteurs < /support> < /argument>.

2.4 Les regles de correction

<TextCoop> permet la deﬁnition de regles de réecriture sur les balises permettant de repositionner certaines
balises qui pourraient ne pas etre positionnées correctement.

Un emploi immediat est lie au ré—équilibrage des balises qui peuvent se chevaucher, en particulier lorsque les
conditions de delimitation d’une regle sont trop peu contraintes. Typiquement, ces regles permettent de corriger
une situation telle que :

<a>, ...<b> < /a>,  < /b> en <a>,  < /a>,  <b>,  < /b>.

Les regles de correction ont la meme forme que celle ci—dessus, la Variable R contenant la structure corrigée :
corriger([<A>], gap, [< /A>], gap, [<B>], gap, [< /B>]) —> [<A>], gap.[<B>],gap, [< /A>], gap, [<
/B>].

On notera qu’ici A et B sont des Variables représentant a priori n’i1nporte quel identiﬁant de balise.

2.5 L’art d’écrire des regles

Dans notre approche, les regles sont écrites pour l’instant totalement de fagon manuelle, a partir d’analyse de
documents et de repérage de marques. Toutefois, le formalisme a été congu pour accueillir les speciﬁcations,

<TEXTCOOP>Z UN ANALYSEUR DE DISCOURS BASE SUR LES GRAMMAIRES LOGIQUES

relativement ouvertes, de systemes bases sur l’apprentissage. Nous souhaitons aussi introduire des outils d’aide a
l’ecriture de regles, par exemple bases sur des techniques de bootstrapping. Ceci reste toutefois a approfondir car
l’analyse de discours a des caracteristiques tres différentes de celle de la phrase ou bootstrapping et apprentissage
ont eté largement testes. Notre experience est que l’écriture de regles qui reconnaissent des structures de discours
et les lient sont complexes : elles présentent peu de marques explicites, ce qui les rend ambigues, elles couvrent
aussi tres souvent des fragments de texte consequents. Ces raisons font que nous avons privilégié dans notre
approche une écriture manuelle des regles que nous associerons a un ensemble d’outils de Visualisation de fagon
a guider les auteurs. Cette écriture, nous pensons, permet d’accéder a une meilleure adéquation linguistique et un
meilleur niveau de generalisation.

Par exemple, c’est a ce niveau que des mecanismes de raisonnement peuvent etre introduits. Dans le cas ci-
dessous :

la conﬁture se prépare avec des fruits rouges (cassis, fraises, framboises) aﬁn de 

pour identiﬁer que la structure entre parentheses est une illustration, faute de marques explicites, Via le controle :
cassis est_un ’fruit rouge’, etc. une terminologie simple est nécessaire. La regle suivante integre noyau et satellite
et s’ecrit, par exemple :

illustration(R) —> Nom(Type), [’(’], liste_Noms(Typel), [’)’], { subsume(Type,Typel) }.

Enﬁn, l’analyse de structures du discours mene a de nombreuses ambiguités. Les regles decrites par les auteurs
reﬂetent ces ambiguites. Notre systeme est congu soit pour reﬂeter toutes les analyses possibles (mode mise au
point) soit pour privilegier un choix a priori (Via le mecanismes de cascades de regles ou des heuristiques). Toute—
fois, les techniques d’interprétation des programmes logiques pourraient permettre des modes intermediaires, ainsi
qu’une interpretation a base de contraintes ’actiVes’ permettant de produire l’ensemble des analyses possibles.

2.6 Gestion de la concurrence entre régles

Nous proposons ici quelques contraintes qui gerent la concurrence entre regles. Les regles étant parfois trop
permissives (ou pourrait parler de principe productif comme pour la syntaxe X—bar), il est necessaire d’ajouter
des contraintes qui en limitent la puissance (on pourrait parler de principes restrictifs). Notre systeme fonctionne
par segments appeles unites textuelles. Celles—ci peuvent etre des paragraphes, des sections, des arbres (pour des
documents semi-structures, etc.). Nous ferons une presentation ici illustrée de ces contraintes.

Certaines structures discursives ont des formes tres proches, difﬁciles a distinguer. <TextCoop> offre actuel—
lement deux possibilités pour gérer la concurrence au niveau de la reconnaissance de structures. Le moteur de
<TextCoop>, presente ci-dessous, execute les regles en cascades. Le langage de <TextCoop> permet de speci-
ﬁer l’ordre dans lesquels les regles sont exécutées.

Nous appellerons ci—dessous paquet de régles l’ensemble des regles qui sont liees a la reconnaissance d’une struc-
ture donnée (par exemple, support d’argument, illustration, reformulation) identiﬁee par l’emploi d’un symbole
identique en partie gauche de regle. L’ analogie avec les paquets de clauses en Prolog est immediate. <TextCoop>
permet de speciﬁer une structure d’ordre (éventuellement partiel) qui indique dans quel ordre les paquets de regles
doivent etre executes. Ainsi dans :

titre < prérequis < sommaire.

les regles reconnaissant les titres seront executees d’abord puis celles liees aux pre—requis, etc. sans possibilité de
retour arriere.

Associe a ce mécanisme de cascades, il est possible de deﬁnir des zones fermées ou une fois une zone reconnue,
aucune regle ne pourra etre appliquée sur cette zone. Une zone fermee est déﬁnie sur un segment de texte inclus
dans une balise ouvrante et fermante du meme type. Lorsque la zone est identiﬁée, il n’est pas possible de tenter
d’appliquer d’autres regles a l’intérieur de cette zone. Par exemple, la balise <titre> déﬁnie dans le traitement des
procedures introduit une telle zone :

zone_fermee([titre]).

Un titre ressemble en effet, quant a sa structure, a une instruction : monter votre mezzanine, on ne Veut pas, une
fois un titre reconnu, l’étiqueter aussi comme une instruction. <TextCoop> permet de deﬁnir une liste de zones
fermées. Cette liste comprend des structures de deux types : (1) des structures qui peuvent etre reconnues par
plusieurs paquets de regles, mais ou l’on Veut privilégier un choix et ne pas provoquer de double étiquetage, aﬁn
de limiter les problemes d’ambiguités (cut ’rouge’ en Prolog), (2) des structures discursives ’terminales’, c’est a

PATRICK SAINT-DIZIER

dire qui ne doivent pas etre davantage decomposees, tout au moins par rapport a la grammaire de discours telle
qu’elle est ecrite. Par exemple, la structure de pre-requis (liste d’ingredients ou d’equipements) est analysee dans
les procedures comme une structure terminale (mais elle pourrait etre plus ﬁnement analysee dans un autre cadre).
Ce second cas est deﬁni d’abord pour des raisons d’efﬁcacite (comme un cut ’vert’ en Prolog).

Outre la possibilite de zones fermees, DisLog offre la possibilite de speciﬁer d’autres types de contraintes. Tout
d’abord on peut indiquer si une structure doit en dominer une autre :

dom(instruction,but).

indique que toute structure de type but est dominee par une instruction. De la meme fagon, on peut indiquer
que deux structures doivent etre dans deux branches differentes de la structure reconnue, sans aucune dominance
possible :

not_dom(instruction,avertissement).

Une instruction ne peut contenir un avertissement. Enﬁn, nous permettons de speciﬁer directement une relation
rhetorique :

rel_rhetorique(noyau,satellite,structure_englobante)., comme dans :
rel_rhetorique(conclusion_avt,support_avt,avertissement).

comme decrit ci-dessus. A ce stade aucune contrainte de precedence n’est donnee. Si l’on veut que le noyau soit
touj ours avant le satellite, il faut ajouter :

prec(conclusion_avt,support_avt). La contraite rel_rhetorique inclut donc la contrainte ’sister’ et un liage selectif
des deux premiers elements speciﬁes.

3 Le moteur de <TextC00p>

Nous decrivons ici le fonctionnement du moteur <TextCoop> qui est, pour l’heure, un interpreteur. Nous in-
diquons d’abord la forme des regles telles que traitees par cet interpreteur puis le fonctionnement du moteur
lui-meme. D’autres fonctionnements peuvent etre envisages, sur le meme schema que celui des DCGs qu’il ne
fait que generaliser. Nous ne nous etendrons pas ici sur les aspects theoriques du systeme. Les textes analyses
etant composes de phrases a nombre de mot ﬁnis, les gaps ignorant eux aussi des suites ﬁnies de mots, on peut,
via enumerabilite recursive, appliquer le theoreme du point ﬁxe pour donner une semantique declarative ’si1nple’,
comme dans les programmes logiques en general.

3.1 Traduction des régles

Le moteur fonctionne comme un interpreteur, les regles ainsi que les divers dispositifs presentes ci-dessus sont
donc traduits sous forme de structures de donnees directement utilisables par le moteur. Pour les regles, cette
structure est proche de celle deﬁnie pour les DCGs dans un mode interprete, elle a la forme suivante :
forme(Identiﬁant,Entree,Sortie,Partie_droite,Resultat).

ou :

— Identiﬁant est le nom du symbole en partie gauche de regle,

— Entree et Sortie contiennent le texte en cours de traitement, ceci traduit la technique des listes de differences

des DCGs, dont nous avons un besoin explicite ici pour reconstruire le texte etiquete,

— Partie_droite est la partie droite de regle, developpee ci—dessous,

— Resultat est la variable R, resultat de l’analyse (avec etiquetage) comme presente ci-dessus.

Les symboles en partie droite sont representes sous forme de liste, apres developpement complet de la regle lorsque
la forme abregee est utilisee. Les symboles terminaux et non terminaux sont augmentes de trois arguments :

— un argument qui represente la chaine de mots couverte par ce symbole,

— les deux variables qui representent la liste de difference propre a ce symbole lorsqu’il est developpe.

Ainsi, le symbole preterminal : expr([type :conseil]) qui represente une expression (terminale) de type conseil est-
il traduit en : expr(EXPR, [type :conseil],E0,El). En ce qui conceme le symbole gap, les trois memes variables
sont aj outees ainsi qu’une marque qui indique le symbole d’arret du gap, cette marque est l’identiﬁant du symbole
qui suit le gap dans la regle et ses contraintes.

Plus globalement, la regle suivante, qui traite de la structure d’une conclusion de conseil :
concl_conseil —> pro(_), aux([ty :etre]), gap([supconseil]), expr([type :conseil]), gap([supconseil]), mﬁn(_).

<TEXTCOOP>Z UN ANALYSEUR DE DISCOURS BASE SUR LES GRAMMAIRES LOGIQUES

est traduite de la fagon suivante :

forme(c—cons—fr, E, S, [ pro(PRO,_,E,E2), aux(AUX,etre,E2,E3),
gap(supconseil, [expr,conseil], E3,E4,Sautel),expr(EXPR,conseil,E4,E5),
gap(supconseil, [mfin,_], E5,E6,Saute2), mfin(MFIN,_,E6,S)], [], % no reasoning

[ ’<concl—cons>’ ,PRO, AUX, Sautel, EXPR, Saute2, '</concl—cons>’, MFIN ]).

’aux’ demande l’auxiliaire etre, ’mﬁn’ est une marque de ﬁn, repertoriée dans le lexique. Les deux symboles gap
contiennent les variables Sautel et Saute2 qui indiquent la chaine de mots qu’ils ont parcourue, et qui sera ignorée,
jusqu’a rencontrer le symbole suivant dans la regle. L’ argument qui contient les restrictions (le seul present dans
la structure initiale) peut etre soit une constante Prolog, dont l’interpretation est directe soit une structure de traits,
qui est interpretee de fagon standard, avec la subsomption sur les traits sémantiques.

3.2 Le fonctionnement global du moteur

Le moteur de <TextCoop> est ecrit en Prolog SWI, et tous les composants linguistiques attaches sont aussi
implementés dans ce cadre. Nous avons cherché a optimiser les traitements sans que ceci soit la priorité : l’objectif
sont les traitements de structures du discours en mode batch.

Comme indique ci—dessus, le moteur fonctionne par cascades de regles, suivant les priorités enoncées. Il n’y a
pas de retour arriere sur les étapes précédentes d’une cascade. Une etape de cascade est identiﬁee par le ou les
symboles en partie droite de regle : des paquets de regles sont donc executes a chaque étape. Au sein d’une etape,
les regles dans un paquet sont executées dans l’ordre dans lequel elle sont ecrites. Une option du moteur permet
d’éviter les retours arriere (couteux) sur ces regles. Cette option est desactivee en phase de mise au point. les
contraints enoncees sont veriﬁees a chaque etape de l’execution des regles.

A titre experimental, l’interpreteur est pourvu, outre la strategie de traitement de la gauche vers la droite, d’une
stratégie inverse, de la droite vers la gauche. Celle—ci est utilisee lorsque les marques identiﬁantes d’une relation
rhetorique sont placees a la ﬁn de la structure, alors que la structure ne debute que par une marque de delimitation.
C’est le cas, par exemple des structures d’illustration du type : (a,b,c,.., par exemple), ou la parenthese ouvrante
sert de délimiteur (elle est peu discriminante de la relation) et ou la marque ’par exemple’ est située en ﬁn de
chaine. Les resultats que nous obtenons indiquent un meilleur taux de reconnaissance et une meilleure efﬁcacite.
Cette stratégie sera automatisee, a partir de l’analyse de la position des marques identiﬁantes.

Le résultat ﬁnal de l’analyse est le texte donné en entree augmenté de balises XML qui delimitent et caractérisent
les structures analysées.

3.3 Evaluation

La premiere version du moteur est a present disponible avec son environnement. Celle—ci a ete realisée dans
l’objectif de valider les idées et de deﬁnir precisemment les fonctionnalites intemes et extemes utiles en analyse
discursive. L’ optimisation du code n’y est que partielle. Les performances du systeme actuel sont les suivantes, sur
la base de 30 patrons (lies au traitement des procedures), avec un lexique de 1300 mots ou expressions et un acces
a un analyseur morphologique, lui aussi en Prolog. Le calcul se fait sur un PC standard. Nous traitons 60 Mo de
texte (hors balises) par heure. La taille du lexique dans cette experience est assez importante pour le traitement du
discours. Dans de nombreuses applications, le lexique utile peut etre nettement plus reduit. Ceci a un impact irn—
portant sur les performances. Le lexique qui a servi a l’expérimentation contient 800 verbes, cependant, dans une
application d’analyse de procedures, ce nombre descend a environ 150 verbes, et a des variations morphologiques
tres réduites. On peut alors traiter jusqu’a 200 Mo de texte par heure. Bien entendu la complexité des patrons
a aussi une inﬂuence sur les performances : les gaps, la longueur des regles, les restrictions mais aussi le non
déterminisme introduit par les regles d’un meme paquet sont des facteurs importants, mais qui restent difﬁciles a
analyser ﬁnement.

Il est nettement plus difﬁcile d’evaluer la qualite de reconnaissance des regles. Cela depend beaucoup des types
de textes traités et de la qualité de conception des regles, comme dans tout type de programmation. En ce qui
conceme les procedures, des resultats detaillés sont donnes dans (Fontan et al. 08). Les textes professionnels

PATRICK SAINT-DIZIER

donnent des resultats tres bons, du fait de leur qualité de redaction et de leur regularité, aussi bien au niveau de
l’écriture des instructions que de celle des conseils, avertissements, deﬁnitions, commentaires ou illustrations.
Nous travaillons actuellement au developement de techniques basées sur le bootstrapping, mais adaptees a la
problematique du discours, Visant a améliorer la deﬁnition des regles pour un type de phenomene donne. Cela
inclut les aspects structurels aussi bien que les aspects lexicaux, en particulier la caractérisation ﬁne des marques.
Ces marques sont de types tres diversiﬁés. Pour bien organiser nos ressources lexicales, il convient d’élaborer, au
sein du systeme, une architecture souple et modulaire, mais non redondante, des ressources lexicales (marqueurs,
classes sémantiques de Verbes, expressions dédiées, etc.).

4 L’environnement linguistique de <TextCoop>

Nous avons presente essentiellement dans ce document le moteur de <TextCoop> ainsi que le formalisme des
regles. Il est clair qu’un tel systeme ne peut fonctionner qu’en s’appuyant sur un ensemble de ressources lexicales,
et ne peut etre Veritablement integre dans des traitements de grande echelle que si, outre ses performances, ses
modules de ressources (lexique, grammaires locales, ontologies et terminologies, etc.) et formats d’entrée sortie
des documents suivent des formats normalises. Il est essentiel aussi qu’il dispose d’un module de mise au point
des regles, de Visualisation des résultats et des recommandations et une methode pour son integration dans des
applications.

Pour l’heure, nous avons développé et integre differents modules de ressources qui sont plus particulierement

pertinents pour l’analyse du discours que l’on peut utiliser tels quels dans les regles, comme par exemple :

— des listes de connecteurs types : de cause, concession, temps, etc.

— des listes de termes spéciﬁques pouvant etre utilises comme marques : marques de l’illustration, de la reformu-
lation, du developpement, etc.

— des listes de Verbes par classes et sous-classes semantiques, inspirées des classes de WordNet,

— des listes de termes avec polarité negative ou positive, ceci est utile en argumentation et en analyse d’opinions.

— des grarnmaires locales : expression du temps, de la quantite, expressions évaluatives simples, etc.

— enﬁn, des modules qui contiennent quelques regles simples pour reconnaitre des structures telles que : illustra-
tion, reformulation, but, condition, deﬁnition et elaboration (une relation nettement plus complexe et compo-
site). De fagon plus générale, nous souhaitons étudier comment on peut greffer un analyseur de phrases au sein
de <TextCoop> pour le compléter.

En matiere de Visualisation des resultats, nous avons conduit une experimentation tres concluante en utilisant

NAVITEXTE (http ://panini.u—parisl0.fr/jhn/?Start zprojets :NaViTexte), meme si cette interface est un peu trop

elaborée pour nos besoins. Nous envisageons a present une Visualisation qui soit davantage sous forme d’abre,

tout en préservant la structure du document original. En matiere de normalisation des donnees et de certains
traitements, nous étudions le cadre de UIMA (http ://www.uima—fr.org/) qui est certainement une direction forte.

L’ aide a la mise au point des regles est difﬁcile a concevoir dans le cadre du discours. Dans notre cadre, elle se

limite actuellement a quelques recommandations sur leur forme et la fagon de les sirnpliﬁer ou de les generaliser.

Nous envisageons de développer un analyseur qui detecterait certains types d’erreurs ou d’incompatibilités er1tre

regles, comme cela existe dans certains compilateurs de regles. Etant dans une etape qui demeure expérimentale,

il nous faut bien identiﬁer les besoins ’raisonnables’ en matiere de mise au point de regles et de ressources avant

d’en realiser une implementation. L’ architecture des ressources linguistiques utilisées dans les regles, pour éviter

les doubles et les incoherences est aussi un suj et d’étude actuel.

5 Les applications

Le projet <TextCoop> est a l’origine dedie a l’analyse des procedures (Delpech et al. 2008). Nous avons donc
conduit nos premieres expérimentations sur les structures liees aux procedures, qui ont des caractéristiques assez
diversiﬁées et qui permettent de bien tester a la fois le moteur et l’ecriture des regles. Un element interessant est
que, dans ce projet, nous avons analyse a la fois des structures linguistiques connues et des structures dédiées
(titres, instructions, etc.). Les caracteristiques globales de ces structures sont les suivantes :

— titres : ressemblent a des instructions, bien que souvent tres elliptiques (Verbe ou objet sous—entendu), les regles

de reconnaissance s’appuient sur de nombreuses considerations typographiques.

