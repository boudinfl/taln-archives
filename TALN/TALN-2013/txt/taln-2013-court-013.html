<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Analyse statique des interactions entre structures &#233;l&#233;mentaires d&#8217;une grammaire</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<div style="page-break-before:always; page-break-after:always"><div><p>Analyse statique des interactions entre structures
&#233;l&#233;mentaires d&#8217;une grammaire
</p>
<p>Guy Perrier
LORIA, Universit&#233; de Lorraine,
&#233;quipe S&#233;magramme, b&#226;t. C,
</p>
<p>Campus Scientifique
BP 239
</p>
<p>54506 Vand&#248;euvre-l&#232;s-Nancy, cedex,France
guy.perrier@loria.fr
</p>
<p>R&#201;SUM&#201;
Nous nous int&#233;ressons ici &#224; la construction semi-automatique de grammaires computationnelles
et &#224; leur utilisation pour l&#8217;analyse syntaxique. Nous consid&#233;rons des grammaires lexicalis&#233;es dont
les structures &#233;l&#233;mentaires sont des arbres, sous-sp&#233;cifi&#233;s ou pas. Nous pr&#233;sentons un algorithme
qui vise &#224; pr&#233;voir l&#8217;ensemble des arbres &#233;l&#233;mentaires attach&#233;s aux mots qui peuvent s&#8217;intercaler
entre deux mots donn&#233;s d&#8217;une phrase, dont on sait que les arbres &#233;l&#233;mentaires associ&#233;es sont des
compagnons, c&#8217;est-&#224;-dire qu&#8217;ils interagiront n&#233;cessairement dans la composition syntaxique de la
phrase.
</p>
<p>ABSTRACT
Static Analysis of Interactions between Elementary Structures of a Grammar
</p>
<p>We are interested in the semi-automatic construction of computational grammars and in their
use for parsing. We consider lexicalized grammars with elementary structures which are trees,
underspecified or not. We present an algorithm that aims at foreseeing all elementary trees
attached at words which can come between two given words of a sentence, whose associated
elementary trees are companions, that is, they will necessarily interact in the syntactic composition
of the sentence.
MOTS-CL&#201;S : grammaire lexicalis&#233;e, grammaire d&#8217;interaction, construction de grammaires.
KEYWORDS: Lexicalized Grammar, Interaction Grammar, Grammar Construction.
</p>
<p>1 Introduction
</p>
<p>Nous poursuivons ici un travail commenc&#233; depuis plus de dix ans autour de la construction semi-
automatique de grammaires computationnelles. Dans le cadre du formalisme des Grammaires
d&#8217;Interaction (GI)(Guillaume et Perrier, 2009), nous avons d&#233;velopp&#233; FRIGRAM1, une grammaire
du fran&#231;ais, et LEOPAR 2, un analyseur syntaxique pour les GI, permet d&#8217;appliquer cette grammaire
&#224; l&#8217;analyse de textes en fran&#231;ais.
</p>
<p>Notre ambition est d&#8217;obtenir une grammaire &#224; large couverture pour analyser des corpus tout
</p>
<p>1. http://wikilligramme.loria.fr/doku.php?id=frigram:frigram
2. http://leopar.loria.fr
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>604 c&#65535; ATALA</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>venant. M&#234;me si nous sommes ouverts &#224; int&#233;grer des m&#233;thodes probabilistes dans notre approche,
nous souhaitons conserver une base symbolique pour &#234;tre en mesure de produire des analyses
suffisamment riches pour que l&#8217;on puisse calculer &#224; partir d&#8217;elles des repr&#233;sentations s&#233;mantiques
compl&#232;tes.
</p>
<p>Nous devons faire face &#224; un premier d&#233;fi, celui de maintenir la coh&#233;rence d&#8217;une grammaire
qui est n&#233;cessairement de taille importante. Certes, l&#8217;organisation d&#8217;une telle grammaire sous
forme d&#8217;une hi&#233;rarchie de modules &#224; l&#8217;aide d&#8217;une relation d&#8217;h&#233;ritage facilite la t&#226;che, mais cela ne
r&#233;soud pas tout. Par ailleurs dans l&#8217;analyse syntaxique, nous sommes confront&#233;s &#224; un second d&#233;fi,
celui de l&#8217;explosion du nombre de structures syntaxiques candidates pour l&#8217;analyse d&#8217;une phrase.
</p>
<p>Pour r&#233;pondre &#224; ces deux d&#233;fis, nous pensons qu&#8217;il est utile d&#8217;analyser la grammaire de fa&#231;on
syst&#233;matique pour pr&#233;voir les interactions entre les structures &#233;l&#233;mentaires qui la d&#233;finissent. Un
travail a commenc&#233; &#224; &#234;tre men&#233; sur FRIGRAM mais il peut s&#8217;&#233;tendre aux grammaires construites
dans d&#8217;autres formalismes, pour peu que ces grammaires soient lexicalis&#233;es.
</p>
<p>Lorsque l&#8217;on analyse une phrase avec une grammaire lexicalis&#233;e, la premi&#232;re &#233;tape consiste &#224;
assigner &#224; chaque mot de la phrase une structure syntaxique &#233;l&#233;mentaire de la grammaire. On
obtient ce qu&#8217;on appelle une s&#233;lection lexicale. Le nombre de s&#233;lections lexicales possibles est
exponentiel par rapport &#224; la longueur de la phrase.
</p>
<p>Pour filtrer les s&#233;lections lexicales, (Bonfante et al., 2009) ont introduit la notion de compagnon.
Un compagnon d&#8217;une structure syntaxique &#233;l&#233;mentaire est une structure syntaxique &#233;l&#233;mentaire
qui peut se combiner avec la premi&#232;re dans la composition syntaxique d&#8217;une phrase. Le principe
de filtrage est ensuite le suivant : si dans une s&#233;lection lexicale, il existe une structure syntaxique
&#233;l&#233;mentaire qui ne trouve ni compagnon &#224; gauche ni compagnon &#224; droite, la s&#233;lection peut &#234;tre
&#233;limin&#233;e. L&#8217;application de ce principe permet de r&#233;duire drastiquement le nombre de s&#233;lections
lexicales. Les compagnons de chaque structure syntaxique &#233;l&#233;mentaire peuvent &#234;tre pr&#233;-calcul&#233;s
sur la grammaire et pour r&#233;duire le nombre de calculs, ceux-ci sont effectu&#233;s sur les structures
syntaxiques &#233;l&#233;mentaires avant ancrage par des mots particuliers.
</p>
<p>La faiblesse du principe de filtrage fond&#233; sur les compagnons est qu&#8217;il est totalement indiff&#233;rent
aux contraintes de localit&#233;. Ainsi, si un mot du d&#233;but d&#8217;une longue phrase trouve le compagnon
de la structure syntaxique qu&#8217;il ancre aupr&#232;s d&#8217;un mot qui est en fin de phrase, quelle que soit la
longueur de la phrase, le principe est respect&#233;.
</p>
<p>C&#8217;est pour pallier cet inconv&#233;nient que nous proposons d&#8217;aller plus loin dans l&#8217;analyse statique des
interactions entre structures syntaxiques &#233;l&#233;mentaires de la grammaire. Consid&#233;rant un couple
particulier de compagnons, nous proposons un algorithme qui permet de pr&#233;voir uniquement
d&#8217;apr&#232;s la grammaire les structures syntaxiques &#233;l&#233;mentaires qui peuvent s&#8217;intercaler entre ces
compagnons dans la composition syntaxique d&#8217;une phrase. Ce calcul devrait nous permettre
d&#8217;aller plus loin dans le filtrage des s&#233;lections lexicales par application du principe suivant : si
dans une s&#233;lection lexicale, nous sommes s&#251;rs que deux mots ont leurs structures syntaxiques
qui sont compagnons, nous devons v&#233;rifier que tous les structures syntaxiques ancrant les mots
interm&#233;diaires sont dans l&#8217;ensemble pr&#233;-calcul&#233; selon notre algorithme.
</p>
<p>Dans la section 2, nous pr&#233;ciserons le concept de compagnon. Dans la section 3, nous d&#233;cri-
rons l&#8217;algorithme de calcul des structures syntaxiques &#233;l&#233;mentaires s&#8217;intercalant entre deux
compagnons et dans la section 4, nous d&#233;roulerons l&#8217;algorithme sur un exemple.
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>605 c&#65535; ATALA</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>2 Les compagnons d&#8217;une structure syntaxique &#233;l&#233;mentaire
</p>
<p>Nous nous situons dans le cadre de formalismes grammaticaux o&#249; les objets manipul&#233;s sont des
structures syntaxiques not&#233;es SSynt. Parmi, celles-ci, nous distinguons les structures finales qui
sont celles repr&#233;sentant la syntaxe compl&#232;te des phrases. Une op&#233;ration de composition binaire
que nous noterons COMP permet de combiner les SSynt 3. Les grammaires y sont d&#233;finies comme
des ensembles finis de SSynt, que nous appellerons structures syntaxiques &#233;l&#233;mentaires et que nous
noterons SSyntE. Dans l&#8217;utilisation que nous faisons de la notion de compagnon, il est n&#233;cessaire
que les grammaires soient lexicalis&#233;es : les SSyntE doivent &#234;tre ancr&#233;es par des mots de la langue.
Pour simplifier l&#8217;expos&#233;, on consid&#233;rera m&#234;me que chaque SSyntE a une ancre unique.
</p>
<p>!&quot;#$%
&amp;'( &#1; )
</p>
<p>*+!&amp;( &#2; ,-./#$%0,-.01,%0&amp;/20&amp;2$*(03,4%
</p>
<p>!5!*2
&amp;'( &#3; 3
</p>
<p>*+!&amp;( &#3; 6$'%
</p>
<p>!7+-.
&amp;'( &#2; !/
</p>
<p>*+!&amp;( &#1; )+-.
</p>
<p>!8((#
&amp;'( &#2; !/
</p>
<p>*+!&amp;( &#1; )+-./#$%
</p>
<p>!9'!&amp;6
$)(
</p>
<p>&amp;'( &#3; 3
*+!&amp;( &#3; 6$'%
</p>
<p>!:
*$11$
</p>
<p>&amp;'( &#3; !
*+!&amp;( &#3; 6$'%
</p>
<p>!:1';
&amp;'( &#3; !
</p>
<p>*+!&amp;( &#3; 6$'%
</p>
<p>!:/
&amp;'( &#1; !/
</p>
<p>*+!&amp;( &#2; )+-./#$%0)+-.0/#$/,-.0,-./#$%0,-.01,%0&amp;/20'//03,4%
</p>
<p>!&lt;$(
&amp;'( &#2; %$(
</p>
<p>*+!&amp;( &#1; %$(
</p>
<p>FIGURE 1 &#8211; Une SSyntE ancrant femme compagnon &#224; droite d&#8217;une SSyntE ancrant est
</p>
<p>Dans ces conditions, on appelle compagnon &#224; droite (compagnon &#224; gauche) d&#8217;une SSyntE S1 toute
SSyntE S2 telle que COMP(S1,S2) soit d&#233;finie et soit compatible avec le fait que l&#8217;ancre de S1
pr&#233;c&#232;de (suit) celle de S2 dans l&#8217;ordre lin&#233;aire de la phrase.
</p>
<p>Appliquons cette notion au formalisme des GI o&#249; les SSynt sont des for&#234;ts d&#8217;arbres ordonn&#233;s
sous-sp&#233;cifi&#233;s. Les n&#339;uds repr&#233;sentent des syntagmes et leurs propri&#233;t&#233;s morpho-syntaxiques
sont repr&#233;sent&#233;es par des traits qui pr&#233;sentent la particularit&#233; d&#8217;&#234;tre polaris&#233;s. Le syst&#232;me de
polarit&#233;s permet d&#8217;exprimer l&#8217;&#233;tat de saturation des SSynt et leur aptitude &#224; interagir entre elles.
Les structures finales sont des arbres satur&#233;s. L&#8217;op&#233;ration de composition syntaxique COMP entre
deux SSynt S1 et S2 consiste &#224; fusionner un n&#339;ud de S1 avec un n&#339;ud de S2 de fa&#231;on &#224; saturer un
trait polaris&#233; de S1 qui ne l&#8217;&#233;tait pas initialement 4. Pour une description exhaustive du formalisme
des GI, le lecteur peut se reporter &#224; (Guillaume et Perrier, 2009). La grammaire &#224; laquelle nous
allons appliquer nos id&#233;es est la grammaire d&#8217;interaction du fran&#231;ais FRIGRAM.
</p>
<p>La figure 1 montre la SSyntE Sest ancrant le verbe est quand il prend un syntagme nominal comme
</p>
<p>3. L&#8217;op&#233;ration COMP n&#8217;est pas n&#233;cessairement d&#233;terministe et il peut y avoir plusieurs fa&#231;ons de composer deux SSynt.
4. Le r&#233;sultat de l&#8217;op&#233;ration COMP doit &#234;tre un arbre sous-sp&#233;cifi&#233; donc on peut en tenir compte pour r&#233;soudre un
</p>
<p>certain nombre de contraintes comme le fait qu&#8217;un n&#339;ud doit avoir un p&#232;re unique.
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>606 c&#65535; ATALA</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>!&quot;#$%
&amp;'( &#1; )
</p>
<p>*+!&amp;( &#2; ,-./#$%0,-.01,%0&amp;/20&amp;2$*(03,4%
</p>
<p>!5!*2
&amp;'( &#3; 3
</p>
<p>*+!&amp;( &#3; 6$'%
</p>
<p>!7+-.
&amp;'( &#2; !/
</p>
<p>*+!&amp;( &#1; )+-.
</p>
<p>!8((#9!:/
&amp;'( &#3; !/
</p>
<p>*+!&amp;( &#3; )+-./#$%
</p>
<p>!;'!&amp;6
$)(
</p>
<p>&amp;'( &#3; 3
*+!&amp;( &#3; 6$'%
</p>
<p>!:1'&lt;
&amp;'( &#3; !
</p>
<p>*+!&amp;( &#3; 6$'%
</p>
<p>!=$(
&amp;'( &#2; %$(
</p>
<p>*+!&amp;( &#1; %$(
</p>
<p>!:
*$11$
</p>
<p>&amp;'( &#3; !
*+!&amp;( &#3; 6$'%
</p>
<p>FIGURE 2 &#8211; La SSynt r&#233;sultant de la composition syntaxique de la SSyntE ancrant femme avec la
SSyntE ancrant est
</p>
<p>attribut du sujet et un de ses compagnons &#224; droite, la SSyntE Sf emme ancrant le nom femme
quand il est t&#234;te d&#8217;un syntagme nominal 5. La figure 2 en fournit la justification en montrant
COMP(Sest ,Sf emme) obtenu en fusionnant le n&#339;ud nAttr de Sest avec le n&#339;ud nNp de Sf emme de
fa&#231;on &#224; saturer les deux traits polaris&#233;s du premier. Le r&#233;sultat de la fusion des deux n&#339;uds est le
n&#339;ud nAttr-nNp. L&#8217;ordre des n&#339;uds dans l&#8217;arbre montre bien que le compagnon est &#224; droite.
</p>
<p>On peut calculer de fa&#231;on syst&#233;matique tous les compagnons &#224; droite et &#224; gauche des SSyntE
d&#8217;une grammaire mais pour &#233;viter d&#8217;avoir un nombre trop important de calculs &#224; faire, on le fait
sur les SSyntE non ancr&#233;es. Ainsi par exemple si on consid&#232;re la SSyntE non ancr&#233;e correspondant
&#224; Sest , on trouve dans FRIGRAM 129 compagnons permettant de saturer les traits du n&#339;ud nAttr :
58 &#224; gauche seulement, 59 &#224; droite seulement et 12 qui sont &#224; la fois &#224; gauche et &#224; droite. Pour
avoir l&#8217;ensemble des compagnons de Sest , il faut ajouter ceux qui permettent de saturer des traits
polaris&#233;s de nSubj et de nPred.
</p>
<p>Dans une phrase donn&#233;e, le nombre de compagnons possibles pour une SSyntE ancrant un mot
est r&#233;duit et on utilise cette information pour filtrer les s&#233;lections lexicales. (Bonfante et al., 2009)
ont montr&#233; que le principe que toute SSyntE d&#8217;une s&#233;lection lexicale doit y trouver au moins un
compagnon permet de filtrer efficacement les s&#233;lections lexicales. Ainsi pour la phrase &quot;Marie est
consid&#233;r&#233;e comme une femme intelligente.&quot;, la grammaire FRIGRAM offre 13 047 840 s&#233;lections
lexicales possibles et le filtrage fond&#233; sur les compagnons permet de r&#233;duire ce nombre &#224; 354.
</p>
<p>5. Pour plus de lisibilit&#233;, tous les traits associ&#233;s &#224; chaque n&#339;ud n&#8217;ont pas &#233;t&#233; marqu&#233;s. N&#8217;apparaissent que les traits
cat et funct.
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>607 c&#65535; ATALA</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>Le but du travail pr&#233;sent&#233; ici est de montrer qu&#8217;il est encore possible d&#8217;aller plus loin pour pallier
une faiblesse du principe : il est indiff&#233;rent &#224; la distance entre une SSyntE et ses compagnons.
Dans notre exemple, comme c&#8217;est indiqu&#233; plus haut, Sest doit aller jusqu&#8217;au mot une pour trouver
son premier compagnon. L&#8217;id&#233;e de l&#8217;algorithme pr&#233;sent&#233; &#224; la section suivante est de pr&#233;voir &#224;
partir de la grammaire les SSyntE qui peuvent &#234;tre situ&#233;es dans une s&#233;lection lexicale entre une
SSyntE donn&#233;e et ses compagnons, calcul qui servira de base &#224; un nouveau principe de filtrage.
</p>
<p>3 L&#8217;algorithme de d&#233;tection des structures syntaxiques &#233;l&#233;-
mentaires s&#8217;intercalant entre deux compagnons
</p>
<p>L&#8217;algorithme va &#234;tre appliqu&#233; au formalisme des GI mais cette application peut &#234;tre &#233;tendu &#224;
tout formalisme manipulant des for&#234;ts d&#8217;arbres ordonn&#233;s avec des structures finales qui sont des
arbres et une op&#233;ration de composition qui est une forme de superposition d&#8217;arbres. Il part de
l&#8217;observation que la plupart du temps, dans FRIGRAM, la composition d&#8217;une SSyntE avec un de
ses compagnons produit une SSynt qui d&#233;finit une zone triangulaire dont la base est d&#233;limit&#233;e
par les deux ancres issues des SSyntE qui ont &#233;t&#233; compos&#233;es et dont le sommet est le premier
anc&#234;tre commun. D&#233;sormais, nous appelleront une telle SSynt une structure bi-ancr&#233;e.
</p>
<p>Formellement, une structure bi-ancr&#233;e S est une SSynt qui a deux ancres distingu&#233;es Ag et Ad,
la premi&#232;re, l&#8217;ancre gauche, se situant avant la seconde, l&#8217;ancre droite, dans l&#8217;ordre lin&#233;aire de
la phrase. En plus, il existe dans S deux suites de n&#339;uds R,N1, . . . ,Ag et R,M1, . . . ,Ad ayant un
d&#233;but commun, le n&#339;ud R, et telles que chaque n&#339;ud de la suite est fils de celui qui le pr&#233;c&#232;de.
La figure 2 montre un exemple de structure bi-ancr&#233;e. Les deux suites de n&#339;uds formant les
c&#244;t&#233;s du triangle sont nPred, nInfl, nVanch et nPred, nAttr-nNp, nNmax, nN.
</p>
<p>Ces deux suites permettent de d&#233;finir une partition sur les n&#339;uds de S entre ceux qui se situent &#224;
l&#8217;int&#233;rieur du triangle d&#233;fini par les deux chemins et ceux qui se situent &#224; l&#8217;ext&#233;rieur. Un n&#339;ud est
interne s&#8217;il se situe apr&#232;s l&#8217;ancre gauche et avant l&#8217;ancre droite selon l&#8217;ordre d&#233;fini sur la structure
bi-ancr&#233;e 6. Un n&#339;ud qui n&#8217;est pas interne, est un n&#339;ud fronti&#232;re s&#8217;il fait partie d&#8217;une des deux
listes de n&#339;uds distingu&#233;es, sinon il est externe.
</p>
<p>Le principe de l&#8217;algorithme s&#8217;appuie sur la forme particuli&#232;re d&#8217;une structure bi-ancr&#233;e qui a la
cons&#233;quence suivante : toute SSyntE dont l&#8217;ancre s&#8217;ins&#232;re entre les deux ancres distingu&#233;es doit
&#234;tre reli&#233;e &#224; un n&#339;ud interne ou fronti&#232;re. Elle peut l&#8217;&#234;tre de fa&#231;on directe par composition avec
la structure bi-ancr&#233;e mais elle peut l&#8217;&#234;tre de fa&#231;on indirecte via une cha&#238;ne d&#8217;autres SSyntE.
Ces SSyntE doivent toutes avoir la propri&#233;t&#233; d&#8217;&#233;tendre vers le bas la structure bi-ancr&#233;e avec un
nouveau n&#339;ud interne. C&#8217;est cela qui va &#234;tre utilis&#233; par l&#8217;algorithme qui se pr&#233;sente ainsi :
</p>
<p>fonction CALCULER_GRAPHE (S,Ag,Ad,noeuds)
initialiser G au graphe vide
tantque noeuds est non vide
</p>
<p>choisir un noeud N de noeuds et le retirer de cet ensemble
M f = CREER_MOTIF ( N , S)
pourchaque SSyntE Si de la grammaire
</p>
<p>si SUBSUMER(M f , Si)
</p>
<p>6. Si l&#8217;ordre est sous-sp&#233;cifi&#233;, un n&#339;ud est interne si, en ajoutant la contrainte de le placer apr&#232;s l&#8217;ancre gauche et
avant l&#8217;ancre droite, on ne cr&#233;e aucune incoh&#233;rence dans l&#8217;ordre entre les n&#339;uds de l&#8217;arbre.
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>608 c&#65535; ATALA</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>(S&#65535;i , Agi , Adi , Ai , noeudsi) = SUPERPOSER (Si , S , Ag, Ad, M f )
Gi = CALCULER_GRAPHE (S&#65535;i , Agi , Adi , noeudsi)
si INTERNE(Ai , S&#65535;i , Agi , Adi))
G = G &#8746; COMPLETER_GRAPHE(Gi , Si ))
</p>
<p>sinon G = G &#8746; Gi
retourner G
</p>
<p>La fonction CALCULER_GRAPHE prend en entr&#233;e une structure bi-ancr&#233;e S avec ses deux ancres
distingu&#233;es gauche et droite Ag et Ad ainsi qu&#8217;un ensemble noeuds de S qui vont &#234;tre le point de
d&#233;part de l&#8217;expansion vers le bas de S. Au d&#233;part, noeuds est initialis&#233;s aux n&#339;uds internes et
fronti&#232;re de S &#224; l&#8217;exception des ancres Ag et Ad.
</p>
<p>En sortie, la fonction CALCULER_GRAPHE retourne un graphe dont les n&#339;uds sont &#233;tiquet&#233;s par des
SSyntE de la grammaire. Il s&#8217;agit en fait d&#8217;une for&#234;t d&#8217;arbres dont la s&#233;mantique est la suivante :
</p>
<p>Si une phrase est analys&#233;e avec succ&#232;s par la grammaire &#224; partir de la SSynt S et si w1
et w2 sont les deux mots de la phrase attach&#233;s aux ancres distingu&#233;es de S, pour tout
mot w situ&#233; entre w1 et w2 qui contribue &#224; l&#8217;analyse avec la SSyntE S1 qu&#8217;il ancre, il
existe une occurrence de S1 dans le graphe dont tous ses pr&#233;d&#233;cesseurs dans le graphe
participe &#224; l&#8217;analyse en ancrant des mots situ&#233;s entre w1 et w2.
</p>
<p>Expliquons maintenant l&#8217;algorithme. Au d&#233;part on choisit un n&#339;ud N de l&#8217;ensemble noeuds que
l&#8217;on retire de l&#8217;ensemble. Ce n&#339;ud va servir de point de d&#233;part &#224; l&#8217;expansion vers le bas de S. A
l&#8217;aide de la fonction CREER_MOTIF , on cr&#233;e un motif M f qui va permettre de filtrer les SSyntE de
la grammaire pertinentes pour cette expansion. M f est form&#233; du n&#339;ud N ainsi que de tous ses
anc&#234;tres et tous ses fr&#232;res dans S. On ajoute en plus un fils N &#65535; de N qui est laiss&#233; compl&#232;tement
sous-sp&#233;cifi&#233; quant aux traits dont il est porteur. Il est seulement ordonn&#233; par rapport &#224; ses fr&#232;res
&#233;ventuels qui sont sur la fronti&#232;re. Ce n&#339;ud est capital car c&#8217;est lui qui va permettre l&#8217;expansion 7.
</p>
<p>Ensuite, on passe en revue toutes les SSyntE de la grammaire &#224; l&#8217;aide du filtre M f . La fonction
bool&#233;enne SUBSUMER teste si M f subsume une SSyntE Si quelconque de la grammaire. Cela veut
dire que tout n&#339;ud de M f s&#8217;interpr&#232;te dans Si et que cette interpr&#233;tation conserve les relations
p&#232;re-fils ainsi que celles de pr&#233;c&#233;dence. En plus, les traits attach&#233;s &#224; chaque n&#339;ud de M f doivent
aussi s&#8217;interpr&#233;ter par des traits attach&#233;s &#224; son n&#339;ud image dans Si en respectant un certain
nombre de propri&#233;t&#233;s qui sont sp&#233;cifiques au formalisme grammatical utilis&#233;. Par exemple, pour
les GI, la polarit&#233; du trait image doit &#234;tre compatible avec celle du trait ant&#233;c&#233;dent.
</p>
<p>Ensuite, si le test est positif, &#224; l&#8217;aide la fonction SUPERPOSER, on compose la SSyntE Si avec S
en suivant le motif M f et en utilisant l&#8217;op&#233;ration COMP de composition syntaxique propre au
formalisme. On obtient une SSyntE S&#65535;i et on distingue dans celle-ci les ancres gauche et droite
Agi et Adi qui sont la transposition dans S&#65535;i des ancres Ag et Ad de S. En plus, on rep&#232;re l&#8217;ancre
Ai apport&#233;e par Si car sa position va jouer un r&#244;le d&#233;cisif pour la suite. La variable noeudsi
repr&#233;sente l&#8217;ensemble des n&#339;uds de S&#65535;i qui vont servir de point de d&#233;part aux expansions futures.
Ce sont les n&#339;uds internes de S&#65535;i qui n&#8217;&#233;taient pr&#233;sents au d&#233;part dans noeuds.
L&#8217;&#233;tape suivante consiste &#224; appliquer r&#233;cursivement la fonction CALCULER_GRAPHE. Elle va per-
mettre de r&#233;cup&#233;rer un graphe Gi et c&#8217;est l&#224; que l&#8217;ancre Ai va jouer un r&#244;le important par le
biais de la fonction bool&#233;enne INTERNE. Cette fonction teste si l&#8217;ancre Ai est un n&#339;ud interne
&#224; la structure bi-ancr&#233;e S&#65535;i . Si nous reprenons notre exemple avec la phrase &#224; analyser &quot;o&#249;
Marie est-elle consid&#233;r&#233;e comme une femme intelligente ?&quot;, les SSyntE associ&#233;es aux mots o&#249; et une
</p>
<p>7. Bien entendu, ce n&#339;ud est un minimum et l&#8217;expansion peut se faire &#224; l&#8217;aide de plusieurs n&#339;uds.
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>609 c&#65535; ATALA</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>v&#233;rifient toutes les deux la condition exprim&#233;e par la fonction SUBSUMER. Pour o&#249;, cela provient
du fait que la SSyntE mod&#233;lise une extraction. Pourtant, seule la seconde v&#233;rifie la condition
exprim&#233;e par la fonction INTERNE, le mot une se situant entre est et femme. Dans ce cas, il va
falloir ajouter Si au graphe Gi . On l&#8217;ajoute comme nouvelle racine en le reliant par un arc &#224; toutes
les anciennes racines de Gi . C&#8217;est le r&#244;le de la fonction COMPL&#201;TER_GRAPHE. Il ne reste plus qu&#8217;&#224;
faire l&#8217;union du graphe obtenu avec G, dans l&#8217;&#233;tat o&#249; il est apr&#232;s utilisation d&#8217;un certain nombre
de n&#339;uds de noeuds. Si Ai est un n&#339;ud externe, on se contente de faire l&#8217;union de Gi avec G.
</p>
<p>4 Application &#224; un exemple
</p>
<p>Appliquons l&#8217;algorithme &#224; la structure bi-ancr&#233;e S de la figure 2. La valeur initiale de noeuds
est l&#8217;ensemble {nInfl, nPred, nAttr-nNp, nDet, nNmax}. On choisit ensuite un n&#339;ud N dans
cet ensemble, par exemple nInfl. On cr&#233;e le motif M f correspondant &#224; l&#8217;aide de la fonction
CR&#201;ER_MOTIF. C&#8217;est le sous arbre de la structure bi-ancr&#233;e form&#233; des trois n&#339;uds nPred, nInfl et
nAttr-nNp. On y ajoute un nouveau fils N &#65535; de nInfl.
</p>
<p>!&quot;#$
%&amp;' &#1; &amp;#$
</p>
<p>()!%' &#1; *+&amp;#
</p>
<p>!&quot;#$,&amp;-
%&amp;' &#1; &amp;#$
</p>
<p>()!%' &#1; ,.#
</p>
<p>!/.#0(
%&amp;' 1 $
</p>
<p>!2
%&amp;' 1 $
</p>
<p>FIGURE 3 &#8211; SSyntE ancrant les adverbes modificateurs de verbes situ&#233;s apr&#232;s ces verbes
</p>
<p>Ensuite, on essaie de faire co&#239;ncider le motif M f avec un sous-arbre de chaque SSyntE de
FRIGRAM. Prenons un cas o&#249; l&#8217;appariement r&#233;ussit, celui de la SSyntE ancrant les adverbes
modificateurs de verbes et situ&#233;s apr&#232;s ces verbes, nomm&#233;e ADVmod_V et repr&#233;sent&#233;e sur la
figure 3. La condition SUBSUMER(M f ,ADVmod_V ) est vraie et on superpose alors ADVmod_V
avec S en suivant le motif M f . Cela revient &#224; &#233;tendre S en ajoutant comme fr&#232;re droit de nVanch
le n&#339;ud nAdvmax de ADVmod_V avec son fils nAdv.
</p>
<p>On relance la fonction principale CALCULER_GRAPHE sur cette nouvelle structure bi-ancr&#233;e S&#65535;i
avec comme valeur pour noeudsi le singleton {nAdvmax}. Nous passerons sur le d&#233;tail de son
ex&#233;cution en en donnant seulement le graphe Gi qu&#8217;elle retourne. Ce graphe est form&#233; de deux
n&#339;uds isol&#233;s ADVmod_ADV1 et ADVmod_ADV2 ancrant les adverbes modificateurs d&#8217;adverbes.
</p>
<p>Comme l&#8217;ancre de ADVmod_V est un n&#339;ud interne, la condition INTERNE est vraie et on compl&#232;te
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>610 c&#65535; ATALA</p>

</div></div>
<div style="page-break-before:always; page-break-after:always"><div><p>le graphe G qui est initialement vide &#224; l&#8217;aide de la fonction COMPL&#201;TER_GRAPHE. On obtient
un graphe de trois n&#339;uds avec comme racine ADVmod_V et ses deux successeurs imm&#233;diats
ADVmod_ADV1 et ADVmod_ADV2.
</p>
<p>L&#8217;algorithme se poursuit par la s&#233;lection d&#8217;autre n&#339;ud de l&#8217;ensemble noeuds, nPred par exemple.
Va s&#8217;ensuivre une extension de S vers le bas &#224; partir de ce n&#339;ud. Il serait trop long de la d&#233;crire
en d&#233;tail mais il est important de noter que cette extension va entra&#238;ner la cr&#233;ation d&#8217;un n&#339;ud qui
repr&#233;sente un syntagme propositionnel. Ce syntagme peut repr&#233;senter une proposition relative
telle que &quot;qu&#8217;elle a&quot; dans la phrase &quot;Marie est avec l&#8217;exp&#233;rience qu&#8217;elle a une femme intelligente.&quot;.
Compte tenu de la r&#233;cursivit&#233; de la langue li&#233;e aux propositions qui peuvent s&#8217;imbriquer les
unes dans les autres &#224; l&#8217;infini, l&#8217;ex&#233;cution de l&#8217;algorithme entre ici dans une boucle infinie. Pour
&#233;viter la non terminaison de l&#8217;algorithme, il suffit de couper l&#8217;extension vers le bas de la structure
bi-ancr&#233;e quand on produit des n&#339;uds source de bouclage ou si l&#8217;on atteint une certaine taille 8.
</p>
<p>En d&#233;finitive, nous obtiendrons un graphe G acyclique qui n&#8217;est pas forc&#233;ment complet. Il est
&#233;ventuellement amput&#233; vers la &quot;fin&quot; mais ce qui est important c&#8217;est que toutes les racines peuvent
&#234;tre calcul&#233;es. Dans notre exemple, le graphe aura quelques dizaines de racines qui sont des
SSyntE ancrant des adverbes modificateurs de verbes ou de phrases, des adverbes entrant dans
des constructions cons&#233;cutives ou comparatives, des pr&#233;positions introduisant des compl&#233;ments
modificateurs de phrases, des pronoms comme tous ou chacun, des conjonctions de subordination
introduisant des propositions circonstancielles, des d&#233;terminants et des adjectifs &#233;pith&#232;tes gauche.
</p>
<p>Si Sest a un comme compagnon unique Sf emme 9 dans une s&#233;lection lexicale qui produit une
analyse, selon la s&#233;mantique du graphe expos&#233;e plus haut (m&#234;me si ce graphe est incomplet),
pour toute SSyntE Sk s&#8217;intercalant entre les deux compagnons dans la s&#233;lection, il existe un
chemin dans le graphe commen&#231;ant &#224; une racine et terminant &#224; un n&#339;ud qui n&#8217;a pas de successeur
ou est une occurrence de Sk.
</p>
<p>5 Conclusion
</p>
<p>Si le calcul des compagnons est impl&#233;ment&#233;, ce n&#8217;est pas le cas pour l&#8217;algorithme de d&#233;tection
des SSyntE pouvant s&#8217;ins&#233;rer entre deux compagnons. Seule son impl&#233;mentation permettra de
dire dans quelle mesure cet algorithme est utile pour accro&#238;tre l&#8217;efficacit&#233; du filtrage.
</p>
<p>R&#233;f&#233;rences
</p>
<p>BONFANTE, G., GUILLAUME, B. et MOREY, M. (2009). Polarization and abstraction of grammatical
formalisms as methods for lexical disambiguation. In 11th International Conference on Parsing
Technology, IWPT&#8217;09, Paris, France.
</p>
<p>GUILLAUME, B. et PERRIER, G. (2009). Interaction Grammars. Research on Language and
Computation, 7:171&#8211;208.
</p>
<p>8. Chaque appel r&#233;cursif de la fonction CALCULER_GRAPHE entra&#238;ne une augmentation de la taille de la structure
bi-ancr&#233;e.
</p>
<p>9. Les deux SSyntE ne sont pas exactement Sest et Sf emme mais les SSyntE non ancr&#233;es dont elles sont issues.
</p>
<p>TALN-R&#201;CITAL 2013, 17-21 Juin, Les Sables d&#8217;Olonne
</p>
<p>611 c&#65535; ATALA</p>

</div></div>
</body></html>