
Bibliothéqucs d’automates ﬁnis ct grammaires context-free :
dc nouveaux traitements informatiqucs

Matthieu Constant
Laboratoire d’Automatique Documentaire et Linguistique (LADL)
Universite de Marne-la-Vallee
Batiment Copemic
Charnps-sur-Mame
77 457 Mame-la-Valle'e
mconstant@uniV-mlV.fr

Résumé — Abstract

La quantité de documents disponibles Via Internet explose. Cette situation nous incite a
rechercher de nouveaux outils de localisation d’inforrnation dans des documents et, en
particulier, a nous pencher sur l’algorithmique des grammaires context-free appliquée a des
familles de graphes d’automates f1nis (strictement f1nis ou a cycles). Nous envisageons une
nouvelle representation et de nouveaux traitements informatiques sur ces grammaires, af1n
d’assurer un acces rapide aux données et un stockage peu coﬁteux en mémoire.

The amount of documents available over the Internet is exploding. This phenomenon requires
the development of new electronic representations and tools to search information into these
documents. This article deals with context-free algorithms applied to finite state graphs
(strictly finite or with cycles). It shows new methods and representations to combine
efficiently complexities in terms of memory space and processing time.

Mots-clés — Keywords
Automates fmis, forme normale de Greibach, grammaires context-free, graphes

Context-Free Grammars, Finite State Automata, Graphs, Greibach Normal Form

1 Introduction

Le LADL a entrepris, des les années 60, une couverture complete du lexique et de la syntaxe
de la langue franeaise. L’équipe de recherche a emmagasiné trois types de ressources
linguistiques : tables de lexique-grammaire, dictionnaires électroniques et grammaires locales
(C. Leclere et al. 1991). Les inforrnaticiens du LADL ont mis en place de nouvelles
representations a états fmis, a la fois, claires, a acces rapide et peu coﬁteuses en mémoire. Les
dictionnaires sont stockés sous la forme d’automates de caracteres (D. Revuz 1991). Les
grammaires locales ont la forme de graphes d’automates f1nis. A terme, les tables de lexique-

Matthieu Constant

grammaire, ressources fondamentales pour l’analyse syntaxique automatique, devraient étre
transformées de maniere systématique en graphes d’automates finis (E. Roche 1993). Le
logiciel INTEX (M. Silberztein 1993) permet aux linguistes d’acquérir, de créer et
d’appliquer ces ressources d’une maniere claire et simple. Ainsi, nous prévoyons, dans un
avenir proche, une forte augmentation du nombre de graphes. Ces graphes sont transforrnés
en transducteurs a états finis (FST) afin de les appliquer a des textes. Cette opération
augmente la place en mémoire nécessaire, de maniere exponentielle. L’algorithmique des
automates finis présente des avantages : déterminisation et minimisation sont a priori de gros
atouts. Toutefois, ces outils classiques montrent leurs limites. Ainsi, la minimalisation, trop
coﬁteuse en temps, a été abandonnée et la déterminisation, bien qu’indispensable a
l’amélioration des temps d’acces, a tendance a faire exploser la mémoire. Cette perspective
nous incite a nous pencher sur l’algorithmique des grammaires context-free. Dans un premier
temps, nous décrivons le systeme actuel et ses limites. Puis, nous montrons une nouvelle
représentation des grammaires locales et les traitements associés. Enfin, nous exposons une
méthode d’optimisation de ces grammaires.

2 Les grammaires locales actuelles sous INTEX

2.1 Les graphes d’INTEX

Les grammaires locales utilisées sous INTEX ont la forme de graphes de transducteurs a états
finis. Le systeme INTEX possede un éditeur de graphes FSGraph. Ces graphes ont un format
nommé GRF. Nous donnons ci-dessous (ﬁgure 1) un exemple de graphe reconnaissant des
dates qui nous servira tout au long de notre article. 11 ne prétend en aucun cas décrire les dates
de maniere exhaustive. C’est un exemple symbolique qui illustrera nos propos. Les boites
grisées représentent des appels a des sous-graphes (ici En1999 et EnDebutDeMatinee). Les
sous-graphes appelés dans cette grammaire se trouvent aux figures 2, 3 et 4. La transition Vide
est notée <E>. Le symbole # interdit l’espace. <le> désigne toutes les formes dérivées de la
forme canonique le, soit le, la, les. L’expression entre guillemets "2000" reconnait la
séquence 2000 sans les guillemets et sans espace entre les chiffres. Par exemple, 2 000 ne
sera pas reconnu car il y a un espace entre les chiffres 2 et 0. Le graphe DATE reconnait des
expressions telles que en 1867 ou en début de matinée. A noter que la transduction (
)ADV+date permet cette insertion en sortie de l’application de ce graphe a un texte
électronique. Il est possible d’utiliser des catégories grammaticales comme <N> qui désigne
un nom, ou <V> qui désigne un Verbe quelle que soit sa forme conjuguée.

[ Enl 999 D
EnD ebutD eMatine e
( )ADV+D ate

Figure l : DATE (GRF)

Vers l’applicati0n de larges bibliothéques de grammaires c0ntext—ﬁ'ee .' de nouveaux
traitements informatiques

# ChjfE'e # ChjﬂS'e

en llmée ChJfE'e # Chjlﬁe III
<E>

l'an "2000"

Figure 2 : En1999 (GRF)

l

2

3

2 commencement apres—m.idi

p 6 @ an debut (dc; Journee D

7 En matinee

8 milieu Soiree

9

0 dans <le>

Figure 3 : Chiffre (GRF) Figure 4 : EnDebutDeMatinee (GRF)

2.2 Le compilateur GRFZFST

Les graphes tels que nous les utilisons sont equivalents a des automates ﬁnis apres
remplacement des noms de sous-graphes par les sous-graphes correspondants. Sous INTEX, il
existe un module qui transforme un graphe en transducteur a etats ﬁnis (format FST). Ce
module possede quelques operations de nettoyage des graphes : suppression des transitions
Vides par exemple (voir 3.2). 11 decoupe les transitions en elements simples. Par exemple, la
transition etiquetee par aprés-midi est decoupee en trois transitions etiquetees par aprés, - et
midi. INTEX donne aussi la possibilite de determiniser le transducteur. Notons que, pour de
gros graphes, nous utilisons un module que nous avons developpe en parallele.
Theoriquement, la representation en transducteurs a etats ﬁnis est ce qu’il y a de plus efﬁcace
en terme de Vitesse d’application (E. Roche et al. 1997). Le FST determinise equivalent au
graphe DATE (figure 1) est donne ci-dessous dans la figure 5 :

C ommenc ement
debut

in <de> aprés - midi
m.I.l.lElJ
JOIJITIEE
dans <le> malinée III
( soxrée )ADV+date
an "2000‘

E11

l'année

o\ooa-Jow.nJ:.L»J1\_)._.
<D\QDG—~.]O‘1\.hJ:-L-Jl\)»—A
<Z)\QDG—~.]O1\JuJhL-Jl\)-—A
<D\dJDG-.]<7\\.nJ>~\.rxJl\J>—A

Figure 5 : DATE (FST)

Matthieu Constant

2.3 Les limites du systéme actuel

Le systeme actuel pose certains problemes qui, a terme, le rendront inadéquat. Nous
dénombrons deux raisons principales pour changer de représentation de grammaires : l’une
matérielle, l’autre théorique.

2. 3. 1 Limites matérielles

Alors que la place en mémoire prise par les graphes au format GRF ne posait pas de
probleme, elle en pose pour les FST. En effet, nous constatons une explosion exponentielle de
la complexité en espace. Prenons le cas d’un graphe de M. Gross (1997) décrivant les Verbes
auxiliaires en anglais (AUX). Le format GRF prend 70 k0 (pour une centaine de sous-
graphes) et le format FST 33 Mo. Le FST déterrninisé occupe méme 50 Mo. Potentiellement,
la complexité est exponentielle. A chaque remplacement d’un nom de graphe, on ajoute la
place mémoire de ce graphe. Ce n’est pas le cas pour le GRF qui a une complexité additive.
Illustrons notre propos par un exemple concret. Prenons un graphe décrivant une structure
syntaxique du Verbe to give: No give N; to N2 (ﬁgure 6). Supposons que les insertions
(Insert) a l’intérieur de la phrase ne soient constituées que par des dates, soit le graphe TIME
des expressions de temps (dates, durées) de M. Gross (plus de 50 Mo). De méme, supposons
que la place en mémoire occupée par les graphes reconnaissant les autres membres de la
structure soit négligeable devant celles de AUX et TIME. Lors du passage en FST, TIME est
dupliqué six fois (soit 300 Mo) et AUX deux fois (soit 100 Mo). Au total, le FST de ce graphe
occupe 400 Mo en mémoire. Par ailleurs, cet exemple ne décrit qu’une seule structure du
Verbe to give qui n’est lui-méme qu’un Verbe parmi des milliers. Ainsi, il faudrait multiplier
l’espace mémoire calculé ci-dessus par quelques centaines de milliers ; arrondissons ce
coefficient a 100 000. Si un ordinateur personnel possédait 50 Go de mémoire Virtuelle. Il
faudrait au moins 800 ordinateurs pour stocker la totalité de la langue anglaise. Ce chiffre est
aujourd’hui inacceptable. Nous montrons ainsi l’inadéquation de ce type de représentation.
Figure 6 : NOGiveN1ToN2

Vers l’application de larges bibliotheques de grammaires context-free .' de nouveaux
traitements informatiques

2. 3.2 Limites théoriques

Il est bien connu que la syntaxe du langage naturel ne peut pas toujours étre décrite sous
forme d’automates finis. Méme s’ils sont tres rares, il existe des cas de description "context-
free" non "ﬁnite state" en linguistique, comme le célebre eta peu pres unique exemple :

La souris (que la petite ﬁlle (que Luc (que Marie aime +E) a prise en
ph0to+E) regarde+ E) montre ses dents .': P : N0 (Rel + E) VNI

La description forrnelle de cet exemple possede une imbrication non bomée de la relative
(Rel) et ainsi, la grammaire a utiliser n’est plus celle d’un automate fini, c’est une grammaire
strictement context-free. Alors que théoriquement, le nombre de remplacements dans cette
grammaire n’est pas borné, le compilateur d’INTEX (2.2) limite le nombre des
remplacements a une constante. Si cette constante était égale a 2 par exemple, la phrase ci-
dessus ne pourrait étre reconnue. Le lecteur remarquera que, dans un cadre plus général, le
formalisme "context-free" n’est plus suffisant pour décrire les langues naturelles: il faut
utiliser des grammaires dépendantes du contexte.

3 Une évolution intermédiaire : le compilateur GRF2FST2

3.1 Le logiciel AGLAE

En prévision de l’explosion du nombre de grammaires et du temps nécessaire lors de leur
application a des textes, nous avons développé en parallele le logiciel AGLAE (S. Paumier a
paraitre) dont le but final est de se substituer a certains modules d’INTEX. AGLAE permet
d’accélérer l’application des graphes sur de gros corpus. Il est, actuellement, jusqu’a 50 fois
plus rapide. Ce logiciel contient deux modules bien distincts : un compilateur de graphes et un
analyseur automatique. Le compilateur traite le graphe GRF fourni par l’utilisateur: par
diverses opérations, il le transforme dans un nouveau format FST2 (3.2). L’analyseur
applique le graphe compile a un texte. La réunion des deux modules constitue le logiciel
AGLAE. La compilation est invisible pour l’utilisateur. Comme dans cet article, nous ne nous
intéressons qu’aux grammaires en elles-mémes, nous nous limitons au module de compilation
qui traite de représentation des graphes et d’opérations sur les grammaires locales.

3.2 Le format FST2 et le compilateur GRF2FST2

Le but du compilateur est d’éViter a l’analyseur de multiples opérations sur les graphes. Le
compilateur prend en entrée un graphe GRF et délivre en sortie une nouvelle représentation
de ce graphe, c’est le format FST2 que nous décrivons ci-dessous. Nous effectuons quelques
traitements dont certains sont réalisés sur le FST : une normalisation des transitions puis un
nettoyage et une déterrninisation locale des graphes.

Dans un cadre théorique, hors linguistique, les graphes utilisés peuvent étre vus comme des
grammaires context-free décrites dans J.-M. Autebert et al. (1997). L’alphabet des éléments
auxiliaires est l’ensemble des étiquettes indiquant les appels aux sous-graphes. Celui des
éléments terrninaux est l’ensemble des autres types d’étiquettes (categories grammaticales,
étiquettes lexicales, etc. ). Ces deux alphabets sont clairement disjoints. Si X est un élément

Matthieu Constant

auxiliaire, les regles correspondantes a X sont factorisées sous la forme d’un graphe nommé
X. L’axiome de départ est le graphe principal. Jusqu’a présent, nous avons considérés nos
grammaires comme de simples automates finis dans nos algorithmes. Vu les problemes que
cela risquait d’engendrer dans le futur (2.3), nous décidons de nous pencher sur une nouvelle
représentation des graphes, équivalente a une grammaire context-free : le format FST2. Cette
representation a pour but de réduire sensiblement l’espace mémoire et de rester dans un
environnement théorique correct. Contrairement au FST, nous gardons le principe d’appel a
des sous-graphes comme dans le format GRF, utilisant ainsi le forrnalisme context-free.

Nous réalisons quelques traitements que l’on n’effectuait pas sur le GRF. Comme pour le
FST, nous découpons les étiquettes en éléments terminaux. Chaque transition ne doit
comporter qu’un seul élément terminal. On évite ainsi un découpage coﬁteux en temps lors de
l’application des graphes. Nous ajoutons quelques améliorations par rapport au FST,
notamment pour les expressions que l’on appelle entre guillemets (2.1). Prenons l’exemple du
graphe 7. Il reconnait l’unique expression Jacques a dit, et non Jacques A DIT qui comporte
des majuscules. Dans le FST, l’expression "Jacques a dit" n’est pas découpée en éléments
terminaux, elle est gardée telle quelle. Par contre, dans le FST2, un découpage est affectué
(ﬁgure 8). Les espaces sont indiqués.

it 19 rbﬂlﬂlﬂlltil

Figure 7 : JacquesADit (GRF et FST) Figure 8 : JacquesADit (F ST2)

Comme pour le FST, nous effectuons un nettoyage du graphe. Nous supprimons les
transitions Vides, les états non accessibles, les états non co-accessibles. Par ailleurs, nous
déterminisons localement les grammaires. Les symboles auxiliaires sont alors considérés
comme des transitions terminales: on ne rentre pas dans les sous-graphes. On reste a un
niveau superficiel. La figure 9 présente le résultat de la compilation de En1999 (figure 2) :
Figure 9 : En1999 (FST2)

La représentation est interrnédiaire entre FST et GRF. En effet, comme pour le GRF, nous
avons des appels a des sous-graphes, ici Chiffre. Comme pour le FST, les transitions a
étiquettes multiples sont décomposées : I ’année, I ’an et, plus particulierement pour le FST2,
"2000". Le FST2 est déterminisé localement: nous factorisons les transitions I ‘. L’espace
mémoire occupé par le FST2 est du méme ordre que le GRF. Le graphe TIME au format
FST2 prend environ 100 ko (plus de 50 Mo pour le FST). La différence est claire. Nous allons
Voir, dans la partie suivante, quelques moyens d’optimiser cette représentation.

Vers l’applicati0n de larges bibliothéques de grammaires c0ntext—ﬁ'ee .' de nouveaux
traitements informatiques

4 Optimisation des graphes : la déterminisation Look-Ahead

4.1 Les limites du FST2

Le résultat obtenu par le compilateur GRF2FST2 peut étre amélioré. Nous avons applique, a
l’aide d’AGLAE, notre graphe AUX des Verbes auxiliaires (2.3.l) sur un corpus constitué
d’une année du journal électronique Le Monde (110 Mo). Cette application a pris une heure.
Puis, nous avons adapté AGLAE aﬁn qu’il accepte en entrée le FST de ce graphe.
L’application prend, dans ce cas, trois-quart d’heure. La difference d’efﬁcacité entre FST2 et
FST est nette. Nous expliquons ce résultat par deux phénomenes. Premierement, la
déterminisation réalisée par le compilateur reste locale. Deuxiemement, l’utilisation de sous-
graphes empéche un acces direct aux éléments terminaux. Dans les parties suivantes, nous
optimisons le FST2 compilé grace a deux méthodes : une déterminisation locale plus
approfondie (4.2) et une remontée des transitions terminales (4.3). L’inconVénient de ces deux
méthodes est d’accroitre l’espace mémoire nécessaire pour stocker les graphes. Par des
expérimentations, il faudra trouver un compromis entre Vitesse d’acces et place mémoire.

4.2 Une déterminisation locale approfondie

Dans la section précédente, nous avons mentionné que le compilateur réalisait une
déterminisation locale des graphes. Si nous regardons les graphes En1999 (ﬁgure 2) et
EnDebutDeMatinee (ﬁgure 4), nous constatons qu’ils commencent tous deux par la
transition étiquetée par en. Alors que la déterminisation de DATE au format FST (figure 5)
met cette transition en facteur pour les deux graphes, la déterminisation locale de DATE ne
peut plus le faire. Ce phénomene est problématique pour les gros graphes. Prenons l’exemple
du graphe TIME de M. Gross, qui comprend une centaine de sous-graphes, la plupart mis en
parallele les uns par rapport aux autres. En faisant remonter les transitions terminales partant
de l’état initial, au niveau du graphe principal, nous dénombrons 29 618 transitions alors que
le nombre total d’étiquettes est 1 134. TIME est donc largement non déterrniniste. En effet,
s’il était déterministe, le nombre de transitions terminales initiales serait au plus égal au
nombre d’étiquettes. Nous expliquons ainsi une grosse partie de la perte de temps constatée
en 4.1. Une solution est d’améliorer la déterminisation. Au lieu de rester en superﬁcie, nous
entrons partiellement dans les sous-graphes et nous regardons leurs premieres transitions. 11
est clair que nous ne pouvons pas déterminiser totalement : risque d’explosion de la mémoire
et, dans le cas de graphes récursifs, de boucle inﬁnie. Nous réalisons une déterminisation
partielle. Nous ﬁxons un parametre n, désignant la pénétration horizontale maximale au-dela
de laquelle la déterminisation s’arréte. Prenons l’exemple, du graphe President de la figure
10. Si l’on regarde les premieres transitions des deux sous-graphes PresidentEco (figure 10)
et PresidentPol (figure 11), on Voit que l’on peut factoriser une bonne partie des deux sous-
graphes. Nous donnons le résultat PresidentDet2 de la déterminisation locale approfondie en
prenant n : 2 (figure 13). Nous ne donnons pas les sous-graphes créés lors de la
déterminisation partielle car ils peuvent étre facilement retrouvés par le lecteur a l’aide des
graphes de départ (figures 10, 11 et 12). On s’apercoit que de nombreux sous-graphes sont
créés : la taille mémoire augmente. Il faut donc éviter de prendre un 11 trop grand.

Matthieu Constant

Pre sidentP 01
__D Pre sidentEco

Figure 10 : President

5
D

Figure 11 : PresidentEco

général
<m°“515‘-11') du cons eil régional

constitutionnel

— <1e> <pré siclent>
députés D

de la chambre des ,
- representants

Répubhque

Figure 12 : PresidentPol

. . PE 2
} PPS;

PEco1}
Figure 13 : PresidentDet2

4.3 Remontée des éléments terminaux

Lors de 1’app1ication des grammaires aux textes, la co'1'ncidence ne se fait qu’entre les mots du
texte et les éléments terminaux des graphes. S’i1 y a plusieurs couches d’appe1s a des sous-
graphes, i1 faut aller chercher les éléments terminaux pour pouvoir faire une comparaison. I1
faut éviter la présence des éléments auxiliaires, c’est-a-dire des appels a des sous-graphes.
Ainsi, comme les premieres transitions d’un graphe jouent un role de filtre, nous réalisons une
Variante de la mise en forme normale de Greibach (S. Greibach 1965) appliquée a des graphes
d’automates finis. Cette méthode consiste a faire remonter les premieres transitions terminales
au niveau du graphe principal. Ainsi, 1e graphe President (figure 10) est transformé en 1e
graphe PresidentGr ci-dessous (figure 14). Nous constatons que ce graphe n’est pas
déterministe. Comme précédemment, les sous-graphes peuvent étre retrouvés par le lecteur.

<monsieur> ’
Figure 14 : PresidentGr

Vers l’applicati0n de larges bibliothéques de grammaires c0ntext—ﬁ'ee .' de nouveaux
traitements informatiques

4.4 La déterminisation Look-Ahead

A partir de la discussion précédente, nous décidons de développer un nouveau module appelé
Déterminisation Look-Ahead (DLA). La méthode utilisée consiste a fusionner les deux
approches données en 4.2 et 4.3. Soit n un parametre que nous fixons. Nous terminalisons et
déterminisons partiellement le graphe en entrée, jusqu’a la pénétration horizontale maximale
n. Désormais, LA-déterminiser sera effectuer une DLA. Pour n:2, la DLA donnerait le
résultat suivant (ﬁgure 15) sur le graphe President (ﬁgure 10) :
<13: }

<monsieur>
D

D D

Figure 15 : President_LA2

Nous avons LA-déterminise le graphe TIME en faisant varier le parametre n. Ensuite, nous
avons appliqué les graphes résultats a un corpus littéraire de 1 Mo constitué du texte Portrait
of a Lady de Henry James, avec le logiciel AGLAE (4.3). Quelques résultats de l’expérience
sont donnés dans le tableau ci-dessous (ﬁgure 16). Notons que la DLA au parametre n:0
constitue le graphe d’entrée. Nous constatons que les résultats dépendent de la nature des
graphes. La mémoire peut rapidement exploser comme pour TIME (des 11 : 2). Les
performances en temps sont nettement accélérées avec n croissant.

FST2 TIME AUX

N 0 1 2 O 1 2 3

Espace mémoire 127 ko 342 ko 11 Mo 60 ko 117 ko 142 ko 500 ko

Temps d’application 420 s 50 s 9 s 9 s 4 s 3 s 2 s
au corpus

Figure 16 : résultats de l’expérience

Nous pensons qu’il faut ajouter des parametres lies a la nature du graphe, afin de préciser
l’optimisation. Nous voulons LA-déterminiser tous les sous-graphes sous certaines conditions
et pas uniquement le graphe principal. Par exemple, nous souhaitons mettre une condition sur
le nombre de sous-graphes appelés au debut du graphe que l’on LA-déterminise. Si cette
condition est Vérifiée, on LA-déterminise normalement jusqu’a n =1 ou 2 ; sinon, on ne fait
rien de spécial. Cette procédure est en cours d’élaboration. Nous pensons encore améliorer
sensiblement les performances.

Matthieu Constant

5 Conclusion et perspectives

La quantité de grammaires locales nécessaires aux analyses remet en cause les performances
des outils actuels. Nous avons concu un systeme utilisant une nouvelle représentation
équivalente a une grammaire context-free et de nouveaux traitements. Nous avons décrit une
méthode d’optimisation paramétrée des graphes : la Déterminisation Look-Ahead (DLA). A
terme, nous envisageons d’optimiser automatiquement les graphes. Par le développement
d’un analyseur automatique de graphes, nous pourrions pré-calculer les parametres de la
DLA. Ces representations et optimisations des graphes nous paraissent indispensables dans le
cadre du LADL. Par ailleurs, nous pensons que ces travaux pourraient étre utiles a d’autres
applications linguistiques utilisant des grammaires de grande taille.

Remerciements

Nous tenons a remercier M. Gross pour ses conseils et S. Paumier pour sa collaboration
active.

Références

Autebert J., Berstel J., Boasson L. (1997), Context-free languages and Pushdown Automata,
in G. Rozenberg and A. Salomaa Eds., Handbook of Formal Languages, Vol.1 .' Word,
Language, Grammar, Springer-Verlag, Berlin, pp. 125-213

Greibach S. (1965), A new normal form theorem for context-free phrase structure grammars,
Journal ofACl\4, Vol.12, pp. 42-52

Gross M. (1997), The Construction of Local Grammars, in E. Roche and Y. Schabes Eds.,
Finite State Language Processing, Cambridge, Mass., The MIT Press, pp. 329-352.

Leclere C., Subirats-Riiggeberg C. (1991), A bibliography of studies on lexicon-grammar,
Lingvisticoe Investigationes, Vol. XV :2, pp.347-409.

Paumier S., (a paraitre), Nouvelles méthodes pour la recherche d’expressions dans de grands
corpus, RISSH.

Revuz, D. (1991), Dictionnaires et lexiques .' méthode et algorithmes, These de doctorat,
Paris, Université Paris 7.

Roche E. (1993), Analyse syntaxique transformationnelle du frangais par transducteurs et
lexique-grammaire, These de doctorat, Paris, Université Paris 7.

Roche E., Schabes Y. (1997), Introduction, in E. Roche and Y. Schabes, Finite State
Language Processing, Cambridge, Mass., The MIT Press, pp. 1-66.

Silberztein M. (1993), Dictionnaires électroniques et analyse automatique de textes .' Le
syste‘me INTEX, Paris, Masson.
