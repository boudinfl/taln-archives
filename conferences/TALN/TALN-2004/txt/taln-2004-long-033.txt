TALN 2004, Fès, 19–21 avril 2004
Détermination de contenu dans G E P HOX

Adil El Ghali
L ATTICE / PPS - Université Paris 7
2, place jussieu
case 7003 - 75251 Paris
adil@linguist.jussieu.fr
Résumé - Abstract
Le générateur G E P HOX que nous réalisons a pour ambition de produire des textes pour des
déﬁnition ou preuves mathématiques écrites à l’aide de l’assistant de preuve P HOX. Dans
cet article nous nous concentrons sur le module de détermination de contenu ContDet de
G E P HOX. Après un aperçu sur l’entrée du générateur, i.e. la preuve formelle et l’ensemble des
règles ayant permis de l’obtenir, nous décrivons les base de connaissances du générateur et le
fonctionnement de l’algorithme de détermination de contenu.
This paper deals with content determination in a text proofs generation system. Our system,
G E P HOX produces a textual version of a mathematical proof formalized using the proof assis-
tant P HOX. We start with a quick presentation of the input of the generator : the formal proof
and the set of rules that the proof assistant user employs in order to ﬁnd it. We describe the
generator knowledge bases and deﬁne the reasoning tasks associated with the KB and show
how the content determination algorithm work.
Mots-clefs – Keywords
Génération de textes, logique de description, détermination de contenu, bases de connaissance,
assistant de preuve
Natural language generation, description logic, content determination, knowledge bases, proof
assistant
Adil El Ghali
Introduction

La détermination de contenu est la première tâche de tout système de génération de texte. Elle
a pour but de produire une représentation abstraite des données fournies en entrée du système.
C’est une des tâches les plus ardues et sans doute la plus importante du processus de génération
(Reiter & Dale, 2000; Sripada et al., 2001). La plupart des utilisateurs d’un système de généra-
tion préfèrent avoir un texte dont le contenu est correct mais pauvrement exprimé plutôt qu’un
texte bien écrit mais dont le contenu n’est pas satisfaisant.
Le générateur G E P HOX que nous réalisons a pour ambition de produire des textes pour des
déﬁnition ou preuves mathématiques écrites à l’aide de l’assistant de preuve P HOX (Raffalli,
2002; Raffalli & Roziere, 2002) . Dans cet article nous nous concentrons sur le module de
détermination de contenu ContDet de G E P HOX.
Un certain nombre de travaux ont été menés dans ce domaine (Hallgren & Ranta, 2000; Coscoy,
2000). Les approches proposées par ces auteurs sont des tentatives plus ou moins réussies
d’établir une correspondance directe entre objets mathématiques et représentations linguis-
tiques. Le point de vue que nous défendons est assez différent : nous pensons qu’au moins
un niveau de représentation intermédiaire est nécessaire, aﬁn de pouvoir raisonner et manipu-
ler non pas des preuves mathématiques mais une vue de ces preuves qui précède leur mise en
langue. Ce point de vue se rapproche plus des travaux de (Fiedler, 2001a; Fiedler, 2001b) où
une représentation intermédiaire en termes d’actes de langage est calculé pour chaque action de
preuve. Cependant, la détermination de contenu et la structuration de document sont confon-
dues dans son travail, alors que nous pensons qu’un certain nombre d’opérations de calcul de
contenu sont indépendantes de la structuration et qu’il faut séparer les deux tâches.
L’approche de détermination de contenu que nous proposons est centrée sur les connaissances
du système de génération. Nous voyons cette tâche comme la construction d’un univers de
discours (section 3). Le module ContDet produit à partir de l’entrée du système une représen-
tation (message) des connaissances qui vont ﬁgurer dans le texte, ce message est exprimé en
logique de description i.e. il peut être vu comme une A-Box. Par ailleurs, ce message est con-
struit de façon à préserver les éléments de structure de P HOX qui vont être utiles pour la suite
du processus de génération, notamment pour la structuration de document.

Services de
entrée
raisonnement
Traduction
Base de         ⇐=             Sélection
connaissance      =⇒           Instanciation
Vériﬁcation
message
Figure 1: Architecture du module ContDet

Le module ContDet repose sur une architecture en pipe-line à quatre sous-modules, comme le
montre la ﬁgure 1. Il utilise une base connaissances écrite en Logique de Description à laquelle
on accède via une interface fournissant des services de raisonnement (subsomption, uniﬁcation
de concepts, ...).
Détermination de contenu dans G E P HOX
L’article commence par une rapide présentation de P HOX et des éléments qui serviront comme
entrée pour notre générateur (section 1). Nous présenterons ensuite les bases de connais-
sances du système et les services de raisonnement qui permettent d’y accéder (section 2) avant
d’expliciter le fonctionnement des différents sous-modules réalisant la détermination de con-
tenu (section 3).
1 Entrée du générateur

1.1     P HOX

P HOX est un assistant de preuve basé sur le système AF 2 1 . Il permet de réaliser sur ordinateur
des preuves mathématiques en déduction naturelle, mais aussi de déﬁnir des théories mathéma-
tiques grâce à un système de gestion de modules. Il est par ailleurs extensible i.e. l’utilisateur
peut déﬁnir ses propres commandes qui correspondent à des tactiques de raisonnement d’un
niveau plus élevé que les règles de déduction habituelles.
Un théorème à prouver est considéré par P HOX comme un but. Le déroulement de la preuve est
une application successive de commandes qui réduisent le but courant en sous-buts plus sim-
ples. Cet ensemble de commandes est appelé script de preuve. P HOX répond aux commandes
du rédacteur2 en donnant le contexte courant de la preuve, c’est-à-dire les hypothèses à dispo-
sition et le(s) but(s) courant(s) qui reste(nt) à démontrer (les hypothèses et les buts courants
forment un séquent). Par ailleurs, le système peut fournir à chaque étape le fragment de l’arbre
de preuve construit i.e. les règles et théorèmes utilisés pour passer du séquent précédent au
séquent courant. La ﬁgure 2 montre un exemple d’entrée pour G E P HOX 3 . Pour produire le
texte correspondant à la preuve (ou à une étape de celle-ci), le générateur prend en entrée toutes
ces informations.

< script >goal ∀x (G x ↔ G1 x ∨ G2 x) → ∀x:G1 G2 x ∨ ∀x:G2 G1 x.< /script >
< phox >
Here is the goal:
goal 1/1
→ (∀ λx (↔ (G x) (∨ (G1 x) (G2 x)))) (∨ (∀ λx (→ (G1 x) (G2 x))) (∀ λx (→ (G2 x) (G1 x))))
< /phox >
< script >intros.< /script >
< proof >
arrow_intro (∀ λx (↔ (G x) (∨ (G1 x) (G2 x)))) λH
(comment "goal 1")
< /proof >
< phox >
New goal is:
goal 1/1
H := ∀ λx (↔ (G x) (∨ (G1 x) (G2 x)))
∨ (∀ λx (→ (G1 x) (G2 x))) (∀ λx (→ (G2 x) (G1 x)))
< /phox >
Figure 2: Exemple d’entrée du générateur
1
Arithmétique fonctionnelle d’ordre 2 (Krivine, 1997)
2
On désigne par rédacteur l’utilisateur de P HOX qui construit la version formelle de la preuve, et par utilisateur
le destinataire du texte produit par G E P HOX.
3
Les tags < script >, < phox > et < proof > délimitent respectivement au script de preuve rentré par le
rédacteur, à la réponse de P HOX qui déﬁnit le contexte courant et au fragment d’arbre de preuve correspondant.
Adil El Ghali
1.2 Les éléments de l’entrée

Script de preuve Les scripts de preuve peuvent contenir deux types de commandes. D’une
part, les annonces qui regroupent, entre autres, les déclarations d’objets (types, variables, ...),
les déﬁnitions ou les énoncés de théorèmes. D’autre part, les commandes de preuve qui re-
groupent les règles de déduction (règles d’introduction ou d’élimination de la déduction na-
turelle) ou tactiques de preuves (raisonnement par l’absurde, par récurrence, ...) servant à
avancer dans la recherche de preuve.
Contexte À chaque étape de la preuve, le rédacteur passe d’un séquent(un ensemble
d’hypothèses et un but à prouver) à un autre en appliquant une règle de déduction ou une tactique
de preuve. Le contexte est l’ensemble des hypothèses et des buts disponibles à chaque étape,
Par exemple, après l’application de la règle d’introduction de → sur l’annonce du théorème à
démontrer
∀x (G x ↔ G1 x ∨ G2 x) → ∀x ∈ G1 G2 x ∨ ∀x ∈ G2 G1 x. 4
le contexte résultant contient l’hypothèse H: ∀x ((G x) ↔ (G 1 x ∨ G2 x)) et le nouveau but
qu’il faut prouver (∀x G1 x → G2 x) ∨ (∀x G2 x → G1 x).
Arbre de preuve Cette partie de l’entrée nous fournit des informations sur ce que le prouveur
a utilisé comme règles élémentaires, théorèmes, axiomes ou déﬁnitions. Elle est plus informa-
tive que le script de preuve, e.g. l’application de la règle d’introduction de → est implicite dans
le script mais elle ne l’est pas dans le fragment d’arbre de preuve correspondant à cette com-
mande. Par ailleurs, quand le prouveur utilise la tactique automatique, les théorèmes et règles
utilisées ne sont explicitées5 que dans l’arbre de preuve.
2 Bases de connaissances
Le module ContDet utilise pour représenter les connaissances du domaine une base de con-
naissances écrite en Logique de Description. Ce choix est motivé par plusieurs raisons, prin-
cipalement : (i) les bonnes propriétés mathématiques de ce formalisme nous permettent de
contrôler la complexité du processus de génération, (ii) la séparation entre connaissances inten-
sionnelles et extensionnelles est bien adaptée à la génération de textes, (iii) l’existence de raison-
neurs optimisés fournissant les services standards de raisonnements facilite l’implémentation du
système.
2.1 Logique de description

Les logiques de description (description logics terme abrégé en DL) (Baader et al., 2003) sont
un formalisme de représentation des connaissances basé sur la logique du premier ordre et
4
Le théorème s’énonce ainsi: « si dans un groupe G, tout élément est dans l’un des deux sous-groupes G 1 ou
G2 alors l’un des sous-groupes est inclu dans l’autre (tout élément de G 1 appartient à G2 ou tout élément de G2
appartient à G1 ). »
5
Ces informations sont importantes parce qu’elles doivent être incluses dans le texte destiné à un utilisateur qui
ne les possède pas dans sa base de connaissances personnelle (cf. section 2.2).
Détermination de contenu dans G E P HOX
descendant des réseaux sémantiques et des systèmes à base de frames. Dans ce formalisme, la
théorie est divisée en deux parties, (i) la T-Box qui regroupe les connaissances intensionnelles
(conceptuelles ou terminologiques) i.e. les concepts et les relations du domaine, et (ii) la A-
Box qui regroupe les connaissances extensionnelles (assertionelles) décrivant les individus du
domaine et les relations entre eux. Les concepts peuvent être vus comme des classes d’individus
du domaine et les rôles comme des relations binaires entre concepts/individus. Le formalisme
offre un certain nombre d’opérateurs (généralement appelés constructeurs) qui permettent de
déﬁnir des concepts et rôles complexes en fonction d’autres plus simples. Le langage que nous
utilisons comprend les constructeurs dont la syntaxe et la sémantique sont présentés dans la
table 1.
Nom du constructeur            Syntaxe           Sémantique
concept atomique               A                 AI ⊆ ∆I
top                                              ∆I
bottom                         ⊥                 ∅
conjonction                    C∧D               C I ∩ DI
disjonction (U)                C∨D               C I ∪ DI
complement (C)                 ¬C                ∆I CI
quantiﬁcation univ.            ∀R.C              { x | ∀y (x,y) ∈ RI ⇒ y ∈ CI }
quantiﬁcation exist. (E)       ∃R.C              { x | ∃y (x,y) ∈ RI ⇒ y ∈ CI }
restrictions numeriques (N )   >n R.C            { x | { y | ∀y (x,y) ∈ RI } > n }
≤n R.C            { x | { y | ∀y (x,y) ∈ RI } ≤ n }
collection d’individus (O)     {a1 ,. . .,an }   {aI1 ,. . .,aIn }
rôle atomique                  P                 PI ⊆ ∆I × ∆I
conjonction de rôle (R)        Q∧R               R I ∩ RI
rôle inverse                   R 1               {(a1 ,a2 ) | ((a2 ,a1 ) ∈ RI }
composition de rôles           Q◦R               {(a1 ,a2 ) | ∃a3 (a1 ,a3 ) ∈ QI ∧ (a3 ,a2 ) ∈ RI }

Table 1: Syntaxe et sémantique des constructeurs de concepts et de rôles
Les DL offrent plusieurs services de raisonnement (Donini et al., 1996; Horrocks, 2002). Soit
une base de connaissances Σ, on désigne par les lettres majuscules C, D des concepts com-
plexes, R, Q des rôleset par les lettres minuscules a, b des individus. Les services de raison-
nements que nous utilisons sont déﬁnis comme suit.

Subsomption : ce qu’on écrit Σ       C     D. Ce service permet de tester si dans la base de
connaissances Σ, C est subsumé par D, ce qui est vériﬁé quand CI ⊆ DI dans tout modèle
I de Σ. Pour les besoins de la détermination de contenu, la subsomption permet de dire si
un concept est plus spéciﬁque qu’un autre. Un service off-line lié à la subsomption est la
classiﬁcation ou hiérarchisation des concepts d’une base de connaissances. Par ailleurs,
ont dit que C et D sont équivalents (noté C ≡ D) si C D et D C.
Consistance : ce qu’on écrit Σ . Ce service permet de vériﬁer si Σ est satisﬁable, i.e. que
Σ a un modèle. La consistance est utilisée par le module ContDet pour assurer que
le message délivré à la sortie du module ne contient pas d’incohérence, ce qui se verrait
dans le texte ou bloquerait le reste du processus de génération.
Test d’instance : ce qu’on écrit Σ C(a) (resp. Σ R(a, b)). Ce service permet de vériﬁer
si l’assertion C(a) (resp. R(a, b)) est satisfaite dans tous les modèles de Σ, autrement dit,
que a est membre du concept C (resp. a,b est membre de la relation R).
Uniﬁcation : ce service de raisonnement, introduit dans (Baader et al., 2000; Baader & Naren-
dran, 2001) a pour but, étant donnés C et D, de trouver une substitution σ (appelée uni-
Adil El Ghali
ﬁeur), telle que σ(C) ≡ σ(D). Par exemple, si C = A∨∀R.A et D = (B1 ∧B2 )∨∀R.(B1 ∧B2 ),
la substitution σ qui remplace A par B1 ∧B2 dans C est un uniﬁeur pour C et D. On utilise
ce service pour trouver un concept dont la déﬁnition s’uniﬁe avec une expression con-
ceptuelle et qui pourrait la désigner. Ce qui permet, par exemple, de détecter des tactiques
de raisonnement complexes.
Projection : c’est un service de raisonnement non standard qui met en jeu deux bases de con-
naissances Σ1 et Σ2 telles que Σ2 ⊂ Σ1 . Pour tout concept C dans Σ1 et n’appartenant pas
à Σ2 , ce service permet de trouver une déﬁnition de C avec uniquement des concepts de
Σ2 . La projection est utilisé par le module ContDet pour adapter le message aux con-
naissances de chaque utilisateur : si au cours du processus de détermination de contenu,
on manipule un concept qui n’est pas connu par l’utilisateur, le message va être enrichi
par la déﬁnition de ce concept, ce qui assure une meilleure compréhension du texte ﬁnal.
Par exemple, dans la présentation d’une preuve manipulant des groupes à un utilisateur
ne maîtrisant pas le concept de groupe, on explicitera qu’un groupe est un ensemble muni
d’une loi associative, possédant un élément neutre et dont tous les éléments possèdent
un inverse. Dans ce cas de ﬁgure, les concepts de Ensemble, Loi, Element, Inverse,
ElementNeutre sont dans la base de connaissances de l’utilisateur, mais pas celui de
Groupe.
2.2 Bases de connaissances de G E P HOX

G E P HOX dispose de deux bases de connaissances. Le première, DKB (Domain Knowledge
Base), contient toute les connaissances sur le domaine mathématique dont dispose le système.
Elle est structurée en deux parties. D’une part, un noyau correspondant à la base de P HOX : les
concepts décrivant les types de base, les commandes et les objets mathématiques (variable,
operateurs-logique, ...) et méta-mathématiques (theoreme, deﬁnition, commandes-de-
preuves, ...) de bas niveau. D’autre part, un ensemble de modules (dont le découpage est
calqué sur celui de P HOX) correspondant aux différentes théories mathématiques, e.g. un mod-
ule pour les entiers, un autre pour les groupes. Lorsque le système entame un processus de
génération, la base de connaissances qu’il utilise ne contiendra que le noyau et les modules
qui représentent les connaissances des théories que le rédacteur de la preuve a choisi d’utiliser.
Ce découpage en modules de la DKB réduit la taille de la base de connaissances effectivement
utilisée et améliore l’efﬁcacité du système.
La deuxième base de connaissances dont dispose le système, UKB (User Knowledge Base), est
spéciﬁque à chaque utilisateur ; il s’agit en fait d’un sous ensemble de la DKB qui reﬂète ses
connaissances.
3 Algorithme de détermination de contenu
Comme on l’a vu dans la section 1, l’entrée du générateur G E P HOX est riche car elle comporte
certains éléments qui peuvent être vus comme du contenu "pur" (la description des objets math-
ématiques, l’arbre de preuve) et d’autres qui sont plutôt des informations sur la structure de la
preuve (les hypothèses et buts intermédiaires, les commandes appliquées). Dans le déroulement
de la tâche de détermination de contenu, chacun de ces éléments prend un statut particulier. Les
premiers vont nous donner les référents aux objets du domaine du discours, et les seconds des
Détermination de contenu dans G E P HOX
actes de langage et des actions de preuve. C’est pour cette raison qu’on a besoin de manipu-
ler dans le module ContDet des structures de données permettant de séparer ces deux types
d’informations. Ainsi le choix du contenu à exprimer se fait en préservant la structure de la
preuve, ce dont on aura besoin dans la tâche de structuration de document (El Ghali & Rous-
sarie, 2003).
La structure de données élémentaire manipulée par le module ContDet que l’on appellera
segment est la traduction d’une étape de preuve dans P HOX. Elle comporte deux parties : la
première, data, qui contient les informations relatives aux objets mathématiques manipulés dans
la preuve, et qui, du point de vue du système de génération, correspond à du contenu pur. La
seconde, struct, qui contient les informations structurantes de la preuve mathématique. Ces
deux parties sont exprimées en DL , ce sont des fragments d’une A-Box. Nous avons choisi de
les exprimer dans la même terminologie pour rendre compte plus facilement des relations entre
les individus dans la partie data et ceux dans la partie struct.
Le module ContDet va tout au long du traitement d’une entrée construire de manière incré-
mentale un univers de discours qui sera composé de segments. Plus précisément, on déﬁnit les
structures de données comme suit :

Déﬁnition 1 segment
Un segment est un quadruplet data, struct, Rint, Rext où data et struct sont deux ensem-
bles de triplets individu, concept, type correspondant aux individus, aux concepts auxquels
ils appartiennent et à leur type, pour respectivement la composante données et la composante
structure. Rint (relations internes au segment) est un ensemble de relations binaires entre des
éléments de data ∪ struct et Rext (relations externes au segment) est un ensemble de relations
binaires dont un participant est dans data ∪ struct et l’autre dans un autre segment.

Déﬁnition 2 univers de discours
Un univers de discours est une suite ordonnée de segments, telle qu’il n’existe pas d’individu
a appartenant à deux segments différents, et telle que tout segment est relié à au moins un autre
segment de i.e. ∀ ∈            Rext = ∅. L’unicité des individus nous assure que notre message
✁           ✂
ne contiendra pas de redondance. La condition de connexité de l’univers de discours quand à
elle sert à identiﬁer les parties du textes qui ont pas de lien et qui correspondront à des unités
textuelles (paragraphes, sections, ...) différents dans le texte ﬁnal.

Déﬁnition 3 types d’individus
Les individus qui composent les segments sont typés pour les besoins de la détermination de
contenu. Les types sont dynamiques et n’apparaissent pas dans la base de connaissances. La
procédure de calcul du type d’un individu nous permet de distinguer les informations qui vont
apparaître dans le message ﬁnal de celles qui n’y seront pas incluses. La visibilité d’un individu
signiﬁe qu’il sera présent dans le message. Prenons le cas d’une formule f qui contient des
variables et des connecteurs logiques. Si les éléments qui composent f ne sont pas utilisés pour
avancer dans la preuve, les individus correspondant ne vont pas apparaître dans le message,
mais ils seront présents dans l’univers de discours en étant cachés. L’individu correspondant à
f les représentera dans le message.
On distingue donc trois types d’individu :

visible c’est le type par défaut, les individus ayant ce type seront présents dans le message
ﬁnal ;
Adil El Ghali
représentant pour les individus qui ont la particularité d’être le seul lien d’un ensemble
d’individus avec le reste du segment ou de l’univers ;
caché pour ceux qui appartiennent à l’ensemble d’un individu représentant.
Le sous-module de traduction traite une à une les parties de l’entrée correspondant à une com-
mande, le segment ainsi produit est intégré à l’univers de discours courant en effectuant des
choix sur les parties à garder et celles à ne pas dire ; par la suite l’univers de discours produit
est instancié pour l’utilisateur courant, puis vériﬁé (cf. section 3.3).
3.1 Traduction

La tâche du sous-module de traduction est de traduire l’entrée (script, réponses de P HOX et
arbre de preuve) en DL. Cette opération doit produire une représentation de toutes les informa-
tions disponibles dans l’entrée. Elle doit, par ailleurs, préserver la structure de la preuve qui va
servir à la structuration de document. La stratégie adoptée pour la traduction est de traiter un
bloc composé d’une commande P HOX, de la réponse à cette commande et du fragment d’arbre
de preuve correspondant, pour construire une structure composée d’une partie donnée et d’une
partie structure.
Une commande P HOX est composé de deux parties :                       l’instruction de preuve
(intro, elim, goal, ...) et une partie arguments qui peut être soit l’énoncé (une formule) d’un
théorème à prouver ou d’une déﬁnition dans le cas des commandes def, goal, lem, ..., soit une
hypothèse, une variable, un opérateur logique, ... pour les autres commandes, soit vide quand
le rédacteur de la preuve laisse à la tactique automatique le soin de choisir les arguments pour
sa commande. Les instructions de preuve vont être traduites par des individus appartenant au
concept correspondant et cet individu sera rangé dans la case struct du segment courant. Pour
la partie arguments nous avons deux cas de ﬁgures. D’une part, un argument peut introduire
un seul individu, c’est le cas pour les variables, les noms d’hypothèses et les opérateurs ; le
module de traduction créé alors un individu pour ce référent et doit calculer le concept auquel
il appartient. D’autre part, un argument peut introduire plusieurs référents de discours; c’est le
cas pour une formule, les variables et connecteurs logiques composant une formule donneront
autant d’individus dans l’univers de discours. Par exemple, une commande goal f va produire
un individu g ⊆ Goal qui sera relié par le rôle has-formula à la traduction de f .
3.2 Sélection

Le sous-module de sélection est le coeur de ContDet : c’est durant cette phase que les choix
les plus importants s’effectuent : décider de ce qui va être inclus dans le message et de ce qu’on
ne va pas dire, garantir que le message est assez informatif, mais pas trop et ne pas perdre la
structure générale de la preuve qui nous servira par la suite.
Le module de sélection construit un univers de discours de manière incrémentale, le processus
commence par un univers de discours vide, on y ajoute au fur et à mesure les segments fournis
par le module de traduction. Quand un segment est ajouté à , plusieurs procédures sont
exécutées :
Détermination de contenu dans G E P HOX
• on identiﬁe dans le segment courant C , les individus déjà présents dans . Pour un tel
individu a, on efface l’occurrence de a dans C et on reporte les relations auxquelles il
participait dans C vers l’occurrence de a dans , les dites relations passeront de Rint à
Rext dans C .
• pour les individus correspondant aux commandes dans struct, vériﬁer s’ils peuvent se
combiner avec un ou plusieurs autres individus de même nature dans les segments précé-
dents pour produire une tactique plus complexe. On identiﬁe, par exemple, un raison-
nement par cas en uniﬁant avec l’expression conceptuelle qui lui correspond dans la base
de connaissances (qui contient des concepts décrivant les différents cas et leurs preuves)
avec les concepts correspondant à un ensemble d’individus dans le volet struct réalisant
un raisonnement par cas. On utilise pour cela l’uniﬁcation entre les concepts correspon-
dant aux tactiques de haut niveau avec les concepts des individus correspondants aux
commandes. Lorsque l’uniﬁcation est possible, les segments en question et C seront✁
fusionnés en un seul segment.
• pour tous les individus modiﬁés dans l’univers (les individus de C et ceux qui en ont été
effacés), on recalcule les concepts aux quels ils appartiennent et qui, dans certains cas,
sont plus spéciﬁques du fait des nouvelles relations. Cela revient à calculer le concept le
plus spéciﬁque de l’individu (on utilise test d’instance et subsomption).
• on identiﬁe les nouveaux individus représentants et on marque comme caché les éléments
de leur ensemble, les individus cachés ne seront pas présents dans le message ﬁnal. Quand
un individu représentant perd son statut, à cause de la présence dans le segment courant
d’un élément de son ensemble, ce dernier devient visible.
3.3 Instanciation et vériﬁcation

La phase de sélection produit un univers de discours qui est exprimé dans la DKB. Pour que
ce message donne un texte compréhensible par l’utilisateur, on va le projeter dans la UKB,
autrement dit, pour tout concept présent dans l’univers et n’appartenant pas à sa UKB, on en
calcule la projection dans la UKB. L’instanciation est en quelque sorte une mise au niveau
de l’utilisateur du message. La raison principale pour laquelle la sélection n’est pas faite en
utilisant directement la UKB est qu’il est parfois nécessaire d’expliquer certaines parties de la
preuve à un utilisateur qui n’aurait pas assez de connaissances pour les comprendre, alors que
le système en dispose. Ce choix a été fait dans l’optique d’utiliser P HOX couplé à G E P HOX
pour l’enseignement des mathématiques (Raffalli & David, 2002).
Pour ﬁnir, on vériﬁe la consistance de la base de connaissances composé de la UKB et la A-Box
correspondant à l’univers de discours. Ceci garantit que le message donnera un texte cohérent
par rapport aux connaissances de l’utilisateur.
Conclusion
Dans cet article nous avons décrit une méthode de détermination de contenu, basée sur
l’exploitation des propriétés des bases de connaissances décrivant le domaine mathématique et
les connaissances qu’en a le destinataire du texte. Cet algorithme sépare deux types d’inférences
mises en oeuvre dans la détermination de contenu : la première correspond au déroulement
Adil El Ghali
de cette tâche i.e. comment on combine les données en entrée du système pour construire
un message cohérent, la deuxième, qui exploite les bases de connaissances du système et les
mécanismes de raisonnement offerts par celles-ci, garantit à notre message les propriétés de
minimalité, de qualité et de ﬁdélité à l’entrée tout en étant au niveau de l’utilisateur
Remerciements
Merci à Laurence Danlos, Michel Parigot et Paul Rozière pour leur patience et leurs remarques.
Références
BAADER F., K USTERS R. & M OLITOR R. (2000). Rewriting Concepts Using Terminologies – Revisited.
Rapport interne 00-04, Germany.
F. BAADER , D. L. M C G UINNESS , D. NARDI & P. F. PATEL -S CHNEIDER, Eds. (2003). Description
Logics Handbook: Theory, Implementation and Applications. Cambridge University Press.
BAADER F. & NARENDRAN P. (2001). Uniﬁcation of concept terms in description logics. Journal of
Symbolic Computation 31(3), p. 277–305.
C OSCOY Y. (2000). Explication textuelles de preuves pour le calcul des constructions inductives. Thèse
d’université, Université de Nice-Sophia-Antipolis.
D ONINI F., L ENZERINI M., NARDI D. & S CHAERF A. (1996). Reasoning in description logics. In G.
B REWKA, Ed., Principles of Knowledge Representation and Reasoning, Studies in Logic, Language and
Information, p. 193–238. CLSI Publications.
E L G HALI A. & ROUSSARIE L. (2003). Computing the rhetoric of text proofs. In Proceeding of ICoS-4,
Nancy, France.
F IEDLER A. (2001a). P.rex: An interactive proof explainer. In Proceedings of the 1st International Joint
Conference on Automated Reasoning (IJCAR’01).
F IEDLER A. (2001b). User-adaptive proof explanation. PhD thesis, Naturwissenschaftlich-Technische
Fakultät I, Universität des Saarlandes, Saarbrücken, Germany.
H ALLGREN T. & R ANTA A. (2000). An extensible proof text editor. In In Logic for Programming and
Automated Reasoning (LPAR’2000),, volume LNCS/LNAI 1955, p. 70–84: Springer Verlag,.
H ORROCKS I. (2002). Reasoning with expressive description logics: Theory and practice. In A.
VORONKOV , Ed., Proceedings of the 18th International Conference on Automated Deduction.
K RIVINE J.-L. (1997). Lambda-calcul, types et modèles. Dunod.
R AFFALLI C. (2002). User’s manual of the PhoX library. LAMA, Université de Savoie.
R AFFALLI C. & DAVID R. (2002). Apprentissage du raisonnement assité par ordinateur. Quadrature
45, p. 25–36.
R AFFALLI C. & ROZIERE P. (2002). The PhoX Proof checker documentation. LAMA, Université de
Savoie / Université Paris 7.
R EITER E. & DALE R. (2000). Buiding Natural Language Generation Systems. Studies in Natural
Language Processing. Cambridge University Press.
S RIPADA S., R EITER E., H UNTER J. & Y U J. (2001). A two-stage model for content determination. In
Proceedings of ENLGW-2001, p. 3–10.
