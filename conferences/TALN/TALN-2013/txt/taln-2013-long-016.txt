
Traitements d’ellipses : deux approches par les grammaires
catégorielles abstraites

Pierre Bourreau1 ∗
(1) SFB 991
Institut für Sprache und Information
Université Heinrich-Heine, 40225 Düsseldorf
RÉSUMÉ
L’étude de phénomènes d’ellipses dans les modèles de l’interface syntaxe-sémantique pose
certains problèmes du fait que le matériel linguistique effacé au niveau phonologique est
néanmoins présent au niveau sémantique. Tel est le cas d’une ellipse verbale ou d’une élision
du sujet, par exemple, phénomènes qui interviennent lorsque deux phrases reliées par une
conjonction partagent le même verbe, ou le même sujet. Nous proposons un traitement de
ces phénomènes dans le formalisme des grammaires catégorielles abstraites selon un patron
que nous intitulons extraction/instanciation et que nous implémentons de deux manières
différentes dans les ACGs.
ABSTRACT
Treating ellipsis : two abstract categorial grammar perspectives
The treatment of ellipsis in models of the syntax-semantics interface is troublesome as
the linguistic material removed in the phonologic interpretation is still necessary in the
semantics. Examples are particular cases of coordination, especially the ones involving verbal
phrase ellipsis or subject elision. We show a way to use abstract categorial grammars so as to
implement a pattern we call extraction/instantiation in order to deal with some of these
phenomena ; we exhibit two different constructions of this principle into ACGs.

MOTS-CLÉS : ellipse, coordination, interface syntaxe-sémantique, grammaires catégorielles
abstraites, grammaires d’arbres adjoints, grammaires IO d’arbres.
KEYWORDS: ellipsis, coordination, syntax-semantics interface, abstract categorial grammars,
tree-adjoining grammars, IO tree-grammars.
∗. Ce travail a été financé par la DFG, dans le cadre du projet SFB 991 “Die Struktur von Repräsentationen in
Sprache, Kognition und Wissenschaft”.

1     Introduction

La description de la syntaxe du langage naturel par le biais de formalismes symboliques a
donné lieu à la création de nombreux modèles tels que les grammaires non-contextuelles,
comme première approximation, et plus récemment les grammaires catégorielles combina-
toires (CCGs pour combinatory categorial grammars) (Steedman, 1987) ou les grammaires
d’arbres adjoints (Joshi et al., 1975; Joshi, 1985) (TAGs pour tree-adjoining grammars).
Tous ces formalismes partagent la propriété de ne pas effacer, et de ne pas copier de ma-
tériel syntaxique ou phonologique : nous parlerons de propriété de linéarité. Cependant,
certains phénomènes syntaxiques usuels semblent nécessiter des mécanismes de copie et/ou
d’effacement :
(1) Marie mange une pizza, et Pierre ε des pâtes.
(2) Jean fait un footing et ε rattrape Marie.
(3) Jean prépare ε et Marie vend des crêpes.
Sur les exemples ci-dessus, des éléments phonologiques sont absents par économie de lan-
gage : le verbe “mange” en (1), et les syntagmes “Jean” en (2) et “des crêpes” en (3). Tous
ces éléments sont néanmoins présents au niveau de l’arbre syntaxique (pour la correction
grammaticale) ou de la sémantique. Par ailleurs, ces trois exemples partagent la présence de
la conjonction de coordination “et” reliant deux phrases. Nous nous intéressons au traitement
de ces phénomènes d’ellipse sous la présence de marqueurs de coordination.
Plusieurs solutions à ce problème ont été proposées afin d’étendre les formalismes grammati-
caux cités ci-dessus. Ainsi, (Steedman, 1990) montre comment traiter de telles coordinations
dans les CCGs ; ces idées ont ensuite été implémentées par (Sarkar et Joshi, 1996) dans les
TAGs, en étendant le formalisme initial afin d’enrichir les arbres de dérivation par une notion
de partage de noeuds, idée ensuite reprise dans (Seddah, 2008; Seddah et al., 2010). Enfin,
(Kobele, 2007) propose l’utilisation de grammaires non-contextuelles d’arbres avec copie IO
(notées IO-CFTGs pour IO context-free tree grammars).
Nous proposons d’utiliser un formalisme plus expressif que les précédents, à savoir les
grammaires catégorielles abstraites (ACGs pour abstract categorial grammars) (de Groote,
2001; Muskens, 2001). Il est en effet possible d’encoder des grammaires de chaînes ou des
grammaires d’arbres dans les ACGs. Qui plus est, la notion de dérivation y est également
relativement flexible puisqu’il est possible de considérer non seulement des arbres mais aussi
des λ-termes comme structures de dérivation. En utilisant ces avantages, nous implémentons
le principe suivant : une phrase où une ellipse intervient est d’abord partiellement construite,
en omettant le constituant commun, qui est rajouté lors de l’étape suivante. Ce principe peut
être naturellement réalisé dans le λ-calcul par le biais de la substitution de termes. En suivant
ce principe, nous présentons deux méthodes, la première faisant intervenir la substitution au
niveau des structures de dérivation (ou tectogrammaire), la seconde au niveau de la syntaxe
(ou phénogrammaire). Nous discutons des avantages de chacune des deux méthodes, et
en particulier de l’existence d’algorithmes d’analyse s’exécutant en temps polynomial pour
chacune d’elles.
Le reste de cet article est structuré comme suit : en section 2, nous présentons les ACGs. En
section 3, les deux approches que nous proposons seront détaillées et discutées. Enfin, en
section 4, nous comparerons notre solution à celles existantes dans la littérature.

2      Grammaires Catégorielles Abstraites

Les grammaires catégorielles abstraites peuvent être vues comme des grammaires de λ-
termes simplement typés. Étant donné un ensemble de types atomiques � , nous définissons
l’ensemble � (� ) des types simples sur � par

� (� ) ::= � |(� (� ) → � (� ))

Nous adopterons la notation usuelle permettant d’omettre certaines parenthèses : un type
(α1 → (α2 → α3 )) sera noté α1 → α2 → α3 .
Une signature d’ordre supérieur est un tuple Σ = (� , C, τ) où :
– � est un ensemble fini de types atomiques.
– C est un ensemble fini de constantes.
– τ est une fonction d’assignation de types de C dans � (� ).
Afin de construire des termes sur une telle signature, nous nous donnons un ensemble de
variables typées : la notation x α désignera une variable x de type α. Étant donnés une
signature Σ = (� , C, τ) et un type α ∈ � (� ), l’ensemble Λα (Σ) des λ-termes de type α
dans Σ se définit par induction :
1. une variable x α appartient à Λα (Σ).
2. une constante c de C appartient à Λα (Σ) si τ(c) = α.
3. si M est un terme de Λα2 (Σ) et si α = α1 → α2 , alors λx α1 .M est un terme de Λα (Σ).
4. si M1 appartient à Λβ (Σ) et M2 à Λβ→α (Σ), alors (M1 M2 ) appartient à Λα (Σ).
L’ensemble des termes simplement typés de Σ est donné par Λ(Σ) = (Λα (Σ))α∈� (� ) . Nous
adopterons la convention usuelle suivante : un terme (. . . ((M1 M2 )M3 ) . . . Mn ) sera écrit
M1 M2 M3 . . . Mn . De plus, nous omettrons d’écrire les types des variables lorsqu’ils ne sont pas
indispensables à la compréhension. Nous supposerons que les notions de variables libres et de
β-réduction sont connues ; nous noterons F V (M ) l’ensemble des variables libres d’un terme
M ; M1 →∗β M2 la β-réduction d’un terme M1 en M2 en un nombre arbitraire de β-contractions,
et |M |β la forme β-normale d’un terme simplement typé. Pour plus de détails sur le λ-calcul
simplement typé, le lecteur peut se référer à (Hindley, 1997).
L’ensemble Lin α (Σ) des termes linéaires de type α dans Σ est défini par induction sur les
règles 1. et 2. ci-dessus (en remplaçant Λα (Σ) par Lin α (Σ)) et :
3’. si M est un terme de Lin α2 (Σ), si α = α1 → α2 et si x α1 ∈ F V (M ), alors λx α1 .M est un
terme de Lin α (Σ).
4’. si M1 appartient à Lin β (Σ), M2 à Lin β→α (Σ) et que F V (M1 )∩ F V (M2 ) = �, alors (M1 M2 )
appartient à Lin α (Σ).
L’ensemble QAff α (Σ) des termes quasi-affines de type α dans Σ est construit par induction
sur les règles 1., 2., 3. et la règle suivante :
4”. si M1 appartient à QAff β (Σ), M2 à QAff β→α (Σ) et que pour toute variable x β ∈ F V (M1 )∩
F V (M2 ), β ∈ � , alors (M1 M2 ) appartient à QAff α (Σ).
L’ordre    (α) d’un type α se définit par induction sur α : si α ∈ � alors       (α) = 1 ; sinon,
α = α1 → α2 et      (α) = ma x(     (α1 ) + 1,    (α2 )). Par extension, l’ordre d’une signature
Σ = (� , C, τ) se définit comme :      (Σ) = ma x c∈C (     (τ(c))).
Remarquons qu’il est possible de voir une signature d’arbre comme une signature d’ordre
2 : dans une telle signature, tout terme M de type atomique et tel que F V (M ) = � peut
effectivement être interprété comme un arbre. Par exemple, l’arbre f (a, b, g(c)) peut être
représenté par le terme f o→o→o→o a o b o (g o→o c o ), où o est un type atomique. De plus, si toutes
les constantes d’une signature d’ordre 2 sont de type o → o (où o est un type atomique), les
termes de la signature peuvent être interprétés comme des chaînes : la chaîne “Jean mange
une pomme” est ainsi représentée par le terme λx o .Jean(mange(une(pomme x))).
Étant données deux signatures Σ1 = (�1 , C1 , τ1 ) et Σ2 = (�2 , C2 , τ2 ), un morphisme � de
Σ1 vers Σ2 est défini à partir d’un couple de fonctions [�1 ; �2 ] vérifiant :
– étant donné un type α ∈ � (�1 ) :
– � (α) = �2 (α) ∈ � (�2 ) si α appartient à �1 .
– � (α) = � (α1 ) → � (α2 ) si α = α1 → α2 .
– étant donné un terme M de Λ(Σ1 ) :
– si M = x α , � (M ) = x � (α) ;
– si M = c ∈ C1 et τ1 (c) = α, � (M ) ∈ Λ� (α) (Σ2 ) ;
– si M = λx α .N , � (M ) = λ� (x α ).� (N ).
– si M = M1 M2 , alors � (M ) = � (M1 )� (M2 ).
Finalement, une ACG G est définie comme un tuple (Σ1 , Σ2 , � , s) où Σ1 et Σ2 sont deux
signatures d’ordre supérieur (appelées respectivement signature abstraite et objet de G), �
est un morphisme de Σ1 vers Σ2 , et s est un type atomique de Σ1 . Une telle grammaire définit
deux langages : un langage abstrait A(G) = {M ∈ Lin s (Σ1 ) | F V (M ) = �} ; un langage objet
O(G) = {M ∈ Λ(Σ2 ) | ∃N ∈ A(G), |� (N )|β = M }. De manière informelle, le langage abstrait
correspond à l’ensemble des dérivations du langage O(G) généré par la grammaire.
Une ACG G est d’ordre n ∈ � si la signature abstraite de G est d’ordre n (nous écrirons que
G est une n-ACG) ; de plus, une n-ACG est dite linéaire (resp. quasi-affine) si pour toute
constante c de la signature abstraite de G, � (c) est un terme linéaire (resp. quasi-affine).
ΣDERIV

ΣSYN                                ΣSEM

ΣSURF
FIGURE 1 – Exemple de modélisation de l’interface syntaxe-sémantique par des ACGs
Grâce au pouvoir expressif du λ-calcul, (de Groote, 2002) et (de Groote et Pogodalla, 2004)
ont montré qu’il est possible d’encoder de nombreux formalismes grammaticaux, dont les TAGs,
comme des 2-ACG linéaires. Par ailleurs, lorsqu’on adopte l’hypothèse de compositionnalité,
il est possible de représenter l’interface syntaxe-sémantique par l’intermédiaire de deux
ACGs G1 = (ΣDERIV , ΣSYN , �SYN , s) et G2 = (ΣDERIV , ΣSEM , �SEM , s) (voire (de Groote, 2001;
Pogodalla, 2004, 2007) pour plus de détails). Un des avantages de ce modèle est donc de
représenter syntaxique et sémantique en parallèle, tout en traitant certains problèmes à des
niveaux différents (par exemple, l’ordonnancement des mots peut être traité au niveau de la
syntaxe, voire de la réalisation de surface, et non pas au niveau des dérivations). De plus, il
est facile d’isoler les différentes représentations d’une phrase, tel que montré sur la figure 1.

3     Extraction et instanciation

Comme énoncé en introduction, nous souhaitons séparer la construction de phrases avec
ellipses en deux étapes : la première consiste à construire une représentation incomplète ;
la seconde à instancier cette représentation à l’aide de l’élément partagé. Au niveau de
la représentation de surface seule une de ces occurrences sera réalisée. Ainsi, pour la
phrase “Jean mange une pizza et Pierre, des pâtes”, nous pouvons considérer que nous
avons deux constituants incomplets, “Jean ε une pizza” et “Pierre ε des pâtes” qui sont re-
liés par la conjonction “et”. Le verbe “mange” est ensuite rajouté à chacun de ces deux
constituants, bien que non-réalisé phonétiquement pour le second. Le fait de garder une
copie du constituant commun est nécessaire dans les ACGs puisque les dérivations des re-
présentations syntaxiques et sémantiques sont symétriques, et qu’une copie de la forme
sémantique du constituant commun est nécessaire, comme illustré dans la formule logique
(∃x.Pizza(x) ∧ Mange(x, Jean) ∧ (∃ y.PlatPates( y) ∧ Mange( y, Pierre)) représentant la sé-
mantique de la phrase ci-dessus. La modélisation du principe extraction/instanciation est
réalisée de manière relativement naturel dans le λ-calcul simplement typé. En effet, un objet
incomplet peut être représenté par un terme de la forme λx.M , où x est une variable dont les
occurrences libres dans M représentent des emplacements vides de l’objet M . L’instanciation
de ces emplacements par un objet N est ensuite simplement réalisée par application dans le
λ-calcul et le terme (λx.M )N est donc l’objet M où les occurrences (libres) de x (dans M )
sont substitués par N .
3.1     Enrichir les structures dérivationelles

Dans ce premier modèle, nous montrons comment la construction de constituants incomplets
peut se réaliser au niveau de la signature des dérivations. Cette approche nous amène à écrire
des ACGs dont l’ordre est supérieur à 2 ; en effet, à une phrase à laquelle il manque un verbe
transitif sera associée une dérivation de la forme λx.M , de type (np → np → s) → s ; la
conjonction de deux phrases incomplètes implique de prendre deux termes de ce type en
argument, et donc de manipuler des constantes d’ordre 4.
En guise d’exemple, nous considérons la grammaire suivante GSURF = (ΣDERIV , ΣSURF , �SURF , s),
afin d’illustrer
 la modélisation d’ellipses verbales :
�DERIV = {np, s}
– ΣDERIV = cJean , cLuc , cPierre , cMohamed : np caime : np → np → s
c         :α→α→α                   (où α = (np → np → s) → s)
� et−TVel
– ΣSURF = �SURF = {σ} Jean, Luc, Pierre, Mohamed, aime, et : σ → σ
 np, s := σ → σ (noté σ2 )
cJean := λx .Jeanx
cLuc := λx σ .Lucx
– �SURF = cMohamed := λx σ .Mohamedx                       cPierre := λx σ .Pierrex
                 2    2
 caime := λP Q x .Q(aime(P x))
σ    σ   σ
c                  β→σ2 β→σ2 β σ                     2  2
et−TVel := λP        Q      R x .PR(et(Q(λS1σ S2σ y σ .S2 (S1 y))x))
(où β désigne le type σ2 → σ2 → σ2 )
Le terme MDERIV = cet−TVel (λP np→np→s .P cLuc cJean )(λP np→np→s .P cMohamed cPierre )caime appar-
tient à Λs (ΣDERIV ). De plus, il est possible de vérifier que �SURF (MDERIV ) se β-réduit en
λx.Jean(aime(Luc(et(Pierre(Mohamedx))))). L’ACG ainsi obtenue est une 4-ACG linéaire.
Cette construction peut s’étendre à d’autres types d’ellipses, tels que les ellipses du sujet ou
de l’objet : il suffit alors de rajouter des constantes cet−Sel et cet−Oel de type (np → s) → (np →
s) → np → s dans ΣDERIV . Comme alternative, nous pouvons envisager la généralisation de
cette constante à un type X → X → X tel que proposer dans (Steedman, 1990).
Afin de construire la représentation sémantique de cet exemple, il nous suffit de créer une
 GSEM = (ΣDERIV , ΣSEM , �SEM , s) comme suit :
seconde ACG
�SEM = {e, t}
– ΣSEM = J, L, P, M : e      A:e→e→t
∧:t →t →t
 np := (e → t) → t (noté γ)                                 s := t
 c
 Jean  := λP e→t
.PJ                                        cLuc := λP e→t .PL
e→t
– �SEM = cMohamed := λP .PM                                            cPierre := λP e→t .PP
                                    e      e
 caime := λP (e→t)→t
Q (e→t)→t
.P(λx .Q(λ y .Ax y)
c              (γ→γ→t)→t (γ→γ→t)→t γ→γ→t
:= λP
et−TVel       1       P    2      R      . ∧ (P R)(P R)
1     2
Cette construction nous permet d’obtenir une 4-ACG (ΣDERIV , ΣSEM , �SEM , s). Nous remarque-
rons, néanmoins, que cette dernière n’est ni linéaire, ni quasi-affine : en effet, la variable R a
deux occurrences libres dans un sous-terme de �SEM (cet−TVel ).
Commentaires :
Les deux ACGs ainsi construites sont donc des n-ACGs où n > 2 ; ceci soulève un des inconvé-
nients de cette méthode, puisque nous savons que, dans ce cas, le problème de l’appartenance
est un problème NP-complet (Kanazawa et Yoshinaka, 2005a), lorsque l’ACG est linéaire.
Du point de vue de la modélisation linguistique, notons qu’il est possible de traiter des
cas d’ellipses multiples d’un même constituant sans modifier notre modèle. Ainsi, afin de
pouvoir dériver la phrase : “Jean aime Luc, Pierre, Mohamed et Paul, Valérie.”, nous rajoutons
la constante c,TV−el de type α → α → α (où α = (np → np → s) → s) à ΣDERIV et telle
2     2                  2  2
que �SURF (c,Tv−el ) = λP β→σ Qβ→σ Rβ x σ .PR(,(Q(λS1σ S2σ y σ .S2 (S1 y))x)) (en considérant
les notations de types ci-dessus). Il est intéressant de remarquer que nous obtenons alors
deux termes M1 et M2 dans Λs (ΣDERIV ) tels que |�SURF (M1 )|β et |�SURF (M2 )|β sont égaux à
λx.Jean(aime(Luc(,(Pierre(Mohamed(et(Paul(Valériex)))))))). Ces deux termes sont :
1. M1 = c,TV−el (λP.P cLuc cJean )(λQ.cet−TVel (λR.RcMohamed cPierre )(λR.RcValerie cPaul )Q)caime cor-
respondant à la dérivation de la phrase pour le parenthésage “[Jean aime Luc, [Pierre,
Mohamed et Paul, Valérie]]” ;
2. M2 = cet−TVel (λQ.c,TV−el (λP.P cLuc cJean )(λP.P cMohamed cPierre )Q)(λR.RcValerie cPaul )caime cor-
respondant à la dérivation de notre exemple pour le parenthésage “[[Jean aime Luc,
Pierre, Mohamed] et Paul, Valérie]” ;
Par ailleurs, remarquons que le verbe n’est réalisé au niveau de la surface que dans le premier
constituant gauche dominé par la coordination ; dans le second cas, il est remonté jusqu’au
constituant correct de manière transitive. La grammaire reste alors une 4-ACG linéaire.
Cette construction peut s’étendre à l’analyse de phénomènes d’ellipses enchâssées comme
dans la phrase suivante en Anglais :
(4) After seeing John running a marathon, Paul planned to ε1 , but Mary didn’t ε2 .
Après avoir vu John courir un marathon, Paul a prévu de le faire, mais pas Marie.
En simplifiant quelque peu la dérivation syntaxique, cette phrase est traitée dans notre
modèle par l’intermédiaire d’un terme cafter M1 (λP.cbut M1� M2� (cplanned−to P))crun ; le morphisme
est ensuite construit en suivant l’exemple précédent.
Il est important de remarquer la similitude entre cette construction et certains travaux
antérieurs sur les ACGs. En effet, cette méthode repose sur le fait de retarder la concaténation
de chaînes, de la même manière que (Pogodalla, 2007) utilise des ACGs d’ordre supérieur au
niveau des dérivations afin de retarder l’ajout de matériel linguistique, permettant ainsi de
modéliser les différentes portées des quantificateurs dans la représentation sémantique.
Remarquons enfin, que nous avons modélisé la réalisation de surface sans décrire la réalisation
de l’arbre syntaxique ; cette construction ne nous apporte effectivement aucune information
supplémentaire sur l’analyse de cette première modélisation.
Par ces divers exemples, nous montrons qu’il est possible de modéliser divers phénomènes
d’ellipses de manière simple et élégante dans les ACGs, sans modifier le formalisme. Notre
construction repose uniquement sur le fait de considérer des termes d’ordre supérieur au ni-
veau des dérivations. Néanmoins, l’inconvénient d’une telle construction est que le traitement
de ces phénomènes ne peut plus être réalisé en temps polynomial. Nous montrons à présent
qu’une solution possible à ce problème consiste à considérer des ACGs d’ordre 2, et à enrichir
le typage de la signature des dérivations, plutôt que la structure des termes.
3.2     Enrichir les types des dérivations

Dans cette seconde approche, nous construisons des modèles de représentation de la structure
de surface à partir des structures de dérivation de manière indirecte, par l’intermédiaire des
structures syntaxiques arborescentes. Ceci nous permettra, en particulier, de mettre en avant
la complexité des morphismes utilisés, cette propriété ayant un impact sur la complexité de
l’analyse dans les ACGs 1 .
Pour ce faire, nous introduisons un opérateur DEL d’effacement au niveau des arbres syn-
taxiques, à la manière de (Kobele, 2007) ou de l’opérateur de “deanchoring” sur les structures
de dérivation dans (Lichte et Kallmeyer, 2010). Dans notre cas, un sous-arbre dominé par cet
opérateur sera interprété comme la chaîne vide ε au niveau de la représentation de surface.
Cet opérateur n’est donc pas indispensable à notre modèle, mais nous permet néanmoins de
faire apparaître l’élément effacé dans l’arbre syntaxique.
Nous donnons un exemple d’un tel arbre en Figure 2, dérivé par la grammaire GSURF =
(ΣSYN , ΣSURF , �SURF , o) définie par :
1. Nous aurions pu procéder de la même manière à l’étape précédente, mais les ACGs étant alors d’ordre 3,
l’analyse n’est, a priori, déjà plus réalisable en temps polynomial
S
S                        Coord                   S
NP              VP                 ET            NP              VP
JEAN       TV              NP                   PIERRE DEL                  NP
MANGE       Det        N                           TV        Det        N
UNE     PIZZA                         MANGE       DES    PÂTES
FIGURE 2 – Arbre dérivé pour la phrase “Jean mange une pizza et Pierre, des pâtes.”

�SYN = {o}
– ΣSYN = SConj : o → o → o → o         NP1 , N , Det, Coord, TV, DEL : o → o
S, N P2 , V P : o → o → o JEAN, MANGE, PIERRE, UNE, DES, PIZZA, PÂTES, ET : o
– ΣSURF = �SURF = {σ} Jean, mange, une, des, pizza, pâtes, et : σ → σ
 o := σ → σ
 S Conj := λP1     P2    P3
σ→σ σ→σ σ→σ σ
x .P1 (P2 (P3 x))
S, NP2 , VP := λP1      P2
σ→σ σ→σ σ
x .P1 (P2 x)
– �SURF = N , NP1 , Det, Coord, TV := λP σ→σ x σ .P x            DEL : λP σ→σ x σ .x
 JEAN := λx σ .Jeanx, PIERRE := λx σ .Pierrex MANGE := λx σ .mangex
 UNE := λx σ .unex, DES := λx σ .desx                 PIZZA := λx σ .pizzax
PÂTES := λx σ .pâtesx                                ET := λx σ .etx

Nous remarquerons que l’opérateur DEL réalise l’effacement au niveau de la chaîne de carac-
tères ; en effet, l’image de ce terme par le morphisme �SURF est un terme quasi-affine, effaçant
sur son premier argument. Ainsi, pour tout terme M , nous avons �SURF (DELM )→∗β λx.x.
Nous pouvons alors vérifier que le terme MSY N correspondant à l’arbre de la figure 2 véri-
fie �SURF (MSY N )→∗β λx.Jean(mange(une(pizza(et(Pierre(des(pâtesx))))))) 2 . Par ailleurs,
l’ACG ainsi présentée n’est pas lexicalisée : l’image de certaines constantes de ΣSYN par �SURF
ne contient pas de constantes. Néanmoins, nous savons qu’il est possible de construire une
2-ACG lexicalisée générant le même langage (Kanazawa et Yoshinaka, 2005b).
Nous décrivons à présent, une seconde implémentation du principe d’extraction/instanciation,
en créant de nouveaux types dans la signature des dérivations : le fait qu’un constituant
d’une certaine catégorie syntaxique soit incomplet pour une autre catégorie syntaxique sera
effectivement dénoté par un type distinct.
En reprenant l’exemple de la figure 2, nous souhaitons donc pouvoir dériver un terme de
la forme λx o .M1 et un terme λx o .M2 représentant chacun les contextes d’arbre pour “Jean
x une pizza” et pour “Pierre x des pâtes”, sachant que pour ce dernier, l’occurrence de x
est dominée par une occurrence de l’opérateur DEL. Nous créons donc un type (noté sTVel )
pour désigner les contextes d’arbre sur un verbe transitif, au niveau des dérivations. De plus,
2. Il est possible de lexicaliser �SURF (DEL), en λP x., x par exemple, de manière à faire apparaître le signe de
ponctuation “,”.
�SYN (sTVel ) = o → o, afin de rendre compte du fait que la dérivation d’un terme de type sTVel
est un contexte d’arbre, tel que nous le codons dans le λ-calcul.
Une constante cet est ensuite nécessaire à ΣDERIV afin de réaliser l’étape d’instanciation, mais
cette fois au niveau des termes des arbres syntaxiques ; il suffit donc de typer cette constante
par sTVel → sTVel → t v → s, un type d’ordre 2. On notera que pour ce faire, nous modifions le
type associé aux verbes transitifs de np → np → s en t v. Intuitivement, ceci revient à associer
à un verbe le plus grand sous-arbre dont l’unique racine est la réalisation phonologique
associée au verbe.
Afin d’illustrer notre proposition, nous donnons la grammaire GSYN = (ΣDERIV , ΣSYN , �SYN , s)
définie ci-dessous. Afin de mieux dissocier les deux étapes de notre méthode, nous isolons
l’étape d’instanciation par l’intermédiaire d’une constante distincte, cSUB , le type de la variable
cet s’en trouvant alors modifié :
  �           = {s, sTVel , v pTVel , n, np, v}
 DERI V
  cet : sTVel → sTVel → s T Vel                 cSUB : sTVel → t v → s
c1 : np → vpTVel → sTVel                      c2 : np → v pTVel
– ΣDERIV =
c3 : n → det → np
  c ,c           : np                           cmange : t v
 Jean Pierre
cune , cdes : det                             cpizza , cpates : n
 s, t v, n, np, det := o                                             sTVel , v pTVel := o → o
                 o→o   o
 cSUB := λP          x .P x
 c
 et  :=   λP   o→o o→o o
P      x .S(P1 x)(Coord ET)(P2 (DELx))
1     2
o o→o o
c1 := λt P          x .S t(P x)                                     c2 := λt o x o .VPx t
– �SYN =                  o o
 c3 := λt 1 t 2 .NP2 t 2 t 1
cJean := NP1 JEAN, cPierre := NP1 PIERRE
                                                                     cmange : V MANGE
 c
 une   :=   Det  UNE , cdes  :=  Det   DES
c
pizza : N PIZZA , cpates : N PÂTES

En considérant la signature abstraite ΣDERIV , nous obtenons un terme Mderiv appartenant au
langage abstrait et tel que Mderiv = cSUB M1 M2 où
1. M1 = cet (c1 cJean (c2 (c3 cune cpizza )))(c1 cPierre (c2 (c3 cdes cpates ))) et
2. M2 = cmange .
Nous remarquerons que �SYN (M1 ) s’interprète alors comme un contexte d’arbre, de la forme
λx o .T , T étant l’arbre de la figure 2 où les occurrences du sous-arbre V MANGE sont remplacées
par x.
Commentaires
Tout d’abord, remarquons que l’ACG G = (ΣDERIV , ΣSYN , �SYN , s) est une 2-ACG quasi-affine.
D’après (Bourreau et Salvati, 2011; Bourreau, 2011) ou (Kanazawa, 2007; Yoshinaka, 2006),
nous savons que le problème de l’analyse, dans ce cas, peut être résolu en temps polynomial.
Ce point différencie donc les deux approches présentées. Ensuite, nous remarquerons qu’il est
à nouveau possible de généraliser le type associé à la conjonction cet au niveau des dérivations
en α → α → α, avec, α ∈ �DERIV .
Néanmoins, comme nous l’avons remarqué, l’ACG (ΣSYN , ΣSURF , �SURF , o) n’est pas lexicalisée.
Le fait de considérer l’ACG lexicalisée équivalente (Σ�SYN , ΣSURF , �SURF�
, o) de (Kanazawa
et Yoshinaka, 2005b) peut a priori avoir un certain impact sur la construction de l’ACG
(ΣDERIV , Σ�SYN , �SYN
, s), cette question demandant à être étudiée plus en détails.
Par ailleurs, le choix d’introduire l’opérateur DEL n’est destiné qu’à faire apparaître l’occur-
rence de constituant effacée dans l’arbre syntaxique. En effet, il est possible de modifier
notre modèle de sorte que �SYN (cet ) = λP1o→o P2o→o x o .S(P1 x)(C on j ET)(P2 ε), où ε est alors
une constante de ΣSYN , de type o et telle que �SURF (ε) = λx σ .x σ . Dans cette proposition
alternative, l’ACG obtenue reste une 2-ACG linéaire.
La gestion de l’effacement par enrichissement des types peut également s’étendre à l’analyse
de phénomènes d’ellipses enchâssées comme dans la phrase (4) de la section précédente.
Un tel cas peut-être traité dans notre proposition en rajoutant une étape supplémentaire
d’extraction/instanciation, par l’intermédiaire d’une constante cSUB de type sV → v pVPinf → sV ,
�         o→o o→o o
et telle que �SYN (cSUB ) = λP1 P2 t .P1 (P2 t). L’utilisation d’une telle constante réalise
alors l’instanciation d’emplacements vides dans un arbre de type sV par un contexte d’arbre
de type vpVPinf . La dérivation de cet exemple est donc réalisée en construisant d’abord deux
contextes d’arbre : Le terme �SYN (cSUB  ) permet alors de substituer les occurrences de x dans
S                                      VP
S      Coord         S                       V       y :VPinf

NP         x :VP but NP         VP             planned to

Paul                 Mary Neg         DEL
V         not x :VP

does

FIGURE 3 – Représentation de la dérivation pour “John planned to but Mary does not”
le premier arbre par le second ; il suffit ensuite de suivre la procédure sur notre exemple
initiale pour obtenir l’arbre souhaité. Nous pouvons alors voir que l’inconvénient principal de
cette méthode est de devoir créer de nombreux types afin de prendre en compte les différents
cas d’ellipses possibles, selon le constituant effacé. Notons également qu’il est possible de
construire la sémantique associée à une phrase où une ellipse a été réalisée, de manière
similaire à la construction précédente. Finalement, il apparaît que les deux constructions
présentées sont liées : notre deuxième proposition repose sur le fait de décomposer les arbres
syntaxiques en unité plus petite, ce qui aboutit à considérer une ACG non-lexicalisée, et à
considérer un nombre de types plus grand. Cependant, il nous faudra étudier ce lien, et la
possibilité d’abaisser l’ordre d’une ACG tout en préservant le langage généré.

4     Méthodes existantes

Une première possibilité de traitement de certains phénomènes d’ellipse consiste à reprendre
les idées de (Steedman, 1990) pour les grammaires catégorielles combinatoires, et à implémen-
ter ces idées dans les ACGs. Steedman suggère, en particulier, l’utilisation d’un combinateur
T de “type raising” afin de traiter des phénomènes d’élision du sujet ou de l’objet ; de plus, les
ellipses verbales nécessitent l’introduction d’un combinateur supplémentaire Bx qui permet de
rompre avec la directionnalité du calcul logique sous-jacent, et un opérateur de décomposition
de type, permettant d’extraire le verbe d’une phrase.
Dans le cadre des ACGs, l’opérateur Bx n’est pas nécessaires, puisque les types ne sont pas
dirigés. l’utilisation du combinateur T revient à modifier les types assignés aux constantes
de la signature des structures de dérivation. Sur un exemple, nous pouvons décrire une
signature des dérivations faite des constantes cJ ean , c M ar ie : (np → s) → s, ccour t : np → s,
c r at t r ape : np → np → s et cet : (np → s) → (np → s) → (np → s). Cette signature permet
de dériver un terme c M ar ie (λ y np .cJ ean (cet ccour t (c r at t r ape y))). Grâce au morphisme �sem ci-
dessous, il est ensuite possible d’associer la forme sémantique souhaitée pour la phrase “Jean
court et rattrape Marie” :
 np := e                                  s := t
cJ ean := λP e→t .PJ                     c M ar ie := λP e→t .PM
– �sem =                                e e
 c r at t r ape := λx y .Rx y             ccour t := λx e .Cx
                 e→t e→t e
cet := λP1 P2 x . ∧ (P1 x)(P2 x)
Nous remarquerons néanmoins que, la signature des dérivations que nous décrivons ci-dessus
est d’ordre supérieur à 2. Par ailleurs, il ne semble pas souhaitable, dans le cas des ACGs, de
typer tous les syntagmes nominaux par un type (np → s) → s, ce qui revient à considérer
des ACGs d’ordre supérieur à 2 pour des cas très simples, sans phénomènes d’ellipses. Enfin,
l’opérateur de décomposition est nécessaire dans le cas d’ellipses verbales pour les langues de
type SVO, car il permet d’extraire le verbe de la phrase en partie gauche de la conjonction.
Cet opérateur permet en fait d’effectuer le même traitement que nous réalisons, c.a.d. de
construire des constituants incomplets puis de les composer avec le constituant commun.
Qui plus est, cet opérateur de décomposition semble poser un problème du point de vue
calculatoire car il introduit deux nouvelles formules, ce qui va à l’encontre de la propriété de
la sous-formule. Enfin, notons que les ACGs permettent l’implémentation du même principe
de manière plus élégante puisque, de par l’indépendance entre dérivations et ordre des mots,
nous n’avons pas eu besoin d’enrichir le formalisme initial de nouveaux opérateurs.
Des extensions des TAGs ont également été proposées, tout d’abord dans (Sarkar et Joshi,
1996) qui proposent une implémentation des idées de (Steedman, 1990) dans les grammaires
d’arbres adjoints, en y rajoutant une opération de conjonction. Par ailleurs, l’objectif des
auteurs est de construire des structures dérivées qui sont des arbres avec partage de noeud.
Qui plus est, ils rendent compte de ce partage de matériel syntaxique au niveau des dérivations,
les structures de dérivation étant également des arbres avec partage de noeuds. Ceci est dû au
fait que les structures de dérivation dans les TAGs sont censés être plus proches de la structure
prédicat/argument de représentation sémantique d’une phrase. D’autres propositions sont
celles de (Seddah, 2008) ou (Seddah et al., 2010), qui considèrent des grammaires de tuples
d’arbres et requièrent des opérations plus complexes ; par exemple, le traitement d’ellipses
multiples se fait en ajoutant un nombre arbitraire d’arbres non-lexicalisés (appelés “ghost trees”
par les auteurs). L’originalité de notre méthode, par rapport à celles-ci, est de pouvoir traiter
les phénomènes d’ellipses que nous avons étudiés sans modifier le formalisme des grammaires
catégorielles abstraites. Par ailleurs, le modèle de l’interface syntaxe sémantique dans les ACGs
permet de séparer explicitement les structures de dérivation, de la représentation sémantique.
Le partage d’information nécessaire au niveau des dérivations dans les TAGs, est donné au
niveau de la signature Σsem dans notre cas.
Enfin, (Kobele, 2007) décrit plusieurs méthodes possibles dont les deux suivantes : la pre-
mière consiste à construire des contextes d’arbres, car du matériel syntaxique est absent aux
emplacements où une ellipse a été réalisée ; l’information manquante doit alors être retrouvée
dans l’arbre (dans le cas d’une ellipse verbale, dans le premier constituant dominé par une
conjonction de coordination). La deuxième approche de (Kobele, 2007) consiste à utiliser
des grammaires non-contextuelles d’arbres avec copie IO.
Les deux approches que nous proposons semblent assez proches des propositions de Kobele,
à la différence que, plutôt que de rechercher le matériel effacé dans l’arbre, nous mettons en
place un mécanisme permettant de le copier. Par ailleurs, les ACGs de notre seconde approche
peuvent être réduites à des grammaires IO-CFTGs. Bien que le patron de dérivation ne soit
pas le même que celui utilisé par Kobele, il semblerait que nous ne puissions pas traiter plus
de phénomènes que dans son approche. En particulier, Kobele montre qu’une des limites de
l’approche par des IO-CFTGs est de ne pas pouvoir traiter des phénomènes tels que :
(5). “John wants to climb Mt. Kilimanjaro and Mary to sail around the world, and while I
know that John will ε1 and Mary won’t ε2 , Bill doesn’t ε3 ”
John veut grimper le Kilimanjaro et Marie naviguer autour du monde, et alors que je sais
que John le fera et pas Marie, Bill ne le sait pas
D’après cette construction, il serait nécessaire de garder l’ensemble des verbes utilisés dans le
constituant à gauche d’une conjonction afin de pouvoir le réutiliser dans les constituants en
partie droite ; qui plus est, ce nombre de verbes est potentiellement infini, ce qui, dans notre
n
première approche nous amène à considérer un nombre de constantes infinies cet           , n ∈ �;
dans notre seconde approche, il nous faudrait considérer un nombre de types infini dans
la signature des dérivations. Ces cas d’ellipses mettent en avant la limite des traitements
proposées. Par ailleurs, ce type d’ellipses paraît maladroit en Français, où les pronoms sont
utilisés afin de se référer à un syntagme précédemment utilisé. Une solution à envisager est
donc d’adapter des techniques de résolution d’anaphores, à partir de continuations dans le
λ-calcul, par exemple (de Groote, 2006), afin de résoudre les phénomènes d’ellipse.
5     Conclusion

Les phénomènes d’ellipses sont fréquents dans le langage naturel et sont des exemples de
phénomènes non-linéaires au niveau de l’interface syntaxe-sémantique. Nous avons proposé
deux approches pour le traitement d’ellipses sous coordination dans les ACGs, en utilisant le
principe d’extraction pour la construction d’une phrase incomplète, suivi d’un mécanisme
d’instanciation, modélisé par la substitution dans le λ-calcul. Dans la première approche,
ce principe est directement codé au niveau des termes des structures de dérivation ; de
manière élégante, nous pouvons alors traiter de nombreux cas d’ellipses, mais la signature
des dérivations étant d’ordre supérieur à 2, le problème de l’analyse est, au meilleur des
cas, NP-complet. Dans la deuxième approche, nous conservons une ACG d’ordre 2, mais les
mécanismes d’extraction sont encodés au niveau des types utilisés dans la signature. Ceci nous
amène alors à considérer un ensemble de types très grand, mais nous permet de réutiliser
des algorithmes d’analyse connus pour s’exécuter en temps polynomial.
Les deux approches ainsi proposées ne nécessitent pas d’étendre le formalisme des ACGs,
contrairement aux solutions proposées dans la littérature, pour les TAGs ou les CCGs. Néan-
moins, les modélisations que nous proposons ne prétendent pas résoudre des phénomènes
d’ellipses complexes, tels que les ellipses de verbes prenant différentes catégories en argument
(dans “Jean est un républicain, et fier de l’être”), ou encore celles faisant intervenir un zeugma
(dans “Napoléon a pris du poids et beaucoup de pays”, discuté dans (Seddah, 2008)). Dans ce
dernier cas, une piste est de tenter de distinguer deux signatures des dérivations Σ DERI V −EX PR
et Σ DERI V −ST R contrôlant les dérivations de l’arbre syntaxique, la première s’assurant de la
construction d’expressions figées.
Par ailleurs, les modèles que nous proposons reposent essentiellement sur la présence d’une
coordination dominant l’occurrence du syntagme effacé, et ne saurait résoudre des cas
d’ellipses ou ce principe n’est pas vérifié. Enfin, et comme discuté dans (Kobele, 2007), les
deux approches semblent trop limités afin de résoudre certains cas d’ellipses faisant intervenir
de multiples verbes, et des méthodes de résolution d’anaphores pourrait se montrer plus
efficaces.
Finalement, cette étude demande à être approfondie afin d’étudier plus en détails le lien entre
les deux propositions présentées. En particulier, il serait intéressant de savoir quand, et à quel
coût, il est possible de diminuer l’ordre d’une ACG tout en préservant le langage généré.
Remerciements : Je remercie les rapporteurs anonymes qui ont grandement aidé à l’amélio-
ration de ce travail. Je tiens également à remercier Laura Kallmeyer et Timm Lichte pour les
discussions qui m’ont amenées à m’intéresser à ce problème.
Références
B OURREAU, P. (2011). Jeux de typage et analyse de λ-grammaires non-contextuelles. Thèse de
doctorat, Laboratoire Bordelais d’Informatique.
B OURREAU, P. et SALVATI, S. (2011). A Datalog recognizer for almost affine λ-CFGs. In
(Kanazawa et al., 2011), pages 21–38.
de GROOTE, P. (2001). Towards abstract categorial grammars. In Association for Computatio-
nal Linguistics, 39th Annual Meeting and 10th Conference of the European Chapter, Proceedings
of the Conference, pages 148–155.
de GROOTE, P. (2002). Tree-adjoining grammar as abstract categorial grammar. In TAG+6,
Proceedings of the sixth International Workshop on Tree Adjoining Grammars and Related
Frameworks, pages 145–150. Università di Venezia.
de GROOTE, P. (2006). Towards a montagovian account of dynamics. In Proceedings of
Semantics and Linguistic Theory XVI.
de GROOTE, P. et POGODALLA, S. (2004). On the expressive power of abstract categorial
grammars : Representing context-free formalisms. Journal of Logic, Language and Information,
13(4):421–438.
HINDLEY, R. J. (1997). Basic Simple Type Theory. Cambridge Press University.
JOSHI, A. K. (1985). Tree-adjoining grammars : How much context-sensitivity is required
to provide reasonable strucutral descriptions ? Natural Language Parsing : Psychological,
Computational and Theoretical Perspectives, pages 206–250.
JOSHI, A. K., LEVY, L. S. et TAKAHASHI, M. (1975). Tree adjunct grammars. Journal of
Comput. Syst. Sci., 10(1):136–163.
KANAZAWA, M. (2007). Parsing and generation as Datalog queries. In Proceedings of the
45th Annual Meeting of the Association for Computational Linguistics, pages 176–183, Prague.
Association for Computational Linguistics.
KANAZAWA, M., KORNAI, A., KRACHT, M. et SEKI, H., éditeurs (2011). The Mathematics of
Language - 12th Biennal Conference, MOL 12, Nara, Japan, September 2011. Proceedings,
volume 6878 de Lecture Notes in Artificial Intelligence. Springer.
KANAZAWA, M. et YOSHINAKA, R. (2005a). The complexity and generative capacity of
lexicalised abstract categorial grammars. In (Kanazawa et al., 2011), pages 330–346.
KANAZAWA, M. et YOSHINAKA, R. (2005b). Lexicalization of second-order ACGs. Rapport
technique NII-2005-012E, NII, National Institute of Informatics, Tokyo.
KOBELE, G. M. (2007). Parsing ellipsis. Unpublished Manuscript.
LICHTE, T. et KALLMEYER, L. (2010). Gapping through TAG derivations. In Procedings of the
10th International Workshop on Tree-Adjoining Grammar and Related Formalisms.
MUSKENS, R. (2001). Lambda Grammars and the Syntax-Semantics Interface. In van ROOY,
R. et STOKHOF, M., éditeurs : Proceedings of the Thirteenth Amsterdam Colloquium, pages
150–155, Amsterdam.
POGODALLA, S. (2004). Computing semantic representation : Towards ACG abstract terms
as derivation trees. In Proceedings of the Seventh International Workshop on Tree Adjoining
Grammar and Related Formalisms (TAG+7), pages 64–71.
POGODALLA, S. (2007). Generalizing a proof-theoretic account of scope ambiguity. In
proceedings of IWCS-7.
SARKAR, A. et JOSHI, A. (1996). Coordination in tree adjoining grammars : formalization
and implementation. In Proceedings of the 16th conference on Computational linguistics -
Volume 2, COLING ’96, pages 610–615, Stroudsburg, PA, USA. Association for Computational
Linguistics.
SEDDAH, D. (2008). The use of MCTAG to process elliptic coordination. In Proceedings of the
Ninth International Workshop on Tree Adjoining Grammars and Related Formalisms, TAG+9.
SEDDAH, D., SAGOT, B. et DANLOS, L. (2010). Control verb, argument cluster coordination
and multi component TAG. In Proceedings of the 10th International Conference on Tree
Adjoining Grammars and Related Formalisms, TAG+10.
STEEDMAN, M. (1987). Combinatory grammars and parasitic gaps. Natural Language &
Linguistic Theory, 5:403–439.
STEEDMAN, M. (1990). Gapping as constituent coordination. Linguistics and Philosophy,
13:207–264.
YOSHINAKA, R. (2006). Linearization of affine abstract categorial grammars. In Proceedings
of the 11th Conference on Formal Grammar, pages 185–199, Malaga, Spain.

